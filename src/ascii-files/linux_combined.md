

== ./linux/linux_0.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/include/asm/core_cia.h#L31-L64

```c
< ASCII >
/*
 * CIA ADDRESS BIT DEFINITIONS
 *
 *  3333 3333 3322 2222 2222 1111 1111 11
 *  9876 5432 1098 7654 3210 9876 5432 1098 7654 3210
 *  ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
 *  1                                             000
 *  ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
 *  |                                             |\|
 *  |                               Byte Enable --+ |
 *  |                             Transfer Length --+
 *  +-- IO space, not cached
 *
 *   Byte      Transfer
 *   Enable    Length    Transfer  Byte    Address
 *   adr<6:5>  adr<4:3>  Length    Enable  Adder
 *   ---------------------------------------------
 *      00        00      Byte      1110   0x000
 *      01        00      Byte      1101   0x020
 *      10        00      Byte      1011   0x040
 *      11        00      Byte      0111   0x060
 *
 *      00        01      Word      1100   0x008
 *      01        01      Word      1001   0x028 <= Not supported in this code.
 *      10        01      Word      0011   0x048
 *
 *      00        10      Tribyte   1000   0x010
 *      01        10      Tribyte   0001   0x030
 *
 *      10        11      Longword  0000   0x058
 *
 *      Note that byte enables are asserted low.
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/include/asm/core_cia.h#L309-L339

```c
/*
 * Memory functions.  64-bit and 32-bit accesses are done through
 * dense memory space, everything else through sparse space.
 *
 * For reading and writing 8 and 16 bit quantities we need to
 * go through one of the three sparse address mapping regions
 * and use the HAE_MEM CSR to provide some bits of the address.
 * The following few routines use only sparse address region 1
 * which gives 1Gbyte of accessible space which relates exactly
 * to the amount of PCI memory mapping *into* system address space.
 * See p 6-17 of the specification but it looks something like this:
 *
< ASCII >
 * 21164 Address:
 *
 *          3         2         1
 * 9876543210987654321098765432109876543210
 * 1ZZZZ0.PCI.QW.Address............BBLL
 *
 * ZZ = SBZ
 * BB = Byte offset
 * LL = Transfer length
 *
 * PCI Address:
 *
 * 3         2         1
 * 10987654321098765432109876543210
 * HHH....PCI.QW.Address........ 00
 *
 * HHH = 31:29 HAE_MEM CSR
 *
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_10.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/core_cia.c#L48-L87

```c
/*
 * Given a bus, device, and function number, compute resulting
 * configuration space address.  It is therefore not safe to have
 * concurrent invocations to configuration space access routines, but
 * there really shouldn't be any need for this.
 *
< ASCII >
 * Type 0:
 *
 *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 
 *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | | |D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|0|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 *	31:11	Device select bit.
 * 	10:8	Function number
 * 	 7:2	Register number
 *
< ASCII >
 * Type 1:
 *
 *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 
 *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | | | | | | | | | | |B|B|B|B|B|B|B|B|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|1|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 *	31:24	reserved
 *	23:16	bus number (8 bits = 128 possible buses)
 *	15:11	Device number (5 bits)
 *	10:8	function number
 *	 7:2	register number
 *  
 * Notes:
 *	The function number selects which function of a multi-function device 
 *	(e.g., SCSI and Ethernet).
 * 
 *	The register selects a DWORD (32 bit) register offset.  Hence it
 *	doesn't get shifted by 2 bits as we want to "drop" the bottom two
 *	bits.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_100.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/ia64/mm/discontig.c#L285-L312

```c
/**
 * find_pernode_space - allocate memory for memory map and per-node structures
 * @start: physical start of range
 * @len: length of range
 * @node: node where this range resides
 *
 * This routine reserves space for the per-cpu data struct, the list of
 * pg_data_ts and the per-node data struct.  Each node will have something like
 * the following in the first chunk of addr. space large enough to hold it.
< ASCII >
 *
 *    ________________________
 *   |                        |
 *   |~~~~~~~~~~~~~~~~~~~~~~~~| <-- NODEDATA_ALIGN(start, node) for the first
 *   |    PERCPU_PAGE_SIZE *  |     start and length big enough
 *   |    cpus_on_this_node   | Node 0 will also have entries for all non-existent cpus.
 *   |------------------------|
 *   |   local pg_data_t *    |
 *   |------------------------|
 *   |  local ia64_node_data  |
 *   |------------------------|
 *   |          ???           |
 *   |________________________|
< ASCII >
 *
 * Once this space has been set aside, the bootmem maps are initialized.  We
 * could probably move the allocation of the per-cpu and ia64_node_data space
 * outside of this function and use alloc_bootmem_node(), but doing it here
 * is straightforward and we get the alignments we want so...
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1000.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/kbdif.h#L204-L251

```c
/*
 *****************************************************************************
 * Description of the protocol between frontend and backend driver.
 *****************************************************************************
 *
 * The two halves of a Para-virtual driver communicate with
 * each other using a shared page and an event channel.
 * Shared page contains a ring with event structures.
 *
 * All reserved fields in the structures below must be 0.
 *
 *****************************************************************************
 *                           Backend to frontend events
 *****************************************************************************
 *
 * Frontends should ignore unknown in events.
 * All event packets have the same length (40 octets)
< ASCII >
 * All event packets have common header:
 *
 *          0         octet
 * +-----------------+
 * |       type      |
 * +-----------------+
 * type - uint8_t, event code, XENKBD_TYPE_???
 *
 *
 * Pointer relative movement event
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |  _TYPE_MOTION  |                     reserved                     | 4
 * +----------------+----------------+----------------+----------------+
 * |                               rel_x                               | 8
 * +----------------+----------------+----------------+----------------+
 * |                               rel_y                               | 12
 * +----------------+----------------+----------------+----------------+
 * |                               rel_z                               | 16
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 20
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 40
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * rel_x - int32_t, relative X motion
 * rel_y - int32_t, relative Y motion
 * rel_z - int32_t, relative Z motion (wheel)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1001.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/kbdif.h#L260-L277

```c
/*
< ASCII >
 * Key event (includes pointer buttons)
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |  _TYPE_KEY     |     pressed    |            reserved             | 4
 * +----------------+----------------+----------------+----------------+
 * |                              keycode                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 12
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 40
 * +----------------+----------------+----------------+----------------+
 *
 * pressed - uint8_t, 1 if pressed; 0 otherwise
 * keycode - uint32_t, KEY_* from linux/input.h
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1002.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/kbdif.h#L285-L307

```c
/*
< ASCII >
 * Pointer absolute position event
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |  _TYPE_POS     |                     reserved                     | 4
 * +----------------+----------------+----------------+----------------+
 * |                               abs_x                               | 8
 * +----------------+----------------+----------------+----------------+
 * |                               abs_y                               | 12
 * +----------------+----------------+----------------+----------------+
 * |                               rel_z                               | 16
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 20
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 40
 * +----------------+----------------+----------------+----------------+
 *
< ASCII >
 * abs_x - int32_t, absolute X position (in FB pixels)
 * abs_y - int32_t, absolute Y position (in FB pixels)
 * rel_z - int32_t, relative Z motion (wheel)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1003.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/kbdif.h#L316-L460

```c
/*
 * Multi-touch event and its sub-types
 *
< ASCII >
 * All multi-touch event packets have common header:
 *
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |  _TYPE_MTOUCH  |   event_type   |   contact_id   |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * event_type - unt8_t, multi-touch event sub-type, XENKBD_MT_EV_???
 * contact_id - unt8_t, ID of the contact
 *
 * Touch interactions can consist of one or more contacts.
 * For each contact, a series of events is generated, starting
 * with a down event, followed by zero or more motion events,
 * and ending with an up event. Events relating to the same
 * contact point can be identified by the ID of the sequence: contact ID.
 * Contact ID may be reused after XENKBD_MT_EV_UP event and
 * is in the [0; XENKBD_FIELD_NUM_CONTACTS - 1] range.
 *
 * For further information please refer to documentation on Wayland [1],
 * Linux [2] and Windows [3] multi-touch support.
 *
 * [1] https://cgit.freedesktop.org/wayland/wayland/tree/protocol/wayland.xml
 * [2] https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.rst
 * [3] https://msdn.microsoft.com/en-us/library/jj151564(v=vs.85).aspx
 *
 *
 * Multi-touch down event - sent when a new touch is made: touch is assigned
 * a unique contact ID, sent with this and consequent events related
 * to this touch.
< ASCII >
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |  _TYPE_MTOUCH  |   _MT_EV_DOWN  |   contact_id   |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                               abs_x                               | 12
 * +----------------+----------------+----------------+----------------+
 * |                               abs_y                               | 16
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 20
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 40
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * abs_x - int32_t, absolute X position, in pixels
 * abs_y - int32_t, absolute Y position, in pixels
 *
< ASCII >
 * Multi-touch contact release event
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |  _TYPE_MTOUCH  |  _MT_EV_UP     |   contact_id   |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 40
 * +----------------+----------------+----------------+----------------+
< ASCII >
< ASCII >
 *
 * Multi-touch motion event
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |  _TYPE_MTOUCH  |  _MT_EV_MOTION |   contact_id   |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                               abs_x                               | 12
 * +----------------+----------------+----------------+----------------+
 * |                               abs_y                               | 16
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 20
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 40
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * abs_x - int32_t, absolute X position, in pixels,
 * abs_y - int32_t, absolute Y position, in pixels,
 *
< ASCII >
 * Multi-touch input synchronization event - shows end of a set of events
 * which logically belong together.
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |  _TYPE_MTOUCH  |  _MT_EV_SYN    |   contact_id   |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 40
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * Multi-touch shape event - touch point's shape has changed its shape.
 * Shape is approximated by an ellipse through the major and minor axis
 * lengths: major is the longer diameter of the ellipse and minor is the
 * shorter one. Center of the ellipse is reported via
 * XENKBD_MT_EV_DOWN/XENKBD_MT_EV_MOTION events.
< ASCII >
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |  _TYPE_MTOUCH  |  _MT_EV_SHAPE  |   contact_id   |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                               major                               | 12
 * +----------------+----------------+----------------+----------------+
 * |                               minor                               | 16
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 20
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 40
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * major - unt32_t, length of the major axis, pixels
 * minor - unt32_t, length of the minor axis, pixels
 *
 * Multi-touch orientation event - touch point's shape has changed
 * its orientation: calculated as a clockwise angle between the major axis
 * of the ellipse and positive Y axis in degrees, [-180; +180].
< ASCII >
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |  _TYPE_MTOUCH  |  _MT_EV_ORIENT |   contact_id   |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |           orientation           |            reserved             | 12
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 16
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 40
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * orientation - int16_t, clockwise angle of the major axis
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1004.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/kbdif.h#L491-L507

```c
/*
 *****************************************************************************
 *                            Frontend to backend events
 *****************************************************************************
 *
 * Out events may be sent only when requested by backend, and receipt
 * of an unknown out event is an error.
 * No out events currently defined.

 * All event packets have the same length (40 octets)
< ASCII >
 * All event packets have common header:
 *          0         octet
 * +-----------------+
 * |       type      |
 * +-----------------+
 * type - uint8_t, event code
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1005.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/netif.h#L321-L337

```c
/*
 * Control requests (struct xen_netif_ctrl_request)
 * ================================================
 *
< ASCII >
 * All requests have the following format:
 *
 *    0     1     2     3     4     5     6     7  octet
 * +-----+-----+-----+-----+-----+-----+-----+-----+
 * |    id     |   type    |         data[0]       |
 * +-----+-----+-----+-----+-----+-----+-----+-----+
 * |         data[1]       |         data[2]       |
 * +-----+-----+-----+-----+-----------------------+
 *
< ASCII >
 * id: the request identifier, echoed in response.
 * type: the type of request (see below)
 * data[]: any data associated with the request (determined by type)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1006.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/netif.h#L355-L373

```c
/*
 * Control responses (struct xen_netif_ctrl_response)
 * ==================================================
 *
< ASCII >
 * All responses have the following format:
 *
 *    0     1     2     3     4     5     6     7  octet
 * +-----+-----+-----+-----+-----+-----+-----+-----+
 * |    id     |   type    |         status        |
 * +-----+-----+-----+-----+-----+-----+-----+-----+
 * |         data          |
 * +-----+-----+-----+-----+
< ASCII >
 *
 * id: the corresponding request identifier
 * type: the type of the corresponding request
 * status: the status of request processing
 * data: any data associated with the response (determined by type and
 *       status)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1007.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/netif.h#L388-L607

```c
/*
 * Control messages
 * ================
 *
 * XEN_NETIF_CTRL_TYPE_SET_HASH_ALGORITHM
 * --------------------------------------
 *
 * This is sent by the frontend to set the desired hash algorithm.
 *
 * Request:
 *
 *  type    = XEN_NETIF_CTRL_TYPE_SET_HASH_ALGORITHM
 *  data[0] = a XEN_NETIF_CTRL_HASH_ALGORITHM_* value
 *  data[1] = 0
 *  data[2] = 0
 *
 * Response:
 *
 *  status = XEN_NETIF_CTRL_STATUS_NOT_SUPPORTED     - Operation not
 *                                                     supported
 *           XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER - The algorithm is not
 *                                                     supported
 *           XEN_NETIF_CTRL_STATUS_SUCCESS           - Operation successful
 *
 * NOTE: Setting data[0] to XEN_NETIF_CTRL_HASH_ALGORITHM_NONE disables
 *       hashing and the backend is free to choose how it steers packets
 *       to queues (which is the default behaviour).
 *
 * XEN_NETIF_CTRL_TYPE_GET_HASH_FLAGS
 * ----------------------------------
 *
 * This is sent by the frontend to query the types of hash supported by
 * the backend.
 *
 * Request:
 *
 *  type    = XEN_NETIF_CTRL_TYPE_GET_HASH_FLAGS
 *  data[0] = 0
 *  data[1] = 0
 *  data[2] = 0
 *
 * Response:
 *
 *  status = XEN_NETIF_CTRL_STATUS_NOT_SUPPORTED - Operation not supported
 *           XEN_NETIF_CTRL_STATUS_SUCCESS       - Operation successful
 *  data   = supported hash types (if operation was successful)
 *
 * NOTE: A valid hash algorithm must be selected before this operation can
 *       succeed.
 *
 * XEN_NETIF_CTRL_TYPE_SET_HASH_FLAGS
 * ----------------------------------
 *
 * This is sent by the frontend to set the types of hash that the backend
 * should calculate. (See above for hash type definitions).
 * Note that the 'maximal' type of hash should always be chosen. For
 * example, if the frontend sets both IPV4 and IPV4_TCP hash types then
 * the latter hash type should be calculated for any TCP packet and the
 * former only calculated for non-TCP packets.
 *
 * Request:
 *
 *  type    = XEN_NETIF_CTRL_TYPE_SET_HASH_FLAGS
 *  data[0] = bitwise OR of XEN_NETIF_CTRL_HASH_TYPE_* values
 *  data[1] = 0
 *  data[2] = 0
 *
 * Response:
 *
 *  status = XEN_NETIF_CTRL_STATUS_NOT_SUPPORTED     - Operation not
 *                                                     supported
 *           XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER - One or more flag
 *                                                     value is invalid or
 *                                                     unsupported
 *           XEN_NETIF_CTRL_STATUS_SUCCESS           - Operation successful
 *  data   = 0
 *
 * NOTE: A valid hash algorithm must be selected before this operation can
 *       succeed.
 *       Also, setting data[0] to zero disables hashing and the backend
 *       is free to choose how it steers packets to queues.
 *
 * XEN_NETIF_CTRL_TYPE_SET_HASH_KEY
 * --------------------------------
 *
 * This is sent by the frontend to set the key of the hash if the algorithm
 * requires it. (See hash algorithms above).
 *
 * Request:
 *
 *  type    = XEN_NETIF_CTRL_TYPE_SET_HASH_KEY
 *  data[0] = grant reference of page containing the key (assumed to
 *            start at beginning of grant)
 *  data[1] = size of key in octets
 *  data[2] = 0
 *
 * Response:
 *
 *  status = XEN_NETIF_CTRL_STATUS_NOT_SUPPORTED     - Operation not
 *                                                     supported
 *           XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER - Key size is invalid
 *           XEN_NETIF_CTRL_STATUS_BUFFER_OVERFLOW   - Key size is larger
 *                                                     than the backend
 *                                                     supports
 *           XEN_NETIF_CTRL_STATUS_SUCCESS           - Operation successful
 *  data   = 0
 *
 * NOTE: Any key octets not specified are assumed to be zero (the key
 *       is assumed to be empty by default) and specifying a new key
 *       invalidates any previous key, hence specifying a key size of
 *       zero will clear the key (which ensures that the calculated hash
 *       will always be zero).
 *       The maximum size of key is algorithm and backend specific, but
 *       is also limited by the single grant reference.
 *       The grant reference may be read-only and must remain valid until
 *       the response has been processed.
 *
 * XEN_NETIF_CTRL_TYPE_GET_HASH_MAPPING_SIZE
 * -----------------------------------------
 *
 * This is sent by the frontend to query the maximum size of mapping
 * table supported by the backend. The size is specified in terms of
 * table entries.
 *
 * Request:
 *
 *  type    = XEN_NETIF_CTRL_TYPE_GET_HASH_MAPPING_SIZE
 *  data[0] = 0
 *  data[1] = 0
 *  data[2] = 0
 *
 * Response:
 *
 *  status = XEN_NETIF_CTRL_STATUS_NOT_SUPPORTED - Operation not supported
 *           XEN_NETIF_CTRL_STATUS_SUCCESS       - Operation successful
 *  data   = maximum number of entries allowed in the mapping table
 *           (if operation was successful) or zero if a mapping table is
 *           not supported (i.e. hash mapping is done only by modular
 *           arithmetic).
 *
 * XEN_NETIF_CTRL_TYPE_SET_HASH_MAPPING_SIZE
 * -------------------------------------
 *
 * This is sent by the frontend to set the actual size of the mapping
 * table to be used by the backend. The size is specified in terms of
 * table entries.
 * Any previous table is invalidated by this message and any new table
 * is assumed to be zero filled.
 *
 * Request:
 *
 *  type    = XEN_NETIF_CTRL_TYPE_SET_HASH_MAPPING_SIZE
 *  data[0] = number of entries in mapping table
 *  data[1] = 0
 *  data[2] = 0
 *
 * Response:
 *
 *  status = XEN_NETIF_CTRL_STATUS_NOT_SUPPORTED     - Operation not
 *                                                     supported
 *           XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER - Table size is invalid
 *           XEN_NETIF_CTRL_STATUS_SUCCESS           - Operation successful
 *  data   = 0
 *
 * NOTE: Setting data[0] to 0 means that hash mapping should be done
 *       using modular arithmetic.
 *
 * XEN_NETIF_CTRL_TYPE_SET_HASH_MAPPING
 * ------------------------------------
 *
 * This is sent by the frontend to set the content of the table mapping
 * hash value to queue number. The backend should calculate the hash from
 * the packet header, use it as an index into the table (modulo the size
 * of the table) and then steer the packet to the queue number found at
 * that index.
 *
 * Request:
 *
 *  type    = XEN_NETIF_CTRL_TYPE_SET_HASH_MAPPING
 *  data[0] = grant reference of page containing the mapping (sub-)table
 *            (assumed to start at beginning of grant)
 *  data[1] = size of (sub-)table in entries
 *  data[2] = offset, in entries, of sub-table within overall table
 *
 * Response:
 *
 *  status = XEN_NETIF_CTRL_STATUS_NOT_SUPPORTED     - Operation not
 *                                                     supported
 *           XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER - Table size or content
 *                                                     is invalid
 *           XEN_NETIF_CTRL_STATUS_BUFFER_OVERFLOW   - Table size is larger
 *                                                     than the backend
 *                                                     supports
 *           XEN_NETIF_CTRL_STATUS_SUCCESS           - Operation successful
 *  data   = 0
 *
< ASCII >
 * NOTE: The overall table has the following format:
 *
 *          0     1     2     3     4     5     6     7  octet
 *       +-----+-----+-----+-----+-----+-----+-----+-----+
 *       |       mapping[0]      |       mapping[1]      |
 *       +-----+-----+-----+-----+-----+-----+-----+-----+
 *       |                       .                       |
 *       |                       .                       |
 *       |                       .                       |
 *       +-----+-----+-----+-----+-----+-----+-----+-----+
 *       |      mapping[N-2]     |      mapping[N-1]     |
 *       +-----+-----+-----+-----+-----+-----+-----+-----+
< ASCII >
 *
 *       where N is specified by a XEN_NETIF_CTRL_TYPE_SET_HASH_MAPPING_SIZE
 *       message and each  mapping must specifies a queue between 0 and
 *       "multi-queue-num-queues" (see above).
 *       The backend may support a mapping table larger than can be
 *       mapped by a single grant reference. Thus sub-tables within a
 *       larger table can be individually set by sending multiple messages
 *       with differing offset values. Specifying a new sub-table does not
 *       invalidate any table data outside that range.
 *       The grant reference may be read-only and must remain valid until
 *       the response has been processed.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1008.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/sndif.h#L29-L408

```c
/*
 ******************************************************************************
 *                  Feature and Parameter Negotiation
 ******************************************************************************
 *
 * Front->back notifications: when enqueuing a new request, sending a
 * notification can be made conditional on xensnd_req (i.e., the generic
 * hold-off mechanism provided by the ring macros). Backends must set
 * xensnd_req appropriately (e.g., using RING_FINAL_CHECK_FOR_REQUESTS()).
 *
 * Back->front notifications: when enqueuing a new response, sending a
 * notification can be made conditional on xensnd_resp (i.e., the generic
 * hold-off mechanism provided by the ring macros). Frontends must set
 * xensnd_resp appropriately (e.g., using RING_FINAL_CHECK_FOR_RESPONSES()).
 *
 * The two halves of a para-virtual sound card driver utilize nodes within
 * XenStore to communicate capabilities and to negotiate operating parameters.
 * This section enumerates these nodes which reside in the respective front and
 * backend portions of XenStore, following the XenBus convention.
 *
 * All data in XenStore is stored as strings. Nodes specifying numeric
 * values are encoded in decimal. Integer value ranges listed below are
 * expressed as fixed sized integer types capable of storing the conversion
 * of a properly formated node string, without loss of information.
 *
 ******************************************************************************
 *                        Example configuration
 ******************************************************************************
 *
 * Note: depending on the use-case backend can expose more sound cards and
 * PCM devices/streams than the underlying HW physically has by employing
 * SW mixers, configuring virtual sound streams, channels etc.
 *
 * This is an example of backend and frontend configuration:
 *
 *--------------------------------- Backend -----------------------------------
 *
 * /local/domain/0/backend/vsnd/1/0/frontend-id = "1"
 * /local/domain/0/backend/vsnd/1/0/frontend = "/local/domain/1/device/vsnd/0"
 * /local/domain/0/backend/vsnd/1/0/state = "4"
 * /local/domain/0/backend/vsnd/1/0/versions = "1,2"
 *
 *--------------------------------- Frontend ----------------------------------
 *
 * /local/domain/1/device/vsnd/0/backend-id = "0"
 * /local/domain/1/device/vsnd/0/backend = "/local/domain/0/backend/vsnd/1/0"
 * /local/domain/1/device/vsnd/0/state = "4"
 * /local/domain/1/device/vsnd/0/version = "1"
 *
 *----------------------------- Card configuration ----------------------------
 *
 * /local/domain/1/device/vsnd/0/short-name = "Card short name"
 * /local/domain/1/device/vsnd/0/long-name = "Card long name"
 * /local/domain/1/device/vsnd/0/sample-rates = "8000,32000,44100,48000,96000"
 * /local/domain/1/device/vsnd/0/sample-formats = "s8,u8,s16_le,s16_be"
 * /local/domain/1/device/vsnd/0/buffer-size = "262144"
 *
 *------------------------------- PCM device 0 --------------------------------
 *
 * /local/domain/1/device/vsnd/0/0/name = "General analog"
 * /local/domain/1/device/vsnd/0/0/channels-max = "5"
 *
 *----------------------------- Stream 0, playback ----------------------------
 *
 * /local/domain/1/device/vsnd/0/0/0/type = "p"
 * /local/domain/1/device/vsnd/0/0/0/sample-formats = "s8,u8"
 * /local/domain/1/device/vsnd/0/0/0/unique-id = "0"
 *
 * /local/domain/1/device/vsnd/0/0/0/ring-ref = "386"
 * /local/domain/1/device/vsnd/0/0/0/event-channel = "15"
 * /local/domain/1/device/vsnd/0/0/0/evt-ring-ref = "1386"
 * /local/domain/1/device/vsnd/0/0/0/evt-event-channel = "215"
 *
 *------------------------------ Stream 1, capture ----------------------------
 *
 * /local/domain/1/device/vsnd/0/0/1/type = "c"
 * /local/domain/1/device/vsnd/0/0/1/channels-max = "2"
 * /local/domain/1/device/vsnd/0/0/1/unique-id = "1"
 *
 * /local/domain/1/device/vsnd/0/0/1/ring-ref = "384"
 * /local/domain/1/device/vsnd/0/0/1/event-channel = "13"
 * /local/domain/1/device/vsnd/0/0/1/evt-ring-ref = "1384"
 * /local/domain/1/device/vsnd/0/0/1/evt-event-channel = "213"
 *
 *------------------------------- PCM device 1 --------------------------------
 *
 * /local/domain/1/device/vsnd/0/1/name = "HDMI-0"
 * /local/domain/1/device/vsnd/0/1/sample-rates = "8000,32000,44100"
 *
 *------------------------------ Stream 0, capture ----------------------------
 *
 * /local/domain/1/device/vsnd/0/1/0/type = "c"
 * /local/domain/1/device/vsnd/0/1/0/unique-id = "2"
 *
 * /local/domain/1/device/vsnd/0/1/0/ring-ref = "387"
 * /local/domain/1/device/vsnd/0/1/0/event-channel = "151"
 * /local/domain/1/device/vsnd/0/1/0/evt-ring-ref = "1387"
 * /local/domain/1/device/vsnd/0/1/0/evt-event-channel = "351"
 *
 *------------------------------- PCM device 2 --------------------------------
 *
 * /local/domain/1/device/vsnd/0/2/name = "SPDIF"
 *
 *----------------------------- Stream 0, playback ----------------------------
 *
 * /local/domain/1/device/vsnd/0/2/0/type = "p"
 * /local/domain/1/device/vsnd/0/2/0/unique-id = "3"
 *
 * /local/domain/1/device/vsnd/0/2/0/ring-ref = "389"
 * /local/domain/1/device/vsnd/0/2/0/event-channel = "152"
 * /local/domain/1/device/vsnd/0/2/0/evt-ring-ref = "1389"
 * /local/domain/1/device/vsnd/0/2/0/evt-event-channel = "452"
 *
 ******************************************************************************
 *                            Backend XenBus Nodes
 ******************************************************************************
 *
 *----------------------------- Protocol version ------------------------------
 *
 * versions
 *      Values:         <string>
 *
 *      List of XENSND_LIST_SEPARATOR separated protocol versions supported
 *      by the backend. For example "1,2,3".
 *
 ******************************************************************************
 *                            Frontend XenBus Nodes
 ******************************************************************************
 *
 *-------------------------------- Addressing ---------------------------------
 *
 * dom-id
 *      Values:         <uint16_t>
 *
 *      Domain identifier.
 *
 * dev-id
 *      Values:         <uint16_t>
 *
 *      Device identifier.
 *
 * pcm-dev-idx
 *      Values:         <uint8_t>
 *
 *      Zero based contigous index of the PCM device.
 *
 * stream-idx
 *      Values:         <uint8_t>
 *
 *      Zero based contigous index of the stream of the PCM device.
 *
 * The following pattern is used for addressing:
 *   /local/domain/<dom-id>/device/vsnd/<dev-id>/<pcm-dev-idx>/<stream-idx>/...
 *
 *----------------------------- Protocol version ------------------------------
 *
 * version
 *      Values:         <string>
 *
 *      Protocol version, chosen among the ones supported by the backend.
 *
 *------------------------------- PCM settings --------------------------------
 *
 * Every virtualized sound frontend has a set of PCM devices and streams, each
 * could be individually configured. Part of the PCM configuration can be
 * defined at higher level of the hierarchy and be fully or partially re-used
 * by the underlying layers. These configuration values are:
 *  o number of channels (min/max)
 *  o supported sample rates
 *  o supported sample formats.
 * E.g. one can define these values for the whole card, device or stream.
 * Every underlying layer in turn can re-define some or all of them to better
 * fit its needs. For example, card may define number of channels to be
 * in [1; 8] range, and some particular stream may be limited to [1; 2] only.
 * The rule is that the underlying layer must be a subset of the upper layer
 * range.
 *
 * channels-min
 *      Values:         <uint8_t>
 *
 *      The minimum amount of channels that is supported, [1; channels-max].
 *      Optional, if not set or omitted a value of 1 is used.
 *
 * channels-max
 *      Values:         <uint8_t>
 *
 *      The maximum amount of channels that is supported.
 *      Must be at least <channels-min>.
 *
 * sample-rates
 *      Values:         <list of uint32_t>
 *
 *      List of supported sample rates separated by XENSND_LIST_SEPARATOR.
 *      Sample rates are expressed as a list of decimal values w/o any
 *      ordering requirement.
 *
 * sample-formats
 *      Values:         <list of XENSND_PCM_FORMAT_XXX_STR>
 *
 *      List of supported sample formats separated by XENSND_LIST_SEPARATOR.
 *      Items must not exceed XENSND_SAMPLE_FORMAT_MAX_LEN length.
 *
 * buffer-size
 *      Values:         <uint32_t>
 *
 *      The maximum size in octets of the buffer to allocate per stream.
 *
 *----------------------- Virtual sound card settings -------------------------
 * short-name
 *      Values:         <char[32]>
 *
 *      Short name of the virtual sound card. Optional.
 *
 * long-name
 *      Values:         <char[80]>
 *
 *      Long name of the virtual sound card. Optional.
 *
 *----------------------------- Device settings -------------------------------
 * name
 *      Values:         <char[80]>
 *
 *      Name of the sound device within the virtual sound card. Optional.
 *
 *----------------------------- Stream settings -------------------------------
 *
 * type
 *      Values:         "p", "c"
 *
 *      Stream type: "p" - playback stream, "c" - capture stream
 *
 *      If both capture and playback are needed then two streams need to be
 *      defined under the same device.
 *
 * unique-id
 *      Values:         <string>
 *
 *      After stream initialization it is assigned a unique ID, so every
 *      stream of the frontend can be identified by the backend by this ID.
 *      This can be UUID or such.
 *
 *-------------------- Stream Request Transport Parameters --------------------
 *
 * event-channel
 *      Values:         <uint32_t>
 *
 *      The identifier of the Xen event channel used to signal activity
 *      in the ring buffer.
 *
 * ring-ref
 *      Values:         <uint32_t>
 *
 *      The Xen grant reference granting permission for the backend to map
 *      a sole page in a single page sized ring buffer.
 *
 *--------------------- Stream Event Transport Parameters ---------------------
 *
 * This communication path is used to deliver asynchronous events from backend
 * to frontend, set up per stream.
 *
 * evt-event-channel
 *      Values:         <uint32_t>
 *
 *      The identifier of the Xen event channel used to signal activity
 *      in the ring buffer.
 *
 * evt-ring-ref
 *      Values:         <uint32_t>
 *
 *      The Xen grant reference granting permission for the backend to map
 *      a sole page in a single page sized ring buffer.
 *
 ******************************************************************************
 *                               STATE DIAGRAMS
 ******************************************************************************
 *
 * Tool stack creates front and back state nodes with initial state
 * XenbusStateInitialising.
 * Tool stack creates and sets up frontend sound configuration nodes per domain.
< ASCII >
 *
 * Front                                Back
 * =================================    =====================================
 * XenbusStateInitialising              XenbusStateInitialising
 *                                       o Query backend device identification
 *                                         data.
 *                                       o Open and validate backend device.
 *                                                      |
 *                                                      |
 *                                                      V
 *                                      XenbusStateInitWait
 *
 * o Query frontend configuration
 * o Allocate and initialize
 *   event channels per configured
 *   playback/capture stream.
 * o Publish transport parameters
 *   that will be in effect during
 *   this connection.
 *              |
 *              |
 *              V
 * XenbusStateInitialised
 *
 *                                       o Query frontend transport parameters.
 *                                       o Connect to the event channels.
 *                                                      |
 *                                                      |
 *                                                      V
 *                                      XenbusStateConnected
 *
 *  o Create and initialize OS
 *    virtual sound device instances
 *    as per configuration.
 *              |
 *              |
 *              V
 * XenbusStateConnected
 *
 *                                      XenbusStateUnknown
 *                                      XenbusStateClosed
 *                                      XenbusStateClosing
 * o Remove virtual sound device
 * o Remove event channels
 *              |
 *              |
 *              V
 * XenbusStateClosed
< ASCII >
 *
 *------------------------------- Recovery flow -------------------------------
 *
 * In case of frontend unrecoverable errors backend handles that as
 * if frontend goes into the XenbusStateClosed state.
 *
 * In case of backend unrecoverable errors frontend tries removing
 * the virtualized device. If this is possible at the moment of error,
 * then frontend goes into the XenbusStateInitialising state and is ready for
 * new connection with backend. If the virtualized device is still in use and
 * cannot be removed, then frontend goes into the XenbusStateReconfiguring state
 * until either the virtualized device removed or backend initiates a new
 * connection. On the virtualized device removal frontend goes into the
 * XenbusStateInitialising state.
 *
 * Note on XenbusStateReconfiguring state of the frontend: if backend has
 * unrecoverable errors then frontend cannot send requests to the backend
 * and thus cannot provide functionality of the virtualized device anymore.
 * After backend is back to normal the virtualized device may still hold some
 * state: configuration in use, allocated buffers, client application state etc.
 * So, in most cases, this will require frontend to implement complex recovery
 * reconnect logic. Instead, by going into XenbusStateReconfiguring state,
 * frontend will make sure no new clients of the virtualized device are
 * accepted, allow existing client(s) to exit gracefully by signaling error
 * state etc.
 * Once all the clients are gone frontend can reinitialize the virtualized
 * device and get into XenbusStateInitialising state again signaling the
 * backend that a new connection can be made.
 *
 * There are multiple conditions possible under which frontend will go from
 * XenbusStateReconfiguring into XenbusStateInitialising, some of them are OS
 * specific. For example:
 * 1. The underlying OS framework may provide callbacks to signal that the last
 *    client of the virtualized device has gone and the device can be removed
 * 2. Frontend can schedule a deferred work (timer/tasklet/workqueue)
 *    to periodically check if this is the right time to re-try removal of
 *    the virtualized device.
 * 3. By any other means.
 *
 ******************************************************************************
 *                             PCM FORMATS
 ******************************************************************************
 *
 * XENSND_PCM_FORMAT_<format>[_<endian>]
 *
 * format: <S/U/F><bits> or <name>
 *     S - signed, U - unsigned, F - float
 *     bits - 8, 16, 24, 32
 *     name - MU_LAW, GSM, etc.
 *
 * endian: <LE/BE>, may be absent
 *     LE - Little endian, BE - Big endian
 */
```
## Visual type:
- #state-machine


== ./linux/linux_1009.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/sndif.h#L524-L618

```c
/*
 ******************************************************************************
 *                          STATUS RETURN CODES
 ******************************************************************************
 *
 * Status return code is zero on success and -XEN_EXX on failure.
 *
 ******************************************************************************
 *                              Assumptions
 ******************************************************************************
 * o usage of grant reference 0 as invalid grant reference:
 *   grant reference 0 is valid, but never exposed to a PV driver,
 *   because of the fact it is already in use/reserved by the PV console.
 * o all references in this document to page sizes must be treated
 *   as pages of size XEN_PAGE_SIZE unless otherwise noted.
 *
 ******************************************************************************
 *       Description of the protocol between frontend and backend driver
 ******************************************************************************
 *
 * The two halves of a Para-virtual sound driver communicate with
 * each other using shared pages and event channels.
 * Shared page contains a ring with request/response packets.
 *
 * Packets, used for input/output operations, e.g. read/write, set/get volume,
 * etc., provide offset/length fields in order to allow asynchronous protocol
 * operation with buffer space sharing: part of the buffer allocated at
 * XENSND_OP_OPEN can be used for audio samples and part, for example,
 * for volume control.
 *
 * All reserved fields in the structures below must be 0.
 *
 *---------------------------------- Requests ---------------------------------
 *
 * All request packets have the same length (64 octets)
< ASCII >
 * All request packets have common header:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |    operation   |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *   id - uint16_t, private guest value, echoed in response
 *   operation - uint8_t, operation code, XENSND_OP_???
 *
 * For all packets which use offset and length:
 *   offset - uint32_t, read or write data offset within the shared buffer,
 *     passed with XENSND_OP_OPEN request, octets,
 *     [0; XENSND_OP_OPEN.buffer_sz - 1].
 *   length - uint32_t, read or write data length, octets
 *
< ASCII >
 * Request open - open a PCM stream for playback or capture:
 *
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                | XENSND_OP_OPEN |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                             pcm_rate                              | 12
 * +----------------+----------------+----------------+----------------+
 * |  pcm_format    |  pcm_channels  |             reserved            | 16
 * +----------------+----------------+----------------+----------------+
 * |                             buffer_sz                             | 20
 * +----------------+----------------+----------------+----------------+
 * |                           gref_directory                          | 24
 * +----------------+----------------+----------------+----------------+
 * |                             period_sz                             | 28
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 32
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * pcm_rate - uint32_t, stream data rate, Hz
 * pcm_format - uint8_t, XENSND_PCM_FORMAT_XXX value
 * pcm_channels - uint8_t, number of channels of this stream,
 *   [channels-min; channels-max]
 * buffer_sz - uint32_t, buffer size to be allocated, octets
 * period_sz - uint32_t, event period size, octets
 *   This is the requested value of the period at which frontend would
 *   like to receive XENSND_EVT_CUR_POS notifications from the backend when
 *   stream position advances during playback/capture.
 *   It shows how many octets are expected to be played/captured before
 *   sending such an event.
 *   If set to 0 no XENSND_EVT_CUR_POS events are sent by the backend.
 *
 * gref_directory - grant_ref_t, a reference to the first shared page
 *   describing shared buffer references. At least one page exists. If shared
 *   buffer size  (buffer_sz) exceeds what can be addressed by this single page,
 *   then reference to the next page must be supplied (see gref_dir_next_page
 *   below)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_101.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/loongarch/include/asm/addrspace.h#L112-L122

```c
/*
< ASCII >
 * On LoongArch, I/O ports mappring is following:
 *
 *              |         ....          |
 *              |-----------------------|
 *              | pci io ports(16K~32M) |
 *              |-----------------------|
 *              | isa io ports(0  ~16K) |
 * PCI_IOBASE ->|-----------------------|
 *              |         ....          |
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1010.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/sndif.h#L630-L658

```c
/*
 * Shared page for XENSND_OP_OPEN buffer descriptor (gref_directory in the
 *   request) employs a list of pages, describing all pages of the shared data
 *   buffer:
< ASCII >
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |                        gref_dir_next_page                         | 4
 * +----------------+----------------+----------------+----------------+
 * |                              gref[0]                              | 8
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                              gref[i]                              | i*4+8
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             gref[N - 1]                           | N*4+8
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * gref_dir_next_page - grant_ref_t, reference to the next page describing
 *   page directory. Must be 0 if there are no more pages in the list.
 * gref[i] - grant_ref_t, reference to a shared page of the buffer
 *   allocated at XENSND_OP_OPEN
 *
 * Number of grant_ref_t entries in the whole page directory is not
 * passed, but instead can be calculated as:
 *   num_grefs_total = (XENSND_OP_OPEN.buffer_sz + XEN_PAGE_SIZE - 1) /
 *       XEN_PAGE_SIZE
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1011.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/sndif.h#L665-L697

```c
/*
< ASCII >
 *  Request close - close an opened pcm stream:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                | XENSND_OP_CLOSE|    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
< ASCII >
 * Request read/write - used for read (for capture) or write (for playback):
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |   operation    |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                              offset                               | 12
 * +----------------+----------------+----------------+----------------+
 * |                              length                               | 16
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 20
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
 *
 * operation - XENSND_OP_READ for read or XENSND_OP_WRITE for write
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1012.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/sndif.h#L704-L810

```c
/*
< ASCII >
 * Request set/get volume - set/get channels' volume of the stream given:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |   operation    |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                              offset                               | 12
 * +----------------+----------------+----------------+----------------+
 * |                              length                               | 16
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 20
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * operation - XENSND_OP_SET_VOLUME for volume set
 *   or XENSND_OP_GET_VOLUME for volume get
< ASCII >
 * Buffer passed with XENSND_OP_OPEN is used to exchange volume
 * values:
 *
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |                             channel[0]                            | 4
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             channel[i]                            | i*4
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                           channel[N - 1]                          | (N-1)*4
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * N = XENSND_OP_OPEN.pcm_channels
 * i - uint8_t, index of a channel
 * channel[i] - sint32_t, volume of i-th channel
 * Volume is expressed as a signed value in steps of 0.001 dB,
 * while 0 being 0 dB.
 *
< ASCII >
 * Request mute/unmute - mute/unmute stream:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |   operation    |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                              offset                               | 12
 * +----------------+----------------+----------------+----------------+
 * |                              length                               | 16
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 20
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * operation - XENSND_OP_MUTE for mute or XENSND_OP_UNMUTE for unmute
 * Buffer passed with XENSND_OP_OPEN is used to exchange mute/unmute
 * values:
 *
< ASCII >
 *                                   0                                 octet
 * +----------------+----------------+----------------+----------------+
 * |                             channel[0]                            | 4
 * +----------------+----------------+----------------+----------------+
 * +/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             channel[i]                            | i*4
 * +----------------+----------------+----------------+----------------+
 * +/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                           channel[N - 1]                          | (N-1)*4
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * N = XENSND_OP_OPEN.pcm_channels
 * i - uint8_t, index of a channel
 * channel[i] - uint8_t, non-zero if i-th channel needs to be muted/unmuted
 *
 *------------------------------------ N.B. -----------------------------------
 *
 * The 'struct xensnd_rw_req' is also used for XENSND_OP_SET_VOLUME,
 * XENSND_OP_GET_VOLUME, XENSND_OP_MUTE, XENSND_OP_UNMUTE.
 *
 * Request stream running state change - trigger PCM stream running state
 * to start, stop, pause or resume:
< ASCII >
 *
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |   _OP_TRIGGER  |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |      type      |                     reserved                     | 12
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 16
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * type - uint8_t, XENSND_OP_TRIGGER_XXX value
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1013.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/sndif.h#L816-L874

```c
/*
 * Request stream parameter ranges: request intervals and
 *   masks of supported ranges for stream configuration values.
 *
 *   Sound device configuration for a particular stream is a limited subset
 *   of the multidimensional configuration available on XenStore, e.g.
 *   once the frame rate has been selected there is a limited supported range
 *   for sample rates becomes available (which might be the same set configured
 *   on XenStore or less). For example, selecting 96kHz sample rate may limit
 *   number of channels available for such configuration from 4 to 2, etc.
 *   Thus, each call to XENSND_OP_HW_PARAM_QUERY may reduce configuration
 *   space making it possible to iteratively get the final stream configuration,
 *   used in XENSND_OP_OPEN request.
 *
 *   See response format for this request.
< ASCII >
 *
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                | _HW_PARAM_QUERY|    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                     formats mask low 32-bit                       | 12
 * +----------------+----------------+----------------+----------------+
 * |                     formats mask high 32-bit                      | 16
 * +----------------+----------------+----------------+----------------+
 * |                              min rate                             | 20
 * +----------------+----------------+----------------+----------------+
 * |                              max rate                             | 24
 * +----------------+----------------+----------------+----------------+
 * |                            min channels                           | 28
 * +----------------+----------------+----------------+----------------+
 * |                            max channels                           | 32
 * +----------------+----------------+----------------+----------------+
 * |                         min buffer frames                         | 36
 * +----------------+----------------+----------------+----------------+
 * |                         max buffer frames                         | 40
 * +----------------+----------------+----------------+----------------+
 * |                         min period frames                         | 44
 * +----------------+----------------+----------------+----------------+
 * |                         max period frames                         | 48
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 52
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * formats - uint64_t, bit mask representing values of the parameter
 *     made as bitwise OR of (1 << XENSND_PCM_FORMAT_XXX) values
 *
 * For interval parameters:
 *   min - uint32_t, minimum value of the parameter
 *   max - uint32_t, maximum value of the parameter
 *
 * Frame is defined as a product of the number of channels by the
 * number of octets per one sample.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1014.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/sndif.h#L896-L950

```c
/*
 *---------------------------------- Responses --------------------------------
 *
 * All response packets have the same length (64 octets)
 *
< ASCII >
 * All response packets have common header:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |    operation   |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                              status                               | 8
 * +----------------+----------------+----------------+----------------+
 *
< ASCII >
 * id - uint16_t, copied from the request
 * operation - uint8_t, XENSND_OP_* - copied from request
 * status - int32_t, response status, zero on success and -XEN_EXX on failure
 *
 *
< ASCII >
 * HW parameter query response - response for XENSND_OP_HW_PARAM_QUERY:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |    operation   |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                              status                               | 8
 * +----------------+----------------+----------------+----------------+
 * |                     formats mask low 32-bit                       | 12
 * +----------------+----------------+----------------+----------------+
 * |                     formats mask high 32-bit                      | 16
 * +----------------+----------------+----------------+----------------+
 * |                              min rate                             | 20
 * +----------------+----------------+----------------+----------------+
 * |                              max rate                             | 24
 * +----------------+----------------+----------------+----------------+
 * |                            min channels                           | 28
 * +----------------+----------------+----------------+----------------+
 * |                            max channels                           | 32
 * +----------------+----------------+----------------+----------------+
 * |                         min buffer frames                         | 36
 * +----------------+----------------+----------------+----------------+
 * |                         max buffer frames                         | 40
 * +----------------+----------------+----------------+----------------+
 * |                         min period frames                         | 44
 * +----------------+----------------+----------------+----------------+
 * |                         max period frames                         | 48
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 52
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * Meaning of the values in this response is the same as for
 * XENSND_OP_HW_PARAM_QUERY request.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1015.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/sndif.h#L952-L991

```c
/*
 *----------------------------------- Events ----------------------------------
 *
 * Events are sent via shared page allocated by the front and propagated by
 *   evt-event-channel/evt-ring-ref XenStore entries
 * All event packets have the same length (64 octets)
< ASCII >
 * All event packets have common header:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |      type      |   reserved     | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * id - uint16_t, event id, may be used by front
 * type - uint8_t, type of the event
 *
 *
 * Current stream position - event from back to front when stream's
 *   playback/capture position has advanced:
< ASCII >
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |   _EVT_CUR_POS |   reserved     | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                         position low 32-bit                       | 12
 * +----------------+----------------+----------------+----------------+
 * |                         position high 32-bit                      | 16
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 20
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *
 * position - current value of stream's playback/capture position, octets
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1016.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/usbif.h#L18-L250

```c
/*
 * Detailed Interface Description
 * ==============================
 * The pvUSB interface is using a split driver design: a frontend driver in
 * the guest and a backend driver in a driver domain (normally dom0) having
 * access to the physical USB device(s) being passed to the guest.
 *
 * The frontend and backend drivers use XenStore to initiate the connection
 * between them, the I/O activity is handled via two shared ring pages and an
 * event channel. As the interface between frontend and backend is at the USB
 * host connector level, multiple (up to 31) physical USB devices can be
 * handled by a single connection.
 *
 * The Xen pvUSB device name is "qusb", so the frontend's XenStore entries are
 * to be found under "device/qusb", while the backend's XenStore entries are
 * under "backend/<guest-dom-id>/qusb".
 *
 * When a new pvUSB connection is established, the frontend needs to setup the
 * two shared ring pages for communication and the event channel. The ring
 * pages need to be made available to the backend via the grant table
 * interface.
 *
 * One of the shared ring pages is used by the backend to inform the frontend
 * about USB device plug events (device to be added or removed). This is the
 * "conn-ring".
 *
 * The other ring page is used for USB I/O communication (requests and
 * responses). This is the "urb-ring".
 *
 * Feature and Parameter Negotiation
 * =================================
 * The two halves of a Xen pvUSB driver utilize nodes within the XenStore to
 * communicate capabilities and to negotiate operating parameters. This
 * section enumerates these nodes which reside in the respective front and
 * backend portions of the XenStore, following the XenBus convention.
 *
 * Any specified default value is in effect if the corresponding XenBus node
 * is not present in the XenStore.
 *
 * XenStore nodes in sections marked "PRIVATE" are solely for use by the
 * driver side whose XenBus tree contains them.
 *
 *****************************************************************************
 *                            Backend XenBus Nodes
 *****************************************************************************
 *
 *------------------ Backend Device Identification (PRIVATE) ------------------
 *
 * num-ports
 *      Values:         unsigned [1...31]
 *
 *      Number of ports for this (virtual) USB host connector.
 *
 * usb-ver
 *      Values:         unsigned [1...2]
 *
 *      USB version of this host connector: 1 = USB 1.1, 2 = USB 2.0.
 *
 * port/[1...31]
 *      Values:         string
 *
 *      Physical USB device connected to the given port, e.g. "3-1.5".
 *
 *****************************************************************************
 *                            Frontend XenBus Nodes
 *****************************************************************************
 *
 *----------------------- Request Transport Parameters -----------------------
 *
 * event-channel
 *      Values:         unsigned
 *
 *      The identifier of the Xen event channel used to signal activity
 *      in the ring buffer.
 *
 * urb-ring-ref
 *      Values:         unsigned
 *
 *      The Xen grant reference granting permission for the backend to map
 *      the sole page in a single page sized ring buffer. This is the ring
 *      buffer for urb requests.
 *
 * conn-ring-ref
 *      Values:         unsigned
 *
 *      The Xen grant reference granting permission for the backend to map
 *      the sole page in a single page sized ring buffer. This is the ring
 *      buffer for connection/disconnection requests.
 *
 * protocol
 *      Values:         string (XEN_IO_PROTO_ABI_*)
 *      Default Value:  XEN_IO_PROTO_ABI_NATIVE
 *
 *      The machine ABI rules governing the format of all ring request and
 *      response structures.
 *
 * Protocol Description
 * ====================
 *
 *-------------------------- USB device plug events --------------------------
 *
 * USB device plug events are send via the "conn-ring" shared page. As only
 * events are being sent, the respective requests from the frontend to the
 * backend are just dummy ones.
< ASCII >
 * The events sent to the frontend have the following layout:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |    portnum     |     speed      | 4
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *   id - uint16_t, event id (taken from the actual frontend dummy request)
 *   portnum - uint8_t, port number (1 ... 31)
 *   speed - uint8_t, device XENUSB_SPEED_*, XENUSB_SPEED_NONE == unplug
 *
< ASCII >
 * The dummy request:
 *         0                1        octet
 * +----------------+----------------+
 * |               id                | 2
 * +----------------+----------------+
 *   id - uint16_t, guest supplied value (no need for being unique)
< ASCII >
 *
 *-------------------------- USB I/O request ---------------------------------
 *
< ASCII >
 * A single USB I/O request on the "urb-ring" has the following layout:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |         nr_buffer_segs          | 4
 * +----------------+----------------+----------------+----------------+
 * |                               pipe                                | 8
 * +----------------+----------------+----------------+----------------+
 * |         transfer_flags          |          buffer_length          | 12
 * +----------------+----------------+----------------+----------------+
 * |                       request type specific                       | 16
 * |                               data                                | 20
 * +----------------+----------------+----------------+----------------+
 * |                              seg[0]                               | 24
 * |                               data                                | 28
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |             seg[XENUSB_MAX_SEGMENTS_PER_REQUEST - 1]              | 144
 * |                               data                                | 148
 * +----------------+----------------+----------------+----------------+
< ASCII >
 * Bit field bit number 0 is always least significant bit, undefined bits must
 * be zero.
 *   id - uint16_t, guest supplied value
 *   nr_buffer_segs - uint16_t, number of segment entries in seg[] array
 *   pipe - uint32_t, bit field with multiple information:
 *     bits 0-4: port request to send to
 *     bit 5: unlink request with specified id (cancel I/O) if set (see below)
 *     bit 7: direction (1 = read from device)
 *     bits 8-14: device number on port
 *     bits 15-18: endpoint of device
 *     bits 30-31: request type: 00 = isochronous, 01 = interrupt,
 *                               10 = control, 11 = bulk
 *   transfer_flags - uint16_t, bit field with processing flags:
 *     bit 0: less data than specified allowed
 *   buffer_length - uint16_t, total length of data
 *   request type specific data - 8 bytes, see below
 *   seg[] - array with 8 byte elements, see below
 *
< ASCII >
 * Request type specific data for isochronous request:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |            interval             |           start_frame           | 4
 * +----------------+----------------+----------------+----------------+
 * |       number_of_packets         |       nr_frame_desc_segs        | 8
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *   interval - uint16_t, time interval in msecs between frames
 *   start_frame - uint16_t, start frame number
 *   number_of_packets - uint16_t, number of packets to transfer
 *   nr_frame_desc_segs - uint16_t number of seg[] frame descriptors elements
 *
< ASCII >
 * Request type specific data for interrupt request:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |            interval             |                0                | 4
 * +----------------+----------------+----------------+----------------+
 * |                                 0                                 | 8
 * +----------------+----------------+----------------+----------------+
 *   interval - uint16_t, time in msecs until interruption
< ASCII >
< ASCII >
 *
 * Request type specific data for control request:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |                      data of setup packet                         | 4
 * |                                                                   | 8
 * +----------------+----------------+----------------+----------------+
< ASCII >
< ASCII >
 *
 * Request type specific data for bulk request:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |                                 0                                 | 4
 * |                                 0                                 | 8
 * +----------------+----------------+----------------+----------------+
< ASCII >
< ASCII >
 *
 * Request type specific data for unlink request:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |           unlink_id             |                0                | 4
 * +----------------+----------------+----------------+----------------+
 * |                                 0                                 | 8
 * +----------------+----------------+----------------+----------------+
 *   unlink_id - uint16_t, request id of request to terminate
< ASCII >
< ASCII >
 *
 * seg[] array element layout:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |                               gref                                | 4
 * +----------------+----------------+----------------+----------------+
 * |             offset              |             length              | 8
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *   gref - uint32_t, grant reference of buffer page
 *   offset - uint16_t, offset of buffer start in page
 *   length - uint16_t, length of buffer in page
< ASCII >
 *
 *-------------------------- USB I/O response --------------------------------
 *
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |          start_frame            | 4
 * +----------------+----------------+----------------+----------------+
 * |                              status                               | 8
 * +----------------+----------------+----------------+----------------+
 * |                          actual_length                            | 12
 * +----------------+----------------+----------------+----------------+
 * |                           error_count                             | 16
 * +----------------+----------------+----------------+----------------+
< ASCII >
 *   id - uint16_t, id of the request this response belongs to
 *   start_frame - uint16_t, start_frame this response (iso requests only)
 *   status - int32_t, XENUSB_STATUS_* (non-iso requests)
 *   actual_length - uint32_t, actual size of data transferred
 *   error_count - uint32_t, number of errors (iso requests)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1017.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/watchdog.c#L646-L657

```c
/*
< ASCII >
 * common function for watchdog, nmi_watchdog and soft_watchdog parameter
 *
 * caller             | table->data points to      | 'which'
 * -------------------|----------------------------|--------------------------
 * proc_watchdog      | watchdog_user_enabled      | NMI_WATCHDOG_ENABLED |
 *                    |                            | SOFT_WATCHDOG_ENABLED
 * -------------------|----------------------------|--------------------------
 * proc_nmi_watchdog  | nmi_watchdog_user_enabled  | NMI_WATCHDOG_ENABLED
 * -------------------|----------------------------|--------------------------
 * proc_soft_watchdog | soft_watchdog_user_enabled | SOFT_WATCHDOG_ENABLED
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1018.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/bpf/btf.c#L104-L169

```c
/* BTF verification:
 *
 * To verify BTF data, two passes are needed.
 *
 * Pass #1
 * ~~~~~~~
 * The first pass is to collect all btf_type objects to
 * an array: "btf->types".
 *
 * Depending on the C type that a btf_type is describing,
 * a btf_type may be followed by extra data.  We don't know
 * how many btf_type is there, and more importantly we don't
 * know where each btf_type is located in the type section.
 *
 * Without knowing the location of each type_id, most verifications
 * cannot be done.  e.g. an earlier btf_type may refer to a later
 * btf_type (recall the "const void *" above), so we cannot
 * check this type-reference in the first pass.
 *
 * In the first pass, it still does some verifications (e.g.
 * checking the name is a valid offset to the string section).
 *
 * Pass #2
 * ~~~~~~~
 * The main focus is to resolve a btf_type that is referring
 * to another type.
 *
 * We have to ensure the referring type:
 * 1) does exist in the BTF (i.e. in btf->types[])
 * 2) does not cause a loop:
 *	struct A {
 *		struct B b;
 *	};
 *
 *	struct B {
 *		struct A a;
 *	};
 *
 * btf_type_needs_resolve() decides if a btf_type needs
 * to be resolved.
 *
 * The needs_resolve type implements the "resolve()" ops which
 * essentially does a DFS and detects backedge.
 *
 * During resolve (or DFS), different C types have different
 * "RESOLVED" conditions.
 *
 * When resolving a BTF_KIND_STRUCT, we need to resolve all its
 * members because a member is always referring to another
 * type.  A struct's member can be treated as "RESOLVED" if
 * it is referring to a BTF_KIND_PTR.  Otherwise, the
 * following valid C struct would be rejected:
 *
 *	struct A {
 *		int m;
 *		struct A *a;
 *	};
 *
 * When resolving a BTF_KIND_PTR, it needs to keep resolving if
 * it is referring to another BTF_KIND_PTR.  Otherwise, we cannot
 * detect a pointer loop, e.g.:
< ASCII >
 * BTF_KIND_CONST -> BTF_KIND_PTR -> BTF_KIND_CONST -> BTF_KIND_PTR +
 *                        ^                                         |
 *                        +-----------------------------------------+
< ASCII >
 *
 */
```
## Visual type:
- #sequence


== ./linux/linux_1019.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/bpf/lpm_trie.c#L41-L150

```c
/* This trie implements a longest prefix match algorithm that can be used to
 * match IP addresses to a stored set of ranges.
 *
 * Data stored in @data of struct bpf_lpm_key and struct lpm_trie_node is
 * interpreted as big endian, so data[0] stores the most significant byte.
 *
 * Match ranges are internally stored in instances of struct lpm_trie_node
 * which each contain their prefix length as well as two pointers that may
 * lead to more nodes containing more specific matches. Each node also stores
 * a value that is defined by and returned to userspace via the update_elem
 * and lookup functions.
 *
 * For instance, let's start with a trie that was created with a prefix length
 * of 32, so it can be used for IPv4 addresses, and one single element that
 * matches 192.168.0.0/16. The data array would hence contain
 * [0xc0, 0xa8, 0x00, 0x00] in big-endian notation. This documentation will
 * stick to IP-address notation for readability though.
 *
 * As the trie is empty initially, the new node (1) will be places as root
 * node, denoted as (R) in the example below. As there are no other node, both
 * child pointers are %NULL.
< ASCII >
 *
 *              +----------------+
 *              |       (1)  (R) |
 *              | 192.168.0.0/16 |
 *              |    value: 1    |
 *              |   [0]    [1]   |
 *              +----------------+
< ASCII >
 *
 * Next, let's add a new node (2) matching 192.168.0.0/24. As there is already
 * a node with the same data and a smaller prefix (ie, a less specific one),
 * node (2) will become a child of (1). In child index depends on the next bit
 * that is outside of what (1) matches, and that bit is 0, so (2) will be
 * child[0] of (1):
< ASCII >
 *
 *              +----------------+
 *              |       (1)  (R) |
 *              | 192.168.0.0/16 |
 *              |    value: 1    |
 *              |   [0]    [1]   |
 *              +----------------+
 *                   |
 *    +----------------+
 *    |       (2)      |
 *    | 192.168.0.0/24 |
 *    |    value: 2    |
 *    |   [0]    [1]   |
 *    +----------------+
< ASCII >
 *
 * The child[1] slot of (1) could be filled with another node which has bit #17
 * (the next bit after the ones that (1) matches on) set to 1. For instance,
 * 192.168.128.0/24:
< ASCII >
 *
 *              +----------------+
 *              |       (1)  (R) |
 *              | 192.168.0.0/16 |
 *              |    value: 1    |
 *              |   [0]    [1]   |
 *              +----------------+
 *                   |      |
 *    +----------------+  +------------------+
 *    |       (2)      |  |        (3)       |
 *    | 192.168.0.0/24 |  | 192.168.128.0/24 |
 *    |    value: 2    |  |     value: 3     |
 *    |   [0]    [1]   |  |    [0]    [1]    |
 *    +----------------+  +------------------+
< ASCII >
 *
 * Let's add another node (4) to the game for 192.168.1.0/24. In order to place
 * it, node (1) is looked at first, and because (4) of the semantics laid out
 * above (bit #17 is 0), it would normally be attached to (1) as child[0].
 * However, that slot is already allocated, so a new node is needed in between.
 * That node does not have a value attached to it and it will never be
 * returned to users as result of a lookup. It is only there to differentiate
 * the traversal further. It will get a prefix as wide as necessary to
 * distinguish its two children:
< ASCII >
 *
 *                      +----------------+
 *                      |       (1)  (R) |
 *                      | 192.168.0.0/16 |
 *                      |    value: 1    |
 *                      |   [0]    [1]   |
 *                      +----------------+
 *                           |      |
 *            +----------------+  +------------------+
 *            |       (4)  (I) |  |        (3)       |
 *            | 192.168.0.0/23 |  | 192.168.128.0/24 |
 *            |    value: ---  |  |     value: 3     |
 *            |   [0]    [1]   |  |    [0]    [1]    |
 *            +----------------+  +------------------+
 *                 |      |
 *  +----------------+  +----------------+
 *  |       (2)      |  |       (5)      |
 *  | 192.168.0.0/24 |  | 192.168.1.0/24 |
 *  |    value: 2    |  |     value: 5   |
 *  |   [0]    [1]   |  |   [0]    [1]   |
 *  +----------------+  +----------------+
< ASCII >
 *
 * 192.168.1.1/32 would be a child of (5) etc.
 *
 * An intermediate node will be turned into a 'real' node on demand. In the
 * example above, (4) would be re-used if 192.168.0.0/23 is added to the trie.
 *
 * A fully populated trie would have a height of 32 nodes, as the trie was
 * created with a prefix length of 32.
 *
 * The lookup starts at the root node. If the current node matches and if there
 * is a child that can be used to become more specific, the trie is traversed
 * downwards. The last node in the traversal that is a non-intermediate one is
 * returned.
 */
```
## Visual type:
- #tree


== ./linux/linux_102.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/loongarch/include/asm/cpu.h#L11-L19

```c
/*
< ASCII >
 * As described in LoongArch specs from Loongson Technology, the PRID register
 * (CPUCFG.00) has the following layout:
 *
 * +---------------+----------------+------------+--------------------+
 * | Reserved      | Company ID     | Series ID  |  Product ID        |
 * +---------------+----------------+------------+--------------------+
 *  31		 24 23		  16 15	       12 11		     0
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1020.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/futex/pi.c#L112-L195

```c
/*
< ASCII >
 * We need to check the following states:
 *
 *      Waiter | pi_state | pi->owner | uTID      | uODIED | ?
 *
 * [1]  NULL   | ---      | ---       | 0         | 0/1    | Valid
 * [2]  NULL   | ---      | ---       | >0        | 0/1    | Valid
 *
 * [3]  Found  | NULL     | --        | Any       | 0/1    | Invalid
 *
 * [4]  Found  | Found    | NULL      | 0         | 1      | Valid
 * [5]  Found  | Found    | NULL      | >0        | 1      | Invalid
 *
 * [6]  Found  | Found    | task      | 0         | 1      | Valid
 *
 * [7]  Found  | Found    | NULL      | Any       | 0      | Invalid
 *
 * [8]  Found  | Found    | task      | ==taskTID | 0/1    | Valid
 * [9]  Found  | Found    | task      | 0         | 0      | Invalid
 * [10] Found  | Found    | task      | !=taskTID | 0/1    | Invalid
< ASCII >
 *
 * [1]	Indicates that the kernel can acquire the futex atomically. We
 *	came here due to a stale FUTEX_WAITERS/FUTEX_OWNER_DIED bit.
 *
 * [2]	Valid, if TID does not belong to a kernel thread. If no matching
 *      thread is found then it indicates that the owner TID has died.
 *
 * [3]	Invalid. The waiter is queued on a non PI futex
 *
 * [4]	Valid state after exit_robust_list(), which sets the user space
 *	value to FUTEX_WAITERS | FUTEX_OWNER_DIED.
 *
 * [5]	The user space value got manipulated between exit_robust_list()
 *	and exit_pi_state_list()
 *
 * [6]	Valid state after exit_pi_state_list() which sets the new owner in
 *	the pi_state but cannot access the user space value.
 *
 * [7]	pi_state->owner can only be NULL when the OWNER_DIED bit is set.
 *
 * [8]	Owner and user space value match
 *
 * [9]	There is no transient state which sets the user space TID to 0
 *	except exit_robust_list(), but this is indicated by the
 *	FUTEX_OWNER_DIED bit. See [4]
 *
 * [10] There is no transient state which leaves owner and user space
 *	TID out of sync. Except one error case where the kernel is denied
 *	write access to the user address, see fixup_pi_state_owner().
 *
 *
 * Serialization and lifetime rules:
 *
 * hb->lock:
 *
 *	hb -> futex_q, relation
 *	futex_q -> pi_state, relation
 *
 *	(cannot be raw because hb can contain arbitrary amount
 *	 of futex_q's)
 *
 * pi_mutex->wait_lock:
 *
 *	{uval, pi_state}
 *
 *	(and pi_mutex 'obviously')
 *
 * p->pi_lock:
 *
 *	p->pi_state_list -> pi_state->list, relation
 *	pi_mutex->owner -> pi_state->owner, relation
 *
 * pi_state->refcount:
 *
 *	pi_state lifetime
 *
 *
 * Lock order:
 *
 *   hb->lock
 *     pi_mutex->wait_lock
 *       p->pi_lock
 *
 */
```
## Visual type:
- #table


== ./linux/linux_1021.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/futex/waitwake.c#L9-L107

```c
/*
 * READ this before attempting to hack on futexes!
 *
 * Basic futex operation and ordering guarantees
 * =============================================
 *
 * The waiter reads the futex value in user space and calls
 * futex_wait(). This function computes the hash bucket and acquires
 * the hash bucket lock. After that it reads the futex user space value
 * again and verifies that the data has not changed. If it has not changed
 * it enqueues itself into the hash bucket, releases the hash bucket lock
 * and schedules.
 *
 * The waker side modifies the user space value of the futex and calls
 * futex_wake(). This function computes the hash bucket and acquires the
 * hash bucket lock. Then it looks for waiters on that futex in the hash
 * bucket and wakes them.
 *
 * In futex wake up scenarios where no tasks are blocked on a futex, taking
 * the hb spinlock can be avoided and simply return. In order for this
 * optimization to work, ordering guarantees must exist so that the waiter
 * being added to the list is acknowledged when the list is concurrently being
 * checked by the waker, avoiding scenarios like the following:
 *
 * CPU 0                               CPU 1
 * val = *futex;
 * sys_futex(WAIT, futex, val);
 *   futex_wait(futex, val);
 *   uval = *futex;
 *                                     *futex = newval;
 *                                     sys_futex(WAKE, futex);
 *                                       futex_wake(futex);
 *                                       if (queue_empty())
 *                                         return;
 *   if (uval == val)
 *      lock(hash_bucket(futex));
 *      queue();
 *     unlock(hash_bucket(futex));
 *     schedule();
 *
 * This would cause the waiter on CPU 0 to wait forever because it
 * missed the transition of the user space value from val to newval
 * and the waker did not find the waiter in the hash bucket queue.
 *
 * The correct serialization ensures that a waiter either observes
 * the changed user space value before blocking or is woken by a
 * concurrent waker:
 *
< ASCII >
 * CPU 0                                 CPU 1
 * val = *futex;
 * sys_futex(WAIT, futex, val);
 *   futex_wait(futex, val);
 *
 *   waiters++; (a)
 *   smp_mb(); (A) <-- paired with -.
 *                                  |
 *   lock(hash_bucket(futex));      |
 *                                  |
 *   uval = *futex;                 |
 *                                  |        *futex = newval;
 *                                  |        sys_futex(WAKE, futex);
 *                                  |          futex_wake(futex);
 *                                  |
 *                                  `--------> smp_mb(); (B)
 *   if (uval == val)
 *     queue();
 *     unlock(hash_bucket(futex));
 *     schedule();                         if (waiters)
 *                                           lock(hash_bucket(futex));
 *   else                                    wake_waiters(futex);
 *     waiters--; (b)                        unlock(hash_bucket(futex));
< ASCII >
 *
 * Where (A) orders the waiters increment and the futex value read through
 * atomic operations (see futex_hb_waiters_inc) and where (B) orders the write
 * to futex and the waiters read (see futex_hb_waiters_pending()).
 *
 * This yields the following case (where X:=waiters, Y:=futex):
 *
 *	X = Y = 0
 *
 *	w[X]=1		w[Y]=1
 *	MB		MB
 *	r[Y]=y		r[X]=x
 *
 * Which guarantees that x==0 && y==0 is impossible; which translates back into
 * the guarantee that we cannot both miss the futex variable change and the
 * enqueue.
 *
 * Note that a new waiter is accounted for in (a) even when it is possible that
 * the wait call can return error, in which case we backtrack from it in (b).
 * Refer to the comment in futex_q_lock().
 *
 * Similarly, in order to account for waiters being requeued on another
 * address we always increment the waiters for the destination bucket before
 * acquiring the lock. It then decrements them again  after releasing it -
 * the code that actually moves the futex(es) between hash buckets (requeue_futex)
 * will do the additional required waiter count housekeeping. This is done for
 * double_lock_hb() and double_unlock_hb(), respectively.
 */
```
## Visual type:
- #custom


== ./linux/linux_1022.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/irq/timings.c#L36-L262

```c
/*
 * The main goal of this algorithm is to predict the next interrupt
 * occurrence on the current CPU.
 *
 * Currently, the interrupt timings are stored in a circular array
 * buffer every time there is an interrupt, as a tuple: the interrupt
 * number and the associated timestamp when the event occurred <irq,
 * timestamp>.
 *
 * For every interrupt occurring in a short period of time, we can
 * measure the elapsed time between the occurrences for the same
 * interrupt and we end up with a suite of intervals. The experience
 * showed the interrupts are often coming following a periodic
 * pattern.
 *
 * The objective of the algorithm is to find out this periodic pattern
 * in a fastest way and use its period to predict the next irq event.
 *
 * When the next interrupt event is requested, we are in the situation
 * where the interrupts are disabled and the circular buffer
 * containing the timings is filled with the events which happened
 * after the previous next-interrupt-event request.
 *
 * At this point, we read the circular buffer and we fill the irq
 * related statistics structure. After this step, the circular array
 * containing the timings is empty because all the values are
 * dispatched in their corresponding buffers.
 *
 * Now for each interrupt, we can predict the next event by using the
 * suffix array, log interval and exponential moving average
 *
 * 1. Suffix array
 *
 * Suffix array is an array of all the suffixes of a string. It is
 * widely used as a data structure for compression, text search, ...
 * For instance for the word 'banana', the suffixes will be: 'banana'
 * 'anana' 'nana' 'ana' 'na' 'a'
 *
 * Usually, the suffix array is sorted but for our purpose it is
 * not necessary and won't provide any improvement in the context of
 * the solved problem where we clearly define the boundaries of the
 * search by a max period and min period.
 *
 * The suffix array will build a suite of intervals of different
 * length and will look for the repetition of each suite. If the suite
 * is repeating then we have the period because it is the length of
 * the suite whatever its position in the buffer.
 *
 * 2. Log interval
 *
 * We saw the irq timings allow to compute the interval of the
 * occurrences for a specific interrupt. We can reasonably assume the
 * longer is the interval, the higher is the error for the next event
 * and we can consider storing those interval values into an array
 * where each slot in the array correspond to an interval at the power
 * of 2 of the index. For example, index 12 will contain values
 * between 2^11 and 2^12.
 *
 * At the end we have an array of values where at each index defines a
 * [2^index - 1, 2 ^ index] interval values allowing to store a large
 * number of values inside a small array.
 *
 * For example, if we have the value 1123, then we store it at
 * ilog2(1123) = 10 index value.
 *
 * Storing those value at the specific index is done by computing an
 * exponential moving average for this specific slot. For instance,
 * for values 1800, 1123, 1453, ... fall under the same slot (10) and
 * the exponential moving average is computed every time a new value
 * is stored at this slot.
 *
 * 3. Exponential Moving Average
 *
 * The EMA is largely used to track a signal for stocks or as a low
 * pass filter. The magic of the formula, is it is very simple and the
 * reactivity of the average can be tuned with the factors called
 * alpha.
 *
 * The higher the alphas are, the faster the average respond to the
 * signal change. In our case, if a slot in the array is a big
 * interval, we can have numbers with a big difference between
 * them. The impact of those differences in the average computation
 * can be tuned by changing the alpha value.
 *
 *
 *  -- The algorithm --
 *
 * We saw the different processing above, now let's see how they are
 * used together.
 *
 * For each interrupt:
 *	For each interval:
 *		Compute the index = ilog2(interval)
 *		Compute a new_ema(buffer[index], interval)
 *		Store the index in a circular buffer
 *
 *	Compute the suffix array of the indexes
 *
 *	For each suffix:
 *		If the suffix is reverse-found 3 times
 *			Return suffix
 *
 *	Return Not found
 *
 * However we can not have endless suffix array to be build, it won't
 * make sense and it will add an extra overhead, so we can restrict
 * this to a maximum suffix length of 5 and a minimum suffix length of
 * 2. The experience showed 5 is the majority of the maximum pattern
 * period found for different devices.
 *
 * The result is a pattern finding less than 1us for an interrupt.
 *
 * Example based on real values:
 *
 * Example 1 : MMC write/read interrupt interval:
 *
 *	223947, 1240, 1384, 1386, 1386,
 *	217416, 1236, 1384, 1386, 1387,
 *	214719, 1241, 1386, 1387, 1384,
 *	213696, 1234, 1384, 1386, 1388,
 *	219904, 1240, 1385, 1389, 1385,
 *	212240, 1240, 1386, 1386, 1386,
 *	214415, 1236, 1384, 1386, 1387,
 *	214276, 1234, 1384, 1388, ?
 *
 * For each element, apply ilog2(value)
 *
 *	15, 8, 8, 8, 8,
 *	15, 8, 8, 8, 8,
 *	15, 8, 8, 8, 8,
 *	15, 8, 8, 8, 8,
 *	15, 8, 8, 8, 8,
 *	15, 8, 8, 8, 8,
 *	15, 8, 8, 8, 8,
 *	15, 8, 8, 8, ?
 *
 * Max period of 5, we take the last (max_period * 3) 15 elements as
 * we can be confident if the pattern repeats itself three times it is
 * a repeating pattern.
 *
 *	             8,
 *	15, 8, 8, 8, 8,
 *	15, 8, 8, 8, 8,
 *	15, 8, 8, 8, ?
 *
 * Suffixes are:
 *
 *  1) 8, 15, 8, 8, 8  <- max period
 *  2) 8, 15, 8, 8
 *  3) 8, 15, 8
 *  4) 8, 15           <- min period
 *
 * From there we search the repeating pattern for each suffix.
< ASCII >
 *
 * buffer: 8, 15, 8, 8, 8, 8, 15, 8, 8, 8, 8, 15, 8, 8, 8
 *         |   |  |  |  |  |   |  |  |  |  |   |  |  |  |
 *         8, 15, 8, 8, 8  |   |  |  |  |  |   |  |  |  |
 *                         8, 15, 8, 8, 8  |   |  |  |  |
 *                                         8, 15, 8, 8, 8
< ASCII >
 *
 * When moving the suffix, we found exactly 3 matches.
 *
 * The first suffix with period 5 is repeating.
 *
 * The next event is (3 * max_period) % suffix_period
 *
 * In this example, the result 0, so the next event is suffix[0] => 8
 *
 * However, 8 is the index in the array of exponential moving average
 * which was calculated on the fly when storing the values, so the
 * interval is ema[8] = 1366
 *
 *
 * Example 2:
 *
 *	4, 3, 5, 100,
 *	3, 3, 5, 117,
 *	4, 4, 5, 112,
 *	4, 3, 4, 110,
 *	3, 5, 3, 117,
 *	4, 4, 5, 112,
 *	4, 3, 4, 110,
 *	3, 4, 5, 112,
 *	4, 3, 4, 110
 *
 * ilog2
 *
 *	0, 0, 0, 4,
 *	0, 0, 0, 4,
 *	0, 0, 0, 4,
 *	0, 0, 0, 4,
 *	0, 0, 0, 4,
 *	0, 0, 0, 4,
 *	0, 0, 0, 4,
 *	0, 0, 0, 4,
 *	0, 0, 0, 4
 *
 * Max period 5:
 *	   0, 0, 4,
 *	0, 0, 0, 4,
 *	0, 0, 0, 4,
 *	0, 0, 0, 4
 *
 * Suffixes:
 *
 *  1) 0, 0, 4, 0, 0
 *  2) 0, 0, 4, 0
 *  3) 0, 0, 4
 *  4) 0, 0
 *
 * buffer: 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4
 *         |  |  |  |  |  |  X
 *         0, 0, 4, 0, 0, |  X
 *                        0, 0
 *
< ASCII >
 * buffer: 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4
 *         |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
 *         0, 0, 4, 0, |  |  |  |  |  |  |  |  |  |  |
 *                     0, 0, 4, 0, |  |  |  |  |  |  |
 *                                 0, 0, 4, 0, |  |  |
 *                                             0  0  4
< ASCII >
 *
 * Pattern is found 3 times, the remaining is 1 which results from
 * (max_period * 3) % suffix_period. This value is the index in the
 * suffix arrays. The suffix array for a period 4 has the value 4
 * at index 1.
 */
```
## Visual type:
- #custom


== ./linux/linux_1023.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/locking/lockdep.c#L2432-L2451

```c
/*
 * printk the shortest lock dependencies from @leaf to @root.
 *
< ASCII >
 * We have a lock dependency path (from a backwards search) as follow:
 *
 *    @leaf                                                                 @root
 *      |                                                                     |
 *      V                                                                     V
 *	          ->parent                                   ->parent
 * | lock_list | ---------> | lock_list | ... | lock_list  | ---------> | lock_list |
 * | L2 <- L1  |            | L3 <- L2  | ... | Ln <- Ln-1 |            |    <- Ln  |
< ASCII >
 *
 * , so when we iterate from @leaf to @root, we actually print the lock
 * dependency path L1 -> L2 -> .. -> Ln in the non-reverse order.
 *
 * Another thing to notice here is that ->class of L2 <- L1 is L1, while the
 * ->trace of L2 <- L1 is the call trace of L2, in fact we don't have the call
 * trace of L1 in the dependency path, which is alright, because most of the
 * time we can figure out where L1 is held from the call trace of L2.
 */
```
## Visual type:
- #custom


== ./linux/linux_1024.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/locking/qspinlock.c#L143-L148

```c
/**
< ASCII >
 * clear_pending - clear the pending bit.
 * @lock: Pointer to queued spinlock structure
 *
 * *,1,* -> *,0,*
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1025.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/locking/qspinlock.c#L154-L161

```c
/**
 * clear_pending_set_locked - take ownership and clear the pending bit.
 * @lock: Pointer to queued spinlock structure
 *
< ASCII >
 * *,1,0 -> *,0,1
< ASCII >
 *
 * Lock stealing is not allowed if this function is used.
 */
```
## Visual type:
- #custom


== ./linux/linux_1026.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/locking/qspinlock.c#L167-L176

```c
/*
 * xchg_tail - Put in the new queue tail code word & retrieve previous one
 * @lock : Pointer to queued spinlock structure
 * @tail : The new queue tail code word
 * Return: The previous queue tail code word
 *
 * xchg(lock, tail), which heads an address dependency
 *
< ASCII >
 * p,*,* -> n,*,* ; prev = xchg(lock, node)
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1027.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/locking/qspinlock.c#L189-L194

```c
/**
 * clear_pending - clear the pending bit.
 * @lock: Pointer to queued spinlock structure
 *
< ASCII >
 * *,1,* -> *,0,*
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1028.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/locking/qspinlock.c#L200-L205

```c
/**
 * clear_pending_set_locked - take ownership and clear the pending bit.
 * @lock: Pointer to queued spinlock structure
 *
< ASCII >
 * *,1,0 -> *,0,1
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1029.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/locking/qspinlock.c#L211-L220

```c
/**
 * xchg_tail - Put in the new queue tail code word & retrieve previous one
 * @lock : Pointer to queued spinlock structure
 * @tail : The new queue tail code word
 * Return: The previous queue tail code word
 *
 * xchg(lock, tail)
 *
< ASCII >
 * p,*,* -> n,*,* ; prev = xchg(lock, node)
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_103.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/loongarch/include/asm/irq.h#L16-L28

```c
/*
 * The highest address on the IRQ stack contains a dummy frame which is
 * structured as follows:
< ASCII >
 *
 *   top ------------
 *       | task sp  | <- irq_stack[cpu] + IRQ_STACK_START
 *       ------------
 *       |          | <- First frame of IRQ context
 *       ------------
< ASCII >
 *
 * task sp holds a copy of the task stack pointer where the struct pt_regs
 * from exception entry can be found.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1030.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/locking/qspinlock.c#L242-L248

```c
/**
 * queued_fetch_set_pending_acquire - fetch the whole lock value and set pending
 * @lock : Pointer to queued spinlock structure
 * Return: The previous lock value
 *
< ASCII >
 * *,*,* -> *,1,*
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1031.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/locking/qspinlock.c#L256-L261

```c
/**
 * set_locked - Set the lock bit and own the lock
 * @lock: Pointer to queued spinlock structure
 *
< ASCII >
 * *,*,0 -> *,0,1
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1032.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/locking/qspinlock.c#L295-L315

```c
/**
 * queued_spin_lock_slowpath - acquire the queued spinlock
 * @lock: Pointer to queued spinlock structure
 * @val: Current value of the queued spinlock 32-bit word
 *
 * (queue tail, pending bit, lock value)
< ASCII >
 *
 *              fast     :    slow                                  :    unlock
 *                       :                                          :
 * uncontended  (0,0,0) -:--> (0,0,1) ------------------------------:--> (*,*,0)
 *                       :       | ^--------.------.             /  :
 *                       :       v           \      \            |  :
 * pending               :    (0,1,1) +--> (0,1,0)   \           |  :
 *                       :       | ^--'              |           |  :
 *                       :       v                   |           |  :
 * uncontended           :    (n,x,y) +--> (n,0,0) --'           |  :
 *   queue               :       | ^--'                          |  :
 *                       :       v                               |  :
 * contended             :    (*,x,y) +--> (*,0,0) ---> (*,0,1) -'  :
 *   queue               :         ^--'                             :
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1033.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/module/strict_rwx.c#L14-L27

```c
/*
 * LKM RO/NX protection: protect module's text/ro-data
 * from modification and any data from execution.
 *
< ASCII >
 * General layout of module is:
 *          [text] [read-only-data] [ro-after-init] [writable data]
 * text_size -----^                ^               ^               ^
 * ro_size ------------------------|               |               |
 * ro_after_init_size -----------------------------|               |
 * size -----------------------------------------------------------|
< ASCII >
 *
 * These values are always page-aligned (as is base) when
 * CONFIG_STRICT_MODULE_RWX is set.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1034.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/sched/core.c#L5597-L5618

```c
/*
< ASCII >
 * State diagram for ->state:
 *
 *
 *          TICK_SCHED_REMOTE_OFFLINE
 *                    |   ^
 *                    |   |
 *                    |   | sched_tick_remote()
 *                    |   |
 *                    |   |
 *                    +--TICK_SCHED_REMOTE_OFFLINING
 *                    |   ^
 *                    |   |
 * sched_tick_start() |   | sched_tick_stop()
 *                    |   |
 *                    V   |
 *          TICK_SCHED_REMOTE_RUNNING
 *
< ASCII >
 *
 * Other transitions get WARN_ON_ONCE(), except that sched_tick_remote()
 * and sched_tick_start() are happy to leave the state in RUNNING.
 */
```
## Visual type:
- #state-machine


== ./linux/linux_1035.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/sched/core.c#L7213-L7224

```c
/**
 * task_prio - return the priority value of a given task.
 * @p: the task in question.
 *
 * Return: The priority value as seen by users in /proc.
< ASCII >
 *
 * sched policy         return value   kernel prio    user prio/nice
 *
 * normal, batch, idle     [0 ... 39]  [100 ... 139]          0/[-20 ... 19]
 * fifo, rr             [-2 ... -100]     [98 ... 0]  [1 ... 99]
 * deadline                     -101             -1           0
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1036.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/sched/cpupri.c#L26-L41

```c
/*
< ASCII >
 * p->rt_priority   p->prio   newpri   cpupri
 *
 *				  -1       -1 (CPUPRI_INVALID)
 *
 *				  99        0 (CPUPRI_NORMAL)
 *
 *		1        98       98        1
 *	      ...
 *	       49        50       50       49
 *	       50        49       49       50
 *	      ...
 *	       99         0        0       99
 *
 *				 100	  100 (CPUPRI_HIGHER)
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1037.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/sched/deadline.c#L336-L389

```c
/*
 * The utilization of a task cannot be immediately removed from
 * the rq active utilization (running_bw) when the task blocks.
 * Instead, we have to wait for the so called "0-lag time".
 *
 * If a task blocks before the "0-lag time", a timer (the inactive
 * timer) is armed, and running_bw is decreased when the timer
 * fires.
 *
 * If the task wakes up again before the inactive timer fires,
 * the timer is canceled, whereas if the task wakes up after the
 * inactive timer fired (and running_bw has been decreased) the
 * task's utilization has to be added to running_bw again.
 * A flag in the deadline scheduling entity (dl_non_contending)
 * is used to avoid race conditions between the inactive timer handler
 * and task wakeups.
 *
 * The following diagram shows how running_bw is updated. A task is
 * "ACTIVE" when its utilization contributes to running_bw; an
 * "ACTIVE contending" task is in the TASK_RUNNING state, while an
 * "ACTIVE non contending" task is a blocked task for which the "0-lag time"
 * has not passed yet. An "INACTIVE" task is a task for which the "0-lag"
 * time already passed, which does not contribute to running_bw anymore.
< ASCII >
 *                              +------------------+
 *             wakeup           |    ACTIVE        |
 *          +------------------>+   contending     |
 *          | add_running_bw    |                  |
 *          |                   +----+------+------+
 *          |                        |      ^
 *          |                dequeue |      |
 * +--------+-------+                |      |
 * |                |   t >= 0-lag   |      | wakeup
 * |    INACTIVE    |<---------------+      |
 * |                | sub_running_bw |      |
 * +--------+-------+                |      |
 *          ^                        |      |
 *          |              t < 0-lag |      |
 *          |                        |      |
 *          |                        V      |
 *          |                   +----+------+------+
 *          | sub_running_bw    |    ACTIVE        |
 *          +-------------------+                  |
 *            inactive timer    |  non contending  |
 *            fired             +------------------+
< ASCII >
 *
 * The task_non_contending() function is invoked when a task
 * blocks, and checks if the 0-lag time already passed or
 * not (in the first case, it directly updates running_bw;
 * in the second case, it arms the inactive timer).
 *
 * The task_contending() function is invoked when a task wakes
 * up, and checks if the task is still in the "ACTIVE non contending"
 * state or not (in the second case, it updates running_bw).
 */
```
## Visual type:
- #state-machine


== ./linux/linux_1038.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/sched/fair.c#L3360-L3432

```c
/*
 * All this does is approximate the hierarchical proportion which includes that
 * global sum we all love to hate.
 *
 * That is, the weight of a group entity, is the proportional share of the
 * group weight based on the group runqueue weights. That is:
< ASCII >
 *
 *                     tg->weight * grq->load.weight
 *   ge->load.weight = -----------------------------               (1)
 *                       \Sum grq->load.weight
< ASCII >
 *
 * Now, because computing that sum is prohibitively expensive to compute (been
 * there, done that) we approximate it with this average stuff. The average
 * moves slower and therefore the approximation is cheaper and more stable.
 *
 * So instead of the above, we substitute:
 *
 *   grq->load.weight -> grq->avg.load_avg                         (2)
 *
 * which yields the following:
< ASCII >
 *
 *                     tg->weight * grq->avg.load_avg
 *   ge->load.weight = ------------------------------              (3)
 *                             tg->load_avg
< ASCII >
 *
 * Where: tg->load_avg ~= \Sum grq->avg.load_avg
 *
 * That is shares_avg, and it is right (given the approximation (2)).
 *
 * The problem with it is that because the average is slow -- it was designed
 * to be exactly that of course -- this leads to transients in boundary
 * conditions. In specific, the case where the group was idle and we start the
 * one task. It takes time for our CPU's grq->avg.load_avg to build up,
 * yielding bad latency etc..
 *
 * Now, in that special case (1) reduces to:
< ASCII >
 *
 *                     tg->weight * grq->load.weight
 *   ge->load.weight = ----------------------------- = tg->weight   (4)
 *                         grp->load.weight
< ASCII >
 *
 * That is, the sum collapses because all other CPUs are idle; the UP scenario.
 *
 * So what we do is modify our approximation (3) to approach (4) in the (near)
 * UP case, like:
< ASCII >
 *
 *   ge->load.weight =
 *
 *              tg->weight * grq->load.weight
 *     ---------------------------------------------------         (5)
 *     tg->load_avg - grq->avg.load_avg + grq->load.weight
< ASCII >
 *
 * But because grq->load.weight can drop to 0, resulting in a divide by zero,
 * we need to use grq->avg.load_avg as its lower bound, which then gives:
< ASCII >
 *
 *
 *                     tg->weight * grq->load.weight
 *   ge->load.weight = -----------------------------		   (6)
 *                             tg_load_avg'
< ASCII >
 *
 * Where:
 *
 *   tg_load_avg' = tg->load_avg - grq->avg.load_avg +
 *                  max(grq->load.weight, grq->avg.load_avg)
 *
 * And that is shares_weight and is icky. In the (near) UP case it approaches
 * (4) while in the normal case it approaches (3). It consistently
 * overestimates the ge->load.weight and therefore:
 *
 *   \Sum ge->load.weight >= tg->weight
 *
 * hence icky!
 */
```
## Visual type:
- #formula


== ./linux/linux_1039.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/sched/fair.c#L7915-L8031

```c
/**************************************************
 * Fair scheduling class load-balancing methods.
 *
 * BASICS
 *
 * The purpose of load-balancing is to achieve the same basic fairness the
 * per-CPU scheduler provides, namely provide a proportional amount of compute
 * time to each task. This is expressed in the following equation:
 *
 *   W_i,n/P_i == W_j,n/P_j for all i,j                               (1)
 *
 * Where W_i,n is the n-th weight average for CPU i. The instantaneous weight
 * W_i,0 is defined as:
 *
 *   W_i,0 = \Sum_j w_i,j                                             (2)
 *
 * Where w_i,j is the weight of the j-th runnable task on CPU i. This weight
 * is derived from the nice value as per sched_prio_to_weight[].
 *
 * The weight average is an exponential decay average of the instantaneous
 * weight:
 *
 *   W'_i,n = (2^n - 1) / 2^n * W_i,n + 1 / 2^n * W_i,0               (3)
 *
 * C_i is the compute capacity of CPU i, typically it is the
 * fraction of 'recent' time available for SCHED_OTHER task execution. But it
 * can also include other factors [XXX].
 *
 * To achieve this balance we define a measure of imbalance which follows
 * directly from (1):
 *
 *   imb_i,j = max{ avg(W/C), W_i/C_i } - min{ avg(W/C), W_j/C_j }    (4)
 *
 * We them move tasks around to minimize the imbalance. In the continuous
 * function space it is obvious this converges, in the discrete case we get
 * a few fun cases generally called infeasible weight scenarios.
 *
 * [XXX expand on:
 *     - infeasible weights;
 *     - local vs global optima in the discrete case. ]
 *
 *
 * SCHED DOMAINS
 *
 * In order to solve the imbalance equation (4), and avoid the obvious O(n^2)
 * for all i,j solution, we create a tree of CPUs that follows the hardware
 * topology where each level pairs two lower groups (or better). This results
 * in O(log n) layers. Furthermore we reduce the number of CPUs going up the
 * tree to only the first of the previous level and we decrease the frequency
 * of load-balance at each level inv. proportional to the number of CPUs in
 * the groups.
 *
< ASCII >
 * This yields:
 *
 *     log_2 n     1     n
 *   \Sum       { --- * --- * 2^i } = O(n)                            (5)
 *     i = 0      2^i   2^i
 *                               `- size of each group
 *         |         |     `- number of CPUs doing load-balance
 *         |         `- freq
 *         `- sum over all levels
< ASCII >
 *
 * Coupled with a limit on how many tasks we can migrate every balance pass,
 * this makes (5) the runtime complexity of the balancer.
 *
 * An important property here is that each CPU is still (indirectly) connected
 * to every other CPU in at most O(log n) steps:
 *
< ASCII >
 * The adjacency matrix of the resulting graph is given by:
 *
 *             log_2 n
 *   A_i,j = \Union     (i % 2^k == 0) && i / 2^(k+1) == j / 2^(k+1)  (6)
 *             k = 0
 *
 * And you'll find that:
 *
 *   A^(log_2 n)_i,j != 0  for all i,j                                (7)
< ASCII >
 *
 * Showing there's indeed a path between every CPU in at most O(log n) steps.
 * The task movement gives a factor of O(m), giving a convergence complexity
 * of:
 *
 *   O(nm log n),  n := nr_cpus, m := nr_tasks                        (8)
 *
 *
 * WORK CONSERVING
 *
 * In order to avoid CPUs going idle while there's still work to do, new idle
 * balancing is more aggressive and has the newly idle CPU iterate up the domain
 * tree itself instead of relying on other CPUs to bring it work.
 *
 * This adds some complexity to both (5) and (8) but it reduces the total idle
 * time.
 *
 * [XXX more?]
 *
 *
 * CGROUPS
 *
 * Cgroups make a horror show out of (2), instead of a simple sum we get:
< ASCII >
 *
 *                                s_k,i
 *   W_i,0 = \Sum_j \Prod_k w_k * -----                               (9)
 *                                 S_k
 *
 * Where
 *
 *   s_k,i = \Sum_j w_i,j,k  and  S_k = \Sum_i s_k,i                 (10)
< ASCII >
 *
 * w_i,j,k is the weight of the j-th runnable task in the k-th cgroup on CPU i.
 *
 * The big problem is S_k, its a global sum needed to compute a local (W_i)
 * property.
 *
 * [XXX write more on how we solve this.. _after_ merging pjt's patches that
 *      rewrite all of this once again.]
 */
```
## Visual type:
- #formula


== ./linux/linux_104.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/loongarch/kernel/ftrace_dyn.c#L118-L137

```c
/*
 * The compiler has inserted 2 NOPs before the regular function prologue.
 * T series registers are available and safe because of LoongArch's psABI.
 *
 * At runtime, we can replace nop with bl to enable ftrace call and replace bl
 * with nop to disable ftrace call. The bl requires us to save the original RA
 * value, so it saves RA at t0 here.
 *
< ASCII >
 * Details are:
 *
 * | Compiled   |       Disabled         |        Enabled         |
 * +------------+------------------------+------------------------+
 * | nop        | move     t0, ra        | move     t0, ra        |
 * | nop        | nop                    | bl       ftrace_caller |
 * | func_body  | func_body              | func_body              |
< ASCII >
 *
 * The RA value will be recovered by ftrace_regs_entry, and restored into RA
 * before returning to the regular function prologue. When a function is not
 * being traced, the "move t0, ra" is not harmful.
 */
```
## Visual type:
- #table


== ./linux/linux_1040.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/sched/loadavg.c#L163-L204

```c
/*
 * Handle NO_HZ for the global load-average.
 *
 * Since the above described distributed algorithm to compute the global
 * load-average relies on per-CPU sampling from the tick, it is affected by
 * NO_HZ.
 *
 * The basic idea is to fold the nr_active delta into a global NO_HZ-delta upon
 * entering NO_HZ state such that we can include this as an 'extra' CPU delta
 * when we read the global state.
 *
 * Obviously reality has to ruin such a delightfully simple scheme:
 *
 *  - When we go NO_HZ idle during the window, we can negate our sample
 *    contribution, causing under-accounting.
 *
 *    We avoid this by keeping two NO_HZ-delta counters and flipping them
 *    when the window starts, thus separating old and new NO_HZ load.
 *
 *    The only trick is the slight shift in index flip for read vs write.
< ASCII >
 *
 *        0s            5s            10s           15s
 *          +10           +10           +10           +10
 *        |-|-----------|-|-----------|-|-----------|-|
 *    r:0 0 1           1 0           0 1           1 0
 *    w:0 1 1           0 0           1 1           0 0
< ASCII >
 *
 *    This ensures we'll fold the old NO_HZ contribution in this window while
 *    accumulating the new one.
 *
 *  - When we wake up from NO_HZ during the window, we push up our
 *    contribution, since we effectively move our sample point to a known
 *    busy state.
 *
 *    This is solved by pushing the window forward, and thus skipping the
 *    sample, for this CPU (effectively using the NO_HZ-delta for this CPU which
 *    was in effect at the time the window opened). This also solves the issue
 *    of having to deal with a CPU having been in NO_HZ for multiple LOAD_FREQ
 *    intervals.
 *
 * When making the ILB scale, we should try to pull this in as well.
 */
```
## Visual type:
- #interval


== ./linux/linux_1041.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/sched/pelt.c#L80-L100

```c
/*
 * Accumulate the three separate parts of the sum; d1 the remainder
 * of the last (incomplete) period, d2 the span of full periods and d3
 * the remainder of the (incomplete) current period.
< ASCII >
 *
 *           d1          d2           d3
 *           ^           ^            ^
 *           |           |            |
 *         |<->|<----------------->|<--->|
 * ... |---x---|------| ... |------|-----x (now)
 *
 *                           p-1
 * u' = (u + d1) y^p + 1024 \Sum y^n + d3 y^0
 *                           n=1
 *
 *    = u y^p +					(Step 1)
 *
 *                     p-1
 *      d1 y^p + 1024 \Sum y^n + d3 y^0		(Step 2)
 *                     n=1
< ASCII >
 */
```
## Visual type:
- #interval


== ./linux/linux_1042.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/sched/pelt.h#L83-L94

```c
/*
 * The clock_pelt scales the time to reflect the effective amount of
 * computation done during the running delta time but then sync back to
 * clock_task when rq is idle.
 *
 *
< ASCII >
 * absolute time   | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16
 * @ max capacity  ------******---------------******---------------
 * @ half capacity ------************---------************---------
 * clock pelt      | 1| 2|    3|    4| 7| 8| 9|   10|   11|14|15|16
< ASCII >
 *
 */
```
## Visual type:
- #interval


== ./linux/linux_1043.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/sched/topology.c#L792-L885

```c
/*
 * NUMA topology (first read the regular topology blurb below)
 *
< ASCII >
 * Given a node-distance table, for example:
 *
 *   node   0   1   2   3
 *     0:  10  20  30  20
 *     1:  20  10  20  30
 *     2:  30  20  10  20
 *     3:  20  30  20  10
 *
 * which represents a 4 node ring topology like:
 *
 *   0 ----- 1
 *   |       |
 *   |       |
 *   |       |
 *   3 ----- 2
< ASCII >
 *
 * We want to construct domains and groups to represent this. The way we go
 * about doing this is to build the domains on 'hops'. For each NUMA level we
 * construct the mask of all nodes reachable in @level hops.
 *
 * For the above NUMA topology that gives 3 levels:
 *
 * NUMA-2	0-3		0-3		0-3		0-3
 *  groups:	{0-1,3},{1-3}	{0-2},{0,2-3}	{1-3},{0-1,3}	{0,2-3},{0-2}
 *
 * NUMA-1	0-1,3		0-2		1-3		0,2-3
 *  groups:	{0},{1},{3}	{0},{1},{2}	{1},{2},{3}	{0},{2},{3}
 *
 * NUMA-0	0		1		2		3
 *
 *
 * As can be seen; things don't nicely line up as with the regular topology.
 * When we iterate a domain in child domain chunks some nodes can be
 * represented multiple times -- hence the "overlap" naming for this part of
 * the topology.
 *
 * In order to minimize this overlap, we only build enough groups to cover the
 * domain. For instance Node-0 NUMA-2 would only get groups: 0-1,3 and 1-3.
 *
 * Because:
 *
 *  - the first group of each domain is its child domain; this
 *    gets us the first 0-1,3
 *  - the only uncovered node is 2, who's child domain is 1-3.
 *
 * However, because of the overlap, computing a unique CPU for each group is
 * more complicated. Consider for instance the groups of NODE-1 NUMA-2, both
 * groups include the CPUs of Node-0, while those CPUs would not in fact ever
 * end up at those groups (they would end up in group: 0-1,3).
 *
 * To correct this we have to introduce the group balance mask. This mask
 * will contain those CPUs in the group that can reach this group given the
 * (child) domain tree.
 *
 * With this we can once again compute balance_cpu and sched_group_capacity
 * relations.
 *
 * XXX include words on how balance_cpu is unique and therefore can be
 * used for sched_group_capacity links.
 *
 *
< ASCII >
 * Another 'interesting' topology is:
 *
 *   node   0   1   2   3
 *     0:  10  20  20  30
 *     1:  20  10  20  20
 *     2:  20  20  10  20
 *     3:  30  20  20  10
 *
 * Which looks a little like:
 *
 *   0 ----- 1
 *   |     / |
 *   |   /   |
 *   | /     |
 *   2 ----- 3
< ASCII >
 *
 * This topology is asymmetric, nodes 1,2 are fully connected, but nodes 0,3
 * are not.
 *
 * This leads to a few particularly weird cases where the sched_domain's are
 * not of the same number for each CPU. Consider:
 *
 * NUMA-2	0-3						0-3
 *  groups:	{0-2},{1-3}					{1-3},{0-2}
 *
 * NUMA-1	0-2		0-3		0-3		1-3
 *
 * NUMA-0	0		1		2		3
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_1044.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/sched/topology.c#L1106-L1175

```c
/*
 * Package topology (also see the load-balance blurb in fair.c)
 *
 * The scheduler builds a tree structure to represent a number of important
 * topology features. By default (default_topology[]) these include:
 *
 *  - Simultaneous multithreading (SMT)
 *  - Multi-Core Cache (MC)
 *  - Package (DIE)
 *
 * Where the last one more or less denotes everything up to a NUMA node.
 *
 * The tree consists of 3 primary data structures:
 *
 *	sched_domain -> sched_group -> sched_group_capacity
 *	    ^ ^             ^ ^
 *          `-'             `-'
 *
 * The sched_domains are per-CPU and have a two way link (parent & child) and
 * denote the ever growing mask of CPUs belonging to that level of topology.
 *
 * Each sched_domain has a circular (double) linked list of sched_group's, each
 * denoting the domains of the level below (or individual CPUs in case of the
 * first domain level). The sched_group linked by a sched_domain includes the
 * CPU of that sched_domain [*].
 *
 * Take for instance a 2 threaded, 2 core, 2 cache cluster part:
< ASCII >
 *
 * CPU   0   1   2   3   4   5   6   7
 *
 * DIE  [                             ]
 * MC   [             ] [             ]
 * SMT  [     ] [     ] [     ] [     ]
 *
 *  - or -
 *
 * DIE  0-7 0-7 0-7 0-7 0-7 0-7 0-7 0-7
 * MC	0-3 0-3 0-3 0-3 4-7 4-7 4-7 4-7
 * SMT  0-1 0-1 2-3 2-3 4-5 4-5 6-7 6-7
 *
 * CPU   0   1   2   3   4   5   6   7
< ASCII >
 *
 * One way to think about it is: sched_domain moves you up and down among these
 * topology levels, while sched_group moves you sideways through it, at child
 * domain granularity.
 *
 * sched_group_capacity ensures each unique sched_group has shared storage.
 *
 * There are two related construction problems, both require a CPU that
 * uniquely identify each group (for a given domain):
 *
 *  - The first is the balance_cpu (see should_we_balance() and the
 *    load-balance blub in fair.c); for each group we only want 1 CPU to
 *    continue balancing at a higher domain.
 *
 *  - The second is the sched_group_capacity; we want all identical groups
 *    to share a single sched_group_capacity.
 *
 * Since these topologies are exclusive by construction. That is, its
 * impossible for an SMT thread to belong to multiple cores, and cores to
 * be part of multiple caches. There is a very clear and unique location
 * for each CPU in the hierarchy.
 *
 * Therefore computing a unique CPU for each group is trivial (the iteration
 * mask is redundant and set all 1s; all CPUs in a group will end up at _that_
 * group), we can simply pick the first CPU in each group.
 *
 *
 * [*] in other words, the first group of each domain is its child domain.
 */
```
## Visual type:
- #custom


== ./linux/linux_1045.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/time/timekeeping.c#L458-L489

```c
/**
 * ktime_get_mono_fast_ns - Fast NMI safe access to clock monotonic
 *
 * This timestamp is not guaranteed to be monotonic across an update.
 * The timestamp is calculated by:
 *
 *	now = base_mono + clock_delta * slope
 *
 * So if the update lowers the slope, readers who are forced to the
 * not yet updated second array are still using the old steeper slope.
 *
< ASCII >
 * tmono
 * ^
 * |    o  n
 * |   o n
 * |  u
 * | o
 * |o
 * |12345678---> reader order
< ASCII >
 *
 * o = old slope
 * u = update
 * n = new slope
 *
 * So reader 6 will observe time going backwards versus reader 5.
 *
 * While other CPUs are likely to be able to observe that, the only way
 * for a CPU local observation is when an NMI hits in the middle of
 * the update. Timestamps taken from that NMI context might be ahead
 * of the following timestamps. Callers need to be aware of that and
 * deal with it.
 */
```
## Visual type:
- #custom


== ./linux/linux_1046.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/time/timer.c#L64-L150

```c
/*
 * The timer wheel has LVL_DEPTH array levels. Each level provides an array of
 * LVL_SIZE buckets. Each level is driven by its own clock and therefor each
 * level has a different granularity.
 *
 * The level granularity is:		LVL_CLK_DIV ^ lvl
 * The level clock frequency is:	HZ / (LVL_CLK_DIV ^ level)
 *
 * The array level of a newly armed timer depends on the relative expiry
 * time. The farther the expiry time is away the higher the array level and
 * therefor the granularity becomes.
 *
 * Contrary to the original timer wheel implementation, which aims for 'exact'
 * expiry of the timers, this implementation removes the need for recascading
 * the timers into the lower array levels. The previous 'classic' timer wheel
 * implementation of the kernel already violated the 'exact' expiry by adding
 * slack to the expiry time to provide batched expiration. The granularity
 * levels provide implicit batching.
 *
 * This is an optimization of the original timer wheel implementation for the
 * majority of the timer wheel use cases: timeouts. The vast majority of
 * timeout timers (networking, disk I/O ...) are canceled before expiry. If
 * the timeout expires it indicates that normal operation is disturbed, so it
 * does not matter much whether the timeout comes with a slight delay.
 *
 * The only exception to this are networking timers with a small expiry
 * time. They rely on the granularity. Those fit into the first wheel level,
 * which has HZ granularity.
 *
 * We don't have cascading anymore. timers with a expiry time above the
 * capacity of the last wheel level are force expired at the maximum timeout
 * value of the last wheel level. From data sampling we know that the maximum
 * value observed is 5 days (network connection tracking), so this should not
 * be an issue.
 *
 * The currently chosen array constants values are a good compromise between
 * array size and granularity.
 *
 * This results in the following granularity and range levels:
 *
< ASCII >
 * HZ 1000 steps
 * Level Offset  Granularity            Range
 *  0      0         1 ms                0 ms -         63 ms
 *  1     64         8 ms               64 ms -        511 ms
 *  2    128        64 ms              512 ms -       4095 ms (512ms - ~4s)
 *  3    192       512 ms             4096 ms -      32767 ms (~4s - ~32s)
 *  4    256      4096 ms (~4s)      32768 ms -     262143 ms (~32s - ~4m)
 *  5    320     32768 ms (~32s)    262144 ms -    2097151 ms (~4m - ~34m)
 *  6    384    262144 ms (~4m)    2097152 ms -   16777215 ms (~34m - ~4h)
 *  7    448   2097152 ms (~34m)  16777216 ms -  134217727 ms (~4h - ~1d)
 *  8    512  16777216 ms (~4h)  134217728 ms - 1073741822 ms (~1d - ~12d)
 *
< ASCII >
< ASCII >
 * HZ  300
 * Level Offset  Granularity            Range
 *  0	   0         3 ms                0 ms -        210 ms
 *  1	  64        26 ms              213 ms -       1703 ms (213ms - ~1s)
 *  2	 128       213 ms             1706 ms -      13650 ms (~1s - ~13s)
 *  3	 192      1706 ms (~1s)      13653 ms -     109223 ms (~13s - ~1m)
 *  4	 256     13653 ms (~13s)    109226 ms -     873810 ms (~1m - ~14m)
 *  5	 320    109226 ms (~1m)     873813 ms -    6990503 ms (~14m - ~1h)
 *  6	 384    873813 ms (~14m)   6990506 ms -   55924050 ms (~1h - ~15h)
 *  7	 448   6990506 ms (~1h)   55924053 ms -  447392423 ms (~15h - ~5d)
 *  8    512  55924053 ms (~15h) 447392426 ms - 3579139406 ms (~5d - ~41d)
 *
< ASCII >
< ASCII >
 * HZ  250
 * Level Offset  Granularity            Range
 *  0	   0         4 ms                0 ms -        255 ms
 *  1	  64        32 ms              256 ms -       2047 ms (256ms - ~2s)
 *  2	 128       256 ms             2048 ms -      16383 ms (~2s - ~16s)
 *  3	 192      2048 ms (~2s)      16384 ms -     131071 ms (~16s - ~2m)
 *  4	 256     16384 ms (~16s)    131072 ms -    1048575 ms (~2m - ~17m)
 *  5	 320    131072 ms (~2m)    1048576 ms -    8388607 ms (~17m - ~2h)
 *  6	 384   1048576 ms (~17m)   8388608 ms -   67108863 ms (~2h - ~18h)
 *  7	 448   8388608 ms (~2h)   67108864 ms -  536870911 ms (~18h - ~6d)
 *  8    512  67108864 ms (~18h) 536870912 ms - 4294967288 ms (~6d - ~49d)
 *
< ASCII >
< ASCII >
 * HZ  100
 * Level Offset  Granularity            Range
 *  0	   0         10 ms               0 ms -        630 ms
 *  1	  64         80 ms             640 ms -       5110 ms (640ms - ~5s)
 *  2	 128        640 ms            5120 ms -      40950 ms (~5s - ~40s)
 *  3	 192       5120 ms (~5s)     40960 ms -     327670 ms (~40s - ~5m)
 *  4	 256      40960 ms (~40s)   327680 ms -    2621430 ms (~5m - ~43m)
 *  5	 320     327680 ms (~5m)   2621440 ms -   20971510 ms (~43m - ~5h)
 *  6	 384    2621440 ms (~43m) 20971520 ms -  167772150 ms (~5h - ~1d)
 *  7	 448   20971520 ms (~5h) 167772160 ms - 1342177270 ms (~1d - ~15d)
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1047.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/trace/ring_buffer.c#L64-L130

```c
/*
 * The ring buffer is made up of a list of pages. A separate list of pages is
 * allocated for each CPU. A writer may only write to a buffer that is
 * associated with the CPU it is currently executing on.  A reader may read
 * from any per cpu buffer.
 *
 * The reader is special. For each per cpu buffer, the reader has its own
 * reader page. When a reader has read the entire reader page, this reader
 * page is swapped with another page in the ring buffer.
 *
 * Now, as long as the writer is off the reader page, the reader can do what
 * ever it wants with that page. The writer will never write to that page
 * again (as long as it is out of the ring buffer).
 *
 * Here's some silly ASCII art.
 *
 *   +------+
 *   |reader|          RING BUFFER
 *   |page  |
 *   +------+        +---+   +---+   +---+
 *                   |   |-->|   |-->|   |
 *                   +---+   +---+   +---+
 *                     ^               |
 *                     |               |
 *                     +---------------+
< ASCII >
< ASCII >
 *
 *
 *   +------+
 *   |reader|          RING BUFFER
 *   |page  |------------------v
 *   +------+        +---+   +---+   +---+
 *                   |   |-->|   |-->|   |
 *                   +---+   +---+   +---+
 *                     ^               |
 *                     |               |
 *                     +---------------+
< ASCII >
< ASCII >
 *
 *
 *   +------+
 *   |reader|          RING BUFFER
 *   |page  |------------------v
 *   +------+        +---+   +---+   +---+
 *      ^            |   |-->|   |-->|   |
 *      |            +---+   +---+   +---+
 *      |                              |
 *      |                              |
 *      +------------------------------+
< ASCII >
< ASCII >
 *
 *
 *   +------+
 *   |buffer|          RING BUFFER
 *   |page  |------------------v
 *   +------+        +---+   +---+   +---+
 *      ^            |   |   |   |-->|   |
 *      |   New      +---+   +---+   +---+
 *      |  Reader------^               |
 *      |   page                       |
 *      +------------------------------+
< ASCII >
 *
 *
 * After we make this swap, the reader can hand this page off to the splice
 * code and be done with it. It can even allocate a new page if it needs to
 * and swap that into the ring buffer.
 *
 * We will be using cmpxchg soon to make all this lockless.
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_1048.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/trace/ring_buffer.c#L1223-L1290

```c
/*
 * Making the ring buffer lockless makes things tricky.
 * Although writes only happen on the CPU that they are on,
 * and they only need to worry about interrupts. Reads can
 * happen on any CPU.
 *
 * The reader page is always off the ring buffer, but when the
 * reader finishes with a page, it needs to swap its page with
 * a new one from the buffer. The reader needs to take from
 * the head (writes go to the tail). But if a writer is in overwrite
 * mode and wraps, it must push the head page forward.
 *
 * Here lies the problem.
 *
 * The reader must be careful to replace only the head page, and
 * not another one. As described at the top of the file in the
 * ASCII art, the reader sets its old page to point to the next
 * page after head. It then sets the page after head to point to
 * the old reader page. But if the writer moves the head page
 * during this operation, the reader could end up with the tail.
 *
 * We use cmpxchg to help prevent this race. We also do something
 * special with the page before head. We set the LSB to 1.
 *
 * When the writer must push the page forward, it will clear the
 * bit that points to the head page, move the head, and then set
 * the bit that points to the new head page.
 *
 * We also don't want an interrupt coming in and moving the head
 * page on another writer. Thus we use the second LSB to catch
 * that too. Thus:
 *
< ASCII >
 * head->list->prev->next        bit 1          bit 0
 *                              -------        -------
 * Normal page                     0              0
 * Points to head page             0              1
 * New head page                   1              0
< ASCII >
 *
 * Note we can not trust the prev pointer of the head page, because:
< ASCII >
 *
 * +----+       +-----+        +-----+
 * |    |------>|  T  |---X--->|  N  |
 * |    |<------|     |        |     |
 * +----+       +-----+        +-----+
 *   ^                           ^ |
 *   |          +-----+          | |
 *   +----------|  R  |----------+ |
 *              |     |<-----------+
 *              +-----+
< ASCII >
 *
 * Key:  ---X-->  HEAD flag set in pointer
 *         T      Tail page
 *         R      Reader page
 *         N      Next page
 *
 * (see __rb_reserve_next() to see where this happens)
 *
 *  What the above shows is that the reader just swapped out
 *  the reader page with a page in the buffer, but before it
 *  could make the new header point back to the new page added
 *  it was preempted by a writer. The writer moved forward onto
 *  the new page added by the reader and is about to move forward
 *  again.
 *
 *  You can see, it is legitimate for the previous pointer of
 *  the head (or any page) not to point back to itself. But only
 *  temporarily.
 */
```
## Visual type:
- #custom


== ./linux/linux_1049.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/kernel/trace/trace_stack.c#L57-L154

```c
/*
 * The stack tracer looks for a maximum stack at each call from a function. It
 * registers a callback from ftrace, and in that callback it examines the stack
 * size. It determines the stack size from the variable passed in, which is the
 * address of a local variable in the stack_trace_call() callback function.
 * The stack size is calculated by the address of the local variable to the top
 * of the current stack. If that size is smaller than the currently saved max
 * stack size, nothing more is done.
 *
 * If the size of the stack is greater than the maximum recorded size, then the
 * following algorithm takes place.
 *
 * For architectures (like x86) that store the function's return address before
 * saving the function's local variables, the stack will look something like
 * this:
 *
 *   [ top of stack ]
 *    0: sys call entry frame
 *   10: return addr to entry code
 *   11: start of sys_foo frame
 *   20: return addr to sys_foo
 *   21: start of kernel_func_bar frame
 *   30: return addr to kernel_func_bar
 *   31: [ do trace stack here ]
 *
 * The save_stack_trace() is called returning all the functions it finds in the
 * current stack. Which would be (from the bottom of the stack to the top):
 *
 *   return addr to kernel_func_bar
 *   return addr to sys_foo
 *   return addr to entry code
 *
 * Now to figure out how much each of these functions' local variable size is,
 * a search of the stack is made to find these values. When a match is made, it
 * is added to the stack_dump_trace[] array. The offset into the stack is saved
 * in the stack_trace_index[] array. The above example would show:
< ASCII >
 *
 *        stack_dump_trace[]        |   stack_trace_index[]
 *        ------------------        +   -------------------
 *  return addr to kernel_func_bar  |          30
 *  return addr to sys_foo          |          20
 *  return addr to entry            |          10
< ASCII >
 *
 * The print_max_stack() function above, uses these values to print the size of
 * each function's portion of the stack.
 *
 *  for (i = 0; i < nr_entries; i++) {
 *     size = i == nr_entries - 1 ? stack_trace_index[i] :
 *                    stack_trace_index[i] - stack_trace_index[i+1]
 *     print "%d %d %d %s\n", i, stack_trace_index[i], size, stack_dump_trace[i]);
 *  }
 *
 * The above shows
< ASCII >
 *
 *     depth size  location
 *     ----- ----  --------
 *  0    30   10   kernel_func_bar
 *  1    20   10   sys_foo
 *  2    10   10   entry code
< ASCII >
 *
 * Now for architectures that might save the return address after the functions
 * local variables (saving the link register before calling nested functions),
 * this will cause the stack to look a little different:
 *
 * [ top of stack ]
 *  0: sys call entry frame
 * 10: start of sys_foo_frame
 * 19: return addr to entry code << lr saved before calling kernel_func_bar
 * 20: start of kernel_func_bar frame
 * 29: return addr to sys_foo_frame << lr saved before calling next function
 * 30: [ do trace stack here ]
 *
 * Although the functions returned by save_stack_trace() may be the same, the
 * placement in the stack will be different. Using the same algorithm as above
 * would yield:
< ASCII >
 *
 *        stack_dump_trace[]        |   stack_trace_index[]
 *        ------------------        +   -------------------
 *  return addr to kernel_func_bar  |          30
 *  return addr to sys_foo          |          29
 *  return addr to entry            |          19
< ASCII >
 *
 * Where the mapping is off by one:
 *
 *   kernel_func_bar stack frame size is 29 - 19 not 30 - 29!
 *
 * To fix this, if the architecture sets ARCH_RET_ADDR_AFTER_LOCAL_VARS the
 * values in stack_trace_index[] are shifted by one to and the number of
 * stack trace entries is decremented by one.
< ASCII >
 *
 *        stack_dump_trace[]        |   stack_trace_index[]
 *        ------------------        +   -------------------
 *  return addr to kernel_func_bar  |          29
 *  return addr to sys_foo          |          19
< ASCII >
 *
 * Although the entry function is not displayed, the first function (sys_foo)
 * will still include the stack size of it.
 */
```
## Visual type:
- #table


== ./linux/linux_105.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/loongarch/net/bpf_jit.c#L63-L88

```c
/*
< ASCII >
 * eBPF prog stack layout:
 *
 *                                        high
 * original $sp ------------> +-------------------------+ <--LOONGARCH_GPR_FP
 *                            |           $ra           |
 *                            +-------------------------+
 *                            |           $fp           |
 *                            +-------------------------+
 *                            |           $s0           |
 *                            +-------------------------+
 *                            |           $s1           |
 *                            +-------------------------+
 *                            |           $s2           |
 *                            +-------------------------+
 *                            |           $s3           |
 *                            +-------------------------+
 *                            |           $s4           |
 *                            +-------------------------+
 *                            |           $s5           |
 *                            +-------------------------+ <--BPF_REG_FP
 *                            |  prog->aux->stack_depth |
 *                            |        (optional)       |
 * current $sp -------------> +-------------------------+
 *                                        low
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1050.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/lib/bitmap.c#L638-L644

```c
/*
< ASCII >
 * Region 9-38:4/10 describes the following bitmap structure:
 * 0	   9  12    18			38	     N
 * .........****......****......****..................
 *	    ^  ^     ^			 ^	     ^
 *      start  off   group_len	       end	 nbits
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1051.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/lib/bitmap.c#L1064-L1169

```c
/**
 * bitmap_onto - translate one bitmap relative to another
 *	@dst: resulting translated bitmap
 * 	@orig: original untranslated bitmap
 * 	@relmap: bitmap relative to which translated
 *	@bits: number of bits in each of these bitmaps
 *
 * Set the n-th bit of @dst iff there exists some m such that the
 * n-th bit of @relmap is set, the m-th bit of @orig is set, and
 * the n-th bit of @relmap is also the m-th _set_ bit of @relmap.
 * (If you understood the previous sentence the first time your
 * read it, you're overqualified for your current job.)
 *
 * In other words, @orig is mapped onto (surjectively) @dst,
 * using the map { <n, m> | the n-th bit of @relmap is the
 * m-th set bit of @relmap }.
 *
 * Any set bits in @orig above bit number W, where W is the
 * weight of (number of set bits in) @relmap are mapped nowhere.
 * In particular, if for all bits m set in @orig, m >= W, then
 * @dst will end up empty.  In situations where the possibility
 * of such an empty result is not desired, one way to avoid it is
 * to use the bitmap_fold() operator, below, to first fold the
 * @orig bitmap over itself so that all its set bits x are in the
 * range 0 <= x < W.  The bitmap_fold() operator does this by
 * setting the bit (m % W) in @dst, for each bit (m) set in @orig.
 *
 * Example [1] for bitmap_onto():
 *  Let's say @relmap has bits 30-39 set, and @orig has bits
 *  1, 3, 5, 7, 9 and 11 set.  Then on return from this routine,
 *  @dst will have bits 31, 33, 35, 37 and 39 set.
 *
 *  When bit 0 is set in @orig, it means turn on the bit in
 *  @dst corresponding to whatever is the first bit (if any)
 *  that is turned on in @relmap.  Since bit 0 was off in the
 *  above example, we leave off that bit (bit 30) in @dst.
 *
 *  When bit 1 is set in @orig (as in the above example), it
 *  means turn on the bit in @dst corresponding to whatever
 *  is the second bit that is turned on in @relmap.  The second
 *  bit in @relmap that was turned on in the above example was
 *  bit 31, so we turned on bit 31 in @dst.
 *
 *  Similarly, we turned on bits 33, 35, 37 and 39 in @dst,
 *  because they were the 4th, 6th, 8th and 10th set bits
 *  set in @relmap, and the 4th, 6th, 8th and 10th bits of
 *  @orig (i.e. bits 3, 5, 7 and 9) were also set.
 *
 *  When bit 11 is set in @orig, it means turn on the bit in
 *  @dst corresponding to whatever is the twelfth bit that is
 *  turned on in @relmap.  In the above example, there were
 *  only ten bits turned on in @relmap (30..39), so that bit
 *  11 was set in @orig had no affect on @dst.
 *
 * Example [2] for bitmap_fold() + bitmap_onto():
 *  Let's say @relmap has these ten bits set::
 *
 *		40 41 42 43 45 48 53 61 74 95
 *
 *  (for the curious, that's 40 plus the first ten terms of the
 *  Fibonacci sequence.)
 *
 *  Further lets say we use the following code, invoking
 *  bitmap_fold() then bitmap_onto, as suggested above to
 *  avoid the possibility of an empty @dst result::
 *
 *	unsigned long *tmp;	// a temporary bitmap's bits
 *
 *	bitmap_fold(tmp, orig, bitmap_weight(relmap, bits), bits);
 *	bitmap_onto(dst, tmp, relmap, bits);
 *
 *  Then this table shows what various values of @dst would be, for
 *  various @orig's.  I list the zero-based positions of each set bit.
 *  The tmp column shows the intermediate result, as computed by
 *  using bitmap_fold() to fold the @orig bitmap modulo ten
 *  (the weight of @relmap):
< ASCII >
 *
 *      =============== ============== =================
 *      @orig           tmp            @dst
 *      0                0             40
 *      1                1             41
 *      9                9             95
 *      10               0             40 [#f1]_
 *      1 3 5 7          1 3 5 7       41 43 48 61
 *      0 1 2 3 4        0 1 2 3 4     40 41 42 43 45
 *      0 9 18 27        0 9 8 7       40 61 74 95
 *      0 10 20 30       0             40
 *      0 11 22 33       0 1 2 3       40 41 42 43
 *      0 12 24 36       0 2 4 6       40 42 45 53
 *      78 102 211       1 2 8         41 42 74 [#f1]_
 *      =============== ============== =================
< ASCII >
 *
 * .. [#f1]
 *
 *     For these marked lines, if we hadn't first done bitmap_fold()
 *     into tmp, then the @dst result would have been empty.
 *
 * If either of @orig or @relmap is empty (no set bits), then @dst
 * will be returned empty.
 *
 * If (as explained above) the only set bits in @orig are in positions
 * m where m >= W, (where W is the weight of @relmap) then @dst will
 * once again be returned empty.
 *
 * All bits in @dst not set by the above rule are cleared.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1052.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/lib/locking-selftest.c#L2599-L2626

```c
/*
 * wait contexts (considering PREEMPT_RT)
 *
 * o: inner is allowed in outer
 * x: inner is disallowed in outer
< ASCII >
 *
 *       \  inner |  RCU  | RAW_SPIN | SPIN | MUTEX
 * outer  \       |       |          |      |
 * ---------------+-------+----------+------+-------
 * HARDIRQ        |   o   |    o     |  o   |  x
 * ---------------+-------+----------+------+-------
 * NOTTHREADED_IRQ|   o   |    o     |  x   |  x
 * ---------------+-------+----------+------+-------
 * SOFTIRQ        |   o   |    o     |  o   |  x
 * ---------------+-------+----------+------+-------
 * RCU            |   o   |    o     |  o   |  x
 * ---------------+-------+----------+------+-------
 * RCU_BH         |   o   |    o     |  o   |  x
 * ---------------+-------+----------+------+-------
 * RCU_SCHED      |   o   |    o     |  x   |  x
 * ---------------+-------+----------+------+-------
 * RAW_SPIN       |   o   |    o     |  x   |  x
 * ---------------+-------+----------+------+-------
 * SPIN           |   o   |    o     |  o   |  x
 * ---------------+-------+----------+------+-------
 * MUTEX          |   o   |    o     |  o   |  o
 * ---------------+-------+----------+------+-------
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1053.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/lib/maple_tree.c#L9-L51

```c
/*
 * DOC: Interesting implementation details of the Maple Tree
 *
 * Each node type has a number of slots for entries and a number of slots for
 * pivots.  In the case of dense nodes, the pivots are implied by the position
 * and are simply the slot index + the minimum of the node.
 *
 * In regular B-Tree terms, pivots are called keys.  The term pivot is used to
 * indicate that the tree is specifying ranges,  Pivots may appear in the
 * subtree with an entry attached to the value where as keys are unique to a
 * specific position of a B-tree.  Pivot values are inclusive of the slot with
 * the same index.
 *
 *
 * The following illustrates the layout of a range64 nodes slots and pivots.
 *
 *
< ASCII >
 *  Slots -> | 0 | 1 | 2 | ... | 12 | 13 | 14 | 15 |
 *           ┬   ┬   ┬   ┬     ┬    ┬    ┬    ┬    ┬
 *           │   │   │   │     │    │    │    │    └─ Implied maximum
 *           │   │   │   │     │    │    │    └─ Pivot 14
 *           │   │   │   │     │    │    └─ Pivot 13
 *           │   │   │   │     │    └─ Pivot 12
 *           │   │   │   │     └─ Pivot 11
 *           │   │   │   └─ Pivot 2
 *           │   │   └─ Pivot 1
 *           │   └─ Pivot 0
 *           └─  Implied minimum
< ASCII >
 *
 * Slot contents:
 *  Internal (non-leaf) nodes contain pointers to other nodes.
 *  Leaf nodes contain entries.
 *
 * The location of interest is often referred to as an offset.  All offsets have
 * a slot, but the last offset has an implied pivot from the node above (or
 * UINT_MAX for the root node.
 *
 * Ranges complicate certain write activities.  When modifying any of
 * the B-tree variants, it is known that one entry will either be added or
 * deleted.  When modifying the Maple Tree, one store operation may overwrite
 * the entire data set, or one half of the tree, or the middle half of the tree.
 *
 */
```
## Visual type:
- #sequence


== ./linux/linux_1054.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/lib/overflow_kunit.c#L591-L596

```c
/*
< ASCII >
 * Allocator uses a trailing node argument --------+  (e.g. kmalloc_node())
 * Allocator uses the gfp_t argument -----------+  |  (e.g. kmalloc())
 * Allocator uses a special leading argument +  |  |  (e.g. devm_kmalloc())
 *                                           |  |  |
< ASCII >
 */
```
## Visual type:
- #annotation


== ./linux/linux_1055.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/lib/test_bpf.c#L2642-L2690

```c
/*
 * Set up a sequence of staggered jumps, forwards and backwards with
 * increasing offset. This tests the conversion of relative jumps to
 * JITed native jumps. On some architectures, for example MIPS, a large
 * PC-relative jump offset may overflow the immediate field of the native
 * conditional branch instruction, triggering a conversion to use an
 * absolute jump instead. Since this changes the jump offsets, another
 * offset computation pass is necessary, and that may in turn trigger
 * another branch conversion. This jump sequence is particularly nasty
 * in that regard.
 *
 * The sequence generation is parameterized by size and jump type.
 * The size must be even, and the expected result is always size + 1.
 * Below is an example with size=8 and result=9.
< ASCII >
 *
 *                     ________________________Start
 *                     R0 = 0
 *                     R1 = r1
 *                     R2 = r2
 *            ,------- JMP +4 * 3______________Preamble: 4 insns
 * ,----------|-ind 0- if R0 != 7 JMP 8 * 3 + 1 <--------------------.
 * |          |        R0 = 8                                        |
 * |          |        JMP +7 * 3               ------------------------.
 * | ,--------|-----1- if R0 != 5 JMP 7 * 3 + 1 <--------------.     |  |
 * | |        |        R0 = 6                                  |     |  |
 * | |        |        JMP +5 * 3               ------------------.  |  |
 * | | ,------|-----2- if R0 != 3 JMP 6 * 3 + 1 <--------.     |  |  |  |
 * | | |      |        R0 = 4                            |     |  |  |  |
 * | | |      |        JMP +3 * 3               ------------.  |  |  |  |
 * | | | ,----|-----3- if R0 != 1 JMP 5 * 3 + 1 <--.     |  |  |  |  |  |
 * | | | |    |        R0 = 2                      |     |  |  |  |  |  |
 * | | | |    |        JMP +1 * 3               ------.  |  |  |  |  |  |
 * | | | | ,--t=====4> if R0 != 0 JMP 4 * 3 + 1    1  2  3  4  5  6  7  8 loc
 * | | | | |           R0 = 1                     -1 +2 -3 +4 -5 +6 -7 +8 off
 * | | | | |           JMP -2 * 3               ---'  |  |  |  |  |  |  |
 * | | | | | ,------5- if R0 != 2 JMP 3 * 3 + 1 <-----'  |  |  |  |  |  |
 * | | | | | |         R0 = 3                            |  |  |  |  |  |
 * | | | | | |         JMP -4 * 3               ---------'  |  |  |  |  |
 * | | | | | | ,----6- if R0 != 4 JMP 2 * 3 + 1 <-----------'  |  |  |  |
 * | | | | | | |       R0 = 5                                  |  |  |  |
 * | | | | | | |       JMP -6 * 3               ---------------'  |  |  |
 * | | | | | | | ,--7- if R0 != 6 JMP 1 * 3 + 1 <-----------------'  |  |
 * | | | | | | | |     R0 = 7                                        |  |
 * | | Error | | |     JMP -8 * 3               ---------------------'  |
 * | | paths | | | ,8- if R0 != 8 JMP 0 * 3 + 1 <-----------------------'
 * | | | | | | | | |   R0 = 9__________________Sequence: 3 * size - 1 insns
 * `-+-+-+-+-+-+-+-+-> EXIT____________________Return: 1 insn
 *
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1056.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/lib/textsearch.c#L11-L97

```c
/**
 * DOC: ts_intro
 * INTRODUCTION
 *
 *   The textsearch infrastructure provides text searching facilities for
 *   both linear and non-linear data. Individual search algorithms are
 *   implemented in modules and chosen by the user.
 *
 * ARCHITECTURE
 *
 * .. code-block:: none
< ASCII >
 *
 *     User
 *     +----------------+
 *     |        finish()|<--------------(6)-----------------+
 *     |get_next_block()|<--------------(5)---------------+ |
 *     |                |                     Algorithm   | |
 *     |                |                    +------------------------------+
 *     |                |                    |  init()   find()   destroy() |
 *     |                |                    +------------------------------+
 *     |                |       Core API           ^       ^          ^
 *     |                |      +---------------+  (2)     (4)        (8)
 *     |             (1)|----->| prepare()     |---+       |          |
 *     |             (3)|----->| find()/next() |-----------+          |
 *     |             (7)|----->| destroy()     |----------------------+
 *     +----------------+      +---------------+
< ASCII >
 *
 *   (1) User configures a search by calling textsearch_prepare() specifying
 *       the search parameters such as the pattern and algorithm name.
 *   (2) Core requests the algorithm to allocate and initialize a search
 *       configuration according to the specified parameters.
 *   (3) User starts the search(es) by calling textsearch_find() or
 *       textsearch_next() to fetch subsequent occurrences. A state variable
 *       is provided to the algorithm to store persistent variables.
 *   (4) Core eventually resets the search offset and forwards the find()
 *       request to the algorithm.
 *   (5) Algorithm calls get_next_block() provided by the user continuously
 *       to fetch the data to be searched in block by block.
 *   (6) Algorithm invokes finish() after the last call to get_next_block
 *       to clean up any leftovers from get_next_block. (Optional)
 *   (7) User destroys the configuration by calling textsearch_destroy().
 *   (8) Core notifies the algorithm to destroy algorithm specific
 *       allocations. (Optional)
 *
 * USAGE
 *
 *   Before a search can be performed, a configuration must be created
 *   by calling textsearch_prepare() specifying the searching algorithm,
 *   the pattern to look for and flags. As a flag, you can set TS_IGNORECASE
 *   to perform case insensitive matching. But it might slow down
 *   performance of algorithm, so you should use it at own your risk.
 *   The returned configuration may then be used for an arbitrary
 *   amount of times and even in parallel as long as a separate struct
 *   ts_state variable is provided to every instance.
 *
 *   The actual search is performed by either calling
 *   textsearch_find_continuous() for linear data or by providing
 *   an own get_next_block() implementation and
 *   calling textsearch_find(). Both functions return
 *   the position of the first occurrence of the pattern or UINT_MAX if
 *   no match was found. Subsequent occurrences can be found by calling
 *   textsearch_next() regardless of the linearity of the data.
 *
 *   Once you're done using a configuration it must be given back via
 *   textsearch_destroy.
 *
 * EXAMPLE::
 *
 *   int pos;
 *   struct ts_config *conf;
 *   struct ts_state state;
 *   const char *pattern = "chicken";
 *   const char *example = "We dance the funky chicken";
 *
 *   conf = textsearch_prepare("kmp", pattern, strlen(pattern),
 *                             GFP_KERNEL, TS_AUTOLOAD);
 *   if (IS_ERR(conf)) {
 *       err = PTR_ERR(conf);
 *       goto errout;
 *   }
 *
 *   pos = textsearch_find_continuous(conf, &state, example, strlen(example));
 *   if (pos != UINT_MAX)
 *       panic("Oh my god, dancing chickens at %d\n", pos);
 *
 *   textsearch_destroy(conf);
 */
```
## Visual type:
- #custom


== ./linux/linux_1057.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/lib/zlib_inflate/inflate.h#L50-L71

```c
/*
    State transitions between above modes -

    (most modes can go to the BAD or MEM mode -- not shown for clarity)

< ASCII >
    Process header:
        HEAD -> (gzip) or (zlib)
        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME
        NAME -> COMMENT -> HCRC -> TYPE
        (zlib) -> DICTID or TYPE
        DICTID -> DICT -> TYPE
    Read deflate blocks:
            TYPE -> STORED or TABLE or LEN or CHECK
            STORED -> COPY -> TYPE
            TABLE -> LENLENS -> CODELENS -> LEN
    Read deflate codes:
                LEN -> LENEXT or LIT or TYPE
                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
                LIT -> LEN
    Process trailer:
        CHECK -> LENGTH -> DONE
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1058.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/lib/zstd/compress/zstd_cwksp.h#L58-L141

```c
/*
 * Zstd fits all its internal datastructures into a single continuous buffer,
 * so that it only needs to perform a single OS allocation (or so that a buffer
 * can be provided to it and it can perform no allocations at all). This buffer
 * is called the workspace.
 *
 * Several optimizations complicate that process of allocating memory ranges
 * from this workspace for each internal datastructure:
 *
 * - These different internal datastructures have different setup requirements:
 *
 *   - The static objects need to be cleared once and can then be trivially
 *     reused for each compression.
 *
 *   - Various buffers don't need to be initialized at all--they are always
 *     written into before they're read.
 *
 *   - The matchstate tables have a unique requirement that they don't need
 *     their memory to be totally cleared, but they do need the memory to have
 *     some bound, i.e., a guarantee that all values in the memory they've been
 *     allocated is less than some maximum value (which is the starting value
 *     for the indices that they will then use for compression). When this
 *     guarantee is provided to them, they can use the memory without any setup
 *     work. When it can't, they have to clear the area.
 *
 * - These buffers also have different alignment requirements.
 *
 * - We would like to reuse the objects in the workspace for multiple
 *   compressions without having to perform any expensive reallocation or
 *   reinitialization work.
 *
 * - We would like to be able to efficiently reuse the workspace across
 *   multiple compressions **even when the compression parameters change** and
 *   we need to resize some of the objects (where possible).
 *
 * To attempt to manage this buffer, given these constraints, the ZSTD_cwksp
 * abstraction was created. It works as follows:
 *
< ASCII >
 * Workspace Layout:
 *
 * [                        ... workspace ...                         ]
 * [objects][tables ... ->] free space [<- ... aligned][<- ... buffers]
< ASCII >
 *
 * The various objects that live in the workspace are divided into the
 * following categories, and are allocated separately:
 *
 * - Static objects: this is optionally the enclosing ZSTD_CCtx or ZSTD_CDict,
 *   so that literally everything fits in a single buffer. Note: if present,
 *   this must be the first object in the workspace, since ZSTD_customFree{CCtx,
 *   CDict}() rely on a pointer comparison to see whether one or two frees are
 *   required.
 *
 * - Fixed size objects: these are fixed-size, fixed-count objects that are
 *   nonetheless "dynamically" allocated in the workspace so that we can
 *   control how they're initialized separately from the broader ZSTD_CCtx.
 *   Examples:
 *   - Entropy Workspace
 *   - 2 x ZSTD_compressedBlockState_t
 *   - CDict dictionary contents
 *
 * - Tables: these are any of several different datastructures (hash tables,
 *   chain tables, binary trees) that all respect a common format: they are
 *   uint32_t arrays, all of whose values are between 0 and (nextSrc - base).
 *   Their sizes depend on the cparams. These tables are 64-byte aligned.
 *
 * - Aligned: these buffers are used for various purposes that require 4 byte
 *   alignment, but don't require any initialization before they're used. These
 *   buffers are each aligned to 64 bytes.
 *
 * - Buffers: these buffers are used for various purposes that don't require
 *   any alignment or initialization before they're used. This means they can
 *   be moved around at no cost for a new compression.
 *
 * Allocating Memory:
 *
 * The various types of objects must be allocated in order, so they can be
 * correctly packed into the workspace buffer. That order is:
 *
 * 1. Objects
 * 2. Buffers
 * 3. Aligned/Tables
 *
 * Attempts to reserve objects of different types out of order will fail.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1059.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/lib/zstd/compress/zstd_fast.c#L46-L91

```c
/*
 * If you squint hard enough (and ignore repcodes), the search operation at any
 * given position is broken into 4 stages:
 *
 * 1. Hash   (map position to hash value via input read)
 * 2. Lookup (map hash val to index via hashtable read)
 * 3. Load   (map index to value at that position via input read)
 * 4. Compare
 *
 * Each of these steps involves a memory read at an address which is computed
 * from the previous step. This means these steps must be sequenced and their
 * latencies are cumulative.
 *
 * Rather than do 1->2->3->4 sequentially for a single position before moving
 * onto the next, this implementation interleaves these operations across the
 * next few positions:
 *
 * R = Repcode Read & Compare
 * H = Hash
 * T = Table Lookup
 * M = Match Read & Compare
< ASCII >
 *
 * Pos | Time -->
 * ----+-------------------
 * N   | ... M
 * N+1 | ...   TM
 * N+2 |    R H   T M
 * N+3 |         H    TM
 * N+4 |           R H   T M
 * N+5 |                H   ...
 * N+6 |                  R ...
< ASCII >
 *
 * This is very much analogous to the pipelining of execution in a CPU. And just
 * like a CPU, we have to dump the pipeline when we find a match (i.e., take a
 * branch).
 *
 * When this happens, we throw away our current state, and do the following prep
 * to re-enter the loop:
< ASCII >
 *
 * Pos | Time -->
 * ----+-------------------
 * N   | H T
 * N+1 |  H
< ASCII >
 *
 * This is also the work we do at the beginning to enter the loop initially.
 */
```
## Visual type:
- #table


== ./linux/linux_106.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/microblaze/include/asm/pgtable.h#L119-L143

```c
/* There are several potential gotchas here.  The hardware TLBLO
 * field looks like this:
< ASCII >
 *
 * 0  1  2  3  4  ... 18 19 20 21 22 23 24 25 26 27 28 29 30 31
 * RPN.....................  0  0 EX WR ZSEL.......  W  I  M  G
< ASCII >
 *
 * Where possible we make the Linux PTE bits match up with this
 *
 * - bits 20 and 21 must be cleared, because we use 4k pages (4xx can
 * support down to 1k pages), this is done in the TLBMiss exception
 * handler.
 * - We use only zones 0 (for kernel pages) and 1 (for user pages)
 * of the 16 available.  Bit 24-26 of the TLB are cleared in the TLB
 * miss handler.  Bit 27 is PAGE_USER, thus selecting the correct
 * zone.
 * - PRESENT *must* be in the bottom two bits because swap cache
 * entries use the top 30 bits.  Because 4xx doesn't support SMP
 * anyway, M is irrelevant so we borrow it for PAGE_PRESENT.  Bit 30
 * is cleared in the TLB miss handler before the TLB entry is loaded.
 * - All other bits of the PTE are loaded into TLBLO without
 *  * modification, leaving us only the bits 20, 21, 24, 25, 26, 30 for
 * software PTE bits.  We actually use bits 21, 24, 25, and
 * 30 respectively for the software bits: ACCESSED, DIRTY, RW, and
 * PRESENT.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1060.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/mm/filemap.c#L2344-L2358

```c
/*
 * CD/DVDs are error prone. When a medium error occurs, the driver may fail
 * a _large_ part of the i/o request. Imagine the worst scenario:
< ASCII >
 *
 *      ---R__________________________________________B__________
 *         ^ reading here                             ^ bad block(assume 4k)
< ASCII >
 *
 * read(R) => miss => readahead(R...B) => media error => frustrating retries
 * => failing the whole request => read(R) => read(R+1) =>
 * readahead(R+1...B+1) => bang => read(R+2) => read(R+3) =>
 * readahead(R+3...B+2) => bang => read(R+3) => read(R+4) =>
 * readahead(R+4...B+3) => bang => read(R+4) => read(R+5) => ......
 *
 * It is going insane. Fix it by quickly scaling down the readahead size.
 */
```
## Visual type:
- #custom


== ./linux/linux_1061.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/mm/memcontrol.c#L2418-L2460

```c
/*
 * When calculating the delay, we use these either side of the exponentiation to
 * maintain precision and scale to a reasonable number of jiffies (see the table
 * below.
 *
 * - MEMCG_DELAY_PRECISION_SHIFT: Extra precision bits while translating the
 *   overage ratio to a delay.
 * - MEMCG_DELAY_SCALING_SHIFT: The number of bits to scale down the
 *   proposed penalty in order to reduce to a reasonable number of jiffies, and
 *   to produce a reasonable delay curve.
 *
 * MEMCG_DELAY_SCALING_SHIFT just happens to be a number that produces a
 * reasonable delay curve compared to precision-adjusted overage, not
 * penalising heavily at first, but still making sure that growth beyond the
 * limit penalises misbehaviour cgroups by slowing them down exponentially. For
 * example, with a high of 100 megabytes:
< ASCII >
 *
 *  +-------+------------------------+
 *  | usage | time to allocate in ms |
 *  +-------+------------------------+
 *  | 100M  |                      0 |
 *  | 101M  |                      6 |
 *  | 102M  |                     25 |
 *  | 103M  |                     57 |
 *  | 104M  |                    102 |
 *  | 105M  |                    159 |
 *  | 106M  |                    230 |
 *  | 107M  |                    313 |
 *  | 108M  |                    409 |
 *  | 109M  |                    518 |
 *  | 110M  |                    639 |
 *  | 111M  |                    774 |
 *  | 112M  |                    921 |
 *  | 113M  |                   1081 |
 *  | 114M  |                   1254 |
 *  | 115M  |                   1439 |
 *  | 116M  |                   1638 |
 *  | 117M  |                   1849 |
 *  | 118M  |                   2000 |
 *  | 119M  |                   2000 |
 *  | 120M  |                   2000 |
 *  +-------+------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1062.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/mm/memory-tiers.c#L48-L104

```c
/*
 * node_demotion[] examples:
 *
 * Example 1:
 *
 * Node 0 & 1 are CPU + DRAM nodes, node 2 & 3 are PMEM nodes.
 *
< ASCII >
 * node distances:
 * node   0    1    2    3
 *    0  10   20   30   40
 *    1  20   10   40   30
 *    2  30   40   10   40
 *    3  40   30   40   10
< ASCII >
 *
 * memory_tiers0 = 0-1
 * memory_tiers1 = 2-3
 *
 * node_demotion[0].preferred = 2
 * node_demotion[1].preferred = 3
 * node_demotion[2].preferred = <empty>
 * node_demotion[3].preferred = <empty>
 *
 * Example 2:
 *
 * Node 0 & 1 are CPU + DRAM nodes, node 2 is memory-only DRAM node.
 *
< ASCII >
 * node distances:
 * node   0    1    2
 *    0  10   20   30
 *    1  20   10   30
 *    2  30   30   10
< ASCII >
 *
 * memory_tiers0 = 0-2
 *
 * node_demotion[0].preferred = <empty>
 * node_demotion[1].preferred = <empty>
 * node_demotion[2].preferred = <empty>
 *
 * Example 3:
 *
 * Node 0 is CPU + DRAM nodes, Node 1 is HBM node, node 2 is PMEM node.
 *
< ASCII >
 * node distances:
 * node   0    1    2
 *    0  10   20   30
 *    1  20   10   40
 *    2  30   40   10
< ASCII >
 *
 * memory_tiers0 = 1
 * memory_tiers1 = 0
 * memory_tiers2 = 2
 *
 * node_demotion[0].preferred = 2
 * node_demotion[1].preferred = 0
 * node_demotion[2].preferred = <empty>
 *
 */
```
## Visual type:
- #table


== ./linux/linux_1063.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/mm/mmap.c#L956-L998

```c
/*
 * Given a mapping request (addr,end,vm_flags,file,pgoff,anon_name),
 * figure out whether that can be merged with its predecessor or its
 * successor.  Or both (it neatly fills a hole).
 *
 * In most cases - when called for mmap, brk or mremap - [addr,end) is
 * certain not to be mapped by the time vma_merge is called; but when
 * called for mprotect, it is certain to be already mapped (either at
 * an offset within prev, or at the start of next), and the flags of
 * this area are about to be changed to vm_flags - and the no-change
 * case has already been eliminated.
 *
 * The following mprotect cases have to be considered, where AAAA is
 * the area passed down from mprotect_fixup, never extending beyond one
 * vma, PPPPPP is the prev vma specified, and NNNNNN the next vma after:
< ASCII >
 *
 *     AAAA             AAAA                   AAAA
 *    PPPPPPNNNNNN    PPPPPPNNNNNN       PPPPPPNNNNNN
 *    cannot merge    might become       might become
 *                    PPNNNNNNNNNN       PPPPPPPPPPNN
 *    mmap, brk or    case 4 below       case 5 below
 *    mremap move:
 *                        AAAA               AAAA
 *                    PPPP    NNNN       PPPPNNNNXXXX
 *                    might become       might become
 *                    PPPPPPPPPPPP 1 or  PPPPPPPPPPPP 6 or
 *                    PPPPPPPPNNNN 2 or  PPPPPPPPXXXX 7 or
 *                    PPPPNNNNNNNN 3     PPPPXXXXXXXX 8
< ASCII >
 *
 * It is important for case 8 that the vma NNNN overlapping the
 * region AAAA is never going to extended over XXXX. Instead XXXX must
 * be extended in region AAAA and NNNN must be removed. This way in
 * all cases where vma_merge succeeds, the moment vma_adjust drops the
 * rmap_locks, the properties of the merged vma will be already
 * correct for the whole merged range. Some of those properties like
 * vm_page_prot/vm_flags may be accessed by rmap_walks and they must
 * be correct for the whole merged range immediately after the
 * rmap_locks are released. Otherwise if XXXX would be removed and
 * NNNN would be extended over the XXXX range, remove_migration_ptes
 * or other rmap walkers (if working on addresses beyond the "end"
 * parameter) may establish ptes with the wrong permissions of NNNN
 * instead of the right permissions of XXXX.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1064.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/mm/page-writeback.c#L895-L908

```c
/*
< ASCII >
 *                           setpoint - dirty 3
 *        f(dirty) := 1.0 + (----------------)
 *                           limit - setpoint
< ASCII >
 *
 * it's a 3rd order polynomial that subjects to
 *
 * (1) f(freerun)  = 2.0 => rampup dirty_ratelimit reasonably fast
 * (2) f(setpoint) = 1.0 => the balance point
 * (3) f(limit)    = 0   => the hard limit
 * (4) df/dx      <= 0	 => negative feedback control
 * (5) the closer to setpoint, the smaller |df/dx| (and the reverse)
 *     => fast response on large errors; small oscillation near setpoint
 */
```
## Visual type:
- #formula


== ./linux/linux_1065.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/mm/page-writeback.c#L926-L1000

```c
/*
 * Dirty position control.
 *
 * (o) global/bdi setpoints
 *
 * We want the dirty pages be balanced around the global/wb setpoints.
 * When the number of dirty pages is higher/lower than the setpoint, the
 * dirty position control ratio (and hence task dirty ratelimit) will be
 * decreased/increased to bring the dirty pages back to the setpoint.
 *
 *     pos_ratio = 1 << RATELIMIT_CALC_SHIFT
 *
 *     if (dirty < setpoint) scale up   pos_ratio
 *     if (dirty > setpoint) scale down pos_ratio
 *
 *     if (wb_dirty < wb_setpoint) scale up   pos_ratio
 *     if (wb_dirty > wb_setpoint) scale down pos_ratio
 *
 *     task_ratelimit = dirty_ratelimit * pos_ratio >> RATELIMIT_CALC_SHIFT
 *
< ASCII >
 * (o) global control line
 *
 *     ^ pos_ratio
 *     |
 *     |            |<===== global dirty control scope ======>|
 * 2.0  * * * * * * *
 *     |            .*
 *     |            . *
 *     |            .   *
 *     |            .     *
 *     |            .        *
 *     |            .            *
 * 1.0 ................................*
 *     |            .                  .     *
 *     |            .                  .          *
 *     |            .                  .              *
 *     |            .                  .                 *
 *     |            .                  .                    *
 *   0 +------------.------------------.----------------------*------------->
 *           freerun^          setpoint^                 limit^   dirty pages
< ASCII >
< ASCII >
 *
 * (o) wb control line
 *
 *     ^ pos_ratio
 *     |
 *     |            *
 *     |              *
 *     |                *
 *     |                  *
 *     |                    * |<=========== span ============>|
 * 1.0 .......................*
 *     |                      . *
 *     |                      .   *
 *     |                      .     *
 *     |                      .       *
 *     |                      .         *
 *     |                      .           *
 *     |                      .             *
 *     |                      .               *
 *     |                      .                 *
 *     |                      .                   *
 *     |                      .                     *
 * 1/4 ...............................................* * * * * * * * * * * *
 *     |                      .                         .
 *     |                      .                           .
 *     |                      .                             .
 *   0 +----------------------.-------------------------------.------------->
 *                wb_setpoint^                    x_intercept^
< ASCII >
 *
 * The wb control line won't drop below pos_ratio=1/4, so that wb_dirty can
 * be smoothly throttled down to normal if it starts high in situations like
 * - start writing to a slow SD card and a fast disk at the same time. The SD
 *   card's wb_dirty may rush to many times higher than wb_setpoint.
 * - the wb dirty thresh drops quickly due to change of JBOD workload
 */
```
## Visual type:
- #plot


== ./linux/linux_1066.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/mm/readahead.c#L374-L411

```c
/*
 * On-demand readahead design.
 *
 * The fields in struct file_ra_state represent the most-recently-executed
 * readahead attempt:
< ASCII >
 *
 *                        |<----- async_size ---------|
 *     |------------------- size -------------------->|
 *     |==================#===========================|
 *     ^start             ^page marked with PG_readahead
< ASCII >
 *
 * To overlap application thinking time and disk I/O time, we do
 * `readahead pipelining': Do not wait until the application consumed all
 * readahead pages and stalled on the missing page at readahead_index;
 * Instead, submit an asynchronous readahead I/O as soon as there are
 * only async_size pages left in the readahead window. Normally async_size
 * will be equal to size, for maximum pipelining.
 *
 * In interleaved sequential reads, concurrent streams on the same fd can
 * be invalidating each other's readahead state. So we flag the new readahead
 * page at (start+size-async_size) with PG_readahead, and use it as readahead
 * indicator. The flag won't be set on already cached pages, to avoid the
 * readahead-for-nothing fuss, saving pointless page cache lookups.
 *
 * prev_pos tracks the last visited byte in the _previous_ read request.
 * It should be maintained by the caller, and will be used for detecting
 * small random reads. Note that the readahead algorithm checks loosely
 * for sequential patterns. Hence interleaved reads might be served as
 * sequential ones.
 *
 * There is a special-case: if the first page which the application tries to
 * read happens to be the first page of the file, it is assumed that a linear
 * read is about to happen and the window is immediately set to the initial size
 * based on I/O request size and the max_readahead.
 *
 * The code ramps up the readahead size aggressively at first, but slow down as
 * it approaches max_readhead.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1067.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/mm/vmalloc.c#L1042-L1068

```c
/*
 * This function populates subtree_max_size from bottom to upper
 * levels starting from VA point. The propagation must be done
 * when VA size is modified by changing its va_start/va_end. Or
 * in case of newly inserting of VA to the tree.
 *
 * It means that __augment_tree_propagate_from() must be called:
 * - After VA has been inserted to the tree(free path);
 * - After VA has been shrunk(allocation path);
 * - After VA has been increased(merging path).
 *
 * Please note that, it does not mean that upper parent nodes
 * and their subtree_max_size are recalculated all the time up
 * to the root node.
< ASCII >
 *
 *       4--8
 *        /\
 *       /  \
 *      /    \
 *    2--2  8--8
< ASCII >
 *
 * For example if we modify the node 4, shrinking it to 2, then
 * no any modification is required. If we shrink the node 2 to 1
 * its subtree_max_size is updated only, and set to 1. If we shrink
 * the node 8 to 6, then its subtree_max_size is set to 6 and parent
 * node becomes 4--6.
 */
```
## Visual type:
- #tree


== ./linux/linux_1068.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/mm/vmscan.c#L2770-L2797

```c
/*
 * The inactive anon list should be small enough that the VM never has
 * to do too much work.
 *
 * The inactive file list should be small enough to leave most memory
 * to the established workingset on the scan-resistant active list,
 * but large enough to avoid thrashing the aggregate readahead window.
 *
 * Both inactive lists should also be large enough that each inactive
 * folio has a chance to be referenced again before it is reclaimed.
 *
 * If that fails and refaulting is observed, the inactive list grows.
 *
 * The inactive_ratio is the target ratio of ACTIVE to INACTIVE folios
 * on this LRU, maintained by the pageout code. An inactive_ratio
 * of 3 means 3:1 or 25% of the folios are kept on the inactive list.
 *
< ASCII >
 * total     target    max
 * memory    ratio     inactive
 * -------------------------------------
 *   10MB       1         5MB
 *  100MB       1        50MB
 *    1GB       3       250MB
 *   10GB      10       0.9GB
 *  100GB      31         3GB
 *    1TB     101        10GB
 *   10TB     320        32GB
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1069.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/mm/workingset.c#L20-L169

```c
/*
 *		Double CLOCK lists
 *
 * Per node, two clock lists are maintained for file pages: the
 * inactive and the active list.  Freshly faulted pages start out at
 * the head of the inactive list and page reclaim scans pages from the
 * tail.  Pages that are accessed multiple times on the inactive list
 * are promoted to the active list, to protect them from reclaim,
 * whereas active pages are demoted to the inactive list when the
 * active list grows too big.
< ASCII >
 *
 *   fault ------------------------+
 *                                 |
 *              +--------------+   |            +-------------+
 *   reclaim <- |   inactive   | <-+-- demotion |    active   | <--+
 *              +--------------+                +-------------+    |
 *                     |                                           |
 *                     +-------------- promotion ------------------+
 *
< ASCII >
 *
 *		Access frequency and refault distance
 *
 * A workload is thrashing when its pages are frequently used but they
 * are evicted from the inactive list every time before another access
 * would have promoted them to the active list.
 *
 * In cases where the average access distance between thrashing pages
 * is bigger than the size of memory there is nothing that can be
 * done - the thrashing set could never fit into memory under any
 * circumstance.
 *
 * However, the average access distance could be bigger than the
 * inactive list, yet smaller than the size of memory.  In this case,
 * the set could fit into memory if it weren't for the currently
 * active pages - which may be used more, hopefully less frequently:
< ASCII >
 *
 *      +-memory available to cache-+
 *      |                           |
 *      +-inactive------+-active----+
 *  a b | c d e f g h i | J K L M N |
 *      +---------------+-----------+
< ASCII >
 *
 * It is prohibitively expensive to accurately track access frequency
 * of pages.  But a reasonable approximation can be made to measure
 * thrashing on the inactive list, after which refaulting pages can be
 * activated optimistically to compete with the existing active pages.
 *
 * Approximating inactive page access frequency - Observations:
 *
 * 1. When a page is accessed for the first time, it is added to the
 *    head of the inactive list, slides every existing inactive page
 *    towards the tail by one slot, and pushes the current tail page
 *    out of memory.
 *
 * 2. When a page is accessed for the second time, it is promoted to
 *    the active list, shrinking the inactive list by one slot.  This
 *    also slides all inactive pages that were faulted into the cache
 *    more recently than the activated page towards the tail of the
 *    inactive list.
 *
 * Thus:
 *
 * 1. The sum of evictions and activations between any two points in
 *    time indicate the minimum number of inactive pages accessed in
 *    between.
 *
 * 2. Moving one inactive page N page slots towards the tail of the
 *    list requires at least N inactive page accesses.
 *
 * Combining these:
 *
 * 1. When a page is finally evicted from memory, the number of
 *    inactive pages accessed while the page was in cache is at least
 *    the number of page slots on the inactive list.
 *
 * 2. In addition, measuring the sum of evictions and activations (E)
 *    at the time of a page's eviction, and comparing it to another
 *    reading (R) at the time the page faults back into memory tells
 *    the minimum number of accesses while the page was not cached.
 *    This is called the refault distance.
 *
 * Because the first access of the page was the fault and the second
 * access the refault, we combine the in-cache distance with the
 * out-of-cache distance to get the complete minimum access distance
 * of this page:
 *
 *      NR_inactive + (R - E)
 *
 * And knowing the minimum access distance of a page, we can easily
 * tell if the page would be able to stay in cache assuming all page
 * slots in the cache were available:
 *
 *   NR_inactive + (R - E) <= NR_inactive + NR_active
 *
 * which can be further simplified to
 *
 *   (R - E) <= NR_active
 *
 * Put into words, the refault distance (out-of-cache) can be seen as
 * a deficit in inactive list space (in-cache).  If the inactive list
 * had (R - E) more page slots, the page would not have been evicted
 * in between accesses, but activated instead.  And on a full system,
 * the only thing eating into inactive list space is active pages.
 *
 *
 *		Refaulting inactive pages
 *
 * All that is known about the active list is that the pages have been
 * accessed more than once in the past.  This means that at any given
 * time there is actually a good chance that pages on the active list
 * are no longer in active use.
 *
 * So when a refault distance of (R - E) is observed and there are at
 * least (R - E) active pages, the refaulting page is activated
 * optimistically in the hope that (R - E) active pages are actually
 * used less frequently than the refaulting page - or even not used at
 * all anymore.
 *
 * That means if inactive cache is refaulting with a suitable refault
 * distance, we assume the cache workingset is transitioning and put
 * pressure on the current active list.
 *
 * If this is wrong and demotion kicks in, the pages which are truly
 * used more frequently will be reactivated while the less frequently
 * used once will be evicted from memory.
 *
 * But if this is right, the stale pages will be pushed out of memory
 * and the used pages get to stay in cache.
 *
 *		Refaulting active pages
 *
 * If on the other hand the refaulting pages have recently been
 * deactivated, it means that the active list is no longer protecting
 * actively used cache from reclaim. The cache is NOT transitioning to
 * a different workingset; the existing workingset is thrashing in the
 * space allocated to the page cache.
 *
 *
 *		Implementation
 *
 * For each node's LRU lists, a counter for inactive evictions and
 * activations is maintained (node->nonresident_age).
 *
 * On eviction, a snapshot of this counter (along with some bits to
 * identify the node) is stored in the now empty page cache
 * slot of the evicted page.  This is called a shadow entry.
 *
 * On cache misses for which there are shadow entries, an eligible
 * refault distance will immediately activate the refaulting page.
 */
```
## Visual type:
- #state-machine


== ./linux/linux_107.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/microblaze/kernel/hw_exception_handler.S#L192-L237

```c
/*
 * hw_exception_handler - Handler for exceptions
 *
 * Exception handler notes:
 * - Handles all exceptions
 * - Does not handle unaligned exceptions during load into r17, r1, r0.
 * - Does not handle unaligned exceptions during store from r17 (cannot be
 *   done) and r1 (slows down common case)
 *
< ASCII >
 *  Relevant register structures
 *
 *  EAR - |----|----|----|----|----|----|----|----|
 *      - <  ##   32 bit faulting address     ##  >
 *
 *  ESR - |----|----|----|----|----| - | - |-----|-----|
 *      -                            W   S   REG   EXC
 *
< ASCII >
< ASCII >
 *
 * STACK FRAME STRUCTURE (for CONFIG_MMU=n)
 * ----------------------------------------
 *
 *      +-------------+         + 0
 *      |     MSR     |
 *      +-------------+         + 4
 *      |     r1      |
 *      |      .      |
 *      |      .      |
 *      |      .      |
 *      |      .      |
 *      |     r18     |
 *      +-------------+         + 76
 *      |      .      |
 *      |      .      |
 *
< ASCII >
 * MMU kernel uses the same 'pt_pool_space' pointed space
 * which is used for storing register values - noMMu style was, that values were
 * stored in stack but in case of failure you lost information about register.
 * Currently you can see register value in memory in specific place.
 * In compare to with previous solution the speed should be the same.
 *
 * MMU exception handler has different handling compare to no MMU kernel.
 * Exception handler use jump table for directing of what happen. For MMU kernel
 * is this approach better because MMU relate exception are handled by asm code
 * in this file. In compare to with MMU expect of unaligned exception
 * is everything handled by C code.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1070.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/mm/kasan/shadow.c#L379-L453

```c
/*
 * Release the backing for the vmalloc region [start, end), which
 * lies within the free region [free_region_start, free_region_end).
 *
 * This can be run lazily, long after the region was freed. It runs
 * under vmap_area_lock, so it's not safe to interact with the vmalloc/vmap
 * infrastructure.
 *
 * How does this work?
 * -------------------
 *
 * We have a region that is page aligned, labeled as A.
 * That might not map onto the shadow in a way that is page-aligned:
< ASCII >
 *
 *                    start                     end
 *                    v                         v
 * |????????|????????|AAAAAAAA|AA....AA|AAAAAAAA|????????| < vmalloc
 *  -------- -------- --------          -------- --------
 *      |        |       |                 |        |
 *      |        |       |         /-------/        |
 *      \-------\|/------/         |/---------------/
 *              |||                ||
 *             |??AAAAAA|AAAAAAAA|AA??????|                < shadow
 *                 (1)      (2)      (3)
< ASCII >
 *
 * First we align the start upwards and the end downwards, so that the
 * shadow of the region aligns with shadow page boundaries. In the
 * example, this gives us the shadow page (2). This is the shadow entirely
 * covered by this allocation.
 *
 * Then we have the tricky bits. We want to know if we can free the
 * partially covered shadow pages - (1) and (3) in the example. For this,
 * we are given the start and end of the free region that contains this
 * allocation. Extending our previous example, we could have:
< ASCII >
 *
 *  free_region_start                                    free_region_end
 *  |                 start                     end      |
 *  v                 v                         v        v
 * |FFFFFFFF|FFFFFFFF|AAAAAAAA|AA....AA|AAAAAAAA|FFFFFFFF| < vmalloc
 *  -------- -------- --------          -------- --------
 *      |        |       |                 |        |
 *      |        |       |         /-------/        |
 *      \-------\|/------/         |/---------------/
 *              |||                ||
 *             |FFAAAAAA|AAAAAAAA|AAF?????|                < shadow
 *                 (1)      (2)      (3)
< ASCII >
 *
 * Once again, we align the start of the free region up, and the end of
 * the free region down so that the shadow is page aligned. So we can free
 * page (1) - we know no allocation currently uses anything in that page,
 * because all of it is in the vmalloc free region. But we cannot free
 * page (3), because we can't be sure that the rest of it is unused.
 *
 * We only consider pages that contain part of the original region for
 * freeing: we don't try to free other pages from the free region or we'd
 * end up trying to free huge chunks of virtual address space.
 *
 * Concurrency
 * -----------
 *
 * How do we know that we're not freeing a page that is simultaneously
 * being used for a fresh allocation in kasan_populate_vmalloc(_pte)?
 *
 * We _can_ have kasan_release_vmalloc and kasan_populate_vmalloc running
 * at the same time. While we run under free_vmap_area_lock, the population
 * code does not.
 *
 * free_vmap_area_lock instead operates to ensure that the larger range
 * [free_region_start, free_region_end) is safe: because __alloc_vmap_area and
 * the per-cpu region-finding algorithm both run under free_vmap_area_lock,
 * no space identified as free will become used while we are running. This
 * means that so long as we are careful with alignment and only free shadow
 * pages entirely covered by the free region, we will not run in to any
 * trouble - any simultaneous allocations will be for disjoint regions.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1071.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/atm/atm_misc.c#L49-L74

```c
/*
 * atm_pcr_goal returns the positive PCR if it should be rounded up, the
 * negative PCR if it should be rounded down, and zero if the maximum available
 * bandwidth should be used.
 *
 * The rules are as follows (* = maximum, - = absent (0), x = value "x",
 * (x+ = x or next value above x, x- = x or next value below):
< ASCII >
 *
 *	min max pcr	result		min max pcr	result
 *	-   -   -	* (UBR only)	x   -   -	x+
 *	-   -   *	*		x   -   *	*
 *	-   -   z	z-		x   -   z	z-
 *	-   *   -	*		x   *   -	x+
 *	-   *   *	*		x   *   *	*
 *	-   *   z	z-		x   *   z	z-
 *	-   y   -	y-		x   y   -	x+
 *	-   y   *	y-		x   y   *	y-
 *	-   y   z	z-		x   y   z	z-
< ASCII >
 *
 * All non-error cases can be converted with the following simple set of rules:
 *
 *   if pcr == z then z-
 *   else if min == x && pcr == - then x+
 *     else if max == y then y-
 *	 else *
 */
```
## Visual type:
- #table


== ./linux/linux_1072.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/bridge/br_multicast.c#L2081-L2085

```c
< ASCII >
/* State          Msg type      New state                Actions
 * INCLUDE (A)    IS_IN (B)     INCLUDE (A+B)            (B)=GMI
 * INCLUDE (A)    ALLOW (B)     INCLUDE (A+B)            (B)=GMI
 * EXCLUDE (X,Y)  ALLOW (A)     EXCLUDE (X+A,Y-A)        (A)=GMI
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1073.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/bridge/br_multicast.c#L2119-L2123

```c
< ASCII >
/* State          Msg type      New state                Actions
 * INCLUDE (A)    IS_EX (B)     EXCLUDE (A*B,B-A)        (B-A)=0
 *                                                       Delete (A-B)
 *                                                       Group Timer=GMI
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1074.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/bridge/br_multicast.c#L2155-L2160

```c
< ASCII >
/* State          Msg type      New state                Actions
 * EXCLUDE (X,Y)  IS_EX (A)     EXCLUDE (A-Y,Y*A)        (A-X-Y)=GMI
 *                                                       Delete (X-A)
 *                                                       Delete (Y-A)
 *                                                       Group Timer=GMI
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1075.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/bridge/br_multicast.c#L2228-L2231

```c
< ASCII >
/* State          Msg type      New state                Actions
 * INCLUDE (A)    TO_IN (B)     INCLUDE (A+B)            (B)=GMI
 *                                                       Send Q(G,A-B)
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1076.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/bridge/br_multicast.c#L2274-L2278

```c
< ASCII >
/* State          Msg type      New state                Actions
 * EXCLUDE (X,Y)  TO_IN (A)     EXCLUDE (X+A,Y-A)        (A)=GMI
 *                                                       Send Q(G,X-A)
 *                                                       Send Q(G)
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1077.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/bridge/br_multicast.c#L2357-L2362

```c
< ASCII >
/* State          Msg type      New state                Actions
 * INCLUDE (A)    TO_EX (B)     EXCLUDE (A*B,B-A)        (B-A)=0
 *                                                       Delete (A-B)
 *                                                       Send Q(G,A*B)
 *                                                       Group Timer=GMI
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1078.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/bridge/br_multicast.c#L2400-L2406

```c
< ASCII >
/* State          Msg type      New state                Actions
 * EXCLUDE (X,Y)  TO_EX (A)     EXCLUDE (A-Y,Y*A)        (A-X-Y)=Group Timer
 *                                                       Delete (X-A)
 *                                                       Delete (Y-A)
 *                                                       Send Q(G,A-Y)
 *                                                       Group Timer=GMI
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1079.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/bridge/br_multicast.c#L2480-L2482

```c
< ASCII >
/* State          Msg type      New state                Actions
 * INCLUDE (A)    BLOCK (B)     INCLUDE (A)              Send Q(G,A*B)
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_108.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/mips/dec/int-handler.S#L36-L124

```c
/*
 * plat_irq_dispatch: Interrupt handler for DECstations
 *
 * We follow the model in the Indy interrupt code by David Miller, where he
 * says: a lot of complication here is taken away because:
 *
 * 1) We handle one interrupt and return, sitting in a loop
 *    and moving across all the pending IRQ bits in the cause
 *    register is _NOT_ the answer, the common case is one
 *    pending IRQ so optimize in that direction.
 *
 * 2) We need not check against bits in the status register
 *    IRQ mask, that would make this routine slow as hell.
 *
 * 3) Linux only thinks in terms of all IRQs on or all IRQs
 *    off, nothing in between like BSD spl() brain-damage.
 *
 * Furthermore, the IRQs on the DECstations look basically (barring
 * software IRQs which we don't use at all) like...
 *
< ASCII >
 * DS2100/3100's, aka kn01, aka Pmax:
 *
 *	MIPS IRQ	Source
 *	--------	------
 *	       0	Software (ignored)
 *	       1	Software (ignored)
 *	       2	SCSI
 *	       3	Lance Ethernet
 *	       4	DZ11 serial
 *	       5	RTC
 *	       6	Memory Controller & Video
 *	       7	FPU
 *
< ASCII >
< ASCII >
 * DS5000/200, aka kn02, aka 3max:
 *
 *	MIPS IRQ	Source
 *	--------	------
 *	       0	Software (ignored)
 *	       1	Software (ignored)
 *	       2	TurboChannel
 *	       3	RTC
 *	       4	Reserved
 *	       5	Memory Controller
 *	       6	Reserved
 *	       7	FPU
 *
< ASCII >
< ASCII >
 * DS5000/1xx's, aka kn02ba, aka 3min:
 *
 *	MIPS IRQ	Source
 *	--------	------
 *	       0	Software (ignored)
 *	       1	Software (ignored)
 *	       2	TurboChannel Slot 0
 *	       3	TurboChannel Slot 1
 *	       4	TurboChannel Slot 2
 *	       5	TurboChannel Slot 3 (ASIC)
 *	       6	Halt button
 *	       7	FPU/R4k timer
 *
< ASCII >
< ASCII >
 * DS5000/2x's, aka kn02ca, aka maxine:
 *
 *	MIPS IRQ	Source
 *	--------	------
 *	       0	Software (ignored)
 *	       1	Software (ignored)
 *	       2	Periodic Interrupt (100usec)
 *	       3	RTC
 *	       4	I/O write timeout
 *	       5	TurboChannel (ASIC)
 *	       6	Halt Keycode from Access.Bus keyboard (CTRL-ALT-ENTER)
 *	       7	FPU/R4k timer
 *
< ASCII >
< ASCII >
 * DS5000/2xx's, aka kn03, aka 3maxplus:
 *
 *	MIPS IRQ	Source
 *	--------	------
 *	       0	Software (ignored)
 *	       1	Software (ignored)
 *	       2	System Board (ASIC)
 *	       3	RTC
 *	       4	Reserved
 *	       5	Memory
 *	       6	Halt Button
 *	       7	FPU/R4k timer
< ASCII >
 *
 * We handle the IRQ according to _our_ priority (see setup.c),
 * then we just return.  If multiple IRQs are pending then we will
 * just take another exception, big deal.
 */
```
## Visual type:
- #table


== ./linux/linux_1080.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/bridge/br_multicast.c#L2517-L2520

```c
< ASCII >
/* State          Msg type      New state                Actions
 * EXCLUDE (X,Y)  BLOCK (A)     EXCLUDE (X+(A-Y),Y)      (A-X-Y)=Group Timer
 *                                                       Send Q(G,A-Y)
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1081.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/ceph/messenger.c#L37-L77

```c
/*
 * We track the state of the socket on a given connection using
 * values defined below.  The transition to a new socket state is
 * handled by a function which verifies we aren't coming from an
 * unexpected state.
< ASCII >
 *
 *      --------
 *      | NEW* |  transient initial state
 *      --------
 *          | con_sock_state_init()
 *          v
 *      ----------
 *      | CLOSED |  initialized, but no socket (and no
 *      ----------  TCP connection)
 *       ^      \
 *       |       \ con_sock_state_connecting()
 *       |        ----------------------
 *       |                              \
 *       + con_sock_state_closed()       \
 *       |+---------------------------    \
 *       | \                          \    \
 *       |  -----------                \    \
 *       |  | CLOSING |  socket event;  \    \
 *       |  -----------  await close     \    \
 *       |       ^                        \   |
 *       |       |                         \  |
 *       |       + con_sock_state_closing() \ |
 *       |      / \                         | |
 *       |     /   ---------------          | |
 *       |    /                   \         v v
 *       |   /                    --------------
 *       |  /    -----------------| CONNECTING |  socket created, TCP
 *       |  |   /                 --------------  connect initiated
 *       |  |   | con_sock_state_connected()
 *       |  |   v
 *      -------------
 *      | CONNECTED |  TCP connection established
 *      -------------
< ASCII >
 *
 * State values for ceph_connection->sock_state; NEW is assumed to be 0.
 */
```
## Visual type:
- #state-machine


== ./linux/linux_1082.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/ceph/striper.c#L11-L23

```c
/*
 * Map a file extent to a stripe unit within an object.
 * Fill in objno, offset into object, and object extent length (i.e. the
 * number of bytes mapped, less than or equal to @l->stripe_unit).
 *
 * Example for stripe_count = 3, stripes_per_object = 4:
< ASCII >
 *
 * blockno   |  0  3  6  9 |  1  4  7 10 |  2  5  8 11 | 12 15 18 21 | 13 16 19
 * stripeno  |  0  1  2  3 |  0  1  2  3 |  0  1  2  3 |  4  5  6  7 |  4  5  6
 * stripepos |      0      |      1      |      2      |      0      |      1
 * objno     |      0      |      1      |      2      |      3      |      4
 * objsetno  |                    0                    |                    1
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1083.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/dccp/feat.c#L134-L151

```c
/*
< ASCII >
 *    Lookup table for location and type of features (from RFC 4340/4342)
 *  +--------------------------+----+-----+----+----+---------+-----------+
 *  | Feature                  | Location | Reconc. | Initial |  Section  |
 *  |                          | RX | TX  | SP | NN |  Value  | Reference |
 *  +--------------------------+----+-----+----+----+---------+-----------+
 *  | DCCPF_CCID               |    |  X  | X  |    |   2     | 10        |
 *  | DCCPF_SHORT_SEQNOS       |    |  X  | X  |    |   0     |  7.6.1    |
 *  | DCCPF_SEQUENCE_WINDOW    |    |  X  |    | X  | 100     |  7.5.2    |
 *  | DCCPF_ECN_INCAPABLE      | X  |     | X  |    |   0     | 12.1      |
 *  | DCCPF_ACK_RATIO          |    |  X  |    | X  |   2     | 11.3      |
 *  | DCCPF_SEND_ACK_VECTOR    | X  |     | X  |    |   0     | 11.5      |
 *  | DCCPF_SEND_NDP_COUNT     |    |  X  | X  |    |   0     |  7.7.2    |
 *  | DCCPF_MIN_CSUM_COVER     | X  |     | X  |    |   0     |  9.2.1    |
 *  | DCCPF_DATA_CHECKSUM      | X  |     | X  |    |   0     |  9.3.1    |
 *  | DCCPF_SEND_LEV_RATE      | X  |     | X  |    |   0     | 4342/8.4  |
 *  +--------------------------+----+-----+----+----+---------+-----------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1084.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/dsa/tag.h#L163-L183

```c
/* Helper for removing DSA header tags from packets in the RX path.
 * Must not be called before skb_pull(len).
< ASCII >
 *                                                                 skb->data
 *                                                                         |
 *                                                                         v
 * |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 * +-----------------------+-----------------------+---------------+-------+
 * |    Destination MAC    |      Source MAC       |  DSA header   | EType |
 * +-----------------------+-----------------------+---------------+-------+
 *                                                 |               |
 * <----- len ----->                               <----- len ----->
 *                 |
 *       >>>>>>>   v
 *       >>>>>>>   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 *       >>>>>>>   +-----------------------+-----------------------+-------+
 *       >>>>>>>   |    Destination MAC    |      Source MAC       | EType |
 *                 +-----------------------+-----------------------+-------+
 *                                                                         ^
 *                                                                         |
 *                                                                 skb->data
< ASCII >
 */
static inline void dsa_strip_etype_header(...) {
   ...
}
```
## Visual type:
- #memory-layout


== ./linux/linux_1085.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/dsa/tag.h#L189-L212

```c
/* Helper for creating space for DSA header tags in TX path packets.
 * Must not be called before skb_push(len).
< ASCII >
 *
 * Before:
 *
 *       <<<<<<<   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 * ^     <<<<<<<   +-----------------------+-----------------------+-------+
 * |     <<<<<<<   |    Destination MAC    |      Source MAC       | EType |
 * |               +-----------------------+-----------------------+-------+
 * <----- len ----->
 * |
 * |
 * skb->data
< ASCII >
< ASCII >
 *
 * After:
 *
 * |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 * +-----------------------+-----------------------+---------------+-------+
 * |    Destination MAC    |      Source MAC       |  DSA header   | EType |
 * +-----------------------+-----------------------+---------------+-------+
 * ^                                               |               |
 * |                                               <----- len ----->
 * skb->data
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1086.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/dsa/tag_8021q.c#L15-L36

```c
/* Binary structure of the fake 12-bit VID field (when the TPID is
 * ETH_P_DSA_8021Q):
< ASCII >
 *
 * | 11  | 10  |  9  |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
 * +-----------+-----+-----------------+-----------+-----------------------+
 * |    RSV    | VBID|    SWITCH_ID    |   VBID    |          PORT         |
 * +-----------+-----+-----------------+-----------+-----------------------+
< ASCII >
 *
 * RSV - VID[11:10]:
 *	Reserved. Must be set to 3 (0b11).
 *
 * SWITCH_ID - VID[8:6]:
 *	Index of switch within DSA tree. Must be between 0 and 7.
 *
 * VBID - { VID[9], VID[5:4] }:
 *	Virtual bridge ID. If between 1 and 7, packet targets the broadcast
 *	domain of a bridge. If transmitted as zero, packet targets a single
 *	port.
 *
 * PORT - VID[3:0]:
 *	Index of switch port. Must be between 0 and 15.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1087.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/dsa/tag_lan9303.c#L12-L31

```c
/* To define the outgoing port and to discover the incoming port a regular
 * VLAN tag is used by the LAN9303. But its VID meaning is 'special':
< ASCII >
 *
 *       Dest MAC       Src MAC        TAG    Type
 * ...| 1 2 3 4 5 6 | 1 2 3 4 5 6 | 1 2 3 4 | 1 2 |...
 *                                |<------->|
 * TAG:
 *    |<------------->|
 *    |  1  2 | 3  4  |
 *      TPID    VID
 *     0x8100
< ASCII >
 *
 * VID bit 3 indicates a request for an ALR lookup.
 *
 * If VID bit 3 is zero, then bits 0 and 1 specify the destination port
 * (0, 1, 2) or broadcast (3) or the source port (1, 2).
 *
 * VID bit 4 is used to specify if the STP port state should be overridden.
 * Required when no forwarding between the external ports should happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1088.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/dsa/tag_rzn1_a5psw.c#L15-L23

```c
/* To define the outgoing port and to discover the incoming port a TAG is
 * inserted after Src MAC :
< ASCII >
 *
 *       Dest MAC       Src MAC           TAG         Type
 * ...| 1 2 3 4 5 6 | 1 2 3 4 5 6 | 1 2 3 4 5 6 7 8 | 1 2 |...
 *                                |<--------------->|
< ASCII >
 *
 * See struct a5psw_tag for layout
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1089.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/ipv4/cipso_ipv4.c#L106-L116

```c
/* Base length of the local tag (non-standard tag).
 *  Tag definition (may change between kernel versions)
< ASCII >
 *
 * 0          8          16         24         32
 * +----------+----------+----------+----------+
 * | 10000000 | 00000110 | 32-bit secid value  |
 * +----------+----------+----------+----------+
 * | in (host byte order)|
 * +----------+----------+
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_109.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/mips/include/asm/dma.h#L29-L75

```c
/*
 * NOTES about DMA transfers:
 *
 *  controller 1: channels 0-3, byte operations, ports 00-1F
 *  controller 2: channels 4-7, word operations, ports C0-DF
 *
 *  - ALL registers are 8 bits only, regardless of transfer size
 *  - channel 4 is not used - cascades 1 into 2.
 *  - channels 0-3 are byte - addresses/counts are for physical bytes
 *  - channels 5-7 are word - addresses/counts are for physical words
 *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
 *  - transfer count loaded to registers is 1 less than actual count
 *  - controller 2 offsets are all even (2x offsets for controller 1)
 *  - page registers for 5-7 don't use data bit 0, represent 128K pages
 *  - page registers for 0-3 use bit 0, represent 64K pages
 *
 * DMA transfers are limited to the lower 16MB of _physical_ memory.
 * Note that addresses loaded into registers must be _physical_ addresses,
 * not logical addresses (which may differ if paging is active).
 *
< ASCII >
 *  Address mapping for channels 0-3:
 *
 *   A23 ... A16 A15 ... A8  A7 ... A0	  (Physical addresses)
 *    |	 ...  |	  |  ... |   |	... |
 *    |	 ...  |	  |  ... |   |	... |
 *    |	 ...  |	  |  ... |   |	... |
 *   P7	 ...  P0  A7 ... A0  A7 ... A0
 * |	Page	| Addr MSB | Addr LSB |	  (DMA registers)
 *
 *  Address mapping for channels 5-7:
 *
 *   A23 ... A17 A16 A15 ... A9 A8 A7 ... A1 A0	   (Physical addresses)
 *    |	 ...  |	  \   \	  ... \	 \  \  ... \  \
 *    |	 ...  |	   \   \   ... \  \  \	... \  (not used)
 *    |	 ...  |	    \	\   ... \  \  \	 ... \
 *   P7	 ...  P1 (0) A7 A6  ... A0 A7 A6 ... A0
 * |	  Page	    |  Addr MSB	  |  Addr LSB  |   (DMA registers)
< ASCII >
 *
 * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
 * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
 * the hardware level, so odd-byte transfers aren't possible).
 *
 * Transfer count (_not # bytes_) is limited to 64K, represented as actual
 * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
 * and up to 128K bytes may be transferred on channels 5-7 in one operation.
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_1090.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/ipv4/fib_semantics.c#L1076-L1118

```c
/*
 * Picture
 * -------
 *
 * Semantics of nexthop is very messy by historical reasons.
 * We have to take into account, that:
 * a) gateway can be actually local interface address,
 *    so that gatewayed route is direct.
 * b) gateway must be on-link address, possibly
 *    described not by an ifaddr, but also by a direct route.
 * c) If both gateway and interface are specified, they should not
 *    contradict.
 * d) If we use tunnel routes, gateway could be not on-link.
 *
 * Attempt to reconcile all of these (alas, self-contradictory) conditions
 * results in pretty ugly and hairy code with obscure logic.
 *
 * I chose to generalized it instead, so that the size
 * of code does not increase practically, but it becomes
 * much more general.
 * Every prefix is assigned a "scope" value: "host" is local address,
 * "link" is direct route,
 * [ ... "site" ... "interior" ... ]
 * and "universe" is true gateway route with global meaning.
 *
 * Every prefix refers to a set of "nexthop"s (gw, oif),
 * where gw must have narrower scope. This recursion stops
 * when gw has LOCAL scope or if "nexthop" is declared ONLINK,
 * which means that gw is forced to be on link.
 *
 * Code is still hairy, but now it is apparently logically
 * consistent and very flexible. F.e. as by-product it allows
 * to co-exists in peace independent exterior and interior
 * routing processes.
 *
 * Normally it looks as following.
< ASCII >
 *
 * {universe prefix}  -> (gw, oif) [scope link]
 *		  |
 *		  |-> {link prefix} -> (gw, oif) [scope local]
 *					|
 *					|-> {local prefix} (terminal node)
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1091.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/ipv4/fib_trie.c#L230-L287

```c
/* To understand this stuff, an understanding of keys and all their bits is
 * necessary. Every node in the trie has a key associated with it, but not
 * all of the bits in that key are significant.
 *
 * Consider a node 'n' and its parent 'tp'.
 *
 * If n is a leaf, every bit in its key is significant. Its presence is
 * necessitated by path compression, since during a tree traversal (when
 * searching for a leaf - unless we are doing an insertion) we will completely
 * ignore all skipped bits we encounter. Thus we need to verify, at the end of
 * a potentially successful search, that we have indeed been walking the
 * correct key path.
 *
 * Note that we can never "miss" the correct key in the tree if present by
 * following the wrong path. Path compression ensures that segments of the key
 * that are the same for all keys with a given prefix are skipped, but the
 * skipped part *is* identical for each node in the subtrie below the skipped
 * bit! trie_insert() in this implementation takes care of that.
 *
 * if n is an internal node - a 'tnode' here, the various parts of its key
 * have many different meanings.
 *
< ASCII >
 * Example:
 * _________________________________________________________________
 * | i | i | i | i | i | i | i | N | N | N | S | S | S | S | S | C |
 * -----------------------------------------------------------------
 *  31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16
 *
 * _________________________________________________________________
 * | C | C | C | u | u | u | u | u | u | u | u | u | u | u | u | u |
 * -----------------------------------------------------------------
 *  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
< ASCII >
 *
 * tp->pos = 22
 * tp->bits = 3
 * n->pos = 13
 * n->bits = 4
 *
 * First, let's just ignore the bits that come before the parent tp, that is
 * the bits from (tp->pos + tp->bits) to 31. They are *known* but at this
 * point we do not use them for anything.
 *
 * The bits from (tp->pos) to (tp->pos + tp->bits - 1) - "N", above - are the
 * index into the parent's child array. That is, they will be used to find
 * 'n' among tp's children.
 *
 * The bits from (n->pos + n->bits) to (tp->pos - 1) - "S" - are skipped bits
 * for the node n.
 *
 * All the bits we have seen so far are significant to the node n. The rest
 * of the bits are really not needed or indeed known in n->key.
 *
 * The bits from (n->pos) to (n->pos + n->bits - 1) - "C" - are the index into
 * n's child array, and will of course be different for each child.
 *
 * The rest of the bits, from 0 to (n->pos -1) - "u" - are completely unknown
 * at this point.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1092.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/ipv4/syncookies.c#L22-L35

```c
/* TCP Timestamp: 6 lowest bits of timestamp sent in the cookie SYN-ACK
 * stores TCP options:
 *
< ASCII >
 * MSB                               LSB
 * | 31 ...   6 |  5  |  4   | 3 2 1 0 |
 * |  Timestamp | ECN | SACK | WScale  |
< ASCII >
 *
 * When we receive a valid cookie-ACK, we look at the echoed tsval (if
 * any) to figure out which TCP options we should use for the rebuilt
 * connection.
 *
 * A WScale setting of '0xf' (which is an invalid scaling value)
 * means that original syn did not include the TCP window scaling option.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1093.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/ipv4/tcp_bbr.c#L1-L58

```c
/* Bottleneck Bandwidth and RTT (BBR) congestion control
 *
 * BBR congestion control computes the sending rate based on the delivery
 * rate (throughput) estimated from ACKs. In a nutshell:
 *
 *   On each ACK, update our model of the network path:
 *      bottleneck_bandwidth = windowed_max(delivered / elapsed, 10 round trips)
 *      min_rtt = windowed_min(rtt, 10 seconds)
 *   pacing_rate = pacing_gain * bottleneck_bandwidth
 *   cwnd = max(cwnd_gain * bottleneck_bandwidth * min_rtt, 4)
 *
 * The core algorithm does not react directly to packet losses or delays,
 * although BBR may adjust the size of next send per ACK when loss is
 * observed, or adjust the sending rate if it estimates there is a
 * traffic policer, in order to keep the drop rate reasonable.
 *
< ASCII >
 * Here is a state transition diagram for BBR:
 *
 *             |
 *             V
 *    +---> STARTUP  ----+
 *    |        |         |
 *    |        V         |
 *    |      DRAIN   ----+
 *    |        |         |
 *    |        V         |
 *    +---> PROBE_BW ----+
 *    |      ^    |      |
 *    |      |    |      |
 *    |      +----+      |
 *    |                  |
 *    +---- PROBE_RTT <--+
< ASCII >
 *
 * A BBR flow starts in STARTUP, and ramps up its sending rate quickly.
 * When it estimates the pipe is full, it enters DRAIN to drain the queue.
 * In steady state a BBR flow only uses PROBE_BW and PROBE_RTT.
 * A long-lived BBR flow spends the vast majority of its time remaining
 * (repeatedly) in PROBE_BW, fully probing and utilizing the pipe's bandwidth
 * in a fair manner, with a small, bounded queue. *If* a flow has been
 * continuously sending for the entire min_rtt window, and hasn't seen an RTT
 * sample that matches or decreases its min_rtt estimate for 10 seconds, then
 * it briefly enters PROBE_RTT to cut inflight to a minimum value to re-probe
 * the path's two-way propagation delay (min_rtt). When exiting PROBE_RTT, if
 * we estimated that we reached the full bw of the pipe then we enter PROBE_BW;
 * otherwise we enter STARTUP to try to fill the pipe.
 *
 * BBR is described in detail in:
 *   "BBR: Congestion-Based Congestion Control",
 *   Neal Cardwell, Yuchung Cheng, C. Stephen Gunn, Soheil Hassas Yeganeh,
 *   Van Jacobson. ACM Queue, Vol. 14 No. 5, September-October 2016.
 *
 * There is a public e-mail list for discussing BBR development and testing:
 *   https://groups.google.com/forum/#!forum/bbr-dev
 *
 * NOTE: BBR might be used with the fq qdisc ("man tc-fq") with pacing enabled,
 * otherwise TCP stack falls back to an internal pacing using one high
 * resolution timer per TCP socket and may use more resources.
 */
```
## Visual type:
- #state-machine


== ./linux/linux_1094.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/ipv4/tcp_input.c#L1119-L1211

```c
/* This procedure tags the retransmission queue when SACKs arrive.
 *
 * We have three tag bits: SACKED(S), RETRANS(R) and LOST(L).
 * Packets in queue with these bits set are counted in variables
 * sacked_out, retrans_out and lost_out, correspondingly.
 *
 * Valid combinations are:
 * Tag  InFlight	Description
 * 0	1		- orig segment is in flight.
 * S	0		- nothing flies, orig reached receiver.
 * L	0		- nothing flies, orig lost by net.
 * R	2		- both orig and retransmit are in flight.
 * L|R	1		- orig is lost, retransmit is in flight.
 * S|R  1		- orig reached receiver, retrans is still in flight.
 * (L|S|R is logically valid, it could occur when L|R is sacked,
 *  but it is equivalent to plain S and code short-curcuits it to S.
 *  L|S is logically invalid, it would mean -1 packet in flight 8))
 *
 * These 6 states form finite state machine, controlled by the following events:
 * 1. New ACK (+SACK) arrives. (tcp_sacktag_write_queue())
 * 2. Retransmission. (tcp_retransmit_skb(), tcp_xmit_retransmit_queue())
 * 3. Loss detection event of two flavors:
 *	A. Scoreboard estimator decided the packet is lost.
 *	   A'. Reno "three dupacks" marks head of queue lost.
 *	B. SACK arrives sacking SND.NXT at the moment, when the
 *	   segment was retransmitted.
 * 4. D-SACK added new rule: D-SACK changes any tag to S.
 *
 * It is pleasant to note, that state diagram turns out to be commutative,
 * so that we are allowed not to be bothered by order of our actions,
 * when multiple events arrive simultaneously. (see the function below).
 *
 * Reordering detection.
 * --------------------
 * Reordering metric is maximal distance, which a packet can be displaced
 * in packet stream. With SACKs we can estimate it:
 *
 * 1. SACK fills old hole and the corresponding segment was not
 *    ever retransmitted -> reordering. Alas, we cannot use it
 *    when segment was retransmitted.
 * 2. The last flaw is solved with D-SACK. D-SACK arrives
 *    for retransmitted and already SACKed segment -> reordering..
 * Both of these heuristics are not used in Loss state, when we cannot
 * account for retransmits accurately.
 *
 * SACK block validation.
 * ----------------------
 *
 * SACK block range validation checks that the received SACK block fits to
 * the expected sequence limits, i.e., it is between SND.UNA and SND.NXT.
 * Note that SND.UNA is not included to the range though being valid because
 * it means that the receiver is rather inconsistent with itself reporting
 * SACK reneging when it should advance SND.UNA. Such SACK block this is
 * perfectly valid, however, in light of RFC2018 which explicitly states
 * that "SACK block MUST reflect the newest segment.  Even if the newest
 * segment is going to be discarded ...", not that it looks very clever
 * in case of head skb. Due to potentional receiver driven attacks, we
 * choose to avoid immediate execution of a walk in write queue due to
 * reneging and defer head skb's loss recovery to standard loss recovery
 * procedure that will eventually trigger (nothing forbids us doing this).
 *
 * Implements also blockage to start_seq wrap-around. Problem lies in the
 * fact that though start_seq (s) is before end_seq (i.e., not reversed),
 * there's no guarantee that it will be before snd_nxt (n). The problem
 * happens when start_seq resides between end_seq wrap (e_w) and snd_nxt
 * wrap (s_w):
< ASCII >
 *
 *         <- outs wnd ->                          <- wrapzone ->
 *         u     e      n                         u_w   e_w  s n_w
 *         |     |      |                          |     |   |  |
 * |<------------+------+----- TCP seqno space --------------+---------->|
 * ...-- <2^31 ->|                                           |<--------...
 * ...---- >2^31 ------>|                                    |<--------...
< ASCII >
 *
 * Current code wouldn't be vulnerable but it's better still to discard such
 * crazy SACK blocks. Doing this check for start_seq alone closes somewhat
 * similar case (end_seq after snd_nxt wrap) as earlier reversed check in
 * snd_nxt wrap -> snd_una region will then become "well defined", i.e.,
 * equal to the ideal case (infinite seqno space without wrap caused issues).
 *
 * With D-SACK the lower bound is extended to cover sequence space below
 * SND.UNA down to undo_marker, which is the last point of interest. Yet
 * again, D-SACK block must not to go across snd_una (for the same reason as
 * for the normal SACK blocks, explained above). But there all simplicity
 * ends, TCP might receive valid D-SACKs below that. As long as they reside
 * fully below undo_marker they do not affect behavior in anyway and can
 * therefore be safely ignored. In rare cases (which are more or less
 * theoretical ones), the D-SACK will nicely cross that boundary due to skb
 * fragmentation and packet reordering past skb's retransmission. To consider
 * them correctly, the acceptable range must be extended even more though
 * the exact amount is rather hard to quantify. However, tp->max_window can
 * be used as an exaggerated estimate.
 */
```
## Visual type:
- #interval


== ./linux/linux_1095.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/l2tp/l2tp_core.c#L581-L639

```c
/* Do receive processing of L2TP data frames. We handle both L2TPv2
 * and L2TPv3 data frames here.
 *
< ASCII >
 * L2TPv2 Data Message Header
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |T|L|x|x|S|x|O|P|x|x|x|x|  Ver  |          Length (opt)         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |           Tunnel ID           |           Session ID          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |             Ns (opt)          |             Nr (opt)          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |      Offset Size (opt)        |    Offset pad... (opt)
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
< ASCII >
 * Data frames are marked by T=0. All other fields are the same as
 * those in L2TP control frames.
 *
< ASCII >
 * L2TPv3 Data Message Header
 *
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      L2TP Session Header                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      L2-Specific Sublayer                     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                        Tunnel Payload                      ...
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
< ASCII >
< ASCII >
 * L2TPv3 Session Header Over IP
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                           Session ID                          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |               Cookie (optional, maximum 64 bits)...
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *                                                                 |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
< ASCII >
< ASCII >
 * L2TPv3 L2-Specific Sublayer Format
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |x|S|x|x|x|x|x|x|              Sequence Number                  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 * Cookie value and sublayer format are negotiated with the peer when
 * the session is set up. Unlike L2TPv2, we do not need to parse the
 * packet header to determine if optional fields are present.
 *
 * Caller must already have parsed the frame and determined that it is
 * a data (not control) frame before coming here. Fields up to the
 * session-id have already been parsed and ptr points to the data
 * after the session-id.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1096.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/l2tp/l2tp_ip.c#L80-L112

```c
/* When processing receive frames, there are two cases to
 * consider. Data frames consist of a non-zero session-id and an
 * optional cookie. Control frames consist of a regular L2TP header
 * preceded by 32-bits of zeros.
 *
< ASCII >
 * L2TPv3 Session Header Over IP
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                           Session ID                          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |               Cookie (optional, maximum 64 bits)...
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *                                                                 |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
< ASCII >
< ASCII >
 * L2TPv3 Control Message Header Over IP
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      (32 bits of zeros)                       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |T|L|x|x|S|x|x|x|x|x|x|x|  Ver  |             Length            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     Control Connection ID                     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |               Ns              |               Nr              |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 * All control frames are passed to userspace.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1097.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/l2tp/l2tp_ip6.c#L93-L125

```c
/* When processing receive frames, there are two cases to
 * consider. Data frames consist of a non-zero session-id and an
 * optional cookie. Control frames consist of a regular L2TP header
 * preceded by 32-bits of zeros.
 *
< ASCII >
 * L2TPv3 Session Header Over IP
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                           Session ID                          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |               Cookie (optional, maximum 64 bits)...
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *                                                                 |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
< ASCII >
< ASCII >
 * L2TPv3 Control Message Header Over IP
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      (32 bits of zeros)                       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |T|L|x|x|S|x|x|x|x|x|x|x|  Ver  |             Length            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     Control Connection ID                     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |               Ns              |               Nr              |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 * All control frames are passed to userspace.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1098.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/mpls/internal.h#L122-L142

```c
< ASCII >
/* The route, nexthops and vias are stored together in the same memory
 * block:
 *
 * +----------------------+
 * | mpls_route           |
 * +----------------------+
 * | mpls_nh 0            |
 * +----------------------+
 * | alignment padding    |   4 bytes for odd number of labels
 * +----------------------+
 * | via[rt_max_alen] 0   |
 * +----------------------+
 * | alignment padding    |   via's aligned on sizeof(unsigned long)
 * +----------------------+
 * | ...                  |
 * +----------------------+
 * | mpls_nh n-1          |
 * +----------------------+
 * | via[rt_max_alen] n-1 |
 * +----------------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1099.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/netfilter/nft_set_pipapo.c#L10-L329

```c
/**
 * DOC: Theory of Operation
 *
 *
 * Problem
 * -------
 *
 * Match packet bytes against entries composed of ranged or non-ranged packet
 * field specifiers, mapping them to arbitrary references. For example:
< ASCII >
 *
 * ::
 *
 *               --- fields --->
 *      |    [net],[port],[net]... => [reference]
 *   entries [net],[port],[net]... => [reference]
 *      |    [net],[port],[net]... => [reference]
 *      V    ...
 *
< ASCII >
 * where [net] fields can be IP ranges or netmasks, and [port] fields are port
 * ranges. Arbitrary packet fields can be matched.
 *
 *
 * Algorithm Overview
 * ------------------
 *
 * This algorithm is loosely inspired by [Ligatti 2010], and fundamentally
 * relies on the consideration that every contiguous range in a space of b bits
 * can be converted into b * 2 netmasks, from Theorem 3 in [Rottenstreich 2010],
 * as also illustrated in Section 9 of [Kogan 2014].
 *
 * Classification against a number of entries, that require matching given bits
 * of a packet field, is performed by grouping those bits in sets of arbitrary
 * size, and classifying packet bits one group at a time.
 *
 * Example:
 *   to match the source port (16 bits) of a packet, we can divide those 16 bits
 *   in 4 groups of 4 bits each. Given the entry:
 *      0000 0001 0101 1001
 *   and a packet with source port:
 *      0000 0001 1010 1001
 *   first and second groups match, but the third doesn't. We conclude that the
 *   packet doesn't match the given entry.
 *
 * Translate the set to a sequence of lookup tables, one per field. Each table
 * has two dimensions: bit groups to be matched for a single packet field, and
 * all the possible values of said groups (buckets). Input entries are
 * represented as one or more rules, depending on the number of composing
 * netmasks for the given field specifier, and a group match is indicated as a
 * set bit, with number corresponding to the rule index, in all the buckets
 * whose value matches the entry for a given group.
 *
 * Rules are mapped between fields through an array of x, n pairs, with each
 * item mapping a matched rule to one or more rules. The position of the pair in
 * the array indicates the matched rule to be mapped to the next field, x
 * indicates the first rule index in the next field, and n the amount of
 * next-field rules the current rule maps to.
 *
 * The mapping array for the last field maps to the desired references.
 *
 * To match, we perform table lookups using the values of grouped packet bits,
 * and use a sequence of bitwise operations to progressively evaluate rule
 * matching.
 *
 * A stand-alone, reference implementation, also including notes about possible
 * future optimisations, is available at:
 *    https://pipapo.lameexcu.se/
 *
 * Insertion
 * ---------
 *
 * - For each packet field:
 *
 *   - divide the b packet bits we want to classify into groups of size t,
 *     obtaining ceil(b / t) groups
 *
 *      Example: match on destination IP address, with t = 4: 32 bits, 8 groups
 *      of 4 bits each
 *
 *   - allocate a lookup table with one column ("bucket") for each possible
 *     value of a group, and with one row for each group
 *
< ASCII >
 *      Example: 8 groups, 2^4 buckets:
 *
 * ::
 *
 *                     bucket
 *      group  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
 *        0
 *        1
 *        2
 *        3
 *        4
 *        5
 *        6
 *        7
< ASCII >
 *
 *   - map the bits we want to classify for the current field, for a given
 *     entry, to a single rule for non-ranged and netmask set items, and to one
 *     or multiple rules for ranges. Ranges are expanded to composing netmasks
 *     by pipapo_expand().
 *
 *      Example: 2 entries, 10.0.0.5:1024 and 192.168.1.0-192.168.2.1:2048
 *      - rule #0: 10.0.0.5
 *      - rule #1: 192.168.1.0/24
 *      - rule #2: 192.168.2.0/31
 *
 *   - insert references to the rules in the lookup table, selecting buckets
 *     according to bit values of a rule in the given group. This is done by
 *     pipapo_insert().
 *
 *      Example: given:
 *      - rule #0: 10.0.0.5 mapping to buckets
 *        < 0 10  0 0   0 0  0 5 >
 *      - rule #1: 192.168.1.0/24 mapping to buckets
 *        < 12 0  10 8  0 1  < 0..15 > < 0..15 > >
 *      - rule #2: 192.168.2.0/31 mapping to buckets
 *        < 12 0  10 8  0 2  0 < 0..1 > >
 *
< ASCII >
 *      these bits are set in the lookup table:
 *
 * ::
 *
 *                     bucket
 *      group  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
 *        0    0                                              1,2
 *        1   1,2                                      0
 *        2    0                                      1,2
 *        3    0                              1,2
 *        4  0,1,2
 *        5    0   1   2
 *        6  0,1,2 1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
 *        7   1,2 1,2  1   1   1  0,1  1   1   1   1   1   1   1   1   1   1
< ASCII >
 *
 *   - if this is not the last field in the set, fill a mapping array that maps
 *     rules from the lookup table to rules belonging to the same entry in
 *     the next lookup table, done by pipapo_map().
 *
 *     Note that as rules map to contiguous ranges of rules, given how netmask
 *     expansion and insertion is performed, &union nft_pipapo_map_bucket stores
 *     this information as pairs of first rule index, rule count.
 *
 *      Example: 2 entries, 10.0.0.5:1024 and 192.168.1.0-192.168.2.1:2048,
 *      given lookup table #0 for field 0 (see example above):
 *
< ASCII >
 * ::
 *
 *                     bucket
 *      group  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
 *        0    0                                              1,2
 *        1   1,2                                      0
 *        2    0                                      1,2
 *        3    0                              1,2
 *        4  0,1,2
 *        5    0   1   2
 *        6  0,1,2 1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
 *        7   1,2 1,2  1   1   1  0,1  1   1   1   1   1   1   1   1   1   1
< ASCII >
 *
 *      and lookup table #1 for field 1 with:
 *      - rule #0: 1024 mapping to buckets
 *        < 0  0  4  0 >
 *      - rule #1: 2048 mapping to buckets
 *        < 0  0  5  0 >
 *
 * ::
 *
< ASCII >
 *                     bucket
 *      group  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
 *        0   0,1
 *        1   0,1
 *        2                    0   1
 *        3   0,1
< ASCII >
 *
 *      we need to map rules for 10.0.0.5 in lookup table #0 (rule #0) to 1024
 *      in lookup table #1 (rule #0) and rules for 192.168.1.0-192.168.2.1
 *      (rules #1, #2) to 2048 in lookup table #2 (rule #1):
 *
 * ::
 *
 *       rule indices in current field: 0    1    2
 *       map to rules in next field:    0    1    1
 *
 *   - if this is the last field in the set, fill a mapping array that maps
 *     rules from the last lookup table to element pointers, also done by
 *     pipapo_map().
 *
 *     Note that, in this implementation, we have two elements (start, end) for
 *     each entry. The pointer to the end element is stored in this array, and
 *     the pointer to the start element is linked from it.
 *
 *      Example: entry 10.0.0.5:1024 has a corresponding &struct nft_pipapo_elem
 *      pointer, 0x66, and element for 192.168.1.0-192.168.2.1:2048 is at 0x42.
 *      From the rules of lookup table #1 as mapped above:
 *
 * ::
 *
 *       rule indices in last field:    0    1
 *       map to elements:             0x66  0x42
 *
 *
 * Matching
 * --------
 *
 * We use a result bitmap, with the size of a single lookup table bucket, to
 * represent the matching state that applies at every algorithm step. This is
 * done by pipapo_lookup().
 *
 * - For each packet field:
 *
 *   - start with an all-ones result bitmap (res_map in pipapo_lookup())
 *
 *   - perform a lookup into the table corresponding to the current field,
 *     for each group, and at every group, AND the current result bitmap with
 *     the value from the lookup table bucket
 *
 * ::
 *
 *      Example: 192.168.1.5 < 12 0  10 8  0 1  0 5 >, with lookup table from
 *      insertion examples.
 *      Lookup table buckets are at least 3 bits wide, we'll assume 8 bits for
 *      convenience in this example. Initial result bitmap is 0xff, the steps
 *      below show the value of the result bitmap after each group is processed:
< ASCII >
 *
 *                     bucket
 *      group  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
 *        0    0                                              1,2
 *        result bitmap is now: 0xff & 0x6 [bucket 12] = 0x6
 *
 *        1   1,2                                      0
 *        result bitmap is now: 0x6 & 0x6 [bucket 0] = 0x6
 *
 *        2    0                                      1,2
 *        result bitmap is now: 0x6 & 0x6 [bucket 10] = 0x6
 *
 *        3    0                              1,2
 *        result bitmap is now: 0x6 & 0x6 [bucket 8] = 0x6
 *
 *        4  0,1,2
 *        result bitmap is now: 0x6 & 0x7 [bucket 0] = 0x6
 *
 *        5    0   1   2
 *        result bitmap is now: 0x6 & 0x2 [bucket 1] = 0x2
 *
 *        6  0,1,2 1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
 *        result bitmap is now: 0x2 & 0x7 [bucket 0] = 0x2
 *
 *        7   1,2 1,2  1   1   1  0,1  1   1   1   1   1   1   1   1   1   1
 *        final result bitmap for this field is: 0x2 & 0x3 [bucket 5] = 0x2
< ASCII >
 *
 *   - at the next field, start with a new, all-zeroes result bitmap. For each
 *     bit set in the previous result bitmap, fill the new result bitmap
 *     (fill_map in pipapo_lookup()) with the rule indices from the
 *     corresponding buckets of the mapping field for this field, done by
 *     pipapo_refill()
 *
 *      Example: with mapping table from insertion examples, with the current
 *      result bitmap from the previous example, 0x02:
 *
 * ::
 *
< ASCII >
 *       rule indices in current field: 0    1    2
 *       map to rules in next field:    0    1    1
< ASCII >
 *
 *      the new result bitmap will be 0x02: rule 1 was set, and rule 1 will be
 *      set.
 *
 *      We can now extend this example to cover the second iteration of the step
 *      above (lookup and AND bitmap): assuming the port field is
 *      2048 < 0  0  5  0 >, with starting result bitmap 0x2, and lookup table
 *      for "port" field from pre-computation example:
 *
 * ::
 *
< ASCII >
 *                     bucket
 *      group  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
 *        0   0,1
 *        1   0,1
 *        2                    0   1
 *        3   0,1
< ASCII >
 *
 *       operations are: 0x2 & 0x3 [bucket 0] & 0x3 [bucket 0] & 0x2 [bucket 5]
 *       & 0x3 [bucket 0], resulting bitmap is 0x2.
 *
 *   - if this is the last field in the set, look up the value from the mapping
 *     array corresponding to the final result bitmap
 *
 *      Example: 0x2 resulting bitmap from 192.168.1.5:2048, mapping array for
 *      last field from insertion example:
 *
 * ::
 *
< ASCII >
 *       rule indices in last field:    0    1
 *       map to elements:             0x66  0x42
< ASCII >
 *
 *      the matching element is at 0x42.
 *
 *
 * References
 * ----------
 *
 * [Ligatti 2010]
 *      A Packet-classification Algorithm for Arbitrary Bitmask Rules, with
 *      Automatic Time-space Tradeoffs
 *      Jay Ligatti, Josh Kuhn, and Chris Gage.
 *      Proceedings of the IEEE International Conference on Computer
 *      Communication Networks (ICCCN), August 2010.
 *      https://www.cse.usf.edu/~ligatti/papers/grouper-conf.pdf
 *
 * [Rottenstreich 2010]
 *      Worst-Case TCAM Rule Expansion
 *      Ori Rottenstreich and Isaac Keslassy.
 *      2010 Proceedings IEEE INFOCOM, San Diego, CA, 2010.
 *      http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.212.4592&rep=rep1&type=pdf
 *
 * [Kogan 2014]
 *      SAX-PAC (Scalable And eXpressive PAcket Classification)
 *      Kirill Kogan, Sergey Nikolenko, Ori Rottenstreich, William Culhane,
 *      and Patrick Eugster.
 *      Proceedings of the 2014 ACM conference on SIGCOMM, August 2014.
 *      https://www.sigcomm.org/sites/default/files/ccr/papers/2014/August/2619239-2626294.pdf
 */
```
## Visual type:
- #custom


== ./linux/linux_11.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/core_lca.c#L59-L99

```c
/*
 * Given a bus, device, and function number, compute resulting
 * configuration space address and setup the LCA_IOC_CONF register
 * accordingly.  It is therefore not safe to have concurrent
 * invocations to configuration space access routines, but there
 * really shouldn't be any need for this.
 *
< ASCII >
 * Type 0:
 *
 *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 
 *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | | | | | | | | | | | | | | | | | | | | | | | |F|F|F|R|R|R|R|R|R|0|0|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
< ASCII >
 *	31:11	Device select bit.
 * 	10:8	Function number
 * 	 7:2	Register number
 *
< ASCII >
 * Type 1:
 *
 *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 
 *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | | | | | | | | | | |B|B|B|B|B|B|B|B|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|1|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 *	31:24	reserved
 *	23:16	bus number (8 bits = 128 possible buses)
 *	15:11	Device number (5 bits)
 *	10:8	function number
 *	 7:2	register number
 *  
 * Notes:
 *	The function number selects which function of a multi-function device 
 *	(e.g., SCSI and Ethernet).
 * 
 *	The register selects a DWORD (32 bit) register offset.  Hence it
 *	doesn't get shifted by 2 bits as we want to "drop" the bottom two
 *	bits.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_110.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/mips/include/asm/irq.h#L25-L37

```c
/*
 * The highest address on the IRQ stack contains a dummy frame put down in
 * genex.S (handle_int & except_vec_vi_handler) which is structured as follows:
< ASCII >
 *
 *   top ------------
 *       | task sp  | <- irq_stack[cpu] + IRQ_STACK_START
 *       ------------
 *       |          | <- First frame of IRQ context
 *       ------------
< ASCII >
 *
 * task sp holds a copy of the task stack pointer where the struct pt_regs
 * from exception entry can be found.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1100.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/netfilter/nft_set_pipapo.c#L708-L742

```c
/**
 * pipapo_lt_4b_to_8b() - Switch lookup table group width from 4 bits to 8 bits
 * @old_groups:	Number of current groups
 * @bsize:	Size of one bucket, in longs
 * @old_lt:	Pointer to the current lookup table
 * @new_lt:	Pointer to the new, pre-allocated lookup table
 *
 * Each bucket with index b in the new lookup table, belonging to group g, is
 * filled with the bit intersection between:
 * - bucket with index given by the upper 4 bits of b, from group g, and
 * - bucket with index given by the lower 4 bits of b, from group g + 1
 *
 * That is, given buckets from the new lookup table N(x, y) and the old lookup
 * table O(x, y), with x bucket index, and y group index:
 *
 *	N(b, g) := O(b / 16, g) & O(b % 16, g + 1)
 *
 * This ensures equivalence of the matching results on lookup. Two examples in
 * pictures:
< ASCII >
 *
 *              bucket
 *  group  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 ... 254 255
 *    0                ^
 *    1                |                                                 ^
 *   ...             ( & )                                               |
 *                  /     \                                              |
 *                 /       \                                         .-( & )-.
 *                /  bucket \                                        |       |
 *      group  0 / 1   2   3 \ 4   5   6   7   8   9  10  11  12  13 |14  15 |
 *        0     /             \                                      |       |
 *        1                    \                                     |       |
 *        2                                                          |     --'
 *        3                                                          '-
 *       ...
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1101.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/netfilter/nft_set_pipapo.c#L1403-L1440

```c
/**
 * pipapo_unmap() - Remove rules from mapping tables, renumber remaining ones
 * @mt:		Mapping array
 * @rules:	Original amount of rules in mapping table
 * @start:	First rule index to be removed
 * @n:		Amount of rules to be removed
 * @to_offset:	First rule index, in next field, this group of rules maps to
 * @is_last:	If this is the last field, delete reference from mapping array
 *
 * This is used to unmap rules from the mapping table for a single field,
 * maintaining consistency and compactness for the existing ones.
 *
 * In pictures: let's assume that we want to delete rules 2 and 3 from the
 * following mapping array:
< ASCII >
 *
 *                 rules
 *               0      1      2      3      4
 *      map to:  4-10   4-10   11-15  11-15  16-18
 *
 * the result will be:
 *
 *                 rules
 *               0      1      2
 *      map to:  4-10   4-10   11-13
 *
 * for fields before the last one. In case this is the mapping table for the
 * last field in a set, and rules map to pointers to &struct nft_pipapo_elem:
 *
 *                      rules
 *                        0      1      2      3      4
 *  element pointers:  0x42   0x42   0x33   0x33   0x44
 *
 * the result will be:
 *
 *                      rules
 *                        0      1      2
 *  element pointers:  0x42   0x42   0x44
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1102.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/netfilter/nft_set_pipapo.c#L1456-L1492

```c
/**
 * pipapo_drop() - Delete entry from lookup and mapping tables, given rule map
 * @m:		Matching data
 * @rulemap:	Table of rule maps, arrays of first rule and amount of rules
 *		in next field a given entry maps to, for each field
 *
 * For each rule in lookup table buckets mapping to this set of rules, drop
 * all bits set in lookup table mapping. In pictures, assuming we want to drop
 * rules 0 and 1 from this lookup table:
 *
< ASCII >
 *                     bucket
 *      group  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
 *        0    0                                              1,2
 *        1   1,2                                      0
 *        2    0                                      1,2
 *        3    0                              1,2
 *        4  0,1,2
 *        5    0   1   2
 *        6  0,1,2 1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
 *        7   1,2 1,2  1   1   1  0,1  1   1   1   1   1   1   1   1   1   1
 *
< ASCII >
< ASCII >
 * rule 2 becomes rule 0, and the result will be:
 *
 *                     bucket
 *      group  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
 *        0                                                    0
 *        1    0
 *        2                                            0
 *        3                                    0
 *        4    0
 *        5            0
 *        6    0
 *        7    0   0
< ASCII >
 *
 * once this is done, call unmap() to drop all the corresponding rule references
 * from mapping tables.
 */
```
## Visual type:
- #table


== ./linux/linux_1103.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/netfilter/nft_set_pipapo.c#L1762-L1808

```c
/**
 * pipapo_get_boundaries() - Get byte interval for associated rules
 * @f:		Field including lookup table
 * @first_rule:	First rule (lowest index)
 * @rule_count:	Number of associated rules
 * @left:	Byte expression for left boundary (start of range)
 * @right:	Byte expression for right boundary (end of range)
 *
 * Given the first rule and amount of rules that originated from the same entry,
 * build the original range associated with the entry, and calculate the length
 * of the originating netmask.
 *
 * In pictures:
< ASCII >
 *
 *                     bucket
 *      group  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
 *        0                                                   1,2
 *        1   1,2
 *        2                                           1,2
 *        3                                   1,2
 *        4   1,2
 *        5        1   2
 *        6   1,2  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
 *        7   1,2 1,2  1   1   1   1   1   1   1   1   1   1   1   1   1   1
< ASCII >
 *
 * this is the lookup table corresponding to the IPv4 range
 * 192.168.1.0-192.168.2.1, which was expanded to the two composing netmasks,
 * rule #1: 192.168.1.0/24, and rule #2: 192.168.2.0/31.
 *
 * This function fills @left and @right with the byte values of the leftmost
 * and rightmost bucket indices for the lowest and highest rule indices,
 * respectively. If @first_rule is 1 and @rule_count is 2, we obtain, in
 * nibbles:
 *   left:  < 12, 0, 10, 8, 0, 1, 0, 0 >
 *   right: < 12, 0, 10, 8, 0, 2, 2, 1 >
 * corresponding to bytes:
 *   left:  < 192, 168, 1, 0 >
 *   right: < 192, 168, 2, 1 >
 * with mask length irrelevant here, unused on return, as the range is already
 * defined by its start and end points. The mask length is relevant for a single
 * ranged entry instead: if @first_rule is 1 and @rule_count is 1, we ignore
 * rule 2 above: @left becomes < 192, 168, 1, 0 >, @right becomes
 * < 192, 168, 1, 255 >, and the mask length, calculated from the distances
 * between leftmost and rightmost bucket indices for each group, would be 24.
 *
 * Return: mask length, in bits.
 */
```
## Visual type:
- #table


== ./linux/linux_1104.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/netfilter/x_tables.c#L869-L911

```c
/**
 * xt_check_entry_offsets - validate arp/ip/ip6t_entry
 *
 * @base: pointer to arp/ip/ip6t_entry
 * @elems: pointer to first xt_entry_match, i.e. ip(6)t_entry->elems
 * @target_offset: the arp/ip/ip6_t->target_offset
 * @next_offset: the arp/ip/ip6_t->next_offset
 *
 * validates that target_offset and next_offset are sane and that all
 * match sizes (if any) align with the target offset.
 *
 * This function does not validate the targets or matches themselves, it
 * only tests that all the offsets and sizes are correct, that all
 * match structures are aligned, and that the last structure ends where
 * the target structure begins.
 *
 * Also see xt_compat_check_entry_offsets for CONFIG_NETFILTER_XTABLES_COMPAT version.
 *
 * The arp/ip/ip6t_entry structure @base must have passed following tests:
 * - it must point to a valid memory location
 * - base to base + next_offset must be accessible, i.e. not exceed allocated
 *   length.
 *
< ASCII >
 * A well-formed entry looks like this:
 *
 * ip(6)t_entry   match [mtdata]  match [mtdata] target [tgdata] ip(6)t_entry
 * e->elems[]-----'                              |               |
 *                matchsize                      |               |
 *                                matchsize      |               |
 *                                               |               |
 * target_offset---------------------------------'               |
 * next_offset---------------------------------------------------'
< ASCII >
 *
 * elems[]: flexible array member at end of ip(6)/arpt_entry struct.
 *          This is where matches (if any) and the target reside.
 * target_offset: beginning of target.
 * next_offset: start of the next rule; also: size of this rule.
 * Since targets have a minimum size, target_offset + minlen <= next_offset.
 *
 * Every match stores its size, sum of sizes must not exceed target_offset.
 *
 * Return: 0 on success, negative errno on failure.
 */
```
## Visual type:
- #custom


== ./linux/linux_1105.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/netfilter/ipvs/ip_vs_sync.c#L95-L128

```c
/*
< ASCII >
     Sync Connection format (sync_conn)

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Type       |    Protocol   | Ver.  |        Size           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             Flags                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |            State              |         cport                 |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |            vport              |         dport                 |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             fwmark                            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             timeout  (in sec.)                |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                              ...                              |
      |                        IP-Addresses  (v4 or v6)               |
      |                              ...                              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  Optional Parameters.
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | Param. Type    | Param. Length |   Param. data                |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
      |                              ...                              |
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               | Param Type    | Param. Length |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           Param  data                         |
      |         Last Param data should be padded for 32 bit alignment |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
*/
```
## Visual type:
- #memory-layout


== ./linux/linux_1106.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/netfilter/ipvs/ip_vs_sync.c#L211-L243

```c
/*
  The master mulitcasts messages (Datagrams) to the backup load balancers
  in the following format.

< ASCII >
 Version 1:
  Note, first byte should be Zero, so ver 0 receivers will drop the packet.

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      0        |    SyncID     |            Size               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Count Conns  |    Version    |    Reserved, set to Zero      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                    IPVS Sync Connection (1)                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            .                                  |
      ~                            .                                  ~
      |                            .                                  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                    IPVS Sync Connection (n)                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 Version 0 Header
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Count Conns  |    SyncID     |            Size               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    IPVS Sync Connection (1)                   |
< ASCII >
*/
```
## Visual type:
- #memory-layout


== ./linux/linux_1107.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sched/sch_dsmark.c#L22-L35

```c
/*
< ASCII >
 * classid	class		marking
 * -------	-----		-------
 *   n/a	  0		n/a
 *   x:0	  1		use entry [0]
 *   ...	 ...		...
 *   x:y y>0	 y+1		use entry [y]
 *   ...	 ...		...
 * x:indices-1	indices		use entry [indices-1]
 *   ...	 ...		...
 *   x:y	 y+1		use entry [y & (indices-1)]
 *   ...	 ...		...
 * 0xffff	0x10000		use entry [indices-1]
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1108.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sched/sch_hfsc.c#L351-L375

```c
/*
 * service curve support functions
 *
 *  external service curve parameters
 *	m: bps
 *	d: us
 *  internal service curve parameters
 *	sm: (bytes/psched_us) << SM_SHIFT
 *	ism: (psched_us/byte) << ISM_SHIFT
 *	dx: psched_us
 *
 * The clock source resolution with ktime and PSCHED_SHIFT 10 is 1.024us.
 *
 * sm and ism are scaled in order to keep effective digits.
 * SM_SHIFT and ISM_SHIFT are selected to keep at least 4 effective
 * digits in decimal using the following table.
< ASCII >
 *
 *  bits/sec      100Kbps     1Mbps     10Mbps     100Mbps    1Gbps
 *  ------------+-------------------------------------------------------
 *  bytes/1.024us 12.8e-3    128e-3     1280e-3    12800e-3   128000e-3
 *
 *  1.024us/byte  78.125     7.8125     0.78125    0.078125   0.0078125
 *
 * So, for PSCHED_SHIFT 10 we need: SM_SHIFT 20, ISM_SHIFT 18.
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1109.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sched/sch_plug.c#L43-L54

```c
/*
< ASCII >
 * State of the queue, when used for network output buffering:
 *
 *                 plug(i+1)            plug(i)          head
 * ------------------+--------------------+---------------->
 *                   |                    |
 *                   |                    |
 * pkts_current_epoch| pkts_last_epoch    |pkts_to_release
 * ----------------->|<--------+--------->|+--------------->
 *                   v                    v
< ASCII >
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_111.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/mips/include/asm/jazz.h#L30-L44

```c
/*
< ASCII >
 * The segments of the seven segment LED are mapped
 * to the control bits as follows:
 *
 *	   (7)
 *	---------
 *	|	|
 *  (2) |	| (6)
 *	|  (1)	|
 *	---------
 *	|	|
 *  (3) |	| (5)
 *	|  (4)	|
 *	--------- . (0)
< ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_1110.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L162-L205

```c
/* 3.3.2 Initiation (INIT) (1)
 *
 * This chunk is used to initiate a SCTP association between two
 * endpoints. The format of the INIT chunk is shown below:
< ASCII >
 *
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |   Type = 1    |  Chunk Flags  |      Chunk Length             |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                         Initiate Tag                          |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |           Advertised Receiver Window Credit (a_rwnd)          |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |  Number of Outbound Streams   |  Number of Inbound Streams    |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                          Initial TSN                          |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    \                                                               \
 *    /              Optional/Variable-Length Parameters              /
 *    \                                                               \
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 *
 * The INIT chunk contains the following parameters. Unless otherwise
 * noted, each parameter MUST only be included once in the INIT chunk.
< ASCII >
 *
 * Fixed Parameters                     Status
 * ----------------------------------------------
 * Initiate Tag                        Mandatory
 * Advertised Receiver Window Credit   Mandatory
 * Number of Outbound Streams          Mandatory
 * Number of Inbound Streams           Mandatory
 * Initial TSN                         Mandatory
 *
 * Variable Parameters                  Status     Type Value
 * -------------------------------------------------------------
 * IPv4 Address (Note 1)               Optional    5
 * IPv6 Address (Note 1)               Optional    6
 * Cookie Preservative                 Optional    9
 * Reserved for ECN Capable (Note 2)   Optional    32768 (0x8000)
 * Host Name Address (Note 3)          Optional    11
 * Supported Address Types (Note 4)    Optional    12
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1111.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L533-L566

```c
/* 3.3.11 Cookie Echo (COOKIE ECHO) (10):
 *
 * This chunk is used only during the initialization of an association.
 * It is sent by the initiator of an association to its peer to complete
 * the initialization process. This chunk MUST precede any DATA chunk
 * sent within the association, but MAY be bundled with one or more DATA
 * chunks in the same packet.
< ASCII >
 *
 *      0                   1                   2                   3
 *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |   Type = 10   |Chunk  Flags   |         Length                |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     /                     Cookie                                    /
 *     \                                                               \
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 * Chunk Flags: 8 bit
 *
 *   Set to zero on transmit and ignored on receipt.
 *
 * Length: 16 bits (unsigned integer)
 *
 *   Set to the size of the chunk in bytes, including the 4 bytes of
 *   the chunk header and the size of the Cookie.
 *
 * Cookie: variable size
 *
 *   This field must contain the exact cookie received in the
 *   State Cookie parameter from the previous INIT ACK.
 *
 *   An implementation SHOULD make the cookie as small as possible
 *   to insure interoperability.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1112.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L601-L618

```c
/* 3.3.12 Cookie Acknowledgement (COOKIE ACK) (11):
 *
 * This chunk is used only during the initialization of an
 * association.  It is used to acknowledge the receipt of a COOKIE
 * ECHO chunk.  This chunk MUST precede any DATA or SACK chunk sent
 * within the association, but MAY be bundled with one or more DATA
 * chunks or SACK chunk in the same SCTP packet.
< ASCII >
 *
 *      0                   1                   2                   3
 *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |   Type = 11   |Chunk  Flags   |     Length = 4                |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 * Chunk Flags: 8 bits
 *
 *   Set to zero on transmit and ignored on receipt.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1113.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L643-L665

```c
/*
 *  Appendix A: Explicit Congestion Notification:
 *  CWR:
 *
 *  RFC 2481 details a specific bit for a sender to send in the header of
 *  its next outbound TCP segment to indicate to its peer that it has
 *  reduced its congestion window.  This is termed the CWR bit.  For
 *  SCTP the same indication is made by including the CWR chunk.
 *  This chunk contains one data element, i.e. the TSN number that
 *  was sent in the ECNE chunk.  This element represents the lowest
 *  TSN number in the datagram that was originally marked with the
 *  CE bit.
< ASCII >
 *
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    | Chunk Type=13 | Flags=00000000|    Chunk Length = 8           |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                      Lowest TSN Number                        |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 *     Note: The CWR is considered a Control chunk.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1114.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L1224-L1234

```c
< ASCII >
/* RFC4820 3. Padding Chunk (PAD)
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | Type = 0x84   |   Flags=0     |             Length            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * \                         Padding Data                          /
 * /                                                               \
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1115.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L2783-L2804

```c
/*
< ASCII >
 * ADDIP 3.1.1 Address Configuration Change Chunk (ASCONF)
 *      0                   1                   2                   3
 *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     | Type = 0xC1   |  Chunk Flags  |      Chunk Length             |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |                       Serial Number                           |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |                    Address Parameter                          |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |                     ASCONF Parameter #1                       |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     \                                                               \
 *     /                             ....                              /
 *     \                                                               \
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |                     ASCONF Parameter #N                       |
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 * Address Parameter and other parameter will not be wrapped in this function
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1116.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L2837-L2860

```c
/* ADDIP
< ASCII >
 * 3.2.1 Add IP Address
 * 	0                   1                   2                   3
 * 	0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |        Type = 0xC001          |    Length = Variable          |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |               ASCONF-Request Correlation ID                   |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |                       Address Parameter                       |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 * 3.2.2 Delete IP Address
 * 	0                   1                   2                   3
 * 	0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |        Type = 0xC002          |    Length = Variable          |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |               ASCONF-Request Correlation ID                   |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |                       Address Parameter                       |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1117.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L2934-L2947

```c
/* ADDIP
< ASCII >
 * 3.2.4 Set Primary IP Address
 *	0                   1                   2                   3
 *	0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |        Type =0xC004           |    Length = Variable          |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |               ASCONF-Request Correlation ID                   |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |                       Address Parameter                       |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 * Create an ASCONF chunk with Set Primary IP address parameter.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1118.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L2978-L2996

```c
< ASCII >
/* ADDIP 3.1.2 Address Configuration Acknowledgement Chunk (ASCONF-ACK)
 *      0                   1                   2                   3
 *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     | Type = 0x80   |  Chunk Flags  |      Chunk Length             |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |                       Serial Number                           |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |                 ASCONF Parameter Response#1                   |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     \                                                               \
 *     /                             ....                              /
 *     \                                                               \
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |                 ASCONF Parameter Response#N                   |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 * Create an ASCONF_ACK chunk with enough space for the parameter responses.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1119.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L3620-L3634

```c
< ASCII >
/* RE-CONFIG 3.1 (RE-CONFIG chunk)
 *   0                   1                   2                   3
 *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  | Type = 130    |  Chunk Flags  |      Chunk Length             |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  \                                                               \
 *  /                  Re-configuration Parameter                   /
 *  \                                                               \
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  \                                                               \
 *  /             Re-configuration Parameter (optional)             /
 *  \                                                               \
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_112.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/mips/include/asm/sn/klconfig.h#L217-L307

```c
/*
 * The KLCONFIG area is organized as a LINKED LIST of BOARDs. A BOARD
 * can be either 'LOCAL' or 'REMOTE'. LOCAL means it is attached to
 * the LOCAL/current NODE. REMOTE means it is attached to a different
 * node.(TBD - Need a way to treat ROUTER boards.)
 *
 * There are 2 different structures to represent these boards -
 * lboard - Local board, rboard - remote board. These 2 structures
 * can be arbitrarily mixed in the LINKED LIST of BOARDs. (Refer
 * Figure below). The first byte of the rboard or lboard structure
 * is used to find out its type - no unions are used.
 * If it is a lboard, then the config info of this board will be found
 * on the local node. (LOCAL NODE BASE + offset value gives pointer to
 * the structure.
 * If it is a rboard, the local structure contains the node number
 * and the offset of the beginning of the LINKED LIST on the remote node.
 * The details of the hardware on a remote node can be built locally,
 * if required, by reading the LINKED LIST on the remote node and
 * ignoring all the rboards on that node.
 *
 * The local node uses the REMOTE NODE NUMBER + OFFSET to point to the
 * First board info on the remote node. The remote node list is
 * traversed as the local list, using the REMOTE BASE ADDRESS and not
 * the local base address and ignoring all rboard values.
 *
 *
< ASCII >
 KLCONFIG

 +------------+	     +------------+	 +------------+	     +------------+
 |  lboard    |	 +-->|	 lboard	  |  +-->|   rboard   |	 +-->|	 lboard	  |
 +------------+	 |   +------------+  |	 +------------+	 |   +------------+
 | board info |	 |   | board info |  |	 |errinfo,bptr|	 |   | board info |
 +------------+	 |   +------------+  |	 +------------+	 |   +------------+
 | offset     |--+   |	offset	  |--+	 |  offset    |--+   |offset=NULL |
 +------------+	     +------------+	 +------------+	     +------------+


 +------------+
 | board info |
 +------------+	      +--------------------------------+
 | compt 1    |------>| type, rev, diaginfo, size ...  |  (CPU)
 +------------+	      +--------------------------------+
 | compt 2    |--+
 +------------+	 |    +--------------------------------+
 |  ...	      |	 +--->| type, rev, diaginfo, size ...  |  (MEM_BANK)
 +------------+	      +--------------------------------+
 | errinfo    |--+
 +------------+	 |    +--------------------------------+
		 +--->|r/l brd errinfo,compt err flags |
		      +--------------------------------+
< ASCII >

 *
 * Each BOARD consists of COMPONENTs and the BOARD structure has
 * pointers (offsets) to its COMPONENT structure.
 * The COMPONENT structure has version info, size and speed info, revision,
 * error info and the NIC info. This structure can accommodate any
 * BOARD with arbitrary COMPONENT composition.
 *
 * The ERRORINFO part of each BOARD has error information
 * that describes errors about the BOARD itself. It also has flags to
 * indicate the COMPONENT(s) on the board that have errors. The error
 * information specific to the COMPONENT is present in the respective
 * COMPONENT structure.
 *
 * The ERRORINFO structure is also treated like a COMPONENT, ie. the
 * BOARD has pointers(offset) to the ERRORINFO structure. The rboard
 * structure also has a pointer to the ERRORINFO structure. This is
 * the place to store ERRORINFO about a REMOTE NODE, if the HUB on
 * that NODE is not working or if the REMOTE MEMORY is BAD. In cases where
 * only the CPU of the REMOTE NODE is disabled, the ERRORINFO pointer can
 * be a NODE NUMBER, REMOTE OFFSET combination, pointing to error info
 * which is present on the REMOTE NODE.(TBD)
 * REMOTE ERRINFO can be stored on any of the nearest nodes
 * or on all the nearest nodes.(TBD)
 * Like BOARD structures, REMOTE ERRINFO structures can be built locally
 * using the rboard errinfo pointer.
 *
 * In order to get useful information from this Data organization, a set of
 * interface routines are provided (TBD). The important thing to remember while
 * manipulating the structures, is that, the NODE number information should
 * be used. If the NODE is non-zero (remote) then each offset should
 * be added to the REMOTE BASE ADDR else it should be added to the LOCAL BASE ADDR.
 * This includes offsets for BOARDS, COMPONENTS and ERRORINFO.
 *
 * Note that these structures do not provide much info about connectivity.
 * That info will be part of HWGRAPH, which is an extension of the cfg_t
 * data structure. (ref IP27prom/cfg.h) It has to be extended to include
 * the IO part of the Network(TBD).
 *
 * The data structures below define the above concepts.
 */
```
## Visual type:
- #custom


== ./linux/linux_1120.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L3652-L3685

```c
< ASCII >
/* RE-CONFIG 4.1 (STREAM OUT RESET)
 *   0                   1                   2                   3
 *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |     Parameter Type = 13       | Parameter Length = 16 + 2 * N |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |           Re-configuration Request Sequence Number            |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |           Re-configuration Response Sequence Number           |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                Sender's Last Assigned TSN                     |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |  Stream Number 1 (optional)   |    Stream Number 2 (optional) |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  /                            ......                             /
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |  Stream Number N-1 (optional) |    Stream Number N (optional) |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 * RE-CONFIG 4.2 (STREAM IN RESET)
 *   0                   1                   2                   3
 *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |     Parameter Type = 14       |  Parameter Length = 8 + 2 * N |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |          Re-configuration Request Sequence Number             |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |  Stream Number 1 (optional)   |    Stream Number 2 (optional) |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  /                            ......                             /
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |  Stream Number N-1 (optional) |    Stream Number N (optional) |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1121.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L3731-L3739

```c
< ASCII >
/* RE-CONFIG 4.3 (SSN/TSN RESET ALL)
 *   0                   1                   2                   3
 *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |     Parameter Type = 15       |      Parameter Length = 8     |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |         Re-configuration Request Sequence Number              |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1122.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L3760-L3770

```c
< ASCII >
/* RE-CONFIG 4.5/4.6 (ADD STREAM)
 *   0                   1                   2                   3
 *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |     Parameter Type = 17       |      Parameter Length = 12    |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |          Re-configuration Request Sequence Number             |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |      Number of new streams    |         Reserved              |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1123.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L3806-L3816

```c
< ASCII >
/* RE-CONFIG 4.4 (RESP)
 *   0                   1                   2                   3
 *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |     Parameter Type = 16       |      Parameter Length         |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |         Re-configuration Response Sequence Number             |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                            Result                             |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1124.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/sm_make_chunk.c#L3838-L3852

```c
< ASCII >
/* RE-CONFIG 4.4 OPTIONAL (TSNRESP)
 *   0                   1                   2                   3
 *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |     Parameter Type = 16       |      Parameter Length         |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |         Re-configuration Response Sequence Number             |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                            Result                             |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                   Sender's Next TSN (optional)                |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                  Receiver's Next TSN (optional)               |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1125.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sctp/socket.c#L8743-L8781

```c
/* Parse out IPPROTO_SCTP CMSG headers.  Perform only minimal validation.
 *
 * From RFC 2292
 * 4.2 The cmsghdr Structure *
 *
 * When ancillary data is sent or received, any number of ancillary data
 * objects can be specified by the msg_control and msg_controllen members of
 * the msghdr structure, because each object is preceded by
 * a cmsghdr structure defining the object's length (the cmsg_len member).
 * Historically Berkeley-derived implementations have passed only one object
 * at a time, but this API allows multiple objects to be
 * passed in a single call to sendmsg() or recvmsg(). The following example
 * shows two ancillary data objects in a control buffer.
< ASCII >
 *
 *   |<--------------------------- msg_controllen -------------------------->|
 *   |                                                                       |
 *
 *   |<----- ancillary data object ----->|<----- ancillary data object ----->|
 *
 *   |<---------- CMSG_SPACE() --------->|<---------- CMSG_SPACE() --------->|
 *   |                                   |                                   |
 *
 *   |<---------- cmsg_len ---------->|  |<--------- cmsg_len ----------->|  |
 *
 *   |<--------- CMSG_LEN() --------->|  |<-------- CMSG_LEN() ---------->|  |
 *   |                                |  |                                |  |
 *
 *   +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+
 *   |cmsg_|cmsg_|cmsg_|XX|           |XX|cmsg_|cmsg_|cmsg_|XX|           |XX|
 *
 *   |len  |level|type |XX|cmsg_data[]|XX|len  |level|type |XX|cmsg_data[]|XX|
 *
 *   +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+
 *    ^
 *    |
< ASCII >
 *
 * msg_control
 * points here
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1126.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sunrpc/xprtrdma/rpc_rdma.c#L319-L332

```c
/* Register and XDR encode the Read list. Supports encoding a list of read
 * segments that belong to a single read chunk.
 *
 * Encoding key for single-list chunks (HLOO = Handle32 Length32 Offset64):
 *
 *  Read chunklist (a linked list):
 *   N elements, position P (same P for all chunks of same arg!):
< ASCII >
 *    1 - PHLOO - 1 - PHLOO - ... - 1 - PHLOO - 0
< ASCII >
 *
 * Returns zero on success, or a negative errno if a failure occurred.
 * @xdr is advanced to the next position in the stream.
 *
 * Only a single @pos value is currently supported.
 */
```
## Visual type:
- #sequence


== ./linux/linux_1127.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sunrpc/xprtrdma/rpc_rdma.c#L375-L389

```c
/* Register and XDR encode the Write list. Supports encoding a list
 * containing one array of plain segments that belong to a single
 * write chunk.
 *
 * Encoding key for single-list chunks (HLOO = Handle32 Length32 Offset64):
 *
 *  Write chunklist (a list of (one) counted array):
 *   N elements:
< ASCII >
 *    1 - N - HLOO - HLOO - ... - HLOO - 0
< ASCII >
 *
 * Returns zero on success, or a negative errno if a failure occurred.
 * @xdr is advanced to the next position in the stream.
 *
 * Only a single Write chunk is currently supported.
 */
```
## Visual type:
- #sequence


== ./linux/linux_1128.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/sunrpc/xprtrdma/rpc_rdma.c#L456-L467

```c
/* Register and XDR encode the Reply chunk. Supports encoding an array
 * of plain segments that belong to a single write (reply) chunk.
 *
 * Encoding key for single-list chunks (HLOO = Handle32 Length32 Offset64):
 *
 *  Reply chunk (a counted array):
 *   N elements:
< ASCII >
 *    1 - N - HLOO - HLOO - ... - HLOO
< ASCII >
 *
 * Returns zero on success, or a negative errno if a failure occurred.
 * @xdr is advanced to the next position in the stream.
 */
```
## Visual type:
- #sequence


== ./linux/linux_1129.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/tipc/crypto.c#L93-L100

```c
/*
< ASCII >
 * struct tipc_key - TIPC keys' status indicator
 *
 *         7     6     5     4     3     2     1     0
 *      +-----+-----+-----+-----+-----+-----+-----+-----+
 * key: | (reserved)|passive idx| active idx|pending idx|
 *      +-----+-----+-----+-----+-----+-----+-----+-----+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_113.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/mips/include/asm/sn/sn0/kldir.h#L22-L118

```c
/*
 * The upper portion of the memory map applies during boot
 * only and is overwritten by IRIX/SYMMON.
< ASCII >
 *
 *				      MEMORY MAP PER NODE
 *
 * 0x2000000 (32M)	   +-----------------------------------------+
 *			   |	  IO6 BUFFERS FOR FLASH ENET IOC3    |
 * 0x1F80000 (31.5M)	   +-----------------------------------------+
 *			   |	  IO6 TEXT/DATA/BSS/stack	     |
 * 0x1C00000 (30M)	   +-----------------------------------------+
 *			   |	  IO6 PROM DEBUG TEXT/DATA/BSS/stack |
 * 0x0800000 (28M)	   +-----------------------------------------+
 *			   |	  IP27 PROM TEXT/DATA/BSS/stack	     |
 * 0x1B00000 (27M)	   +-----------------------------------------+
 *			   |	  IP27 CFG			     |
 * 0x1A00000 (26M)	   +-----------------------------------------+
 *			   |	  Graphics PROM			     |
 * 0x1800000 (24M)	   +-----------------------------------------+
 *			   |	  3rd Party PROM drivers	     |
 * 0x1600000 (22M)	   +-----------------------------------------+
 *			   |					     |
 *			   |	  Free				     |
 *			   |					     |
 *			   +-----------------------------------------+
 *			   |	  UNIX DEBUG Version		     |
 * 0x190000 (2M--)	   +-----------------------------------------+
 *			   |	  SYMMON			     |
 *			   |	  (For UNIX Debug only)		     |
 * 0x34000 (208K)	   +-----------------------------------------+
 *			   |	  SYMMON STACK [NUM_CPU_PER_NODE]    |
 *			   |	  (For UNIX Debug only)		     |
 * 0x25000 (148K)	   +-----------------------------------------+
 *			   |	  KLCONFIG - II (temp)		     |
 *			   |					     |
 *			   |	----------------------------	     |
 *			   |					     |
 *			   |	  UNIX NON-DEBUG Version	     |
 * 0x19000 (100K)	   +-----------------------------------------+
< ASCII >
 *
 *
 * The lower portion of the memory map contains information that is
 * permanent and is used by the IP27PROM, IO6PROM and IRIX.
< ASCII >
 *
 * 0x19000 (100K)	   +-----------------------------------------+
 *			   |					     |
 *			   |	  PI Error Spools (32K)		     |
 *			   |					     |
 * 0x12000 (72K)	   +-----------------------------------------+
 *			   |	  Unused			     |
 * 0x11c00 (71K)	   +-----------------------------------------+
 *			   |	  CPU 1 NMI Eframe area		     |
 * 0x11a00 (70.5K)	   +-----------------------------------------+
 *			   |	  CPU 0 NMI Eframe area		     |
 * 0x11800 (70K)	   +-----------------------------------------+
 *			   |	  CPU 1 NMI Register save area	     |
 * 0x11600 (69.5K)	   +-----------------------------------------+
 *			   |	  CPU 0 NMI Register save area	     |
 * 0x11400 (69K)	   +-----------------------------------------+
 *			   |	  GDA (1k)			     |
 * 0x11000 (68K)	   +-----------------------------------------+
 *			   |	  Early cache Exception stack	     |
 *			   |		 and/or			     |
 *			   |	  kernel/io6prom nmi registers	     |
 * 0x10800  (66k)	   +-----------------------------------------+
 *			   |	  cache error eframe		     |
 * 0x10400 (65K)	   +-----------------------------------------+
 *			   |	  Exception Handlers (UALIAS copy)   |
 * 0x10000 (64K)	   +-----------------------------------------+
 *			   |					     |
 *			   |					     |
 *			   |	  KLCONFIG - I (permanent) (48K)     |
 *			   |					     |
 *			   |					     |
 *			   |					     |
 * 0x4000 (16K)		   +-----------------------------------------+
 *			   |	  NMI Handler (Protected Page)	     |
 * 0x3000 (12K)		   +-----------------------------------------+
 *			   |	  ARCS PVECTORS (master node only)   |
 * 0x2c00 (11K)		   +-----------------------------------------+
 *			   |	  ARCS TVECTORS (master node only)   |
 * 0x2800 (10K)		   +-----------------------------------------+
 *			   |	  LAUNCH [NUM_CPU]		     |
 * 0x2400 (9K)		   +-----------------------------------------+
 *			   |	  Low memory directory (KLDIR)	     |
 * 0x2000 (8K)		   +-----------------------------------------+
 *			   |	  ARCS SPB (1K)			     |
 * 0x1000 (4K)		   +-----------------------------------------+
 *			   |	  Early cache Exception stack	     |
 *			   |		 and/or			     |
 *			   |	  kernel/io6prom nmi registers	     |
 * 0x800  (2k)		   +-----------------------------------------+
 *			   |	  cache error eframe		     |
 * 0x400 (1K)		   +-----------------------------------------+
 *			   |	  Exception Handlers		     |
 * 0x0	 (0K)		   +-----------------------------------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1130.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/tipc/crypto.h#L72-L116

```c
/*
< ASCII >
 * TIPC encryption message format:
 *
 *     3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0
 *     1 0 9 8 7 6 5 4|3 2 1 0 9 8 7 6|5 4 3 2 1 0 9 8|7 6 5 4 3 2 1 0
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * w0:|Ver=7| User  |D|TX |RX |K|M|N|             Rsvd                |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * w1:|                             Seqno                             |
 * w2:|                           (8 octets)                          |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * w3:\                            Prevnode                           \
 *    /                        (4 or 16 octets)                       /
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    \                                                               \
 *    /       Encrypted complete TIPC V2 header and user data         /
 *    \                                                               \
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                                                               |
 *    |                             AuthTag                           |
 *    |                           (16 octets)                         |
 *    |                                                               |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 * Word0:
 *	Ver	: = 7 i.e. TIPC encryption message version
 *	User	: = 7 (for LINK_PROTOCOL); = 13 (for LINK_CONFIG) or = 0
 *	D	: The destined bit i.e. the message's destination node is
 *	          "known" or not at the message encryption
 *	TX	: TX key used for the message encryption
 *	RX	: Currently RX active key corresponding to the destination
 *	          node's TX key (when the "D" bit is set)
 *	K	: Keep-alive bit (for RPS, LINK_PROTOCOL/STATE_MSG only)
 *	M       : Bit indicates if sender has master key
 *	N	: Bit indicates if sender has no RX keys corresponding to the
 *	          receiver's TX (when the "D" bit is set)
 *	Rsvd	: Reserved bit, field
 * Word1-2:
 *	Seqno	: The 64-bit sequence number of the encrypted message, also
 *		  part of the nonce used for the message encryption/decryption
 * Word3-:
 *	Prevnode: The source node address, or ID in case LINK_CONFIG only
 *	AuthTag	: The authentication tag for the message integrity checking
 *		  generated by the message encryption
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1131.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/tipc/msg.h#L152-L159

```c
/* struct tipc_gap_ack - TIPC Gap ACK block
 * @ack: seqno of the last consecutive packet in link deferdq
 * @gap: number of gap packets since the last ack
 *
< ASCII >
 * E.g:
 *       link deferdq: 1 2 3 4      10 11      13 14 15       20
 * --> Gap ACK blocks:      <4, 5>,   <11, 1>,      <15, 4>, <20, 0>
< ASCII >
 */
```
## Visual type:
- #sequence


== ./linux/linux_1132.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/tipc/msg.h#L165-L185

```c
/* struct tipc_gap_ack_blks
 * @len: actual length of the record
 * @ugack_cnt: number of Gap ACK blocks for unicast (following the broadcast
 *             ones)
 * @start_index: starting index for "valid" broadcast Gap ACK blocks
 * @bgack_cnt: number of Gap ACK blocks for broadcast in the record
 * @gacks: array of Gap ACK blocks
< ASCII >
 *
 *  31                       16 15                        0
 * +-------------+-------------+-------------+-------------+
 * |  bgack_cnt  |  ugack_cnt  |            len            |
 * +-------------+-------------+-------------+-------------+  -
 * |            gap            |            ack            |   |
 * +-------------+-------------+-------------+-------------+    > bc gacks
 * :                           :                           :   |
 * +-------------+-------------+-------------+-------------+  -
 * |            gap            |            ack            |   |
 * +-------------+-------------+-------------+-------------+    > uc gacks
 * :                           :                           :   |
 * +-------------+-------------+-------------+-------------+  -
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1133.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/tls/tls_sw.c#L1416-L1427

```c
/* Decrypt handlers
 *
 * tls_decrypt_sw() and tls_decrypt_device() are decrypt handlers.
< ASCII >
 * They must transform the darg in/out argument are as follows:
 *       |          Input            |         Output
 * -------------------------------------------------------------------
 *    zc | Zero-copy decrypt allowed | Zero-copy performed
 * async | Async decrypt allowed     | Async crypto used / in progress
 *   skb |            *              | Output skb
 *
 * If ZC decryption was performed darg.skb will point to the input skb.
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1134.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/xdp/xsk_queue.h#L50-L90

```c
/* The structure of the shared state of the rings are a simple
 * circular buffer, as outlined in
 * Documentation/core-api/circular-buffers.rst. For the Rx and
 * completion ring, the kernel is the producer and user space is the
 * consumer. For the Tx and fill rings, the kernel is the consumer and
 * user space is the producer.
 *
< ASCII >
 * producer                         consumer
 *
 * if (LOAD ->consumer) {  (A)      LOAD.acq ->producer  (C)
 *    STORE $data                   LOAD $data
 *    STORE.rel ->producer (B)      STORE.rel ->consumer (D)
 * }
< ASCII >
 *
 * (A) pairs with (D), and (B) pairs with (C).
 *
 * Starting with (B), it protects the data from being written after
 * the producer pointer. If this barrier was missing, the consumer
 * could observe the producer pointer being set and thus load the data
 * before the producer has written the new data. The consumer would in
 * this case load the old data.
 *
 * (C) protects the consumer from speculatively loading the data before
 * the producer pointer actually has been read. If we do not have this
 * barrier, some architectures could load old data as speculative loads
 * are not discarded as the CPU does not know there is a dependency
 * between ->producer and data.
 *
 * (A) is a control dependency that separates the load of ->consumer
 * from the stores of $data. In case ->consumer indicates there is no
 * room in the buffer to store $data we do not. The dependency will
 * order both of the stores after the loads. So no barrier is needed.
 *
 * (D) protects the load of the data to be observed to happen after the
 * store of the consumer pointer. If we did not have this memory
 * barrier, the producer could observe the consumer pointer being set
 * and overwrite the data with a new value before the consumer got the
 * chance to read the old value. The consumer would thus miss reading
 * the old entry and very likely read the new entry twice, once right
 * now and again after circling through the ring.
 */
```
## Visual type:
- #custom


== ./linux/linux_1135.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/net/xfrm/xfrm_policy.c#L77-L112

```c
< ASCII >
/* xfrm inexact policy search tree:
 * xfrm_pol_inexact_bin = hash(dir,type,family,if_id);
 *  |
 * +---- root_d: sorted by daddr:prefix
 * |                 |
 * |        xfrm_pol_inexact_node
 * |                 |
 * |                 +- root: sorted by saddr/prefix
 * |                 |              |
 * |                 |         xfrm_pol_inexact_node
 * |                 |              |
 * |                 |              + root: unused
 * |                 |              |
 * |                 |              + hhead: saddr:daddr policies
 * |                 |
 * |                 +- coarse policies and all any:daddr policies
 * |
 * +---- root_s: sorted by saddr:prefix
 * |                 |
 * |        xfrm_pol_inexact_node
 * |                 |
 * |                 + root: unused
 * |                 |
 * |                 + hhead: saddr:any policies
 * |
 * +---- coarse policies and all any:any policies
< ASCII >
 *
 * Lookups return four candidate lists:
 * 1. any:any list from top-level xfrm_pol_inexact_bin
 * 2. any:daddr list from daddr tree
 * 3. saddr:daddr list from 2nd level daddr tree
 * 4. saddr:any list from saddr tree
 *
 * This result set then needs to be searched for the policy with
 * the lowest priority.  If two results have same prio, youngest one wins.
 */
```
## Visual type:
- #tree


== ./linux/linux_1136.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/samples/bpf/cpustat_kern.c#L27-L47

```c
/*
 * my_map structure is used to record cstate and pstate index and
 * timestamp (Idx, Ts), when new event incoming we need to update
 * combination for new state index and timestamp (Idx`, Ts`).
 *
 * Based on (Idx, Ts) and (Idx`, Ts`) we can calculate the time
 * interval for the previous state: Duration(Idx) = Ts` - Ts.
 *
 * Every CPU has one below array for recording state index and
 * timestamp, and record for cstate and pstate saperately:
< ASCII >
 *
 * +--------------------------+
 * | cstate timestamp         |
 * +--------------------------+
 * | cstate index             |
 * +--------------------------+
 * | pstate timestamp         |
 * +--------------------------+
 * | pstate index             |
 * +--------------------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1137.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/scripts/kconfig/expr.c#L192-L220

```c
/*
 * Rewrites the expressions 'ep1' and 'ep2' to remove operands common to both.
< ASCII >
 * Example reductions:
 *
 *	ep1: A && B           ->  ep1: y
 *	ep2: A && B && C      ->  ep2: C
 *
 *	ep1: A || B           ->  ep1: n
 *	ep2: A || B || C      ->  ep2: C
 *
 *	ep1: A && (B && FOO)  ->  ep1: FOO
 *	ep2: (BAR && B) && A  ->  ep2: BAR
 *
 *	ep1: A && (B || C)    ->  ep1: y
 *	ep2: (C || B) && A    ->  ep2: y
< ASCII >
 *
 * Comparisons are done between all operands at the same "level" of && or ||.
 * For example, in the expression 'e1 && (e2 || e3) && (e4 || e5)', the
 * following operands will be compared:
< ASCII >
 *
 *	- 'e1', 'e2 || e3', and 'e4 || e5', against each other
 *	- e2 against e3
 *	- e4 against e5
< ASCII >
 *
 * Parentheses are irrelevant within a single level. 'e1 && (e2 && e3)' and
 * '(e1 && e2) && e3' are both a single level.
 *
 * See __expr_eliminate_eq() as well.
 */
```
## Visual type:



== ./linux/linux_1138.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/scripts/kconfig/expr.c#L305-L315

```c
/*
 * Recursively performs the following simplifications in-place (as well as the
 * corresponding simplifications with swapped operands):
< ASCII >
 *
 *	expr && n  ->  n
 *	expr && y  ->  expr
 *	expr || n  ->  expr
 *	expr || y  ->  y
< ASCII >
 *
 * Returns the optimized expression.
 */
```
## Visual type:



== ./linux/linux_1139.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/scripts/kconfig/expr.c#L653-L663

```c
/*
 * Rewrites 'e' in-place to remove ("join") duplicate and other redundant
 * operands.
 *
< ASCII >
 * Example simplifications:
 *
 *	A || B || A    ->  A || B
 *	A && B && A=y  ->  A=y && B
< ASCII >
 *
 * Returns the deduplicated expression.
 */
```
## Visual type:



== ./linux/linux_114.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/mips/net/bpf_jit_comp32.c#L1348-L1370

```c
/*
 * Stack frame layout for a JITed program (stack grows down).
 *
< ASCII >
 * Higher address  : Caller's stack frame       :
 *                 :----------------------------:
 *                 : 64-bit eBPF args r3-r5     :
 *                 :----------------------------:
 *                 : Reserved / tail call count :
 *                 +============================+  <--- MIPS sp before call
 *                 | Callee-saved registers,    |
 *                 | including RA and FP        |
 *                 +----------------------------+  <--- eBPF FP (MIPS zero,fp)
 *                 | Local eBPF variables       |
 *                 | allocated by program       |
 *                 +----------------------------+
 *                 | Reserved for caller-saved  |
 *                 | registers                  |
 *                 +----------------------------+
 *                 | Reserved for 64-bit eBPF   |
 *                 | args r3-r5 & args passed   |
 *                 | on stack in kernel calls   |
 * Lower address   +============================+  <--- MIPS sp
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1140.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/security/selinux/ss/services.c#L3289-L3310

```c
/**
 * security_net_peersid_resolve - Compare and resolve two network peer SIDs
 * @state: SELinux state
 * @nlbl_sid: NetLabel SID
 * @nlbl_type: NetLabel labeling protocol type
 * @xfrm_sid: XFRM SID
 * @peer_sid: network peer sid
 *
 * Description:
 * Compare the @nlbl_sid and @xfrm_sid values and if the two SIDs can be
 * resolved into a single SID it is returned via @peer_sid and the function
 * returns zero.  Otherwise @peer_sid is set to SECSID_NULL and the function
 * returns a negative value.  A table summarizing the behavior is below:
< ASCII >
 *
 *                                 | function return |      @sid
 *   ------------------------------+-----------------+-----------------
 *   no peer labels                |        0        |    SECSID_NULL
 *   single peer label             |        0        |    <peer_label>
 *   multiple, consistent labels   |        0        |    <peer_label>
 *   multiple, inconsistent labels |    -<errno>     |    SECSID_NULL
< ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_1141.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/core/seq/seq_prioq.c#L14-L37

```c
/* Implementation is a simple linked list for now...

   This priority queue orders the events on timestamp. For events with an
   equeal timestamp the queue behaves as a FIFO. 
< ASCII >

   *
   *           +-------+
   *  Head --> | first |
   *           +-------+
   *                 |next
   *           +-----v-+
   *           |       |
   *           +-------+
   *                 |
   *           +-----v-+
   *           |       |
   *           +-------+
   *                 |
   *           +-----v-+
   *  Tail --> | last  |
   *           +-------+
< ASCII >
   *

 */
```
## Visual type:
- #custom


== ./linux/linux_1142.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/drivers/mtpav.c#L142-L158

```c
/*
< ASCII >
 * possible hardware ports (selected by 0xf5 port message)
 *      0x00		all ports
 *      0x01 .. 0x08    this MTP's ports 1..8
 *      0x09 .. 0x10    networked MTP's ports (9..16)
 *      0x11            networked MTP's computer port
 *      0x63            to ADAT
 *
 * mappig:
 *  subdevice 0 - (X-1)    ports
 *            X - (2*X-1)  networked ports
 *            X            computer
 *            X+1          ADAT
 *            X+2          all ports
 *
 *  where X = chip->num_ports
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1143.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/drivers/mts64.c#L250-L260

```c
/*  map hardware port to substream number
 * 
 *  When reading a byte from the device, the device tells us
 *  on what port the byte is. This HW port has to be mapped to
 *  the midiport (substream number).
 *  substream 0-3 are Midiports 1-4
 *  substream 4 is SMPTE Timecode
< ASCII >
 *  The mapping is done by the table:
 *  HW | 0 | 1 | 2 | 3 | 4 
 *  SW | 0 | 1 | 4 | 2 | 3
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1144.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/drivers/portman2x4.c#L146-L153

```c
/* Parallel Port Status Register BUSY and SELECT lines are multiplexed
 * between several functions.  Depending on which 2x4 "register" is
 * currently selected (b1..b3), the BUSY and SELECT lines are
 * assigned as follows:
 *
< ASCII >
 *   SELECT LINE:                                                    A3 A2 A1
 *                                                                   --------
< ASCII >
 */
```
## Visual type:
- #annotation


== ./linux/linux_1145.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/drivers/portman2x4.c#L163-L165

```c
< ASCII >
/*   BUSY LINE:                                                      A3 A2 A1
 *                                                                   --------
< ASCII >
 */
```
## Visual type:
- #annotation


== ./linux/linux_1146.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/hda/hdac_stream.c#L17-L48

```c
/*
 * the hdac_stream library is intended to be used with the following
 * transitions. The states are not formally defined in the code but loosely
 * inspired by boolean variables. Note that the 'prepared' field is not used
 * in this library but by the callers during the hw_params/prepare transitions
< ASCII >
 *
 *			   |
 *	stream_init()	   |
 *			   v
 *			+--+-------+
 *			|  unused  |
 *			+--+----+--+
 *			   |    ^
 *	stream_assign()	   | 	|    stream_release()
 *			   v	|
 *			+--+----+--+
 *			|  opened  |
 *			+--+----+--+
 *			   |    ^
 *	stream_reset()	   |    |
 *	stream_setup()	   |	|    stream_cleanup()
 *			   v	|
 *			+--+----+--+
 *			| prepared |
 *			+--+----+--+
 *			   |    ^
 *	stream_start()	   | 	|    stream_stop()
 *			   v	|
 *			+--+----+--+
 *			|  running |
 *			+----------+
< ASCII >
 */
```
## Visual type:
- #state-machine


== ./linux/linux_1147.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/hda/hdmi_chmap.c#L11-L24

```c
/*
< ASCII >
 * CEA speaker placement:
 *
 *        FLH       FCH        FRH
 *  FLW    FL  FLC   FC   FRC   FR   FRW
 *
 *                                  LFE
 *                     TC
 *
 *          RL  RLC   RC   RRC   RR
< ASCII >
 *
 * The Left/Right Surround channel _notions_ LS/RS in SMPTE 320M corresponds to
 * CEA RL/RR; The SMPTE channel _assignment_ C/LFE is swapped to CEA LFE/FC.
 */
```
## Visual type:
- #custom


== ./linux/linux_1148.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/hda/hdmi_chmap.c#L77-L91

```c
/*
< ASCII >
 * ALSA sequence is:
 *
 *       surround40   surround41   surround50   surround51   surround71
 * ch0   front left   =            =            =            =
 * ch1   front right  =            =            =            =
 * ch2   rear left    =            =            =            =
 * ch3   rear right   =            =            =            =
 * ch4                LFE          center       center       center
 * ch5                                          LFE          LFE
 * ch6                                                       side left
 * ch7                                                       side right
 *
 * surround71 = {FL, FR, RLC, RRC, FC, LFE, RL, RR}
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1149.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/pci/cs46xx/cs46xx_dsp_task_types.h#L17-L37

```c
/*********************************************************************************************
Example hierarchy of stream control blocks in the SP

< ASCII >
hfgTree
Ptr____Call (c)
       \
 -------+------         -------------      -------------      -------------      -----
| SBlaster IF  |______\| Foreground  |___\| Middlegr'nd |___\| Background  |___\| Nul |
|              |Goto  /| tree header |g  /| tree header |g  /| tree header |g  /| SCB |r
 -------------- (g)     -------------      -------------      -------------      -----
       |c                     |c                 |c                 |c
       |                      |                  |                  |
      \/                  -------------      -------------      -------------   
                       | Foreground  |_\  | Middlegr'nd |_\  | Background  |_\
                       |     tree    |g/  |    tree     |g/  |     tree    |g/
                        -------------      -------------      -------------   
                              |c                 |c                 |c
                              |                  |                  | 
                             \/                 \/                 \/ 
< ASCII >

*********************************************************************************************/
```
## Visual type:
- #custom


== ./linux/linux_115.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/mips/sgi-ip22/ip22-int.c#L170-L196

```c
/*
 * IRQs on the INDY look basically (barring software IRQs which we don't use
 * at all) like:
 *
< ASCII >
 *	MIPS IRQ	Source
 *	--------	------
 *	       0	Software (ignored)
 *	       1	Software (ignored)
 *	       2	Local IRQ level zero
 *	       3	Local IRQ level one
 *	       4	8254 Timer zero
 *	       5	8254 Timer one
 *	       6	Bus Error
 *	       7	R4k timer (what we use)
< ASCII >
 *
 * We handle the IRQ according to _our_ priority which is:
 *
< ASCII >
 * Highest ----	    R4k Timer
 *		    Local IRQ zero
 *		    Local IRQ one
 *		    Bus Error
 *		    8254 Timer zero
 * Lowest  ----	    8254 Timer one
< ASCII >
 *
 * then we just return, if multiple IRQs are pending then we will just take
 * another exception, big deal.
 */
```
## Visual type:
- #table


== ./linux/linux_1150.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/pci/hda/patch_hdmi.c#L3839-L3855

```c
/*
 * The SCRATCH0 register is used to notify the HDMI codec of changes in audio
 * format. On Tegra, bit 31 is used as a trigger that causes an interrupt to
 * be raised in the HDMI codec. The remainder of the bits is arbitrary. This
 * implementation stores the HDA format (see AC_FMT_*) in bits [15:0] and an
 * additional bit (at position 30) to signal the validity of the format.
 *
< ASCII >
 * | 31      | 30    | 29  16 | 15   0 |
 * +---------+-------+--------+--------+
 * | TRIGGER | VALID | UNUSED | FORMAT |
 * +-----------------------------------|
< ASCII >
 *
 * Note that for the trigger bit to take effect it needs to change value
 * (i.e. it needs to be toggled). The trigger bit is not applicable from
 * TEGRA234 chip onwards, as new verb id 0xf80 will be used for interrupt
 * trigger to hdmi.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1151.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/pci/ice1712/se.c#L31-L95

```c
/*
 *  system configuration ICE_EEP2_SYSCONF=0x4b
 *    XIN1 49.152MHz
 *    not have UART
 *    one stereo ADC and a S/PDIF receiver connected
 *    four stereo DACs connected
 *
 *  AC-Link configuration ICE_EEP2_ACLINK=0x80
 *    use I2C, not use AC97
 *
 *  I2S converters feature ICE_EEP2_I2S=0x78
 *    I2S codec has no volume/mute control feature
 *    I2S codec supports 96KHz and 192KHz
 *    I2S codec 24bits
 *
 *  S/PDIF configuration ICE_EEP2_SPDIF=0xc3
 *    Enable integrated S/PDIF transmitter
 *    internal S/PDIF out implemented
 *    S/PDIF is stereo
 *    External S/PDIF out implemented
 *
 *
 * ** connected chips **
 *
 *  WM8740
 *      A 2ch-DAC of main outputs.
 *      It setuped as I2S mode by wire, so no way to setup from software.
 *      The sample-rate are automatically changed.
< ASCII > 
 *          ML/I2S (28pin) --------+
 *          MC/DM1 (27pin) -- 5V   |
 *          MD/DM0 (26pin) -- GND  |
 *          MUTEB  (25pin) -- NC   |
 *          MODE   (24pin) -- GND  |
 *          CSBIW  (23pin) --------+
 *                                 |
 *          RSTB   (22pin) --R(1K)-+
< ASCII >
 *      Probably it reduce the noise from the control line.
 *
 *  WM8766
 *      A 6ch-DAC for surrounds.
 *      It's control wire was connected to GPIOxx (3-wire serial interface)
< ASCII >
 *          ML/I2S (11pin) -- GPIO18
 *          MC/IWL (12pin) -- GPIO17
 *          MD/DM  (13pin) -- GPIO16
 *          MUTE   (14pin) -- GPIO01
< ASCII >
 *
 *  WM8776
 *     A 2ch-ADC(with 10ch-selector) plus 2ch-DAC.
 *     It's control wire was connected to SDA/SCLK (2-wire serial interface)
< ASCII >
 *          MODE (16pin) -- R(1K) -- GND
 *          CE   (17pin) -- R(1K) -- GND  2-wire mode (address=0x34)
 *          DI   (18pin) -- SDA
 *          CL   (19pin) -- SCLK
< ASCII >
 *
 *
 * ** output pins and device names **
 *
 *   7.1ch name -- output connector color -- device (-D option)
< ASCII >
 *
 *      FRONT 2ch                  -- green  -- plughw:0,0
 *      CENTER(Lch) SUBWOOFER(Rch) -- black  -- plughw:0,2,0
 *      SURROUND 2ch               -- orange -- plughw:0,2,1
 *      SURROUND BACK 2ch          -- white  -- plughw:0,2,2
< ASCII >
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_1152.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/pci/rme9652/hdspm.c#L31-L120

```c
/* *************    Register Documentation   *******************************************************
 *
 * Work in progress! Documentation is based on the code in this file.
< ASCII >
 *
 * --------- HDSPM_controlRegister ---------
 * :7654.3210:7654.3210:7654.3210:7654.3210: bit number per byte
 * :||||.||||:||||.||||:||||.||||:||||.||||:
 * :3322.2222:2222.1111:1111.1100:0000.0000: bit number
 * :1098.7654:3210.9876:5432.1098:7654.3210: 0..31
 * :||||.||||:||||.||||:||||.||||:||||.||||:
 * :8421.8421:8421.8421:8421.8421:8421.8421: hex digit
 * :    .    :    .    :    .    :  x .    :  HDSPM_AudioInterruptEnable \_ setting both bits
 * :    .    :    .    :    .    :    .   x:  HDSPM_Start                /  enables audio IO
 * :    .    :    .    :    .    :   x.    :  HDSPM_ClockModeMaster - 1: Master, 0: Slave
 * :    .    :    .    :    .    :    .210 :  HDSPM_LatencyMask - 3 Bit value for latency
 * :    .    :    .    :    .    :    .    :      0:64, 1:128, 2:256, 3:512,
 * :    .    :    .    :    .    :    .    :      4:1024, 5:2048, 6:4096, 7:8192
 * :x   .    :    .    :    .   x:xx  .    :  HDSPM_FrequencyMask
 * :    .    :    .    :    .    :10  .    :  HDSPM_Frequency1|HDSPM_Frequency0: 1=32K,2=44.1K,3=48K,0=??
 * :    .    :    .    :    .   x:    .    :  <MADI> HDSPM_DoubleSpeed
 * :x   .    :    .    :    .    :    .    :  <MADI> HDSPM_QuadSpeed
 * :    .  3 :    .  10:  2 .    :    .    :  HDSPM_SyncRefMask :
 * :    .    :    .   x:    .    :    .    :  HDSPM_SyncRef0
 * :    .    :    .  x :    .    :    .    :  HDSPM_SyncRef1
 * :    .    :    .    :  x .    :    .    :  <AES32> HDSPM_SyncRef2
 * :    .  x :    .    :    .    :    .    :  <AES32> HDSPM_SyncRef3
 * :    .    :    .  10:    .    :    .    :  <MADI> sync ref: 0:WC, 1:Madi, 2:TCO, 3:SyncIn
 * :    .  3 :    .  10:  2 .    :    .    :  <AES32>  0:WC, 1:AES1 ... 8:AES8, 9: TCO, 10:SyncIn?
 * :    .  x :    .    :    .    :    .    :  <MADIe> HDSPe_FLOAT_FORMAT
 * :    .    :    .    : x  .    :    .    :  <MADI> HDSPM_InputSelect0 : 0=optical,1=coax
 * :    .    :    .    :x   .    :    .    :  <MADI> HDSPM_InputSelect1
 * :    .    :    .x   :    .    :    .    :  <MADI> HDSPM_clr_tms
 * :    .    :    .    :    . x  :    .    :  <MADI> HDSPM_TX_64ch
 * :    .    :    .    :    . x  :    .    :  <AES32> HDSPM_Emphasis
 * :    .    :    .    :    .x   :    .    :  <MADI> HDSPM_AutoInp
 * :    .    :    . x  :    .    :    .    :  <MADI> HDSPM_SMUX
 * :    .    :    .x   :    .    :    .    :  <MADI> HDSPM_clr_tms
 * :    .    :   x.    :    .    :    .    :  <MADI> HDSPM_taxi_reset
 * :    .   x:    .    :    .    :    .    :  <MADI> HDSPM_LineOut
 * :    .   x:    .    :    .    :    .    :  <AES32> ??????????????????
 * :    .    :   x.    :    .    :    .    :  <AES32> HDSPM_WCK48
 * :    .    :    .    :    .x   :    .    :  <AES32> HDSPM_Dolby
 * :    .    : x  .    :    .    :    .    :  HDSPM_Midi0InterruptEnable
 * :    .    :x   .    :    .    :    .    :  HDSPM_Midi1InterruptEnable
 * :    .    :  x .    :    .    :    .    :  HDSPM_Midi2InterruptEnable
 * :    . x  :    .    :    .    :    .    :  <MADI> HDSPM_Midi3InterruptEnable
 * :    . x  :    .    :    .    :    .    :  <AES32> HDSPM_DS_DoubleWire
 * :    .x   :    .    :    .    :    .    :  <AES32> HDSPM_QS_DoubleWire
 * :   x.    :    .    :    .    :    .    :  <AES32> HDSPM_QS_QuadWire
 * :    .    :    .    :    .  x :    .    :  <AES32> HDSPM_Professional
 * : x  .    :    .    :    .    :    .    :  HDSPM_wclk_sel
 * :    .    :    .    :    .    :    .    :
 * :7654.3210:7654.3210:7654.3210:7654.3210: bit number per byte
 * :||||.||||:||||.||||:||||.||||:||||.||||:
 * :3322.2222:2222.1111:1111.1100:0000.0000: bit number
 * :1098.7654:3210.9876:5432.1098:7654.3210: 0..31
 * :||||.||||:||||.||||:||||.||||:||||.||||:
 * :8421.8421:8421.8421:8421.8421:8421.8421:hex digit
< ASCII >
 *
 *
 *
 * AIO / RayDAT only
 *
< ASCII >
 * ------------ HDSPM_WR_SETTINGS ----------
 * :3322.2222:2222.1111:1111.1100:0000.0000: bit number per byte
 * :1098.7654:3210.9876:5432.1098:7654.3210:
 * :||||.||||:||||.||||:||||.||||:||||.||||: bit number
 * :7654.3210:7654.3210:7654.3210:7654.3210: 0..31
 * :||||.||||:||||.||||:||||.||||:||||.||||:
 * :8421.8421:8421.8421:8421.8421:8421.8421: hex digit
 * :    .    :    .    :    .    :    .   x: HDSPM_c0Master 1: Master, 0: Slave
 * :    .    :    .    :    .    :    .  x : HDSPM_c0_SyncRef0
 * :    .    :    .    :    .    :    . x  : HDSPM_c0_SyncRef1
 * :    .    :    .    :    .    :    .x   : HDSPM_c0_SyncRef2
 * :    .    :    .    :    .    :   x.    : HDSPM_c0_SyncRef3
 * :    .    :    .    :    .    :   3.210 : HDSPM_c0_SyncRefMask:
 * :    .    :    .    :    .    :    .    :  RayDat: 0:WC, 1:AES, 2:SPDIF, 3..6: ADAT1..4,
 * :    .    :    .    :    .    :    .    :          9:TCO, 10:SyncIn
 * :    .    :    .    :    .    :    .    :  AIO: 0:WC, 1:AES, 2: SPDIF, 3: ATAT,
 * :    .    :    .    :    .    :    .    :          9:TCO, 10:SyncIn
 * :    .    :    .    :    .    :    .    :
 * :    .    :    .    :    .    :    .    :
 * :3322.2222:2222.1111:1111.1100:0000.0000: bit number per byte
 * :1098.7654:3210.9876:5432.1098:7654.3210:
 * :||||.||||:||||.||||:||||.||||:||||.||||: bit number
 * :7654.3210:7654.3210:7654.3210:7654.3210: 0..31
 * :||||.||||:||||.||||:||||.||||:||||.||||:
 * :8421.8421:8421.8421:8421.8421:8421.8421: hex digit
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1153.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/codecs/cs42xx8.c#L185-L193

```c
/*
< ASCII >
 * According to reference mannual, define the cs42xx8_ratio struct
 * MFreq2 | MFreq1 | MFreq0 |     Description     | SSM | DSM | QSM |
 * 0      | 0      | 0      |1.029MHz to 12.8MHz  | 256 | 128 |  64 |
 * 0      | 0      | 1      |1.536MHz to 19.2MHz  | 384 | 192 |  96 |
 * 0      | 1      | 0      |2.048MHz to 25.6MHz  | 512 | 256 | 128 |
 * 0      | 1      | 1      |3.072MHz to 38.4MHz  | 768 | 384 | 192 |
 * 1      | x      | x      |4.096MHz to 51.2MHz  |1024 | 512 | 256 |
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1154.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/codecs/hdmi-codec.c#L23-L33

```c
/*
< ASCII >
 * CEA speaker placement for HDMI 1.4:
 *
 *  FL  FLC   FC   FRC   FR   FRW
 *
 *                                  LFE
 *
 *  RL  RLC   RC   RRC   RR
 *
 *  Speaker placement has to be extended to support HDMI 2.0
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1155.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/codecs/sgtl5000.c#L517-L539

```c
/*
 * custom function to get of PCM playback volume
 *
< ASCII >
 * dac volume register
 * 15-------------8-7--------------0
 * | R channel vol | L channel vol |
 *  -------------------------------
< ASCII >
 *
 * PCM volume with 0.5017 dB steps from 0 to -90 dB
 *
 * register values map to dB
 * 0x3B and less = Reserved
 * 0x3C = 0 dB
 * 0x3D = -0.5 dB
 * 0xF0 = -90 dB
 * 0xFC and greater = Muted
 *
< ASCII >
 * register value map to userspace value
 *
 * register value	0x3c(0dB)	  0xf0(-90dB)0xfc
 *			------------------------------
 * userspace value	0xc0			     0
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1156.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/codecs/sgtl5000.c#L570-L592

```c
/*
 * custom function to put of PCM playback volume
 *
< ASCII >
 * dac volume register
 * 15-------------8-7--------------0
 * | R channel vol | L channel vol |
 *  -------------------------------
< ASCII >
 *
 * PCM volume with 0.5017 dB steps from 0 to -90 dB
 *
 * register values map to dB
 * 0x3B and less = Reserved
 * 0x3C = 0 dB
 * 0x3D = -0.5 dB
 * 0xF0 = -90 dB
 * 0xFC and greater = Muted
 *
< ASCII >
 * userspace value map to register value
 *
 * userspace value	0xc0			     0
 *			------------------------------
 * register value	0x3c(0dB)	0xf0(-90dB)0xfc
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1157.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/fsl/fsl_dma.c#L298-L359

```c
/**
 * fsl_dma_open: open a new substream.
 *
 * Each substream has its own DMA buffer.
 *
 * ALSA divides the DMA buffer into N periods.  We create NUM_DMA_LINKS link
 * descriptors that ping-pong from one period to the next.  For example, if
 * there are six periods and two link descriptors, this is how they look
 * before playback starts:
 *
< ASCII >
 *      	   The last link descriptor
 *   ____________  points back to the first
 *  |   	 |
 *  V   	 |
 *  ___    ___   |
 * |   |->|   |->|
 * |___|  |___|
 *   |      |
 *   |      |
 *   V      V
 *  _________________________________________
 * |      |      |      |      |      |      |  The DMA buffer is
 * |      |      |      |      |      |      |    divided into 6 parts
 * |______|______|______|______|______|______|
 *
 * and here's how they look after the first period is finished playing:
 *
 *   ____________
 *  |   	 |
 *  V   	 |
 *  ___    ___   |
 * |   |->|   |->|
 * |___|  |___|
 *   |      |
 *   |______________
 *          |       |
 *          V       V
 *  _________________________________________
 * |      |      |      |      |      |      |
 * |      |      |      |      |      |      |
 * |______|______|______|______|______|______|
< ASCII >
 *
 * The first link descriptor now points to the third period.  The DMA
 * controller is currently playing the second period.  When it finishes, it
 * will jump back to the first descriptor and play the third period.
 *
 * There are four reasons we do this:
 *
 * 1. The only way to get the DMA controller to automatically restart the
 *    transfer when it gets to the end of the buffer is to use chaining
 *    mode.  Basic direct mode doesn't offer that feature.
 * 2. We need to receive an interrupt at the end of every period.  The DMA
 *    controller can generate an interrupt at the end of every link transfer
 *    (aka segment).  Making each period into a DMA segment will give us the
 *    interrupts we need.
 * 3. By creating only two link descriptors, regardless of the number of
 *    periods, we do not need to reallocate the link descriptors if the
 *    number of periods changes.
 * 4. All of the audio data is still stored in a single, contiguous DMA
 *    buffer, which is what ALSA expects.  We're just dividing it into
 *    contiguous parts, and creating a link descriptor for each one.
 */
```
## Visual type:
- #custom


== ./linux/linux_1158.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/fsl/imx-pcm-rpmsg.h#L2-L271

```c
/*
 * Copyright 2017-2021  NXP
 *
 ******************************************************************************
 * Communication stack of audio with rpmsg
 ******************************************************************************
 * Packet structure:
 *   A SRTM message consists of a 10 bytes header followed by 0~N bytes of data
< ASCII >
 *
 *   +---------------+-------------------------------+
 *   |               |            Content            |
 *   +---------------+-------------------------------+
 *   |  Byte Offset  | 7   6   5   4   3   2   1   0 |
 *   +---------------+---+---+---+---+---+---+---+---+
 *   |       0       |           Category            |
 *   +---------------+---+---+---+---+---+---+---+---+
 *   |     1 ~ 2     |           Version             |
 *   +---------------+---+---+---+---+---+---+---+---+
 *   |       3       |             Type              |
 *   +---------------+---+---+---+---+---+---+---+---+
 *   |       4       |           Command             |
 *   +---------------+---+---+---+---+---+---+---+---+
 *   |       5       |           Reserved0           |
 *   +---------------+---+---+---+---+---+---+---+---+
 *   |       6       |           Reserved1           |
 *   +---------------+---+---+---+---+---+---+---+---+
 *   |       7       |           Reserved2           |
 *   +---------------+---+---+---+---+---+---+---+---+
 *   |       8       |           Reserved3           |
 *   +---------------+---+---+---+---+---+---+---+---+
 *   |       9       |           Reserved4           |
 *   +---------------+---+---+---+---+---+---+---+---+
 *   |       10      |            DATA 0             |
 *   +---------------+---+---+---+---+---+---+---+---+
 *   :   :   :   :   :   :   :   :   :   :   :   :   :
 *   +---------------+---+---+---+---+---+---+---+---+
 *   |   N + 10 - 1  |            DATA N-1           |
 *   +---------------+---+---+---+---+---+---+---+---+
 *
 *   +----------+------------+------------------------------------------------+
 *   |  Field   |    Byte    |                                                |
 *   +----------+------------+------------------------------------------------+
 *   | Category |     0      | The destination category.                      |
 *   +----------+------------+------------------------------------------------+
 *   | Version  |   1 ~ 2    | The category version of the sender of the      |
 *   |          |            | packet.                                        |
 *   |          |            | The first byte represent the major version of  |
 *   |          |            | the packet.The second byte represent the minor |
 *   |          |            | version of the packet.                         |
 *   +----------+------------+------------------------------------------------+
 *   |  Type    |     3      | The message type of current message packet.    |
 *   +----------+------------+------------------------------------------------+
 *   | Command  |     4      | The command byte sent to remote processor/SoC. |
 *   +----------+------------+------------------------------------------------+
 *   | Reserved |   5 ~ 9    | Reserved field for future extension.           |
 *   +----------+------------+------------------------------------------------+
 *   | Data     |     N      | The data payload of the message packet.        |
 *   +----------+------------+------------------------------------------------+
< ASCII >
 *
 * Audio control:
< ASCII >
 *   SRTM Audio Control Category Request Command Table:
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   | Category | Version | Type | Command | Data                          | Function              |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x00   | Data[0]: Audio Device Index   | Open a TX Instance.   |
 *   |          |         |      |         | Data[1]:     format           |                       |
 *   |          |         |      |         | Data[2]:     channels         |                       |
 *   |          |         |      |         | Data[3-6]:   samplerate       |                       |
 *   |          |         |      |         | Data[7-10]:  buffer_addr      |                       |
 *   |          |         |      |         | Data[11-14]: buffer_size      |                       |
 *   |          |         |      |         | Data[15-18]: period_size      |                       |
 *   |          |         |      |         | Data[19-22]: buffer_tail      |                       |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x01   | Data[0]: Audio Device Index   | Start a TX Instance.  |
 *   |          |         |      |         | Same as above command         |                       |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x02   | Data[0]: Audio Device Index   | Pause a TX Instance.  |
 *   |          |         |      |         | Same as above command         |                       |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x03   | Data[0]: Audio Device Index   | Resume a TX Instance. |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x04   | Data[0]: Audio Device Index   | Stop a TX Instance.   |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x05   | Data[0]: Audio Device Index   | Close a TX Instance.  |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x06   | Data[0]: Audio Device Index   | Set Parameters for    |
 *   |          |         |      |         | Data[1]:     format           | a TX Instance.        |
 *   |          |         |      |         | Data[2]:     channels         |                       |
 *   |          |         |      |         | Data[3-6]:   samplerate       |                       |
 *   |          |         |      |         | Data[7-22]:  reserved         |                       |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x07   | Data[0]: Audio Device Index   | Set TX Buffer.        |
 *   |          |         |      |         | Data[1-6]:   reserved         |                       |
 *   |          |         |      |         | Data[7-10]:  buffer_addr      |                       |
 *   |          |         |      |         | Data[11-14]: buffer_size      |                       |
 *   |          |         |      |         | Data[15-18]: period_size      |                       |
 *   |          |         |      |         | Data[19-22]: buffer_tail      |                       |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x08   | Data[0]: Audio Device Index   | Suspend a TX Instance |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x09   | Data[0]: Audio Device Index   | Resume a TX Instance. |
 *   |          |         |      |         | Data[1]:     format           |                       |
 *   |          |         |      |         | Data[2]:     channels         |                       |
 *   |          |         |      |         | Data[3-6]:   samplerate       |                       |
 *   |          |         |      |         | Data[7-10]:  buffer_addr      |                       |
 *   |          |         |      |         | Data[11-14]: buffer_size      |                       |
 *   |          |         |      |         | Data[15-18]: period_size      |                       |
 *   |          |         |      |         | Data[19-22]: buffer_tail      |                       |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x0A   | Data[0]: Audio Device Index   | Open a RX Instance.   |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x0B   | Data[0]: Audio Device Index   | Start a RX Instance.  |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x0C   | Data[0]: Audio Device Index   | Pause a RX Instance.  |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x0D   | Data[0]: Audio Device Index   | Resume a RX Instance. |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x0E   | Data[0]: Audio Device Index   | Stop a RX Instance.   |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x0F   | Data[0]: Audio Device Index   | Close a RX Instance.  |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x10   | Data[0]: Audio Device Index   | Set Parameters for    |
 *   |          |         |      |         | Data[1]:     format           | a RX Instance.        |
 *   |          |         |      |         | Data[2]:     channels         |                       |
 *   |          |         |      |         | Data[3-6]:   samplerate       |                       |
 *   |          |         |      |         | Data[7-22]:  reserved         |                       |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x11   | Data[0]: Audio Device Index   | Set RX Buffer.        |
 *   |          |         |      |         | Data[1-6]:   reserved         |                       |
 *   |          |         |      |         | Data[7-10]:  buffer_addr      |                       |
 *   |          |         |      |         | Data[11-14]: buffer_size      |                       |
 *   |          |         |      |         | Data[15-18]: period_size      |                       |
 *   |          |         |      |         | Data[19-22]: buffer_tail      |                       |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x12   | Data[0]: Audio Device Index   | Suspend a RX Instance.|
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x13   | Data[0]: Audio Device Index   | Resume a RX Instance. |
 *   |          |         |      |         | Data[1]:     format           |                       |
 *   |          |         |      |         | Data[2]:     channels         |                       |
 *   |          |         |      |         | Data[3-6]:   samplerate       |                       |
 *   |          |         |      |         | Data[7-10]:  buffer_addr      |                       |
 *   |          |         |      |         | Data[11-14]: buffer_size      |                       |
 *   |          |         |      |         | Data[15-18]: period_size      |                       |
 *   |          |         |      |         | Data[19-22]: buffer_tail      |                       |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x14   | Data[0]: Audio Device Index   | Set register value    |
 *   |          |         |      |         | Data[1-6]:   reserved         | to codec              |
 *   |          |         |      |         | Data[7-10]:  register         |                       |
 *   |          |         |      |         | Data[11-14]: value            |                       |
 *   |          |         |      |         | Data[15-22]: reserved         |                       |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x00 |  0x15   | Data[0]: Audio Device Index   | Get register value    |
 *   |          |         |      |         | Data[1-6]:   reserved         | from codec            |
 *   |          |         |      |         | Data[7-10]:  register         |                       |
 *   |          |         |      |         | Data[11-22]: reserved         |                       |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
< ASCII >
 *   Note 1: See <List of Sample Format> for available value of
 *           Sample Format;
 *   Note 2: See <List of Audio Channels> for available value of Channels;
 *   Note 3: Sample Rate of Set Parameters for an Audio TX Instance
 *           Command and Set Parameters for an Audio RX Instance Command is
 *           in little-endian format.
 *
< ASCII >
 *   SRTM Audio Control Category Response Command Table:
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   | Category | Version | Type | Command | Data                          | Function              |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x00   | Data[0]: Audio Device Index   | Reply for Open        |
 *   |          |         |      |         | Data[1]: Return code          | a TX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x01   | Data[0]: Audio Device Index   | Reply for Start       |
 *   |          |         |      |         | Data[1]: Return code          | a TX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x02   | Data[0]: Audio Device Index   | Reply for Pause       |
 *   |          |         |      |         | Data[1]: Return code          | a TX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x03   | Data[0]: Audio Device Index   | Reply for Resume      |
 *   |          |         |      |         | Data[1]: Return code          | a TX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x04   | Data[0]: Audio Device Index   | Reply for Stop        |
 *   |          |         |      |         | Data[1]: Return code          | a TX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x05   | Data[0]: Audio Device Index   | Reply for Close       |
 *   |          |         |      |         | Data[1]: Return code          | a TX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x06   | Data[0]: Audio Device Index   | Reply for Set Param   |
 *   |          |         |      |         | Data[1]: Return code          | for a TX Instance.    |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x07   | Data[0]: Audio Device Index   | Reply for Set         |
 *   |          |         |      |         | Data[1]: Return code          | TX Buffer             |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x08   | Data[0]: Audio Device Index   | Reply for Suspend     |
 *   |          |         |      |         | Data[1]: Return code          | a TX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x09   | Data[0]: Audio Device Index   | Reply for Resume      |
 *   |          |         |      |         | Data[1]: Return code          | a TX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x0A   | Data[0]: Audio Device Index   | Reply for Open        |
 *   |          |         |      |         | Data[1]: Return code          | a TX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x0B   | Data[0]: Audio Device Index   | Reply for Start       |
 *   |          |         |      |         | Data[1]: Return code          | a TX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x0C   | Data[0]: Audio Device Index   | Reply for Pause       |
 *   |          |         |      |         | Data[1]: Return code          | a TX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x0D   | Data[0]: Audio Device Index   | Reply for Resume      |
 *   |          |         |      |         | Data[1]: Return code          | a RX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x0E   | Data[0]: Audio Device Index   | Reply for Stop        |
 *   |          |         |      |         | Data[1]: Return code          | a RX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x0F   | Data[0]: Audio Device Index   | Reply for Close       |
 *   |          |         |      |         | Data[1]: Return code          | a RX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x10   | Data[0]: Audio Device Index   | Reply for Set Param   |
 *   |          |         |      |         | Data[1]: Return code          | for a RX Instance.    |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x11   | Data[0]: Audio Device Index   | Reply for Set         |
 *   |          |         |      |         | Data[1]: Return code          | RX Buffer             |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x12   | Data[0]: Audio Device Index   | Reply for Suspend     |
 *   |          |         |      |         | Data[1]: Return code          | a RX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x13   | Data[0]: Audio Device Index   | Reply for Resume      |
 *   |          |         |      |         | Data[1]: Return code          | a RX Instance         |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x14   | Data[0]: Audio Device Index   | Reply for Set codec   |
 *   |          |         |      |         | Data[1]: Return code          | register value        |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x01 |  0x15   | Data[0]: Audio Device Index   | Reply for Get codec   |
 *   |          |         |      |         | Data[1]: Return code          | register value        |
 *   |          |         |      |         | Data[2-6]:   reserved         |                       |
 *   |          |         |      |         | Data[7-10]:  register         |                       |
 *   |          |         |      |         | Data[11-14]: value            |                       |
 *   |          |         |      |         | Data[15-22]: reserved         |                       |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
< ASCII >
 *
< ASCII >
 *   SRTM Audio Control Category Notification Command Table:
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   | Category | Version | Type | Command | Data                          | Function              |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x02 |  0x00   | Data[0]: Audio Device Index   | Notify one TX period  |
 *   |          |         |      |         |                               | is finished           |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
 *   |  0x03    | 0x0100  | 0x02 |  0x01   | Data[0]: Audio Device Index   | Notify one RX period  |
 *   |          |         |      |         |                               | is finished           |
 *   +----------+---------+------+---------+-------------------------------+-----------------------+
< ASCII >
< ASCII >
 *
 *   List of Sample Format:
 *   +------------------+-----------------------+
 *   | Sample Format    |   Description         |
 *   +------------------+-----------------------+
 *   |       0x0        | S16_LE                |
 *   +------------------+-----------------------+
 *   |       0x1        | S24_LE                |
 *   +------------------+-----------------------+
 *
< ASCII >
< ASCII >
 *   List of Audio Channels
 *   +------------------+-----------------------+
 *   |  Audio Channel   |   Description         |
 *   +------------------+-----------------------+
 *   |       0x0        | Left Channel          |
 *   +------------------+-----------------------+
 *   |       0x1        | Right Channel         |
 *   +------------------+---------------- ------+
 *   |       0x2        | Left & Right Channel  |
 *   +------------------+-----------------------+
 *
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1159.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/sh/fsi.c#L159-L174

```c
/*
 *	period/frame/sample image
 *
< ASCII >
 * ex) PCM (2ch)
 *
 * period pos					   period pos
 *   [n]					     [n + 1]
 *   |<-------------------- period--------------------->|
 * ==|============================================ ... =|==
 *   |							|
 *   ||<-----  frame ----->|<------ frame ----->|  ...	|
 *   |+--------------------+--------------------+- ...	|
 *   ||[ sample ][ sample ]|[ sample ][ sample ]|  ...	|
 *   |+--------------------+--------------------+- ...	|
 * ==|============================================ ... =|==
< ASCII >
 */
```
## Visual type:
- #interval


== ./linux/linux_116.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/nios2/include/asm/pgtable-bits.h#L13-L19

```c
/*
 * These are actual hardware defined protection bits in the tlbacc register
 * which looks like this:
 *
< ASCII >
 * 31 30 ... 26 25 24 23 22 21 20 19 18 ...  1  0
 * ignored........  C  R  W  X  G PFN............
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1160.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/sh/fsi.c#L176-L186

```c
/*
< ASCII >
 *	FSI FIFO image
 *
 *	|	     |
 *	|	     |
 *	| [ sample ] |
 *	| [ sample ] |
 *	| [ sample ] |
 *	| [ sample ] |
 *		--> go to codecs
< ASCII >
 */
```
## Visual type:
- #sequence


== ./linux/linux_1161.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/sh/fsi.c#L188-L194

```c
/*
< ASCII >
 *	FSI clock
 *
 * FSIxCLK [CPG] (ick) ------->	|
 *				|-> FSI_DIV (div)-> FSI2
 * FSIxCK [external] (xck) --->	|
< ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_1162.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/sh/rcar/core.c#L36-L91

```c
/*
 *	driver data Image
 *
< ASCII >
 * rsnd_priv
 *   |
 *   | ** this depends on Gen1/Gen2
 *   |
 *   +- gen
 *   |
 *   | ** these depend on data path
 *   | ** gen and platform data control it
 *   |
 *   +- rdai[0]
 *   |   |		 sru     ssiu      ssi
 *   |   +- playback -> [mod] -> [mod] -> [mod] -> ...
 *   |   |
 *   |   |		 sru     ssiu      ssi
 *   |   +- capture  -> [mod] -> [mod] -> [mod] -> ...
 *   |
 *   +- rdai[1]
 *   |   |		 sru     ssiu      ssi
 *   |   +- playback -> [mod] -> [mod] -> [mod] -> ...
 *   |   |
 *   |   |		 sru     ssiu      ssi
 *   |   +- capture  -> [mod] -> [mod] -> [mod] -> ...
 *   ...
 *   |
 *   | ** these control ssi
 *   |
 *   +- ssi
 *   |  |
 *   |  +- ssi[0]
 *   |  +- ssi[1]
 *   |  +- ssi[2]
 *   |  ...
 *   |
 *   | ** these control src
 *   |
 *   +- src
 *      |
 *      +- src[0]
 *      +- src[1]
 *      +- src[2]
 *      ...
< ASCII >
 *
 *
 * for_each_rsnd_dai(xx, priv, xx)
 *  rdai[0] => rdai[1] => rdai[2] => ...
 *
 * for_each_rsnd_mod(xx, rdai, xx)
 *  [mod] => [mod] => [mod] => ...
 *
 * rsnd_dai_call(xxx, fn )
 *  [mod]->fn() -> [mod]->fn() -> [mod]->fn()...
 *
 */
```
## Visual type:
- #tree


== ./linux/linux_1163.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/sh/rcar/ctu.c#L12-L70

```c
/*
 * User needs to setup CTU by amixer, and its settings are
 * based on below registers
< ASCII >
 *
 * CTUn_CPMDR : amixser set "CTU Pass"
 * CTUn_SV0xR : amixser set "CTU SV0"
 * CTUn_SV1xR : amixser set "CTU SV1"
 * CTUn_SV2xR : amixser set "CTU SV2"
 * CTUn_SV3xR : amixser set "CTU SV3"
 *
 * [CTU Pass]
 * 0000: default
 * 0001: Connect input data of channel 0
 * 0010: Connect input data of channel 1
 * 0011: Connect input data of channel 2
 * 0100: Connect input data of channel 3
 * 0101: Connect input data of channel 4
 * 0110: Connect input data of channel 5
 * 0111: Connect input data of channel 6
 * 1000: Connect input data of channel 7
 * 1001: Connect calculated data by scale values of matrix row 0
 * 1010: Connect calculated data by scale values of matrix row 1
 * 1011: Connect calculated data by scale values of matrix row 2
 * 1100: Connect calculated data by scale values of matrix row 3
 *
 * [CTU SVx]
 * [Output0] = [SV00, SV01, SV02, SV03, SV04, SV05, SV06, SV07]
 * [Output1] = [SV10, SV11, SV12, SV13, SV14, SV15, SV16, SV17]
 * [Output2] = [SV20, SV21, SV22, SV23, SV24, SV25, SV26, SV27]
 * [Output3] = [SV30, SV31, SV32, SV33, SV34, SV35, SV36, SV37]
 * [Output4] = [ 0,   0,    0,    0,    0,    0,    0,    0   ]
 * [Output5] = [ 0,   0,    0,    0,    0,    0,    0,    0   ]
 * [Output6] = [ 0,   0,    0,    0,    0,    0,    0,    0   ]
 * [Output7] = [ 0,   0,    0,    0,    0,    0,    0,    0   ]
 *
 * [SVxx]
 * Plus					Minus
 * value	time		dB	value		time		dB
 * -----------------------------------------------------------------------
 * H'7F_FFFF	2		6	H'80_0000	2		6
 * ...
 * H'40_0000	1		0	H'C0_0000	1		0
 * ...
 * H'00_0001	2.38 x 10^-7	-132
 * H'00_0000	0		Mute	H'FF_FFFF	2.38 x 10^-7	-132
 *
 *
 * Ex) Input ch -> Output ch
 *	1ch     ->  0ch
 *	0ch     ->  1ch
 *
 *	amixer set "CTU Reset" on
 *	amixer set "CTU Pass" 9,10
 *	amixer set "CTU SV0" 0,4194304
 *	amixer set "CTU SV1" 4194304,0
 * or
 *	amixer set "CTU Reset" on
 *	amixer set "CTU Pass" 2,1
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1164.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/sh/rcar/dma.c#L548-L562

```c
/*
< ASCII >
 *	DMA read/write register offset
 *
 *	RSND_xxx_I_N	for Audio DMAC input
 *	RSND_xxx_O_N	for Audio DMAC output
 *	RSND_xxx_I_P	for Audio DMAC peri peri input
 *	RSND_xxx_O_P	for Audio DMAC peri peri output
 *
 *	ex) R-Car H2 case
 *	      mod        / DMAC in    / DMAC out   / DMAC PP in / DMAC pp out
 *	SSI : 0xec541000 / 0xec241008 / 0xec24100c
 *	SSIU: 0xec541000 / 0xec100000 / 0xec100000 / 0xec400000 / 0xec400000
 *	SCU : 0xec500000 / 0xec000000 / 0xec004000 / 0xec300000 / 0xec304000
 *	CMD : 0xec500000 /            / 0xec008000                0xec308000
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1165.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/sh/rcar/src.c#L56-L64

```c
/*
< ASCII >
 *		image of SRC (Sampling Rate Converter)
 *
 * 96kHz   <-> +-----+	48kHz	+-----+	 48kHz	+-------+
 * 48kHz   <-> | SRC | <------>	| SSI |	<----->	| codec |
 * 44.1kHz <-> +-----+		+-----+		+-------+
 * ...
< ASCII >
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_1166.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/sof/core.c#L146-L184

```c
/*
< ASCII >
 *			FW Boot State Transition Diagram
 *
 *    +----------------------------------------------------------------------+
 *    |									     |
 * ------------------	     ------------------				     |
 * |		    |	     |		      |				     |
 * |   BOOT_FAILED  |<-------|  READY_FAILED  |				     |
 * |		    |<--+    |	              |	   ------------------	     |
 * ------------------	|    ------------------	   |		    |	     |
 *	^		|	    ^		   |	CRASHED	    |---+    |
 *	|		|	    |		   |		    |	|    |
 * (FW Boot Timeout)	|	(FW_READY FAIL)	   ------------------	|    |
 *	|		|	    |		     ^			|    |
 *	|		|	    |		     |(DSP Panic)	|    |
 * ------------------	|	    |		   ------------------	|    |
 * |		    |	|	    |		   |		    |	|    |
 * |   IN_PROGRESS  |---------------+------------->|    COMPLETE    |	|    |
 * |		    | (FW Boot OK)   (FW_READY OK) |		    |	|    |
 * ------------------	|			   ------------------	|    |
 *	^		|				|		|    |
 *	|		|				|		|    |
 * (FW Loading OK)	|			(System Suspend/Runtime Suspend)
 *	|		|				|		|    |
 *	|	(FW Loading Fail)			|		|    |
 * ------------------	|	------------------	|		|    |
 * |		    |	|	|		 |<-----+		|    |
 * |   PREPARE	    |---+	|   NOT_STARTED  |<---------------------+    |
 * |		    |		|		 |<--------------------------+
 * ------------------		------------------
 *    |	    ^			    |	   ^
 *    |	    |			    |	   |
 *    |	    +-----------------------+	   |
 *    |		(DSP Probe OK)		   |
 *    |					   |
 *    |					   |
 *    +------------------------------------+
 *	(System Suspend/Runtime Suspend)
< ASCII >
 */
```
## Visual type:
- #state-machine


== ./linux/linux_1167.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/sof/ipc4-mtrace.c#L11-L42

```c
/*
< ASCII >
 * debug info window is organized in 16 (equal sized) pages:
 *
 *	------------------------
 *	| Page0  - descriptors |
 *	------------------------
 *	| Page1  - slot0       |
 *	------------------------
 *	| Page2  - slot1       |
 *	------------------------
 *	|         ...          |
 *	------------------------
 *	| Page14  - slot13     |
 *	------------------------
 *	| Page15  - slot14     |
 *	------------------------
< ASCII >
 *
 * The slot size == page size
 *
 * The first page contains descriptors for the remaining 15 cores
 * The slot descriptor is:
 * u32 res_id;
 * u32 type;
 * u32 vma;
 *
 * Log buffer slots have the following layout:
 * u32 host_read_ptr;
 * u32 dsp_write_ptr;
 * u8 buffer[];
 *
 * The two pointers are offsets within the buffer.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1168.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/sof/intel/hda-dsp.c#L590-L618

```c
/*
< ASCII >
 * Audio DSP states may transform as below:-
 *
 *                                         Opportunistic D0I3 in S0
 *     Runtime    +---------------------+  Delayed D0i3 work timeout
 *     suspend    |                     +--------------------+
 *   +------------+       D0I0(active)  |                    |
 *   |            |                     <---------------+    |
 *   |   +-------->                     |    New IPC	|    |
 *   |   |Runtime +--^--+---------^--+--+ (via mailbox)	|    |
 *   |   |resume     |  |         |  |			|    |
 *   |   |           |  |         |  |			|    |
 *   |   |     System|  |         |  |			|    |
 *   |   |     resume|  | S3/S0IX |  |                  |    |
 *   |   |	     |  | suspend |  | S0IX             |    |
 *   |   |           |  |         |  |suspend           |    |
 *   |   |           |  |         |  |                  |    |
 *   |   |           |  |         |  |                  |    |
 * +-v---+-----------+--v-------+ |  |           +------+----v----+
 * |                            | |  +----------->                |
 * |       D3 (suspended)       | |              |      D0I3      |
 * |                            | +--------------+                |
 * |                            |  System resume |                |
 * +----------------------------+		 +----------------+
< ASCII >
 *
 * S0IX suspend: The DSP is in D0I3 if any D0I3-compatible streams
 *		 ignored the suspend trigger. Otherwise the DSP
 *		 is in D3.
 */
```
## Visual type:
- #state-machine


== ./linux/linux_1169.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/ti/omap3pandora.c#L102-L109

```c
/*
< ASCII >
 * Audio paths on Pandora board:
 *
 *  |O| ---> PCM DAC +-> AMP -> Headphone Jack
 *  |M|         A    +--------> Line Out
 *  |A| <~~clk~~+
 *  |P| <--- TWL4030 <--------- Line In and MICs
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_117.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/nios2/include/asm/pgtable.h#L234-L244

```c
/*
 * Encode and decode a swap entry (must be !pte_none(pte) && !pte_present(pte):
< ASCII >
 *
 * 31 30 29 28 27 26 25 24 23 22 21 20 19 18 ...  1  0
 *  0  0  0  0 type.  0  0  0  0  0  0 offset.........
< ASCII >
 *
 * This gives us up to 2**2 = 4 swap files and 2**20 * 4K = 4G per swap file.
 *
 * Note that the offset field is always non-zero, thus !pte_none(pte) is always
 * true.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1170.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/soc/uniphier/aio.h#L159-L192

```c
/**
 * 'SoftWare MAPping' setting of UniPhier AIO registers.
 *
 * We have to setup 'virtual' register maps to access 'real' registers of AIO.
 * This feature is legacy and meaningless but AIO needs this to work.
 *
< ASCII >
 * Each hardware blocks have own virtual register maps as following:
 *
 * Address Virtual                      Real
 * ------- ---------                    ---------------
 * 0x12000 DMAC map0 --> [selector] --> DMAC hardware 3
 * 0x12080 DMAC map1 --> [selector] --> DMAC hardware 1
 * ...
 * 0x42000 Port map0 --> [selector] --> Port hardware 1
 * 0x42400 Port map1 --> [selector] --> Port hardware 2
 * ...
< ASCII >
 *
 * ch   : Input or output channel of DMAC
 * rb   : Ring buffer
 * iport: PCM input port
 * iif  : Input interface
 * oport: PCM output port
 * oif  : Output interface
 * och  : Output channel of DMAC for sampling rate converter
 *
 * These are examples for sound data paths:
 *
 * For caputure device:
 *   (outer of AIO) -> iport -> iif -> ch -> rb -> (CPU)
 * For playback device:
 *   (CPU) -> rb -> ch -> oif -> oport -> (outer of AIO)
 * For sampling rate converter device:
 *   (CPU) -> rb -> ch -> oif -> (HW SRC) -> iif -> och -> orb -> (CPU)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1171.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/usb/mixer_maps.c#L38-L54

```c
/*
< ASCII >
 * Topology of SB Extigy (see on the wide screen :)

USB_IN[1] --->FU[2]------------------------------+->MU[16]-->PU[17]-+->FU[18]--+->EU[27]--+->EU[21]-->FU[22]--+->FU[23] > Dig_OUT[24]
                                                 ^                  |          |          |                   |
USB_IN[3] -+->SU[5]-->FU[6]--+->MU[14] ->PU[15]->+                  |          |          |                   +->FU[25] > Dig_OUT[26]
           ^                 ^                   |                  |          |          |
Dig_IN[4] -+                 |                   |                  |          |          +->FU[28]---------------------> Spk_OUT[19]
                             |                   |                  |          |
Lin-IN[7] -+-->FU[8]---------+                   |                  |          +----------------------------------------> Hph_OUT[20]
           |                                     |                  |
Mic-IN[9] --+->FU[10]----------------------------+                  |
           ||                                                       |
           ||  +----------------------------------------------------+
           VV  V
           ++--+->SU[11]-->FU[12] --------------------------------------------------------------------------------------> USB_OUT[13]
< ASCII >
*/
```
## Visual type:
- #topology


== ./linux/linux_1172.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/usb/mixer_maps.c#L127-L142

```c
/* Topology of SB Audigy 2 NX
< ASCII >

          +----------------------------->EU[27]--+
          |                                      v
          | +----------------------------------->SU[29]---->FU[22]-->Dig_OUT[24]
          | |                                    ^
USB_IN[1]-+------------+              +->EU[17]->+->FU[11]-+
            |          v              |          v         |
Dig_IN[4]---+->FU[6]-->MU[16]->FU[18]-+->EU[21]->SU[31]----->FU[30]->Hph_OUT[20]
            |          ^              |                    |
Lin_IN[7]-+--->FU[8]---+              +->EU[23]->FU[28]------------->Spk_OUT[19]
          | |                                              v
          +--->FU[12]------------------------------------->SU[14]--->USB_OUT[15]
            |                                              ^
            +->FU[13]--------------------------------------+
< ASCII >
*/
```
## Visual type:
- #topology


== ./linux/linux_1173.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/usb/mixer_scarlett.c#L30-L118

```c
/* Mixer Interface for the Focusrite Scarlett 18i6 audio interface.
 *
 * The protocol was reverse engineered by looking at communication between
 * Scarlett MixControl (v 1.2.128.0) and the Focusrite(R) Scarlett 18i6
 * (firmware v305) using wireshark and usbmon in January 2013.
 * Extended in July 2013.
 *
 * this mixer gives complete access to all features of the device:
 *  - change Impedance of inputs (Line-in, Mic / Instrument, Hi-Z)
 *  - select clock source
 *  - dynamic input to mixer-matrix assignment
 *  - 18 x 6 mixer-matrix gain stages
 *  - bus routing & volume control
 *  - automatic re-initialization on connect if device was power-cycled
 *
 * USB URB commands overview (bRequest = 0x01 = UAC2_CS_CUR)
 * wIndex
 * 0x01 Analog Input line/instrument impedance switch, wValue=0x0901 +
 *      channel, data=Line/Inst (2bytes)
 *      pad (-10dB) switch, wValue=0x0b01 + channel, data=Off/On (2bytes)
 *      ?? wValue=0x0803/04, ?? (2bytes)
 * 0x0a Master Volume, wValue=0x0200+bus[0:all + only 1..4?] data(2bytes)
 *      Bus Mute/Unmute wValue=0x0100+bus[0:all + only 1..4?], data(2bytes)
 * 0x28 Clock source, wValue=0x0100, data={1:int,2:spdif,3:adat} (1byte)
 * 0x29 Set Sample-rate, wValue=0x0100, data=sample-rate(4bytes)
 * 0x32 Mixer mux, wValue=0x0600 + mixer-channel, data=input-to-connect(2bytes)
 * 0x33 Output mux, wValue=bus, data=input-to-connect(2bytes)
 * 0x34 Capture mux, wValue=0...18, data=input-to-connect(2bytes)
 * 0x3c Matrix Mixer gains, wValue=mixer-node  data=gain(2bytes)
 *      ?? [sometimes](4bytes, e.g 0x000003be 0x000003bf ...03ff)
 *
 * USB reads: (i.e. actually issued by original software)
 * 0x01 wValue=0x0901+channel (1byte!!), wValue=0x0b01+channed (1byte!!)
 * 0x29 wValue=0x0100 sample-rate(4bytes)
 *      wValue=0x0200 ?? 1byte (only once)
 * 0x2a wValue=0x0100 ?? 4bytes, sample-rate2 ??
 *
 * USB reads with bRequest = 0x03 = UAC2_CS_MEM
 * 0x3c wValue=0x0002 1byte: sync status (locked=1)
 *      wValue=0x0000 18*2byte: peak meter (inputs)
 *      wValue=0x0001 8(?)*2byte: peak meter (mix)
 *      wValue=0x0003 6*2byte: peak meter (pcm/daw)
 *
 * USB write with bRequest = 0x03
 * 0x3c Save settings to hardware: wValue=0x005a, data=0xa5
< ASCII >
 *
 *
 * <ditaa>
 *  /--------------\    18chn            6chn    /--------------\
 *  | Hardware  in +--+-------\        /------+--+ ALSA PCM out |
 *  \--------------/  |       |        |      |  \--------------/
 *                    |       |        |      |
 *                    |       v        v      |
 *                    |   +---------------+   |
 *                    |    \ Matrix  Mux /    |
 *                    |     +-----+-----+     |
 *                    |           |           |
 *                    |           | 18chn     |
 *                    |           v           |
 *                    |     +-----------+     |
 *                    |     | Mixer     |     |
 *                    |     |    Matrix |     |
 *                    |     |           |     |
 *                    |     | 18x6 Gain |     |
 *                    |     |   stages  |     |
 *                    |     +-----+-----+     |
 *                    |           |           |
 *                    |           |           |
 *                    | 18chn     | 6chn      | 6chn
 *                    v           v           v
 *                    =========================
 *             +---------------+     +--—------------+
 *              \ Output  Mux /       \ Capture Mux /
 *               +-----+-----+         +-----+-----+
 *                     |                     |
 *                     | 6chn                |
 *                     v                     |
 *              +-------------+              |
 *              | Master Gain |              |
 *              +------+------+              |
 *                     |                     |
 *                     | 6chn                | 18chn
 *                     | (3 stereo pairs)    |
 *  /--------------\   |                     |   /--------------\
 *  | Hardware out |<--/                     \-->| ALSA PCM  in |
 *  \--------------/                             \--------------/
 * </ditaa>
< ASCII >
 *
 */
```
## Visual type:
- #schematic


== ./linux/linux_1174.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/x86/intel_hdmi_audio.c#L827-L865

```c
/*
 * PCM ring buffer handling
 *
 * The hardware provides a ring buffer with the fixed 4 buffer descriptors
 * (BDs).  The driver maps these 4 BDs onto the PCM ring buffer.  The mapping
 * moves at each period elapsed.  The below illustrates how it works:
 *
< ASCII >
 * At time=0
 *  PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
 *  BD  | 0 | 1 | 2 | 3 |
 *
 * At time=1 (period elapsed)
 *  PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
 *  BD      | 1 | 2 | 3 | 0 |
 *
 * At time=2 (second period elapsed)
 *  PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
 *  BD          | 2 | 3 | 0 | 1 |
< ASCII >
 *
 * The bd_head field points to the index of the BD to be read.  It's also the
 * position to be filled at next.  The pcm_head and the pcm_filled fields
 * point to the indices of the current position and of the next position to
 * be filled, respectively.  For PCM buffer there are both _head and _filled
 * because they may be difference when nperiods > 4.  For example, in the
 * example above at t=1, bd_head=1 and pcm_head=1 while pcm_filled=5:
 *
< ASCII >
 * pcm_head (=1) --v               v-- pcm_filled (=5)
 *       PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
 *       BD      | 1 | 2 | 3 | 0 |
 *  bd_head (=1) --^               ^-- next to fill (= bd_head)
< ASCII >
 *
 * For nperiods < 4, the remaining BDs out of 4 are marked as invalid, so that
 * the hardware skips those BDs in the loop.
 *
 * An exceptional setup is the case with nperiods=1.  Since we have to update
 * BDs after finishing one BD processing, we'd need at least two BDs, where
 * both BDs point to the same content, the same address, the same size of the
 * whole PCM buffer.
 */
```
## Visual type:
- #custom


== ./linux/linux_1175.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/sound/x86/intel_hdmi_audio.h#L40-L52

```c
/*
< ASCII >
 *	CEA speaker placement:
 *
 *	FL  FLC   FC   FRC   FR
 *
 *						LFE
 *
 *	RL  RLC   RC   RRC   RR
< ASCII >
 *
 *	The Left/Right Surround channel _notions_ LS/RS in SMPTE 320M
 *	corresponds to CEA RL/RR; The SMPTE channel _assignment_ C/LFE is
 *	swapped to CEA LFE/FC.
 */
```
## Visual type:
- #custom


== ./linux/linux_1176.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/arch/arm64/include/asm/sysreg.h#L482-L494

```c
/*
< ASCII >
 * Group 0 of activity monitors (architected):
 *                op0  op1  CRn   CRm       op2
 * Counter:       11   011  1101  010:n<3>  n<2:0>
 * Type:          11   011  1101  011:n<3>  n<2:0>
 * n: 0-15
 *
 * Group 1 of activity monitors (auxiliary):
 *                op0  op1  CRn   CRm       op2
 * Counter:       11   011  1101  110:n<3>  n<2:0>
 * Type:          11   011  1101  111:n<3>  n<2:0>
 * n: 0-15
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1177.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/arch/x86/include/asm/irq_vectors.h#L6-L27

```c
/*
 * Linux IRQ vector layout.
 *
 * There are 256 IDT entries (per CPU - each entry is 8 bytes) which can
 * be defined by Linux. They are used as a jump table by the CPU when a
 * given vector is triggered - by a CPU-external, CPU-internal or
 * software-triggered event.
 *
 * Linux sets the kernel code address each entry jumps to early during
 * bootup, and never changes them. This is the general layout of the
 * IDT entries:
< ASCII >
 *
 *  Vectors   0 ...  31 : system traps and exceptions - hardcoded events
 *  Vectors  32 ... 127 : device interrupts
 *  Vector  128         : legacy int80 syscall interface
 *  Vectors 129 ... LOCAL_TIMER_VECTOR-1
 *  Vectors LOCAL_TIMER_VECTOR ... 255 : special interrupts
< ASCII >
 *
 * 64-bit x86 has per CPU IDT tables, 32-bit has one shared IDT table.
 *
 * This file enumerates the exact layout of them:
 */
```
## Visual type:
- #custom


== ./linux/linux_1178.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/include/uapi/linux/kvm.h#L2071-L2093

```c
/*
< ASCII >
 * KVM dirty GFN flags, defined as:
 *
 * |---------------+---------------+--------------|
 * | bit 1 (reset) | bit 0 (dirty) | Status       |
 * |---------------+---------------+--------------|
 * |             0 |             0 | Invalid GFN  |
 * |             0 |             1 | Dirty GFN    |
 * |             1 |             X | GFN to reset |
 * |---------------+---------------+--------------|
< ASCII >
< ASCII >
 *
 * Lifecycle of a dirty GFN goes like:
 *
 *      dirtied         harvested        reset
 * 00 -----------> 01 -------------> 1X -------+
 *  ^                                          |
 *  |                                          |
 *  +------------------------------------------+
< ASCII >
 *
 * The userspace program is only responsible for the 01->1X state
 * conversion after harvesting an entry.  Also, it must not skip any
 * dirty bits, so that dirty bits are always harvested in sequence.
 */
```
## Visual type:
- #table


== ./linux/linux_1179.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/include/uapi/linux/netlink.h#L202-L209

```c
/*
< ASCII >
 *  <------- NLA_HDRLEN ------> <-- NLA_ALIGN(payload)-->
 * +---------------------+- - -+- - - - - - - - - -+- - -+
 * |        Header       | Pad |     Payload       | Pad |
 * |   (struct nlattr)   | ing |                   | ing |
 * +---------------------+- - -+- - - - - - - - - -+- - -+
 *  <-------------- nlattr->nla_len -------------->
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_118.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/nios2/mm/pgtable.c#L15-L31

```c
< ASCII >
/* pteaddr:
 *   ptbase | vpn* | zero
 *   31-22  | 21-2 | 1-0
 *
 *   *vpn is preserved on double fault
 *
 * tlbacc:
 *   IG   |*flags| pfn
 *   31-25|24-20 | 19-0
 *
 *   *crwxg
 *
 * tlbmisc:
 *   resv  |way   |rd | we|pid |dbl|bad|perm|d
 *   31-24 |23-20 |19 | 20|17-4|3  |2  |1   |0
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1180.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/include/uapi/linux/netlink.h#L216-L225

```c
/*
< ASCII >
 * nla_type (16 bits)
 * +---+---+-------------------------------+
 * | N | O | Attribute Type                |
 * +---+---+-------------------------------+
< ASCII >
 * N := Carries nested attributes
 * O := Payload stored in network byte order
 *
 * Note: The N and O flag are mutually exclusive.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1181.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/include/uapi/linux/pkt_cls.h#L555-L568

```c
< ASCII >
/*  0                   1
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 
 * +-----------------------+-+-+---+
 * |         Unused        |S|I| R |
 * +-----------------------+-+-+---+
< ASCII >
 *
 * R(2) ::= relation to next ematch
 *          where: 0 0 END (last ematch)
 *                 0 1 AND
 *                 1 0 OR
 *                 1 1 Unused (invalid)
 * I(1) ::= invert result
 * S(1) ::= simple payload
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1182.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/lib/bpf/libbpf.c#L6262-L6342

```c
/*
 * Relocate sub-program calls.
 *
 * Algorithm operates as follows. Each entry-point BPF program (referred to as
 * main prog) is processed separately. For each subprog (non-entry functions,
 * that can be called from either entry progs or other subprogs) gets their
 * sub_insn_off reset to zero. This serves as indicator that this subprogram
 * hasn't been yet appended and relocated within current main prog. Once its
 * relocated, sub_insn_off will point at the position within current main prog
 * where given subprog was appended. This will further be used to relocate all
 * the call instructions jumping into this subprog.
 *
 * We start with main program and process all call instructions. If the call
 * is into a subprog that hasn't been processed (i.e., subprog->sub_insn_off
 * is zero), subprog instructions are appended at the end of main program's
 * instruction array. Then main program is "put on hold" while we recursively
 * process newly appended subprogram. If that subprogram calls into another
 * subprogram that hasn't been appended, new subprogram is appended again to
 * the *main* prog's instructions (subprog's instructions are always left
 * untouched, as they need to be in unmodified state for subsequent main progs
 * and subprog instructions are always sent only as part of a main prog) and
 * the process continues recursively. Once all the subprogs called from a main
 * prog or any of its subprogs are appended (and relocated), all their
 * positions within finalized instructions array are known, so it's easy to
 * rewrite call instructions with correct relative offsets, corresponding to
 * desired target subprog.
 *
 * Its important to realize that some subprogs might not be called from some
 * main prog and any of its called/used subprogs. Those will keep their
 * subprog->sub_insn_off as zero at all times and won't be appended to current
 * main prog and won't be relocated within the context of current main prog.
 * They might still be used from other main progs later.
 *
 * Visually this process can be shown as below. Suppose we have two main
 * programs mainA and mainB and BPF object contains three subprogs: subA,
 * subB, and subC. mainA calls only subA, mainB calls only subC, but subA and
 * subC both call subB:
< ASCII >
 *
 *        +--------+ +-------+
 *        |        v v       |
 *     +--+---+ +--+-+-+ +---+--+
 *     | subA | | subB | | subC |
 *     +--+---+ +------+ +---+--+
 *        ^                  ^
 *        |                  |
 *    +---+-------+   +------+----+
 *    |   mainA   |   |   mainB   |
 *    +-----------+   +-----------+
< ASCII >
 *
 * We'll start relocating mainA, will find subA, append it and start
 * processing sub A recursively:
< ASCII >
 *
 *    +-----------+------+
 *    |   mainA   | subA |
 *    +-----------+------+
< ASCII >
 *
 * At this point we notice that subB is used from subA, so we append it and
 * relocate (there are no further subcalls from subB):
< ASCII >
 *
 *    +-----------+------+------+
 *    |   mainA   | subA | subB |
 *    +-----------+------+------+
< ASCII >
 *
 * At this point, we relocate subA calls, then go one level up and finish with
 * relocatin mainA calls. mainA is done.
 *
 * For mainB process is similar but results in different order. We start with
 * mainB and skip subA and subB, as mainB never calls them (at least
 * directly), but we see subC is needed, so we append and start processing it:
 *
< ASCII >
 *    +-----------+------+
 *    |   mainB   | subC |
 *    +-----------+------+
< ASCII >
 * Now we see subC needs subB, so we go back to it, append and relocate it:
 *
< ASCII >
 *    +-----------+------+------+
 *    |   mainB   | subC | subB |
 *    +-----------+------+------+
< ASCII >
 *
 * At this point we unwind recursion, relocate calls in subC, then in mainB.
 */
```
## Visual type:
- #custom


== ./linux/linux_1183.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/objtool/check.c#L2700-L2752

```c
/*
 * A note about DRAP stack alignment:
 *
 * GCC has the concept of a DRAP register, which is used to help keep track of
 * the stack pointer when aligning the stack.  r10 or r13 is used as the DRAP
 * register.  The typical DRAP pattern is:
< ASCII >
 *
 *   4c 8d 54 24 08		lea    0x8(%rsp),%r10
 *   48 83 e4 c0		and    $0xffffffffffffffc0,%rsp
 *   41 ff 72 f8		pushq  -0x8(%r10)
 *   55				push   %rbp
 *   48 89 e5			mov    %rsp,%rbp
 *				(more pushes)
 *   41 52			push   %r10
 *				...
 *   41 5a			pop    %r10
 *				(more pops)
 *   5d				pop    %rbp
 *   49 8d 62 f8		lea    -0x8(%r10),%rsp
 *   c3				retq
< ASCII >
 *
 * There are some variations in the epilogues, like:
 *
< ASCII >
 *   5b				pop    %rbx
 *   41 5a			pop    %r10
 *   41 5c			pop    %r12
 *   41 5d			pop    %r13
 *   41 5e			pop    %r14
 *   c9				leaveq
 *   49 8d 62 f8		lea    -0x8(%r10),%rsp
 *   c3				retq
< ASCII >
 *
 * and:
 *
< ASCII >
 *   4c 8b 55 e8		mov    -0x18(%rbp),%r10
 *   48 8b 5d e0		mov    -0x20(%rbp),%rbx
 *   4c 8b 65 f0		mov    -0x10(%rbp),%r12
 *   4c 8b 6d f8		mov    -0x8(%rbp),%r13
 *   c9				leaveq
 *   49 8d 62 f8		lea    -0x8(%r10),%rsp
 *   c3				retq
< ASCII >
 *
 * Sometimes r13 is used as the DRAP register, in which case it's saved and
 * restored beforehand:
< ASCII >
 *
 *   41 55			push   %r13
 *   4c 8d 6c 24 10		lea    0x10(%rsp),%r13
 *   48 83 e4 f0		and    $0xfffffffffffffff0,%rsp
 *				...
 *   49 8d 65 f0		lea    -0x10(%r13),%rsp
 *   41 5d			pop    %r13
 *   c3				retq
< ASCII >
 */
```
## Visual type:



== ./linux/linux_1184.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/objtool/arch/x86/decode.c#L110-L120

```c
/*
< ASCII >
 * Helpers to decode ModRM/SIB:
 *
 * r/m| AX  CX  DX  BX |  SP |  BP |  SI  DI |
 *    | R8  R9 R10 R11 | R12 | R13 | R14 R15 |
 * Mod+----------------+-----+-----+---------+
 * 00 |    [r/m]       |[SIB]|[IP+]|  [r/m]  |
 * 01 |  [r/m + d8]    |[S+d]|   [r/m + d8]  |
 * 10 |  [r/m + d32]   |[S+D]|   [r/m + d32] |
 * 11 |                   r/ m               |
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1185.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/perf/builtin-sched.c#L2100-L2121

```c
/*
 * Explanation of delta-time stats:
 *
 *            t = time of current schedule out event
 *        tprev = time of previous sched out event
 *                also time of schedule-in event for current task
 *    last_time = time of last sched change event for current task
 *                (i.e, time process was last scheduled out)
 * ready_to_run = time of wakeup for current task
< ASCII >
 *
 * -----|------------|------------|------------|------
 *    last         ready        tprev          t
 *    time         to run
 *
 *      |-------- dt_wait --------|
 *                   |- dt_delay -|-- dt_run --|
< ASCII >
 *
 *   dt_run = run time of current task
 *  dt_wait = time between last schedule out event for task and tprev
 *            represents time spent off the cpu
 * dt_delay = time between wakeup and schedule-in of task
 */
```
## Visual type:
- #interval


== ./linux/linux_1186.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/perf/tests/hists_common.h#L36-L70

```c
/*
 * The setup_fake_machine() provides a test environment which consists
 * of 3 processes that have 3 mappings and in turn, have 3 symbols
 * respectively.  See below table:
< ASCII >
 *
 * Command:  Pid  Shared Object               Symbol
 * .............  .............  ...................
 *    perf:  100           perf  main
 *    perf:  100           perf  run_command
 *    perf:  100           perf  cmd_record
 *    perf:  100           libc  malloc
 *    perf:  100           libc  free
 *    perf:  100           libc  realloc
 *    perf:  100       [kernel]  schedule
 *    perf:  100       [kernel]  page_fault
 *    perf:  100       [kernel]  sys_perf_event_open
 *    perf:  200           perf  main
 *    perf:  200           perf  run_command
 *    perf:  200           perf  cmd_record
 *    perf:  200           libc  malloc
 *    perf:  200           libc  free
 *    perf:  200           libc  realloc
 *    perf:  200       [kernel]  schedule
 *    perf:  200       [kernel]  page_fault
 *    perf:  200       [kernel]  sys_perf_event_open
 *    bash:  300           bash  main
 *    bash:  300           bash  xmalloc
 *    bash:  300           bash  xfree
 *    bash:  300           libc  malloc
 *    bash:  300           libc  free
 *    bash:  300           libc  realloc
 *    bash:  300       [kernel]  schedule
 *    bash:  300       [kernel]  page_fault
 *    bash:  300       [kernel]  sys_perf_event_open
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1187.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/perf/util/annotate.c#L1196-L1206

```c
/*
< ASCII >
 * Allocating the disasm annotation line data with
 * following structure:
 *
 *    -------------------------------------------
 *    struct disasm_line | struct annotation_line
 *    -------------------------------------------
< ASCII >
 *
 * We have 'struct annotation_line' member as last member
 * of 'struct disasm_line' to have an easy access.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1188.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/perf/util/auxtrace.c#L1738-L1780

```c
/*
 * In the compat mode kernel runs in 64-bit and perf tool runs in 32-bit mode,
 * 32-bit perf tool cannot access 64-bit value atomically, which might lead to
 * the issues caused by the below sequence on multiple CPUs: when perf tool
 * accesses either the load operation or the store operation for 64-bit value,
 * on some architectures the operation is divided into two instructions, one
 * is for accessing the low 32-bit value and another is for the high 32-bit;
 * thus these two user operations can give the kernel chances to access the
 * 64-bit value, and thus leads to the unexpected load values.
< ASCII >
 *
 *   kernel (64-bit)                        user (32-bit)
 *
 *   if (LOAD ->aux_tail) { --,             LOAD ->aux_head_lo
 *       STORE $aux_data      |       ,--->
 *       FLUSH $aux_data      |       |     LOAD ->aux_head_hi
 *       STORE ->aux_head   --|-------`     smp_rmb()
 *   }                        |             LOAD $data
 *                            |             smp_mb()
 *                            |             STORE ->aux_tail_lo
 *                            `----------->
 *                                          STORE ->aux_tail_hi
< ASCII >
 *
 * For this reason, it's impossible for the perf tool to work correctly when
 * the AUX head or tail is bigger than 4GB (more than 32 bits length); and we
 * can not simply limit the AUX ring buffer to less than 4GB, the reason is
 * the pointers can be increased monotonically, whatever the buffer size it is,
 * at the end the head and tail can be bigger than 4GB and carry out to the
 * high 32-bit.
 *
 * To mitigate the issues and improve the user experience, we can allow the
 * perf tool working in certain conditions and bail out with error if detect
 * any overflow cannot be handled.
 *
 * For reading the AUX head, it reads out the values for three times, and
 * compares the high 4 bytes of the values between the first time and the last
 * time, if there has no change for high 4 bytes injected by the kernel during
 * the user reading sequence, it's safe for use the second value.
 *
 * When compat_auxtrace_mmap__write_tail() detects any carrying in the high
 * 32 bits, it means there have two store operations in user space and it cannot
 * promise the atomicity for 64-bit write, so return '-1' in this case to tell
 * the caller an overflow error has happened.
 */
```
## Visual type:
- #custom


== ./linux/linux_1189.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/perf/util/bpf_counter.c#L696-L769

```c
/*
 * bperf: share hardware PMCs with BPF
 *
 * perf uses performance monitoring counters (PMC) to monitor system
 * performance. The PMCs are limited hardware resources. For example,
 * Intel CPUs have 3x fixed PMCs and 4x programmable PMCs per cpu.
 *
 * Modern data center systems use these PMCs in many different ways:
 * system level monitoring, (maybe nested) container level monitoring, per
 * process monitoring, profiling (in sample mode), etc. In some cases,
 * there are more active perf_events than available hardware PMCs. To allow
 * all perf_events to have a chance to run, it is necessary to do expensive
 * time multiplexing of events.
 *
 * On the other hand, many monitoring tools count the common metrics
 * (cycles, instructions). It is a waste to have multiple tools create
 * multiple perf_events of "cycles" and occupy multiple PMCs.
 *
 * bperf tries to reduce such wastes by allowing multiple perf_events of
 * "cycles" or "instructions" (at different scopes) to share PMUs. Instead
 * of having each perf-stat session to read its own perf_events, bperf uses
 * BPF programs to read the perf_events and aggregate readings to BPF maps.
 * Then, the perf-stat session(s) reads the values from these BPF maps.
 *
< ASCII >
 *                                ||
 *       shared progs and maps <- || -> per session progs and maps
 *                                ||
 *   ---------------              ||
 *   | perf_events |              ||
 *   ---------------       fexit  ||      -----------------
 *          |             --------||----> | follower prog |
 *       --------------- /        || ---  -----------------
 * cs -> | leader prog |/         ||/        |         |
 *   --> ---------------         /||  --------------  ------------------
 *  /       |         |         / ||  | filter map |  | accum_readings |
 * /  ------------  ------------  ||  --------------  ------------------
 * |  | prev map |  | diff map |  ||                        |
 * |  ------------  ------------  ||                        |
 *  \                             ||                        |
 * = \ ==================================================== | ============
 *    \                                                    /   user space
 *     \                                                  /
 *      \                                                /
 *    BPF_PROG_TEST_RUN                    BPF_MAP_LOOKUP_ELEM
 *        \                                            /
 *         \                                          /
 *          \------  perf-stat ----------------------/
< ASCII >
 *
 * The figure above shows the architecture of bperf. Note that the figure
 * is divided into 3 regions: shared progs and maps (top left), per session
 * progs and maps (top right), and user space (bottom).
 *
 * The leader prog is triggered on each context switch (cs). The leader
 * prog reads perf_events and stores the difference (current_reading -
 * previous_reading) to the diff map. For the same metric, e.g. "cycles",
 * multiple perf-stat sessions share the same leader prog.
 *
 * Each perf-stat session creates a follower prog as fexit program to the
 * leader prog. It is possible to attach up to BPF_MAX_TRAMP_PROGS (38)
 * follower progs to the same leader prog. The follower prog checks current
 * task and processor ID to decide whether to add the value from the diff
 * map to its accumulated reading map (accum_readings).
 *
 * Finally, perf-stat user space reads the value from accum_reading map.
 *
 * Besides context switch, it is also necessary to trigger the leader prog
 * before perf-stat reads the value. Otherwise, the accum_reading map may
 * not have the latest reading from the perf_events. This is achieved by
 * triggering the event via sys_bpf(BPF_PROG_TEST_RUN) to each CPU.
 *
 * Comment before the definition of struct perf_event_attr_map_entry
 * describes how different sessions of perf-stat share information about
 * the leader prog.
 */
```
## Visual type:
- #custom


== ./linux/linux_119.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/parisc/include/asm/processor.h#L166-L234

```c
/* The ELF abi wants things done a "wee bit" differently than
 * som does.  Supporting this behavior here avoids
 * having our own version of create_elf_tables.
 *
 * Oh, and yes, that is not a typo, we are really passing argc in r25
 * and argv in r24 (rather than r26 and r25).  This is because that's
 * where __libc_start_main wants them.
 *
 * Duplicated from dl-machine.h for the benefit of readers:
 *
 *  Our initial stack layout is rather different from everyone else's
 *  due to the unique PA-RISC ABI.  As far as I know it looks like
 *  this:

< ASCII >
   -----------------------------------  (user startup code creates this frame)
   | 32 bytes of magic                 |
   | --------------------------------- |
   | 32 bytes argument/sp save area    |
   | --------------------------------- | (bprm->p)                    |
   | ELF auxiliary info                |
   | (up to 28 words)                  |
   | --------------------------------- |
   | NULL                              |
   | --------------------------------- |
   | Environment pointers              |
   | --------------------------------- |
   | NULL                              |
   | --------------------------------- |
   | Argument pointers                 |
   | --------------------------------- | <- argv                      |
   | argc (1 word)                     |
   | --------------------------------- | <- bprm->exec (HACK!)        |
   | N bytes of slack                  |
   | --------------------------------- |
   | filename passed to execve         |
   | --------------------------------- | (mm->env_end)                |
   | env strings                       |
   | --------------------------------- | (mm->env_start, mm->arg_end) |
   | arg strings                       |
   | --------------------------------- |
   | additional faked arg strings if   |
   | we're invoked via binfmt_script   |
   | --------------------------------- | (mm->arg_start)              |
   stack base is at TASK_SIZE - rlim_max.
< ASCII >

on downward growing arches, it looks like this:
   stack base at TASK_SIZE
   | filename passed to execve
   | env strings
   | arg strings
   | faked arg strings
   | slack
   | ELF
   | envps
   | argvs
   | argc

 *  The pleasant part of this is that if we need to skip arguments we
 *  can just decrement argc and move argv, because the stack pointer
 *  is utterly unrelated to the location of the environment and
 *  argument vectors.
 *
 * Note that the S/390 people took the easy way out and hacked their
 * GCC to make the stack grow downwards.
 *
 * Final Note: For entry from syscall, the W (wide) bit of the PSW
 * is stuffed into the lowest bit of the user sp (%r30), so we fill
 * it in here from the current->personality
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1190.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/perf/util/evlist.h#L23-L43

```c
/*
< ASCII >
 * State machine of bkw_mmap_state:
 *
 *                     .________________(forbid)_____________.
 *                     |                                     V
 * NOTREADY --(0)--> RUNNING --(1)--> DATA_PENDING --(2)--> EMPTY
 *                     ^  ^              |   ^               |
 *                     |  |__(forbid)____/   |___(forbid)___/|
 *                     |                                     |
 *                      \_________________(3)_______________/
< ASCII >
 *
 * NOTREADY     : Backward ring buffers are not ready
 * RUNNING      : Backward ring buffers are recording
 * DATA_PENDING : We are required to collect data from backward ring buffers
 * EMPTY        : We have collected data from backward ring buffers.
 *
 * (0): Setup backward ring buffer
 * (1): Pause ring buffers for reading
 * (2): Read from ring buffers
 * (3): Resume ring buffers for recording
 */
```
## Visual type:
- #state-machine


== ./linux/linux_1191.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/perf/util/kwork.h#L35-L76

```c
/*
< ASCII >
 * data structure:
 *
 *                 +==================+ +============+ +======================+
 *                 |      class       | |    work    | |         atom         |
 *                 +==================+ +============+ +======================+
 * +------------+  |  +-----+         | |  +------+  | |  +-------+   +-----+ |
 * | perf_kwork | +-> | irq | --------|+-> | eth0 | --+-> | raise | - | ... | --+   +-----------+
 * +-----+------+ ||  +-----+         |||  +------+  |||  +-------+   +-----+ | |   |           |
 *       |        ||                  |||            |||                      | +-> | atom_page |
 *       |        ||                  |||            |||  +-------+   +-----+ |     |           |
 *       |  class_list                |||            |+-> | entry | - | ... | ----> |           |
 *       |        ||                  |||            |||  +-------+   +-----+ |     |           |
 *       |        ||                  |||            |||                      | +-> |           |
 *       |        ||                  |||            |||  +-------+   +-----+ | |   |           |
 *       |        ||                  |||            |+-> | exit  | - | ... | --+   +-----+-----+
 *       |        ||                  |||            | |  +-------+   +-----+ |           |
 *       |        ||                  |||            | |                      |           |
 *       |        ||                  |||  +-----+   | |                      |           |
 *       |        ||                  |+-> | ... |   | |                      |           |
 *       |        ||                  | |  +-----+   | |                      |           |
 *       |        ||                  | |            | |                      |           |
 *       |        ||  +---------+     | |  +-----+   | |  +-------+   +-----+ |           |
 *       |        +-> | softirq | -------> | RCU | ---+-> | raise | - | ... | --+   +-----+-----+
 *       |        ||  +---------+     | |  +-----+   |||  +-------+   +-----+ | |   |           |
 *       |        ||                  | |            |||                      | +-> | atom_page |
 *       |        ||                  | |            |||  +-------+   +-----+ |     |           |
 *       |        ||                  | |            |+-> | entry | - | ... | ----> |           |
 *       |        ||                  | |            |||  +-------+   +-----+ |     |           |
 *       |        ||                  | |            |||                      | +-> |           |
 *       |        ||                  | |            |||  +-------+   +-----+ | |   |           |
 *       |        ||                  | |            |+-> | exit  | - | ... | --+   +-----+-----+
 *       |        ||                  | |            | |  +-------+   +-----+ |           |
 *       |        ||                  | |            | |                      |           |
 *       |        ||  +-----------+   | |  +-----+   | |                      |           |
 *       |        +-> | workqueue | -----> | ... |   | |                      |           |
 *       |         |  +-----------+   | |  +-----+   | |                      |           |
 *       |         +==================+ +============+ +======================+           |
 *       |                                                                                |
 *       +---->  atom_page_list  ---------------------------------------------------------+
 *
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1192.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/perf/util/session.c#L1041-L1079

```c
/*
 * When perf record finishes a pass on every buffers, it records this pseudo
 * event.
 * We record the max timestamp t found in the pass n.
 * Assuming these timestamps are monotonic across cpus, we know that if
 * a buffer still has events with timestamps below t, they will be all
 * available and then read in the pass n + 1.
 * Hence when we start to read the pass n + 2, we can safely flush every
 * events with timestamps below t.
< ASCII >
 *
 *    ============ PASS n =================
 *       CPU 0         |   CPU 1
 *                     |
 *    cnt1 timestamps  |   cnt2 timestamps
 *          1          |         2
 *          2          |         3
 *          -          |         4  <--- max recorded
 *
 *    ============ PASS n + 1 ==============
 *       CPU 0         |   CPU 1
 *                     |
 *    cnt1 timestamps  |   cnt2 timestamps
 *          3          |         5
 *          4          |         6
 *          5          |         7 <---- max recorded
 *
 *      Flush every events below timestamp 4
 *
 *    ============ PASS n + 2 ==============
 *       CPU 0         |   CPU 1
 *                     |
 *    cnt1 timestamps  |   cnt2 timestamps
 *          6          |         8
 *          7          |         9
 *          -          |         10
 *
 *      Flush every events below timestamp 7
 *      etc...
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1193.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/perf/util/stat.c#L41-L56

```c
/*
< ASCII >
 * http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
 *
 *       (\Sum n_i^2) - ((\Sum n_i)^2)/n
 * s^2 = -------------------------------
 *                  n - 1
< ASCII >
 *
 * http://en.wikipedia.org/wiki/Stddev
 *
 * The std dev of the mean is related to the std dev by:
 *
< ASCII >
 *             s
 * s_mean = -------
 *          sqrt(n)
< ASCII >
 *
 */
```
## Visual type:
- #formula


== ./linux/linux_1194.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/perf/util/trigger.h#L7-L23

```c
/*
 * Use trigger to model operations which need to be executed when
 * an event (a signal, for example) is observed.
 *
< ASCII >
 * States and transits:
 *
 *
 *  OFF--> ON --> READY --(hit)--> HIT
 *                 ^               |
 *                 |            (ready)
 *                 |               |
 *                  \_____________/
< ASCII >
 *
 * is_hit and is_ready are two key functions to query the state of
 * a trigger. is_hit means the event already happen; is_ready means the
 * trigger is waiting for the event.
 */
```
## Visual type:
- #state-machine


== ./linux/linux_1195.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/perf/util/hisi-ptt-decoder/hisi-ptt-pkt-decoder.c#L18-L40

```c
/*
 * For 8DW format, the bit[31:11] of DW0 is always 0x1fffff, which can be
 * used to distinguish the data format.
< ASCII >
 * 8DW format is like:
 *   bits [                 31:11                 ][       10:0       ]
 *        |---------------------------------------|-------------------|
 *    DW0 [                0x1fffff               ][ Reserved (0x7ff) ]
 *    DW1 [                       Prefix                              ]
 *    DW2 [                     Header DW0                            ]
 *    DW3 [                     Header DW1                            ]
 *    DW4 [                     Header DW2                            ]
 *    DW5 [                     Header DW3                            ]
 *    DW6 [                   Reserved (0x0)                          ]
 *    DW7 [                        Time                               ]
 *
 * 4DW format is like:
 *   bits [31:30] [ 29:25 ][24][23][22][21][    20:11   ][    10:0    ]
 *        |-----|---------|---|---|---|---|-------------|-------------|
 *    DW0 [ Fmt ][  Type  ][T9][T8][TH][SO][   Length   ][    Time    ]
 *    DW1 [                     Header DW1                            ]
 *    DW2 [                     Header DW2                            ]
 *    DW3 [                     Header DW3                            ]
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1196.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_api.c#L52-L69

```c
/*
 * A test that tries to allocate memory next to a reserved region that starts at
 * the misaligned address. Expect to create two separate entries, with the new
 * entry aligned to the provided alignment:
< ASCII >
 *
 *              +
 * |            +--------+         +--------|
 * |            |  rgn2  |         |  rgn1  |
 * +------------+--------+---------+--------+
 *              ^
 *              |
 *              Aligned address boundary
< ASCII >
 *
 * The allocation direction is top-down and region arrays are sorted from lower
 * to higher addresses, so the new region will be the first entry in
 * memory.reserved array. The previously reserved region does not get modified.
 * Region counter and total size get updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1197.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_api.c#L113-L122

```c
/*
< ASCII >
 * A test that tries to allocate memory when there is enough space at the end
 * of the previously reserved block (i.e. first fit):
 *
 *  |              +--------+--------------|
 *  |              |   r1   |      r2      |
 *  +--------------+--------+--------------+
< ASCII >
 *
 * Expect a merge of both regions. Only the region size gets updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1198.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_api.c#L155-L165

```c
/*
 * A test that tries to allocate memory when there is not enough space at the
 * end of the previously reserved block (i.e. second fit):
< ASCII >
 *
 *  |            +-----------+------+     |
 *  |            |     r2    |  r1  |     |
 *  +------------+-----------+------+-----+
< ASCII >
 *
 * Expect a merge of both regions. Both the base address and size of the region
 * get updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1199.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_api.c#L253-L263

```c
/*
 * A test that tries to allocate memory when there are two reserved regions with
 * a gap big enough to accommodate the new region:
< ASCII >
 *
 *  |     +--------+--------+--------+     |
 *  |     |   r2   |   r3   |   r1   |     |
 *  +-----+--------+--------+--------+-----+
< ASCII >
 *
 * Expect to merge all of them, creating one big entry in memblock.reserved
 * array. The region counter and total size fields get updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_12.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/core_marvel.c#L475-L500

```c
/*
 * PCI Configuration Space access functions
 *
< ASCII >
 * Configuration space addresses have the following format:
 *
 * 	|2 2 2 2|1 1 1 1|1 1 1 1|1 1 
 * 	|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
 * 	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * 	|B|B|B|B|B|B|B|B|D|D|D|D|D|F|F|F|R|R|R|R|R|R|R|R|
 * 	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 *	 n:24	reserved for hose base
 *	23:16	bus number (8 bits = 128 possible buses)
 *	15:11	Device number (5 bits)
 *	10:8	function number
 *	 7:2	register number
 *  
 * Notes:
 *	IO7 determines whether to use a type 0 or type 1 config cycle
 *	based on the bus number. Therefore the bus number must be set 
 *	to 0 for the root bus on any hose.
 *	
 *	The function number selects which function of a multi-function device 
 *	(e.g., SCSI and Ethernet).
 * 
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_120.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/parisc/math-emu/dbl_float.h#L213-L222

```c
/* This magnitude comparison uses the signless first words and
 * the regular part2 words.  The comparison is graphically:
< ASCII >
 *
 *       1st greater?  -------------
 *                                 |
 *       1st less?-----------------+---------
 *                                 |        |
 *       2nd greater or equal----->|        |
 *                               False     True
< ASCII >
 */
```
## Visual type:
- #flowchart


== ./linux/linux_1200.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_api.c#L307-L319

```c
/*
 * A test that tries to allocate memory when the memory is filled with reserved
 * regions with memory gaps too small to fit the new region:
< ASCII >
 *
 * +-------+
 * |  new  |
 * +--+----+
 *    |    +-----+    +-----+    +-----+    |
 *    |    | res |    | res |    | res |    |
 *    +----+-----+----+-----+----+-----+----+
< ASCII >
 *
 * Expect no allocation to happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1201.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_api.c#L369-L381

```c
/*
 * A test that tries to allocate memory when the memory is almost full,
 * with not enough space left for the new region:
< ASCII >
 *
 *                                +-------+
 *                                |  new  |
 *                                +-------+
 *  |-----------------------------+   |
 *  |          reserved           |   |
 *  +-----------------------------+---+
< ASCII >
 *
 * Expect no allocation to happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1202.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_api.c#L403-L413

```c
/*
 * A test that tries to allocate memory when the memory is almost full,
 * but there is just enough space left:
< ASCII >
 *
 *  |---------------------------+---------|
 *  |          reserved         |   new   |
 *  +---------------------------+---------+
< ASCII >
 *
 * Expect to allocate memory and merge all the regions. The total size field
 * gets updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1203.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_api.c#L469-L481

```c
/*
 * A test that tries to allocate a region that is larger than the total size of
 * available memory (memblock.memory):
< ASCII >
 *
 *  +-----------------------------------+
 *  |                 new               |
 *  +-----------------------------------+
 *  |                                 |
 *  |                                 |
 *  +---------------------------------+
< ASCII >
 *
 * Expect no allocation to happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1204.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_api.c#L531-L547

```c
/*
 * A test that tries to allocate memory next to a reserved region that starts at
 * the misaligned address. Expect to create two separate entries, with the new
 * entry aligned to the provided alignment:
< ASCII >
 *
 *                      +
 *  |    +----------+   +----------+     |
 *  |    |   rgn1   |   |   rgn2   |     |
 *  +----+----------+---+----------+-----+
 *                      ^
 *                      |
 *                      Aligned address boundary
< ASCII >
 *
 * The allocation direction is bottom-up, so the new region will be the second
 * entry in memory.reserved array. The previously reserved region does not get
 * modified. Region counter and total size get updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1205.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_api.c#L590-L599

```c
/*
 * A test that tries to allocate memory when there is enough space at
 * the beginning of the previously reserved block (i.e. first fit):
< ASCII >
 *
 *  |------------------+--------+         |
 *  |        r1        |   r2   |         |
 *  +------------------+--------+---------+
< ASCII >
 *
 * Expect a merge of both regions. Only the region size gets updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1206.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_api.c#L629-L638

```c
/*
 * A test that tries to allocate memory when there is not enough space at
 * the beginning of the previously reserved block (i.e. second fit):
< ASCII >
 *
 *  |    +--------+--------------+         |
 *  |    |   r1   |      r2      |         |
 *  +----+--------+--------------+---------+
< ASCII >
 *
 * Expect a merge of both regions. Only the region size gets updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1207.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_api.c#L676-L688

```c
/*
 * A test that tries to allocate memory when there are two reserved regions, the
 * first one starting at the beginning of the available memory, with a gap too
 * small to fit the new region:
< ASCII >
 *
 *  |------------+     +--------+--------+  |
 *  |     r1     |     |   r2   |   r3   |  |
 *  +------------+-----+--------+--------+--+
< ASCII >
 *
 * Expect to allocate after the second region, which starts at the higher
 * address, and merge them into one. The region counter and total size fields
 * get updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1208.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L64-L78

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * is partially reserved but has enough memory for the allocated region:
< ASCII >
 *
 *  |           +---------------------------------------+          |
 *  |           |               requested               |          |
 *  +-----------+---------------------------------------+----------+
 *
 *  |           +------------------+              +-----+          |
 *  |           |     reserved     |              | new |          |
 *  +-----------+------------------+--------------+-----+----------+
< ASCII >
 *
 * Expect to allocate an aligned region at the end of the requested node. The
 * region count and total size get updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1209.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L120-L139

```c
/*
 * A test that tries to allocate a memory region that spans over the min_addr
 * and max_addr range and overlaps with two different nodes, where the first
 * node is the requested node:
< ASCII >
 *
 *                                min_addr
 *                                |           max_addr
 *                                |           |
 *                                v           v
 *  |           +-----------------------+-----------+              |
 *  |           |       requested       |   node3   |              |
 *  +-----------+-----------------------+-----------+--------------+
 *                                +           +
 *  |                       +-----------+                          |
 *  |                       |    rgn    |                          |
 *  +-----------------------+-----------+--------------------------+
< ASCII >
 *
 * Expect to drop the lower limit and allocate a memory region that ends at
 * the end of the requested node.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_121.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/parisc/math-emu/float.h#L39-L47

```c
/*
 * Declare the basic structures for the 3 different
 * floating-point precisions.
 *        
< ASCII >
 * Single number  
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |s|       exp     |               mantissa                      |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1210.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L177-L196

```c
/*
 * A test that tries to allocate a memory region that spans over the min_addr
 * and max_addr range and overlaps with two different nodes, where the requested
 * node ends before min_addr:
 *
< ASCII >
 *                                         min_addr
 *                                         |         max_addr
 *                                         |         |
 *                                         v         v
 *  |    +---------------+        +-------------+---------+          |
 *  |    |   requested   |        |    node1    |  node2  |          |
 *  +----+---------------+--------+-------------+---------+----------+
 *                                         +         +
 *  |          +---------+                                           |
 *  |          |   rgn   |                                           |
 *  +----------+---------+-------------------------------------------+
< ASCII >
 *
 * Expect to drop the lower limit and allocate a memory region that ends at
 * the end of the requested node.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1211.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L234-L254

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range when
 * the requested node and the range do not overlap, and requested node ends
 * before min_addr. The range overlaps with multiple nodes along node
 * boundaries:
< ASCII >
 *
 *                          min_addr
 *                          |                                 max_addr
 *                          |                                 |
 *                          v                                 v
 *  |-----------+           +----------+----...----+----------+      |
 *  | requested |           | min node |    ...    | max node |      |
 *  +-----------+-----------+----------+----...----+----------+------+
 *                          +                                 +
 *  |     +-----+                                                    |
 *  |     | rgn |                                                    |
 *  +-----+-----+----------------------------------------------------+
< ASCII >
 *
 * Expect to drop the lower limit and allocate a memory region that ends at
 * the end of the requested node.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1212.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L333-L347

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * is partially reserved but has enough memory for the allocated region:
< ASCII >
 *
 *  |           +---------------------------------------+         |
 *  |           |               requested               |         |
 *  +-----------+---------------------------------------+---------+
 *
 *  |           +------------------+-----+                        |
 *  |           |     reserved     | new |                        |
 *  +-----------+------------------+-----+------------------------+
< ASCII >
 *
 * Expect to allocate an aligned region in the requested node that merges with
 * the existing reserved region. The total size gets updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1213.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L391-L410

```c
/*
 * A test that tries to allocate a memory region that spans over the min_addr
 * and max_addr range and overlaps with two different nodes, where the first
 * node is the requested node:
 *
 *                                min_addr
 *                                |           max_addr
 *                                |           |
 *                                v           v
 *  |           +-----------------------+-----------+              |
 *  |           |       requested       |   node3   |              |
 *  +-----------+-----------------------+-----------+--------------+
 *                                +           +
 *  |           +-----------+                                      |
 *  |           |    rgn    |                                      |
 *  +-----------+-----------+--------------------------------------+
< ASCII >
 *
 * Expect to drop the lower limit and allocate a memory region at the beginning
 * of the requested node.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1214.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L448-L467

```c
/*
 * A test that tries to allocate a memory region that spans over the min_addr
 * and max_addr range and overlaps with two different nodes, where the requested
 * node ends before min_addr:
< ASCII >
 *
 *                                          min_addr
 *                                         |         max_addr
 *                                         |         |
 *                                         v         v
 *  |    +---------------+        +-------------+---------+         |
 *  |    |   requested   |        |    node1    |  node2  |         |
 *  +----+---------------+--------+-------------+---------+---------+
 *                                         +         +
 *  |    +---------+                                                |
 *  |    |   rgn   |                                                |
 *  +----+---------+------------------------------------------------+
< ASCII >
 *
 * Expect to drop the lower limit and allocate a memory region that starts at
 * the beginning of the requested node.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1215.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L505-L525

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range when
 * the requested node and the range do not overlap, and requested node ends
 * before min_addr. The range overlaps with multiple nodes along node
 * boundaries:
< ASCII >
 *
 *                          min_addr
 *                          |                                 max_addr
 *                          |                                 |
 *                          v                                 v
 *  |-----------+           +----------+----...----+----------+      |
 *  | requested |           | min node |    ...    | max node |      |
 *  +-----------+-----------+----------+----...----+----------+------+
 *                          +                                 +
 *  |-----+                                                          |
 *  | rgn |                                                          |
 *  +-----+----------------------------------------------------------+
< ASCII >
 *
 * Expect to drop the lower limit and allocate a memory region that starts at
 * the beginning of the requested node.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1216.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L563-L576

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * does not have enough memory to allocate a region of the requested size:
< ASCII >
 *
 *  |   +-----+                            |
 *  |   | req |                            |
 *  +---+-----+----------------------------+
 *
 *  +---------+
 *  |   rgn   |
 *  +---------+
< ASCII >
 *
 * Expect no allocation to happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1217.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L604-L617

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * is fully reserved:
< ASCII >
 *
 *  |              +---------+             |
 *  |              |requested|             |
 *  +--------------+---------+-------------+
 *
 *  |              +---------+             |
 *  |              | reserved|             |
 *  +--------------+---------+-------------+
< ASCII >
 *
 * Expect no allocation to happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1218.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L646-L660

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * is partially reserved and does not have enough contiguous memory for the
 * allocated region:
< ASCII >
 *
 *  |           +-----------------------+    |
 *  |           |       requested       |    |
 *  +-----------+-----------------------+----+
 *
 *  |                 +----------+           |
 *  |                 | reserved |           |
 *  +-----------------+----------+-----------+
< ASCII >
 *
 * Expect no allocation to happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1219.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L694-L708

```c
/*
 * A test that tries to allocate a memory region that spans over the min_addr
 * and max_addr range and overlaps with two different nodes, where the second
 * node is the requested node:
< ASCII >
 *
 *                               min_addr
 *                               |         max_addr
 *                               |         |
 *                               v         v
 *  |      +--------------------------+---------+                |
 *  |      |        first node        |requested|                |
 *  +------+--------------------------+---------+----------------+
< ASCII >
 *
 * Expect no allocation to happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_122.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/parisc/math-emu/float.h#L95-L104

```c
/* 
< ASCII >
 * Double number.
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |s|       exponent      |          mantissa part 1              |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |                    mantissa part 2                            |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1220.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L735-L750

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range when
 * the requested node and the range do not overlap, and requested node starts
 * after max_addr. The range overlaps with multiple nodes along node
 * boundaries:
< ASCII >
 *
 *        min_addr
 *        |                                 max_addr
 *        |                                 |
 *        v                                 v
 *  |     +----------+----...----+----------+        +-----------+   |
 *  |     | min node |    ...    | max node |        | requested |   |
 *  +-----+----------+----...----+----------+--------+-----------+---+
< ASCII >
 *
 * Expect no allocation to happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1221.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L778-L791

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * does not have enough memory to allocate a region of the requested size.
 * Additionally, none of the nodes have enough memory to allocate the region:
< ASCII >
 *
 * +-----------------------------------+
 * |                new                |
 * +-----------------------------------+
 *     |-------+-------+-------+-------+-------+-------+-------+-------|
 *     | node0 | node1 | node2 | node3 | node4 | node5 | node6 | node7 |
 *     +-------+-------+-------+-------+-------+-------+-------+-------+
< ASCII >
 *
 * Expect no allocation to happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1222.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L816-L836

```c
/*
 * A test that tries to allocate memory within min_addr and max_addr range when
 * there are two reserved regions at the borders. The requested node starts at
 * min_addr and ends at max_addr and is the same size as the region to be
 * allocated:
< ASCII >
 *
 *                     min_addr
 *                     |                       max_addr
 *                     |                       |
 *                     v                       v
 *  |      +-----------+-----------------------+-----------------------|
 *  |      |   node5   |       requested       |         node7         |
 *  +------+-----------+-----------------------+-----------------------+
 *                     +                       +
 *  |             +----+-----------------------+----+                  |
 *  |             | r2 |          new          | r1 |                  |
 *  +-------------+----+-----------------------+----+------------------+
< ASCII >
 *
 * Expect to merge all of the regions into one. The region counter and total
 * size fields get updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1223.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_exact_nid_api.c#L888-L911

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range,
 * where the total range can fit the region, but it is split between two nodes
 * and everything else is reserved. Additionally, nid is set to NUMA_NO_NODE
 * instead of requesting a specific node:
< ASCII >
 *
 *                         +-----------+
 *                         |    new    |
 *                         +-----------+
 *  |      +---------------------+-----------|
 *  |      |      prev node      | next node |
 *  +------+---------------------+-----------+
 *                         +           +
 *  |----------------------+           +-----|
 *  |          r1          |           |  r2 |
 *  +----------------------+-----------+-----+
 *                         ^           ^
 *                         |           |
 *                         |           max_addr
 *                         |
 *                         min_addr
< ASCII >
 *
 * Expect no allocation to happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1224.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_helpers_api.c#L4-L17

```c
/*
 * A simple test that tries to allocate a memory region above a specified,
 * aligned address:
< ASCII >
 *
 *             +
 *  |          +-----------+         |
 *  |          |    rgn    |         |
 *  +----------+-----------+---------+
 *             ^
 *             |
 *             Aligned min_addr
< ASCII >
 *
 * Expect to allocate a cleared region at the minimal memory address.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1225.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_helpers_api.c#L46-L60

```c
/*
 * A test that tries to allocate a memory region above a certain address.
 * The minimal address here is not aligned:
< ASCII >
 *
 *         +      +
 *  |      +      +---------+            |
 *  |      |      |   rgn   |            |
 *  +------+------+---------+------------+
 *         ^      ^------.
 *         |             |
 *       min_addr        Aligned address
 *                       boundary
< ASCII >
 *
 * Expect to allocate a cleared region at the closest aligned memory address.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1226.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_helpers_api.c#L90-L107

```c
/*
 * A test that tries to allocate a memory region above an address that is too
 * close to the end of the memory:
< ASCII >
 *
 *              +        +
 *  |           +--------+---+      |
 *  |           |   rgn  +   |      |
 *  +-----------+--------+---+------+
 *              ^        ^
 *              |        |
 *              |        min_addr
 *              |
 *              Aligned address
 *              boundary
< ASCII >
 *
 * Expect to prioritize granting memory over satisfying the minimal address
 * requirement.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1227.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_helpers_api.c#L135-L150

```c
/*
 * A test that tries to allocate a memory region when there is no space
 * available above the minimal address above a certain address:
< ASCII >
 *
 *                     +
 *  |        +---------+-------------|
 *  |        |   rgn   |             |
 *  +--------+---------+-------------+
 *                     ^
 *                     |
 *                     min_addr
< ASCII >
 *
 * Expect to prioritize granting memory over satisfying the minimal address
 * requirement and to allocate next to the previously reserved region. The
 * regions get merged into one.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1228.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_helpers_api.c#L218-L233

```c
/*
 * A test that tries to allocate a memory region above an address that is too
 * close to the end of the memory:
< ASCII >
 *
 *                             +
 *  |-----------+              +     |
 *  |    rgn    |              |     |
 *  +-----------+--------------+-----+
 *  ^                          ^
 *  |                          |
 *  Aligned address            min_addr
 *  boundary
< ASCII >
 *
 * Expect to prioritize granting memory over satisfying the minimal address
 * requirement. Allocation happens at beginning of the available memory.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1229.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_helpers_api.c#L261-L275

```c
/*
 * A test that tries to allocate a memory region when there is no space
 * available above the minimal address above a certain address:
< ASCII >
 *
 *                   +
 *  |-----------+    +-------------------|
 *  |    rgn    |    |                   |
 *  +-----------+----+-------------------+
 *                   ^
 *                   |
 *                   min_addr
< ASCII >
 *
 * Expect to prioritize granting memory over satisfying the minimal address
 * requirement and to allocate at the beginning of the available memory.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_123.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/parisc/math-emu/float.h#L172-L189

```c
/* 
< ASCII >
 * Quad number.
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |s|          exponent           |      mantissa part 1          |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |                    mantissa part 2                            |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |                    mantissa part 3                            |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |                    mantissa part 4                            |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1230.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L50-L63

```c
/*
 * A simple test that tries to allocate a memory region within min_addr and
 * max_addr range:
< ASCII >
 *
 *        +                   +
 *   |    +       +-----------+      |
 *   |    |       |    rgn    |      |
 *   +----+-------+-----------+------+
 *        ^                   ^
 *        |                   |
 *        min_addr           max_addr
< ASCII >
 *
 * Expect to allocate a region that ends at max_addr.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1231.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L99-L115

```c
/*
 * A simple test that tries to allocate a memory region within min_addr and
 * max_addr range, where the end address is misaligned:
< ASCII >
 *
 *         +       +            +
 *  |      +       +---------+  +    |
 *  |      |       |   rgn   |  |    |
 *  +------+-------+---------+--+----+
 *         ^       ^            ^
 *         |       |            |
 *       min_add   |            max_addr
 *                 |
 *                 Aligned address
 *                 boundary
< ASCII >
 *
 * Expect to allocate an aligned region that ends before max_addr.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1232.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L152-L166

```c
/*
 * A simple test that tries to allocate a memory region, which spans over the
 * min_addr and max_addr range:
< ASCII >
 *
 *         +               +
 *  |      +---------------+       |
 *  |      |      rgn      |       |
 *  +------+---------------+-------+
 *         ^               ^
 *         |               |
 *         min_addr        max_addr
< ASCII >
 *
 * Expect to allocate a region that starts at min_addr and ends at
 * max_addr, given that min_addr is aligned.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1233.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L202-L218

```c
/*
 * A test that tries to allocate a memory region, which can't fit into
 * min_addr and max_addr range:
< ASCII >
 *
 *           +          +     +
 *  |        +----------+-----+    |
 *  |        |   rgn    +     |    |
 *  +--------+----------+-----+----+
 *           ^          ^     ^
 *           |          |     |
 *           Aligned    |    max_addr
 *           address    |
 *           boundary   min_add
< ASCII >
 *
 * Expect to drop the lower limit and allocate a memory region which
 * ends at max_addr (if the address is aligned).
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1234.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L251-L270

```c
/*
 * A test that tries to allocate a memory region, which can't fit into
 * min_addr and max_addr range, with the latter being too close to the beginning
 * of the available memory:
 *
< ASCII >
 *   +-------------+
 *   |     new     |
 *   +-------------+
 *         +       +
 *         |       +              |
 *         |       |              |
 *         +-------+--------------+
 *         ^       ^
 *         |       |
 *         |       max_addr
 *         |
 *         min_addr
< ASCII >
 *
 * Expect no allocation to happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1235.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L295-L308

```c
/*
 * A test that tries to allocate a memory region within min_addr min_addr range,
 * with min_addr being so close that it's next to an allocated region:
 *
< ASCII >
 *          +                        +
 *  |       +--------+---------------|
 *  |       |   r1   |      rgn      |
 *  +-------+--------+---------------+
 *          ^                        ^
 *          |                        |
 *          min_addr                 max_addr
< ASCII >
 *
 * Expect a merge of both regions. Only the region size gets updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1236.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L347-L360

```c
/*
 * A test that tries to allocate a memory region within min_addr and max_addr,
 * with max_addr being so close that it's next to an allocated region:
 *
< ASCII >
 *             +             +
 *  |          +-------------+--------|
 *  |          |     rgn     |   r1   |
 *  +----------+-------------+--------+
 *             ^             ^
 *             |             |
 *             min_addr      max_addr
< ASCII >
 *
 * Expect a merge of regions. Only the region size gets updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1237.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L397-L412

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range, when
 * there are two reserved regions at the borders, with a gap big enough to fit
 * a new region:
< ASCII >
 *
 *                +           +
 *  |    +--------+   +-------+------+  |
 *  |    |   r2   |   |  rgn  |  r1  |  |
 *  +----+--------+---+-------+------+--+
 *                ^           ^
 *                |           |
 *                min_addr    max_addr
< ASCII >
 *
 * Expect to merge the new region with r1. The second region does not get
 * updated. The total size field gets updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1238.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L463-L478

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range, when
 * there are two reserved regions at the borders, with a gap of a size equal to
 * the size of the new region:
< ASCII >
 *
 *                 +        +
 *  |     +--------+--------+--------+     |
 *  |     |   r2   |   r3   |   r1   |     |
 *  +-----+--------+--------+--------+-----+
 *                 ^        ^
 *                 |        |
 *                 min_addr max_addr
< ASCII >
 *
 * Expect to merge all of the regions into one. The region counter and total
 * size fields get updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1239.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L523-L540

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range, when
 * there are two reserved regions at the borders, with a gap that can't fit
 * a new region:
< ASCII >
 *
 *                       +    +
 *  |  +----------+------+    +------+   |
 *  |  |    r3    |  r2  |    |  r1  |   |
 *  +--+----------+------+----+------+---+
 *                       ^    ^
 *                       |    |
 *                       |    max_addr
 *                       |
 *                       min_addr
< ASCII >
 *
 * Expect to merge the new region with r2. The second region does not get
 * updated. The total size counter gets updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_124.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/parisc/math-emu/float.h#L284-L292

```c
/*
 * Declare the basic structures for the 3 different
 * fixed-point precisions.
 *        
< ASCII >
 * Single number  
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |s|                    integer                                  |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1240.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L590-L608

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range, but
 * it's too narrow and everything else is reserved:
 *
< ASCII >
 *            +-----------+
 *            |    new    |
 *            +-----------+
 *                 +      +
 *  |--------------+      +----------|
 *  |      r2      |      |    r1    |
 *  +--------------+------+----------+
 *                 ^      ^
 *                 |      |
 *                 |      max_addr
 *                 |
 *                 min_addr
< ASCII >
 *
 * Expect no allocation to happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1241.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L719-L732

```c
/*
 * A simple test that tries to allocate a memory region within min_addr and
 * max_addr range:
< ASCII >
 *
 *        +                       +
 *   |    +-----------+           |      |
 *   |    |    rgn    |           |      |
 *   +----+-----------+-----------+------+
 *        ^                       ^
 *        |                       |
 *        min_addr                max_addr
< ASCII >
 *
 * Expect to allocate a region that ends before max_addr.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1242.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L768-L784

```c
/*
 * A simple test that tries to allocate a memory region within min_addr and
 * max_addr range, where the start address is misaligned:
< ASCII >
 *
 *        +                     +
 *  |     +   +-----------+     +     |
 *  |     |   |    rgn    |     |     |
 *  +-----+---+-----------+-----+-----+
 *        ^   ^----.            ^
 *        |        |            |
 *     min_add     |            max_addr
 *                 |
 *                 Aligned address
 *                 boundary
< ASCII >
 *
 * Expect to allocate an aligned region that ends before max_addr.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1243.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L821-L837

```c
/*
 * A test that tries to allocate a memory region, which can't fit into min_addr
 * and max_addr range:
 *
< ASCII >
 *                      +    +
 *  |---------+         +    +      |
 *  |   rgn   |         |    |      |
 *  +---------+---------+----+------+
 *                      ^    ^
 *                      |    |
 *                      |    max_addr
 *                      |
 *                      min_add
< ASCII >
 *
 * Expect to drop the lower limit and allocate a memory region which
 * starts at the beginning of the available memory.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1244.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L870-L885

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range, when
 * there are two reserved regions at the borders, with a gap big enough to fit
 * a new region:
< ASCII >
 *
 *                +           +
 *  |    +--------+-------+   +------+  |
 *  |    |   r2   |  rgn  |   |  r1  |  |
 *  +----+--------+-------+---+------+--+
 *                ^           ^
 *                |           |
 *                min_addr    max_addr
< ASCII >
 *
 * Expect to merge the new region with r2. The second region does not get
 * updated. The total size field gets updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1245.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L936-L954

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range, when
 * there are two reserved regions at the borders, with a gap of a size equal to
 * the size of the new region:
< ASCII >
 *
 *                         +   +
 *  |----------+    +------+   +----+  |
 *  |    r3    |    |  r2  |   | r1 |  |
 *  +----------+----+------+---+----+--+
 *                         ^   ^
 *                         |   |
 *                         |  max_addr
 *                         |
 *                         min_addr
< ASCII >
 *
 * Expect to drop the lower limit and allocate memory at the beginning of the
 * available memory. The region counter and total size fields get updated.
 * Other regions are not modified.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1246.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L1279-L1293

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * does not have enough memory to allocate a region of the requested size:
 *
< ASCII >
 *  |   +-----+          +------------------+     |
 *  |   | req |          |     expected     |     |
 *  +---+-----+----------+------------------+-----+
 *
 *  |                             +---------+     |
 *  |                             |   rgn   |     |
 *  +-----------------------------+---------+-----+
< ASCII >
 *
 * Expect to allocate an aligned region at the end of the last node that has
 * enough memory (in this case, nid = 6) after falling back to NUMA_NO_NODE.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1247.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L1331-L1346

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * is fully reserved:
< ASCII >
 *
 *  |              +---------+            +------------------+     |
 *  |              |requested|            |     expected     |     |
 *  +--------------+---------+------------+------------------+-----+
 *
 *  |              +---------+                     +---------+     |
 *  |              | reserved|                     |   new   |     |
 *  +--------------+---------+---------------------+---------+-----+
< ASCII >
 *
 * Expect to allocate an aligned region at the end of the last node that is
 * large enough and has enough unreserved memory (in this case, nid = 6) after
 * falling back to NUMA_NO_NODE. The region count and total size get updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1248.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L1385-L1399

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * is partially reserved but has enough memory for the allocated region:
< ASCII >
 *
 *  |           +---------------------------------------+          |
 *  |           |               requested               |          |
 *  +-----------+---------------------------------------+----------+
 *
 *  |           +------------------+              +-----+          |
 *  |           |     reserved     |              | new |          |
 *  +-----------+------------------+--------------+-----+----------+
< ASCII >
 *
 * Expect to allocate an aligned region at the end of the requested node. The
 * region count and total size get updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1249.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L1440-L1457

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * is partially reserved and does not have enough contiguous memory for the
 * allocated region:
< ASCII >
 *
 *  |           +-----------------------+         +----------------------|
 *  |           |       requested       |         |       expected       |
 *  +-----------+-----------------------+---------+----------------------+
 *
 *  |                 +----------+                           +-----------|
 *  |                 | reserved |                           |    new    |
 *  +-----------------+----------+---------------------------+-----------+
< ASCII >
 *
 * Expect to allocate an aligned region at the end of the last node that is
 * large enough and has enough unreserved memory (in this case,
 * nid = NUMA_NODES - 1) after falling back to NUMA_NO_NODE. The region count
 * and total size get updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_125.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/parisc/math-emu/float.h#L295-L304

```c
/* 
< ASCII >
 * Double number.
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |s|                     high integer                            |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |                       low integer                             |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1250.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L1501-L1520

```c
/*
 * A test that tries to allocate a memory region that spans over the min_addr
 * and max_addr range and overlaps with two different nodes, where the first
 * node is the requested node:
 *
< ASCII >
 *                                min_addr
 *                                |           max_addr
 *                                |           |
 *                                v           v
 *  |           +-----------------------+-----------+              |
 *  |           |       requested       |   node3   |              |
 *  +-----------+-----------------------+-----------+--------------+
 *                                +           +
 *  |                       +-----------+                          |
 *  |                       |    rgn    |                          |
 *  +-----------------------+-----------+--------------------------+
< ASCII >
 *
 * Expect to drop the lower limit and allocate a memory region that ends at
 * the end of the requested node.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1251.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L1557-L1576

```c
/*
 * A test that tries to allocate a memory region that spans over the min_addr
 * and max_addr range and overlaps with two different nodes, where the second
 * node is the requested node:
< ASCII >
 *
 *                               min_addr
 *                               |         max_addr
 *                               |         |
 *                               v         v
 *  |      +--------------------------+---------+                |
 *  |      |         expected         |requested|                |
 *  +------+--------------------------+---------+----------------+
 *                               +         +
 *  |                       +---------+                          |
 *  |                       |   rgn   |                          |
 *  +-----------------------+---------+--------------------------+
< ASCII >
 *
 * Expect to drop the lower limit and allocate a memory region that
 * ends at the end of the first node that overlaps with the range.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1252.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L1614-L1633

```c
/*
 * A test that tries to allocate a memory region that spans over the min_addr
 * and max_addr range and overlaps with two different nodes, where the requested
 * node ends before min_addr:
< ASCII >
 *
 *                                         min_addr
 *                                         |         max_addr
 *                                         |         |
 *                                         v         v
 *  |    +---------------+        +-------------+---------+          |
 *  |    |   requested   |        |    node1    |  node2  |          |
 *  +----+---------------+--------+-------------+---------+----------+
 *                                         +         +
 *  |          +---------+                                           |
 *  |          |   rgn   |                                           |
 *  +----------+---------+-------------------------------------------+
< ASCII >
 *
 * Expect to drop the lower limit and allocate a memory region that ends at
 * the end of the requested node.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1253.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L1670-L1690

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range when
 * the requested node and the range do not overlap, and requested node ends
 * before min_addr. The range overlaps with multiple nodes along node
 * boundaries:
< ASCII >
 *
 *                          min_addr
 *                          |                                 max_addr
 *                          |                                 |
 *                          v                                 v
 *  |-----------+           +----------+----...----+----------+      |
 *  | requested |           | min node |    ...    | max node |      |
 *  +-----------+-----------+----------+----...----+----------+------+
 *                          +                                 +
 *  |                                                   +-----+      |
 *  |                                                   | rgn |      |
 *  +---------------------------------------------------+-----+------+
< ASCII >
 *
 * Expect to allocate a memory region at the end of the final node in
 * the range after falling back to NUMA_NO_NODE.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1254.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L1726-L1746

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range when
 * the requested node and the range do not overlap, and requested node starts
 * after max_addr. The range overlaps with multiple nodes along node
 * boundaries:
< ASCII >
 *
 *        min_addr
 *        |                                 max_addr
 *        |                                 |
 *        v                                 v
 *  |     +----------+----...----+----------+        +-----------+   |
 *  |     | min node |    ...    | max node |        | requested |   |
 *  +-----+----------+----...----+----------+--------+-----------+---+
 *        +                                 +
 *  |                                 +-----+                        |
 *  |                                 | rgn |                        |
 *  +---------------------------------+-----+------------------------+
< ASCII >
 *
 * Expect to allocate a memory region at the end of the final node in
 * the range after falling back to NUMA_NO_NODE.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1255.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L1823-L1837

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * does not have enough memory to allocate a region of the requested size:
< ASCII >
 *
 *  |----------------------+-----+                |
 *  |       expected       | req |                |
 *  +----------------------+-----+----------------+
 *
 *  |---------+                                   |
 *  |   rgn   |                                   |
 *  +---------+-----------------------------------+
< ASCII >
 *
 * Expect to allocate an aligned region at the beginning of the first node that
 * has enough memory (in this case, nid = 0) after falling back to NUMA_NO_NODE.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1256.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L1875-L1891

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * is fully reserved:
< ASCII >
 *
 *  |----------------------+     +-----------+                    |
 *  |       expected       |     | requested |                    |
 *  +----------------------+-----+-----------+--------------------+
 *
 *  |-----------+                +-----------+                    |
 *  |    new    |                |  reserved |                    |
 *  +-----------+----------------+-----------+--------------------+
< ASCII >
 *
 * Expect to allocate an aligned region at the beginning of the first node that
 * is large enough and has enough unreserved memory (in this case, nid = 0)
 * after falling back to NUMA_NO_NODE. The region count and total size get
 * updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1257.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L1930-L1944

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * is partially reserved but has enough memory for the allocated region:
< ASCII >
 *
 *  |           +---------------------------------------+         |
 *  |           |               requested               |         |
 *  +-----------+---------------------------------------+---------+
 *
 *  |           +------------------+-----+                        |
 *  |           |     reserved     | new |                        |
 *  +-----------+------------------+-----+------------------------+
< ASCII >
 *
 * Expect to allocate an aligned region in the requested node that merges with
 * the existing reserved region. The total size gets updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1258.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L1987-L2004

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * is partially reserved and does not have enough contiguous memory for the
 * allocated region:
< ASCII >
 *
 *  |----------------------+       +-----------------------+         |
 *  |       expected       |       |       requested       |         |
 *  +----------------------+-------+-----------------------+---------+
 *
 *  |-----------+                        +----------+                |
 *  |    new    |                        | reserved |                |
 *  +-----------+------------------------+----------+----------------+
< ASCII >
 *
 * Expect to allocate an aligned region at the beginning of the first
 * node that is large enough and has enough unreserved memory (in this case,
 * nid = 0) after falling back to NUMA_NO_NODE. The region count and total size
 * get updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1259.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L2048-L2067

```c
/*
 * A test that tries to allocate a memory region that spans over the min_addr
 * and max_addr range and overlaps with two different nodes, where the first
 * node is the requested node:
< ASCII >
 *
 *                                min_addr
 *                                |           max_addr
 *                                |           |
 *                                v           v
 *  |           +-----------------------+-----------+              |
 *  |           |       requested       |   node3   |              |
 *  +-----------+-----------------------+-----------+--------------+
 *                                +           +
 *  |           +-----------+                                      |
 *  |           |    rgn    |                                      |
 *  +-----------+-----------+--------------------------------------+
< ASCII >
 *
 * Expect to drop the lower limit and allocate a memory region at the beginning
 * of the requested node.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_126.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/parisc/math-emu/float.h#L315-L332

```c
/* 
< ASCII >
 * Quad number.
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |s|                  integer part1                              |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |                    integer part 2                             |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |                    integer part 3                             |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |                    integer part 4                             |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1260.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L2104-L2123

```c
/*
 * A test that tries to allocate a memory region that spans over the min_addr
 * and max_addr range and overlaps with two different nodes, where the second
 * node is the requested node:
< ASCII >
 *
 *                                                min_addr
 *                                                |         max_addr
 *                                                |         |
 *                                                v         v
 *  |------------------+        +----------------------+---------+      |
 *  |     expected     |        |       previous       |requested|      |
 *  +------------------+--------+----------------------+---------+------+
 *                                                +         +
 *  |---------+                                                         |
 *  |   rgn   |                                                         |
 *  +---------+---------------------------------------------------------+
< ASCII >
 *
 * Expect to drop the lower limit and allocate a memory region at the beginning
 * of the first node that has enough memory.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1261.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L2162-L2181

```c
/*
 * A test that tries to allocate a memory region that spans over the min_addr
 * and max_addr range and overlaps with two different nodes, where the requested
 * node ends before min_addr:
 *
< ASCII >
 *                                          min_addr
 *                                         |         max_addr
 *                                         |         |
 *                                         v         v
 *  |    +---------------+        +-------------+---------+         |
 *  |    |   requested   |        |    node1    |  node2  |         |
 *  +----+---------------+--------+-------------+---------+---------+
 *                                         +         +
 *  |    +---------+                                                |
 *  |    |   rgn   |                                                |
 *  +----+---------+------------------------------------------------+
< ASCII >
 *
 * Expect to drop the lower limit and allocate a memory region that starts at
 * the beginning of the requested node.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1262.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L2218-L2238

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range when
 * the requested node and the range do not overlap, and requested node ends
 * before min_addr. The range overlaps with multiple nodes along node
 * boundaries:
< ASCII >
 *
 *                          min_addr
 *                          |                                 max_addr
 *                          |                                 |
 *                          v                                 v
 *  |-----------+           +----------+----...----+----------+      |
 *  | requested |           | min node |    ...    | max node |      |
 *  +-----------+-----------+----------+----...----+----------+------+
 *                          +                                 +
 *  |                       +-----+                                  |
 *  |                       | rgn |                                  |
 *  +-----------------------+-----+----------------------------------+
< ASCII >
 *
 * Expect to allocate a memory region at the beginning of the first node
 * in the range after falling back to NUMA_NO_NODE.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1263.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L2274-L2294

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range when
 * the requested node and the range do not overlap, and requested node starts
 * after max_addr. The range overlaps with multiple nodes along node
 * boundaries:
< ASCII >
 *
 *        min_addr
 *        |                                 max_addr
 *        |                                 |
 *        v                                 v
 *  |     +----------+----...----+----------+         +---------+   |
 *  |     | min node |    ...    | max node |         |requested|   |
 *  +-----+----------+----...----+----------+---------+---------+---+
 *        +                                 +
 *  |     +-----+                                                   |
 *  |     | rgn |                                                   |
 *  +-----+-----+---------------------------------------------------+
< ASCII >
 *
 * Expect to allocate a memory region at the beginning of the first node
 * in the range after falling back to NUMA_NO_NODE.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1264.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L2330-L2343

```c
/*
 * A test that tries to allocate a memory region in a specific NUMA node that
 * does not have enough memory to allocate a region of the requested size.
 * Additionally, none of the nodes have enough memory to allocate the region:
< ASCII >
 *
 * +-----------------------------------+
 * |                new                |
 * +-----------------------------------+
 *     |-------+-------+-------+-------+-------+-------+-------+-------|
 *     | node0 | node1 | node2 | node3 | node4 | node5 | node6 | node7 |
 *     +-------+-------+-------+-------+-------+-------+-------+-------+
< ASCII >
 *
 * Expect no allocation to happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1265.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L2367-L2387

```c
/*
 * A test that tries to allocate memory within min_addr and max_addr range when
 * there are two reserved regions at the borders. The requested node starts at
 * min_addr and ends at max_addr and is the same size as the region to be
 * allocated:
< ASCII >
 *
 *                     min_addr
 *                     |                       max_addr
 *                     |                       |
 *                     v                       v
 *  |      +-----------+-----------------------+-----------------------|
 *  |      |   node5   |       requested       |         node7         |
 *  +------+-----------+-----------------------+-----------------------+
 *                     +                       +
 *  |             +----+-----------------------+----+                  |
 *  |             | r2 |          new          | r1 |                  |
 *  +-------------+----+-----------------------+----+------------------+
< ASCII >
 *
 * Expect to merge all of the regions into one. The region counter and total
 * size fields get updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1266.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/alloc_nid_api.c#L2438-L2461

```c
/*
 * A test that tries to allocate memory within min_addr and max_add range,
 * where the total range can fit the region, but it is split between two nodes
 * and everything else is reserved. Additionally, nid is set to NUMA_NO_NODE
 * instead of requesting a specific node:
< ASCII >
 *
 *                         +-----------+
 *                         |    new    |
 *                         +-----------+
 *  |      +---------------------+-----------|
 *  |      |      prev node      | next node |
 *  +------+---------------------+-----------+
 *                         +           +
 *  |----------------------+           +-----|
 *  |          r1          |           |  r2 |
 *  +----------------------+-----------+-----+
 *                         ^           ^
 *                         |           |
 *                         |           max_addr
 *                         |
 *                         min_addr
< ASCII >
 *
 * Expect no allocation to happen.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1267.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L105-L116

```c
/*
 * A test that tries to add two memory blocks that don't overlap with one
 * another:
< ASCII >
 *
 *  |        +--------+        +--------+  |
 *  |        |   r1   |        |   r2   |  |
 *  +--------+--------+--------+--------+--+
< ASCII >
 *
 * Expect to add two correctly initialized entries to the collection of
 * available memory regions (memblock.memory). The total size and
 * region counter fields get updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1268.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L153-L169

```c
/*
 * A test that tries to add two memory blocks r1 and r2, where r2 overlaps
 * with the beginning of r1 (that is r1.base < r2.base + r2.size):
< ASCII >
 *
 *  |    +----+----+------------+          |
 *  |    |    |r2  |   r1       |          |
 *  +----+----+----+------------+----------+
 *       ^    ^
 *       |    |
 *       |    r1.base
 *       |
 *       r2.base
< ASCII >
 *
 * Expect to merge the two entries into one region that starts at r2.base
 * and has size of two regions minus their intersection. The total size of
 * the available memory is updated, and the region counter stays the same.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1269.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L205-L221

```c
/*
 * A test that tries to add two memory blocks r1 and r2, where r2 overlaps
 * with the end of r1 (that is r2.base < r1.base + r1.size):
< ASCII >
 *
 *  |  +--+------+----------+              |
 *  |  |  | r1   | r2       |              |
 *  +--+--+------+----------+--------------+
 *     ^  ^
 *     |  |
 *     |  r2.base
 *     |
 *     r1.base
< ASCII >
 *
 * Expect to merge the two entries into one region that starts at r1.base
 * and has size of two regions minus their intersection. The total size of
 * the available memory is updated, and the region counter stays the same.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_127.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/parisc/math-emu/float.h#L403-L409

```c
/* Declare status register equivalent to FPUs architecture.
 *
< ASCII >
 *  0 1 2 3 4 5 6 7 8 910 1 2 3 4 5 6 7 8 920 1 2 3 4 5 6 7 8 930 1
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |V|Z|O|U|I|C|  rsv  |  model    | version |RM |rsv|T|r|V|Z|O|U|I|
 * +-------+-------+-------+-------+-------+-------+-------+-------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1270.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L257-L271

```c
/*
 * A test that tries to add two memory blocks r1 and r2, where r2 is
 * within the range of r1 (that is r1.base < r2.base &&
 * r2.base + r2.size < r1.base + r1.size):
< ASCII >
 *
 *  |   +-------+--+-----------------------+
 *  |   |       |r2|      r1               |
 *  +---+-------+--+-----------------------+
 *      ^
 *      |
 *      r1.base
< ASCII >
 *
 * Expect to merge two entries into one region that stays the same.
 * The counter and total size of available memory are not updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1271.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L330-L341

```c
/*
 * A test that tries to add two memory blocks that don't overlap with one
 * another and then add a third memory block in the space between the first two:
< ASCII >
 *
 *  |        +--------+--------+--------+  |
 *  |        |   r1   |   r3   |   r2   |  |
 *  +--------+--------+--------+--------+--+
< ASCII >
 *
 * Expect to merge the three entries into one region that starts at r1.base
 * and has size of r1.size + r2.size + r3.size. The region counter and total
 * size of the available memory are updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1272.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L382-L395

```c
/*
 * A simple test that tries to add a memory block r when r extends past
 * PHYS_ADDR_MAX:
< ASCII >
 *
 *                               +--------+
 *                               |    r   |
 *                               +--------+
 *  |                            +----+
 *  |                            | rgn|
 *  +----------------------------+----+
< ASCII >
 *
 * Expect to add a memory block of size PHYS_ADDR_MAX - r.base. Expect the
 * total size of available memory and the counter to be updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1273.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L570-L580

```c
/*
 * A test that tries to mark two memory blocks that don't overlap as reserved:
 *
< ASCII >
 *  |        +--+      +----------------+  |
 *  |        |r1|      |       r2       |  |
 *  +--------+--+------+----------------+--+
< ASCII >
 *
 * Expect to add two entries to the collection of reserved memory regions
 * (memblock.reserved). The total size and region counter for
 * memblock.reserved are updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1274.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L617-L634

```c
/*
 * A test that tries to mark two memory blocks r1 and r2 as reserved,
 * where r2 overlaps with the beginning of r1 (that is
 * r1.base < r2.base + r2.size):
< ASCII >
 *
 *  |  +--------------+--+--------------+  |
 *  |  |       r2     |  |     r1       |  |
 *  +--+--------------+--+--------------+--+
 *     ^              ^
 *     |              |
 *     |              r1.base
 *     |
 *     r2.base
< ASCII >
 *
 * Expect to merge two entries into one region that starts at r2.base and
 * has size of two regions minus their intersection. The total size of the
 * reserved memory is updated, and the region counter is not updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1275.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L670-L687

```c
/*
 * A test that tries to mark two memory blocks r1 and r2 as reserved,
 * where r2 overlaps with the end of r1 (that is
 * r2.base < r1.base + r1.size):
< ASCII >
 *
 *  |  +--------------+--+--------------+  |
 *  |  |       r1     |  |     r2       |  |
 *  +--+--------------+--+--------------+--+
 *     ^              ^
 *     |              |
 *     |              r2.base
 *     |
 *     r1.base
< ASCII >
 *
 * Expect to merge two entries into one region that starts at r1.base and
 * has size of two regions minus their intersection. The total size of the
 * reserved memory is updated, and the region counter is not updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1276.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L723-L739

```c
/*
 * A test that tries to mark two memory blocks r1 and r2 as reserved,
 * where r2 is within the range of r1 (that is
 * (r1.base < r2.base) && (r2.base + r2.size < r1.base + r1.size)):
< ASCII >
 *
 *  | +-----+--+---------------------------|
 *  | |     |r2|          r1               |
 *  +-+-----+--+---------------------------+
 *    ^     ^
 *    |     |
 *    |     r2.base
 *    |
 *    r1.base
< ASCII >
 *
 * Expect to merge two entries into one region that stays the same. The
 * counter and total size of available memory are not updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1277.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L799-L810

```c
/*
 * A test that tries to mark two memory blocks that don't overlap as reserved
 * and then reserve a third memory block in the space between the first two:
< ASCII >
 *
 *  |        +--------+--------+--------+  |
 *  |        |   r1   |   r3   |   r2   |  |
 *  +--------+--------+--------+--------+--+
< ASCII >
 *
 * Expect to merge the three entries into one reserved region that starts at
 * r1.base and has size of r1.size + r2.size + r3.size. The region counter and
 * total for memblock.reserved are updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1278.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L851-L864

```c
/*
 * A simple test that tries to reserve a memory block r when r extends past
 * PHYS_ADDR_MAX:
< ASCII >
 *
 *                               +--------+
 *                               |    r   |
 *                               +--------+
 *  |                            +----+
 *  |                            | rgn|
 *  +----------------------------+----+
< ASCII >
 *
 * Expect to reserve a memory block of size PHYS_ADDR_MAX - r.base. Expect the
 * total size of reserved memory and the counter to be updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1279.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1006-L1021

```c
/*
 * A simple test that tries to remove a region r1 from the array of
 * available memory regions. By "removing" a region we mean overwriting it
 * with the next region r2 in memblock.memory:
< ASCII >
 *
 *  |  ......          +----------------+  |
 *  |  : r1 :          |       r2       |  |
 *  +--+----+----------+----------------+--+
 *                     ^
 *                     |
 *                     rgn.base
< ASCII >
 *
 * Expect to add two memory blocks r1 and r2 and then remove r1 so that
 * r2 is the first available region. The region counter and total size
 * are updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_128.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/parisc/math-emu/float.h#L448-L454

```c
/* Declare exception registers equivalent to FPUs architecture 
 *
< ASCII >
 *  0 1 2 3 4 5 6 7 8 910 1 2 3 4 5 6 7 8 920 1 2 3 4 5 6 7 8 930 1
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |excepttype |  r1     | r2/ext  |  operation  |parm |n| t/cond  |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1280.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1055-L1070

```c
/*
 * A test that tries to remove a region r2 that was not registered as
 * available memory (i.e. has no corresponding entry in memblock.memory):
< ASCII >
 *
 *                     +----------------+
 *                     |       r2       |
 *                     +----------------+
 *  |  +----+                              |
 *  |  | r1 |                              |
 *  +--+----+------------------------------+
 *     ^
 *     |
 *     rgn.base
< ASCII >
 *
 * Expect the array, regions counter and total size to not be modified.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1281.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1103-L1121

```c
/*
 * A test that tries to remove a region r2 that overlaps with the
 * beginning of the already existing entry r1
 * (that is r1.base < r2.base + r2.size):
< ASCII >
 *
 *           +-----------------+
 *           |       r2        |
 *           +-----------------+
 *  |                 .........+--------+  |
 *  |                 :     r1 |  rgn   |  |
 *  +-----------------+--------+--------+--+
 *                    ^        ^
 *                    |        |
 *                    |        rgn.base
 *                    r1.base
 *
< ASCII >
 * Expect that only the intersection of both regions is removed from the
 * available memory pool. The regions counter and total size are updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1282.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1159-L1175

```c
/*
 * A test that tries to remove a region r2 that overlaps with the end of
 * the already existing region r1 (that is r2.base < r1.base + r1.size):
 *
< ASCII >
 *        +--------------------------------+
 *        |               r2               |
 *        +--------------------------------+
 *  | +---+.....                           |
 *  | |rgn| r1 :                           |
 *  +-+---+----+---------------------------+
 *    ^
 *    |
 *    r1.base
< ASCII >
 *
 * Expect that only the intersection of both regions is removed from the
 * available memory pool. The regions counter and total size are updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1283.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1211-L1229

```c
/*
 * A test that tries to remove a region r2 that is within the range of
 * the already existing entry r1 (that is
 * (r1.base < r2.base) && (r2.base + r2.size < r1.base + r1.size)):
< ASCII >
 *
 *                  +----+
 *                  | r2 |
 *                  +----+
 *  | +-------------+....+---------------+ |
 *  | |     rgn1    | r1 |     rgn2      | |
 *  +-+-------------+----+---------------+-+
 *    ^
 *    |
 *    r1.base
< ASCII >
 *
 * Expect that the region is split into two - one that ends at r2.base and
 * another that starts at r2.base + r2.size, with appropriate sizes. The
 * region counter and total size are updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1284.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1306-L1320

```c
/*
 * A simple test that tries remove a region r2 from the array of available
 * memory regions when r2 extends past PHYS_ADDR_MAX:
< ASCII >
 *
 *                               +--------+
 *                               |   r2   |
 *                               +--------+
 *  |                        +---+....+
 *  |                        |rgn|    |
 *  +------------------------+---+----+
< ASCII >
 *
 * Expect that only the portion between PHYS_ADDR_MAX and r2.base is removed.
 * Expect the total size of available memory to be updated and the counter to
 * not be updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1285.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1357-L1371

```c
/*
 * A test that tries to remove a region r3 that overlaps with two existing
 * regions r1 and r2:
< ASCII >
 *
 *            +----------------+
 *            |       r3       |
 *            +----------------+
 *  |    +----+.....   ........+--------+
 *  |    |    |r1  :   :       |r2      |     |
 *  +----+----+----+---+-------+--------+-----+
< ASCII >
 *
 * Expect that only the intersections of r1 with r3 and r2 with r3 are removed
 * from the available memory pool. Expect the total size of available memory to
 * be updated and the counter to not be updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1286.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1440-L1454

```c
/*
 * A simple test that tries to free a memory block r1 that was marked
 * earlier as reserved. By "freeing" a region we mean overwriting it with
 * the next entry r2 in memblock.reserved:
< ASCII >
 *
 *  |              ......           +----+ |
 *  |              : r1 :           | r2 | |
 *  +--------------+----+-----------+----+-+
 *                                  ^
 *                                  |
 *                                  rgn.base
< ASCII >
 *
 * Expect to reserve two memory regions and then erase r1 region with the
 * value of r2. The region counter and total size are updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1287.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1488-L1503

```c
/*
 * A test that tries to free a region r2 that was not marked as reserved
 * (i.e. has no corresponding entry in memblock.reserved):
< ASCII >
 *
 *                     +----------------+
 *                     |       r2       |
 *                     +----------------+
 *  |  +----+                              |
 *  |  | r1 |                              |
 *  +--+----+------------------------------+
 *     ^
 *     |
 *     rgn.base
< ASCII >
 *
 * The array, regions counter and total size are not modified.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1288.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1536-L1554

```c
/*
 * A test that tries to free a region r2 that overlaps with the beginning
 * of the already existing entry r1 (that is r1.base < r2.base + r2.size):
 *
< ASCII >
 *     +----+
 *     | r2 |
 *     +----+
 *  |    ...+--------------+               |
 *  |    :  |    r1        |               |
 *  +----+--+--------------+---------------+
 *       ^  ^
 *       |  |
 *       |  rgn.base
 *       |
 *       r1.base
< ASCII >
 *
 * Expect that only the intersection of both regions is freed. The
 * regions counter and total size are updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1289.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1590-L1603

```c
/*
 * A test that tries to free a region r2 that overlaps with the end of
 * the already existing entry r1 (that is r2.base < r1.base + r1.size):
 *
< ASCII >
 *                   +----------------+
 *                   |       r2       |
 *                   +----------------+
 *  |    +-----------+.....                |
 *  |    |       r1  |    :                |
 *  +----+-----------+----+----------------+
< ASCII >
 *
 * Expect that only the intersection of both regions is freed. The
 * regions counter and total size are updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_129.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/parisc/math-emu/float.h#L467-L473

```c
/* Declare the condition field
< ASCII >
 *
 *  0 1 2 3 4 5 6 7 8 910 1 2 3 4 5 6 7 8 920 1 2 3 4 5 6 7 8 930 1
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |                                                     |G|L|E|U|X|
 * +-------+-------+-------+-------+-------+-------+-------+-------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1290.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1639-L1657

```c
/*
 * A test that tries to free a region r2 that is within the range of the
 * already existing entry r1 (that is
 * (r1.base < r2.base) && (r2.base + r2.size < r1.base + r1.size)):
< ASCII >
 *
 *                    +----+
 *                    | r2 |
 *                    +----+
 *  |    +------------+....+---------------+
 *  |    |    rgn1    | r1 |     rgn2      |
 *  +----+------------+----+---------------+
 *       ^
 *       |
 *       r1.base
< ASCII >
 *
 * Expect that the region is split into two - one that ends at r2.base and
 * another that starts at r2.base + r2.size, with appropriate sizes. The
 * region counter and total size fields are updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1291.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1734-L1747

```c
/*
 * A simple test that tries free a region r2 when r2 extends past PHYS_ADDR_MAX:
 *
< ASCII >
 *                               +--------+
 *                               |   r2   |
 *                               +--------+
 *  |                        +---+....+
 *  |                        |rgn|    |
 *  +------------------------+---+----+
< ASCII >
 *
 * Expect that only the portion between PHYS_ADDR_MAX and r2.base is freed.
 * Expect the total size of reserved memory to be updated and the counter to
 * not be updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1292.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1784-L1798

```c
/*
 * A test that tries to free a reserved region r3 that overlaps with two
 * existing reserved regions r1 and r2:
< ASCII >
 *
 *            +----------------+
 *            |       r3       |
 *            +----------------+
 *  |    +----+.....   ........+--------+
 *  |    |    |r1  :   :       |r2      |     |
 *  +----+----+----+---+-------+--------+-----+
< ASCII >
 *
 * Expect that only the intersections of r1 with r3 and r2 with r3 are freed
 * from the collection of reserved memory. Expect the total size of reserved
 * memory to be updated and the counter to not be updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1293.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1944-L1961

```c
/*
 * A test that tries to trim memory when there are two available regions, r1 and
 * r2. Region r1 is aligned on both ends and region r2 is unaligned on one end
 * and smaller than the alignment:
< ASCII >
 *
 *                                     alignment
 *                                     |--------|
 * |        +-----------------+        +------+   |
 * |        |        r1       |        |  r2  |   |
 * +--------+-----------------+--------+------+---+
 *          ^        ^        ^        ^      ^
 *          |________|________|________|      |
 *                            |               Unaligned address
 *                Aligned addresses
< ASCII >
 *
 * Expect that r1 will not be trimmed and r2 will be removed. Expect the
 * counter to be updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1294.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L1995-L2013

```c
/*
 * A test that tries to trim memory when there are two available regions, r1 and
 * r2. Region r1 is aligned on both ends and region r2 is unaligned at the base
 * and aligned at the end:
< ASCII >
 *
 *                               Unaligned address
 *                                       |
 *                                       v
 * |        +-----------------+          +---------------+   |
 * |        |        r1       |          |      r2       |   |
 * +--------+-----------------+----------+---------------+---+
 *          ^        ^        ^        ^        ^        ^
 *          |________|________|________|________|________|
 *                            |
 *                    Aligned addresses
 *
< ASCII >
 * Expect that r1 will not be trimmed and r2 will be trimmed at the base.
 * Expect the counter to not be updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1295.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/basic_api.c#L2056-L2074

```c
/*
 * A test that tries to trim memory when there are two available regions, r1 and
 * r2. Region r1 is aligned on both ends and region r2 is aligned at the base
 * and unaligned at the end:
< ASCII >
 *
 *                                             Unaligned address
 *                                                     |
 *                                                     v
 * |        +-----------------+        +---------------+   |
 * |        |        r1       |        |      r2       |   |
 * +--------+-----------------+--------+---------------+---+
 *          ^        ^        ^        ^        ^        ^
 *          |________|________|________|________|________|
 *                            |
 *                    Aligned addresses
< ASCII >
 *
 * Expect that r1 will not be trimmed and r2 will be trimmed at the end.
 * Expect the counter to not be updated.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1296.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/memblock/tests/common.c#L74-L84

```c
/**
 * setup_numa_memblock:
 * Set up a memory layout with multiple NUMA nodes in a previously allocated
 * dummy physical memory.
 * @node_fracs: an array representing the fraction of MEM_SIZE contained in
 *              each node in basis point units (one hundredth of 1% or 1/10000).
 *              For example, if node 0 should contain 1/8 of MEM_SIZE,
 *              node_fracs[0] = 1250.
 *
 * The nids will be set to 0 through NUMA_NODES - 1.
 */
```
## Visual type:


== ./linux/linux_1297.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/nvdimm/test/nfit.c#L26-L94

```c
/*
 * Generate an NFIT table to describe the following topology:
 *
 * BUS0: Interleaved PMEM regions, and aliasing with BLK regions
< ASCII >
 *
 *                     (a)                       (b)            DIMM   BLK-REGION
 *           +----------+--------------+----------+---------+
 * +------+  |  blk2.0  |     pm0.0    |  blk2.1  |  pm1.0  |    0      region2
 * | imc0 +--+- - - - - region0 - - - -+----------+         +
 * +--+---+  |  blk3.0  |     pm0.0    |  blk3.1  |  pm1.0  |    1      region3
 *    |      +----------+--------------v----------v         v
 * +--+---+                            |                    |
 * | cpu0 |                                    region1
 * +--+---+                            |                    |
 *    |      +-------------------------^----------^         ^
 * +--+---+  |                 blk4.0             |  pm1.0  |    2      region4
 * | imc1 +--+-------------------------+----------+         +
 * +------+  |                 blk5.0             |  pm1.0  |    3      region5
 *           +-------------------------+----------+-+-------+
 *
 * +--+---+
 * | cpu1 |
 * +--+---+                   (Hotplug DIMM)
 *    |      +----------------------------------------------+
 * +--+---+  |                 blk6.0/pm7.0                 |    4      region6/7
 * | imc0 +--+----------------------------------------------+
 * +------+
< ASCII >
 *
 *
 * *) In this layout we have four dimms and two memory controllers in one
 *    socket.  Each unique interface (BLK or PMEM) to DPA space
 *    is identified by a region device with a dynamically assigned id.
 *
 * *) The first portion of dimm0 and dimm1 are interleaved as REGION0.
 *    A single PMEM namespace "pm0.0" is created using half of the
 *    REGION0 SPA-range.  REGION0 spans dimm0 and dimm1.  PMEM namespace
 *    allocate from from the bottom of a region.  The unallocated
 *    portion of REGION0 aliases with REGION2 and REGION3.  That
 *    unallacted capacity is reclaimed as BLK namespaces ("blk2.0" and
 *    "blk3.0") starting at the base of each DIMM to offset (a) in those
 *    DIMMs.  "pm0.0", "blk2.0" and "blk3.0" are free-form readable
 *    names that can be assigned to a namespace.
 *
 * *) In the last portion of dimm0 and dimm1 we have an interleaved
 *    SPA range, REGION1, that spans those two dimms as well as dimm2
 *    and dimm3.  Some of REGION1 allocated to a PMEM namespace named
 *    "pm1.0" the rest is reclaimed in 4 BLK namespaces (for each
 *    dimm in the interleave set), "blk2.1", "blk3.1", "blk4.0", and
 *    "blk5.0".
 *
 * *) The portion of dimm2 and dimm3 that do not participate in the
 *    REGION1 interleaved SPA range (i.e. the DPA address below offset
 *    (b) are also included in the "blk4.0" and "blk5.0" namespaces.
 *    Note, that BLK namespaces need not be contiguous in DPA-space, and
 *    can consume aliased capacity from multiple interleave sets.
 *
 * BUS1: Legacy NVDIMM (single contiguous range)
 *
< ASCII >
 *  region2
 * +---------------------+
 * |---------------------|
 * ||       pm2.0       ||
 * |---------------------|
 * +---------------------+
< ASCII >
 *
 * *) A NFIT-table may describe a simple system-physical-address range
 *    with no BLK aliasing.  This type of region may optionally
 *    reference an NVDIMM.
 */
```
## Visual type:
- #topology


== ./linux/linux_1298.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/bpf/progs/test_tcp_estats.c#L8-L33

```c
/* This program shows clang/llvm is able to generate code pattern
 * like:
< ASCII >
 *   _tcp_send_active_reset:
 *      0:       bf 16 00 00 00 00 00 00         r6 = r1
 *    ......
 *    335:       b7 01 00 00 0f 00 00 00         r1 = 15
 *    336:       05 00 48 00 00 00 00 00         goto 72
 *
 *   LBB0_3:
 *    337:       b7 01 00 00 01 00 00 00         r1 = 1
 *    338:       63 1a d0 ff 00 00 00 00         *(u32 *)(r10 - 48) = r1
 *    408:       b7 01 00 00 03 00 00 00         r1 = 3
 *
 *   LBB0_4:
 *    409:       71 a2 fe ff 00 00 00 00         r2 = *(u8 *)(r10 - 2)
 *    410:       bf a7 00 00 00 00 00 00         r7 = r10
 *    411:       07 07 00 00 b8 ff ff ff         r7 += -72
 *    412:       bf 73 00 00 00 00 00 00         r3 = r7
 *    413:       0f 13 00 00 00 00 00 00         r3 += r1
 *    414:       73 23 2d 00 00 00 00 00         *(u8 *)(r3 + 45) = r2
< ASCII >
 *
 * From the above code snippet, the code generated by the compiler
 * is reasonable. The "r1" is assigned to different values in basic
 * blocks "_tcp_send_active_reset" and "LBB0_3", and used in "LBB0_4".
 * The verifier should be able to handle such code patterns.
 */
```
## Visual type:
- #custom


== ./linux/linux_1299.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/bpf/prog_tests/btf.c#L1185-L1191

```c
< ASCII >
/* Array_A  <------------------+
 *     elem_type == Array_B    |
 *                    |        |
 *                    |        |
 * Array_B  <-------- +        |
 *      elem_type == Array A --+
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_13.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/core_mcpcia.c#L44-L84

```c
/*
 * Given a bus, device, and function number, compute resulting
 * configuration space address and setup the MCPCIA_HAXR2 register
 * accordingly.  It is therefore not safe to have concurrent
 * invocations to configuration space access routines, but there
 * really shouldn't be any need for this.
 *
< ASCII >
 * Type 0:
 *
 *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 
 *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | | |D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|0|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 *	31:11	Device select bit.
 * 	10:8	Function number
 * 	 7:2	Register number
 *
< ASCII >
 * Type 1:
 *
 *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 
 *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | | | | | | | | | | |B|B|B|B|B|B|B|B|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|1|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 *	31:24	reserved
 *	23:16	bus number (8 bits = 128 possible buses)
 *	15:11	Device number (5 bits)
 *	10:8	function number
 *	 7:2	register number
 *  
 * Notes:
 *	The function number selects which function of a multi-function device 
 *	(e.g., SCSI and Ethernet).
 * 
 *	The register selects a DWORD (32 bit) register offset.  Hence it
 *	doesn't get shifted by 2 bits as we want to "drop" the bottom two
 *	bits.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_130.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/include/asm/bitops.h#L2-L30

```c
/*
 * PowerPC atomic bit operations.
 *
 * Merged version by David Gibson <david@gibson.dropbear.id.au>.
 * Based on ppc64 versions by: Dave Engebretsen, Todd Inglett, Don
 * Reed, Pat McCarthy, Peter Bergner, Anton Blanchard.  They
 * originally took it from the ppc32 code.
 *
 * Within a word, bits are numbered LSB first.  Lot's of places make
 * this assumption by directly testing bits with (val & (1<<nr)).
 * This can cause confusion for large (> 1 word) bitmaps on a
 * big-endian system because, unlike little endian, the number of each
 * bit depends on the word size.
 *
< ASCII >
 * The bitop functions are defined to work on unsigned longs, so for a
 * ppc64 system the bits end up numbered:
 *   |63..............0|127............64|191...........128|255...........192|
 * and on ppc32:
 *   |31.....0|63....32|95....64|127...96|159..128|191..160|223..192|255..224|
< ASCII >
 *
 * There are a few little-endian macros used mostly for filesystem
 * bitmaps, these work on similar bit arrays layouts, but
 * byte-oriented:
< ASCII >
 *   |7...0|15...8|23...16|31...24|39...32|47...40|55...48|63...56|
< ASCII >
 *
 * The main difference is that bit 3-5 (64b) or 3-4 (32b) in the bit
 * number field needs to be reversed compared to the big-endian bit
 * fields. This can be achieved by XOR with 0x38 (64b) or 0x18 (32b).
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1300.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/bpf/prog_tests/btf.c#L1216-L1226

```c
/* typedef is _before_ the BTF type of Array_A and Array_B
 *
 * typedef Array_B int_array;
 *
< ASCII >
 * Array_A  <------------------+
 *     elem_type == int_array  |
 *                    |        |
 *                    |        |
 * Array_B  <-------- +        |
 *      elem_type == Array_A --+
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1301.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/bpf/prog_tests/btf.c#L1253-L1259

```c
< ASCII >
/* Array_A  <------------------+
 *     elem_type == Array_B    |
 *                    |        |
 *                    |        |
 * Array_B  <-------- +        |
 *      elem_type == Array_A --+
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1302.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/bpf/prog_tests/btf.c#L1284-L1294

```c
/* typedef is _between_ the BTF type of Array_A and Array_B
 *
 * typedef Array_B int_array;
 *
< ASCII >
 * Array_A  <------------------+
 *     elem_type == int_array  |
 *                    |        |
 *                    |        |
 * Array_B  <-------- +        |
 *      elem_type == Array_A --+
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1303.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/bpf/prog_tests/test_tunnel.c#L3-L50

```c
/*
 * End-to-end eBPF tunnel test suite
 *   The file tests BPF network tunnel implementation.
 *
< ASCII >
 * Topology:
 * ---------
 *     root namespace   |     at_ns0 namespace
 *                       |
 *       -----------     |     -----------
 *       | tnl dev |     |     | tnl dev |  (overlay network)
 *       -----------     |     -----------
 *       metadata-mode   |     metadata-mode
 *        with bpf       |       with bpf
 *                       |
 *       ----------      |     ----------
 *       |  veth1  | --------- |  veth0  |  (underlay network)
 *       ----------    peer    ----------
< ASCII >
 *
 *
 *  Device Configuration
 *  --------------------
 *  root namespace with metadata-mode tunnel + BPF
 *  Device names and addresses:
 *	veth1 IP 1: 172.16.1.200, IPv6: 00::22 (underlay)
 *		IP 2: 172.16.1.20, IPv6: 00::bb (underlay)
 *	tunnel dev <type>11, ex: gre11, IPv4: 10.1.1.200, IPv6: 1::22 (overlay)
 *
 *  Namespace at_ns0 with native tunnel
 *  Device names and addresses:
 *	veth0 IPv4: 172.16.1.100, IPv6: 00::11 (underlay)
 *	tunnel dev <type>00, ex: gre00, IPv4: 10.1.1.100, IPv6: 1::11 (overlay)
 *
 *
 * End-to-end ping packet flow
 *  ---------------------------
 *  Most of the tests start by namespace creation, device configuration,
 *  then ping the underlay and overlay network.  When doing 'ping 10.1.1.100'
 *  from root namespace, the following operations happen:
 *  1) Route lookup shows 10.1.1.100/24 belongs to tnl dev, fwd to tnl dev.
 *  2) Tnl device's egress BPF program is triggered and set the tunnel metadata,
 *     with local_ip=172.16.1.200, remote_ip=172.16.1.100. BPF program choose
 *     the primary or secondary ip of veth1 as the local ip of tunnel. The
 *     choice is made based on the value of bpf map local_ip_map.
 *  3) Outer tunnel header is prepended and route the packet to veth1's egress.
 *  4) veth0's ingress queue receive the tunneled packet at namespace at_ns0.
 *  5) Tunnel protocol handler, ex: vxlan_rcv, decap the packet.
 *  6) Forward the packet to the overlay tnl dev.
 */
```
## Visual type:
- #topology


== ./linux/linux_1304.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/bpf/prog_tests/xfrm_info.c#L3-L44

```c
/*
< ASCII >
 * Topology:
 * ---------
 *   NS0 namespace         |   NS1 namespace        | NS2 namespace
 *                         |                        |
 *   +---------------+     |   +---------------+    |
 *   |    ipsec0     |---------|    ipsec0     |    |
 *   | 192.168.1.100 |     |   | 192.168.1.200 |    |
 *   | if_id: bpf    |     |   +---------------+    |
 *   +---------------+     |                        |
 *           |             |                        |   +---------------+
 *           |             |                        |   |    ipsec0     |
 *           \------------------------------------------| 192.168.1.200 |
 *                         |                        |   +---------------+
 *                         |                        |
 *                         |                        | (overlay network)
 *      ------------------------------------------------------
 *                         |                        | (underlay network)
 *   +--------------+      |   +--------------+     |
 *   |    veth01    |----------|    veth10    |     |
 *   | 172.16.1.100 |      |   | 172.16.1.200 |     |
 *   ---------------+      |   +--------------+     |
 *                         |                        |
 *   +--------------+      |                        |   +--------------+
 *   |    veth02    |-----------------------------------|    veth20    |
 *   | 172.16.2.100 |      |                        |   | 172.16.2.200 |
 *   +--------------+      |                        |   +--------------+
< ASCII >
 *
 *
 * Test Packet flow
 * -----------
 *  The tests perform 'ping 192.168.1.200' from the NS0 namespace:
 *  1) request is routed to NS0 ipsec0
 *  2) NS0 ipsec0 tc egress BPF program is triggered and sets the if_id based
 *     on the requested value. This makes the ipsec0 device in external mode
 *     select the destination tunnel
 *  3) ping reaches the other namespace (NS1 or NS2 based on which if_id was
 *     used) and response is sent
 *  4) response is received on NS0 ipsec0, tc ingress program is triggered and
 *     records the response if_id
 *  5) requested if_id is compared with received if_id
 */
```
## Visual type:
- #topology


== ./linux/linux_1305.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/bpf/verifier/event_output.c#L1-L25

```c
/* instructions used to output a skb based software event, produced
 * from code snippet:
 * struct TMP {
 *  uint64_t tmp;
 * } tt;
 * tt.tmp = 5;
 * bpf_perf_event_output(skb, &connection_tracking_event_map, 0,
 *			 &tt, sizeof(tt));
 * return 1;
 *
< ASCII >
 * the bpf assembly from llvm is:
 *        0:       b7 02 00 00 05 00 00 00         r2 = 5
 *        1:       7b 2a f8 ff 00 00 00 00         *(u64 *)(r10 - 8) = r2
 *        2:       bf a4 00 00 00 00 00 00         r4 = r10
 *        3:       07 04 00 00 f8 ff ff ff         r4 += -8
 *        4:       18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00    r2 = 0ll
 *        6:       b7 03 00 00 00 00 00 00         r3 = 0
 *        7:       b7 05 00 00 08 00 00 00         r5 = 8
 *        8:       85 00 00 00 19 00 00 00         call 25
 *        9:       b7 00 00 00 01 00 00 00         r0 = 1
 *       10:       95 00 00 00 00 00 00 00         exit
< ASCII >
 *
 *     The reason I put the code here instead of fill_helpers is that map fixup
 *     is against the insns, instead of filled prog.
 */
```
## Visual type:
- #custom


== ./linux/linux_1306.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/cgroup/test_kill.c#L98-L112

```c
/*
< ASCII >
 * The test creates the following hierarchy:
 *       A
 *    / / \ \
 *   B  E  I K
 *  /\  |
 * C  D F
 *      |
 *      G
 *      |
 *      H
< ASCII >
 *
 * with a process in C, H and 3 processes in K.
 * Then it tries to kill the whole tree.
 */
```
## Visual type:
- #tree


== ./linux/linux_1307.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L156-L162

```c
/*
< ASCII >
 *          t0
 *           | (ew)
 *          e0
 *           | (lt)
 *          s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1308.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L187-L193

```c
/*
< ASCII >
 *          t0
 *           | (ew)
 *          e0
 *           | (et)
 *          s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1309.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L218-L224

```c
/*
< ASCII >
 *           t0
 *            | (ew)
 *           e0
 *     (lt) /  \ (lt)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_131.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/include/asm/code-patching.h#L25-L41

```c
/*
< ASCII >
 * Powerpc branch instruction is :
 *
 *  0         6                 30   31
 *  +---------+----------------+---+---+
 *  | opcode  |     LI         |AA |LK |
 *  +---------+----------------+---+---+
 *  Where AA = 0 and LK = 0
< ASCII >
 *
 * LI is a signed 24 bits integer. The real branch offset is computed
 * by: imm32 = SignExtend(LI:'0b00', 32);
 *
 * So the maximum forward branch should be:
 *   (0x007fffff << 2) = 0x01fffffc =  0x1fffffc
 * The maximum backward branch should be:
 *   (0xff800000 << 2) = 0xfe000000 = -0x2000000
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1310.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L256-L262

```c
/*
< ASCII >
 *           t0
 *            | (ew)
 *           e0
 *     (et) /  \ (et)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1311.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L294-L300

```c
/*
< ASCII >
 *          t0
 *           | (p)
 *          e0
 *           | (lt)
 *          s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1312.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L333-L339

```c
/*
< ASCII >
 *          t0
 *           | (p)
 *          e0
 *           | (et)
 *          s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1313.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L372-L378

```c
/*
< ASCII >
 *           t0
 *            | (p)
 *           e0
 *     (lt) /  \ (lt)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1314.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L419-L425

```c
/*
< ASCII >
 *           t0
 *            | (p)
 *           e0
 *     (et) /  \ (et)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1315.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L465-L471

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (ew)
 *           e0
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1316.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L508-L514

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (ew)
 *           e0
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1317.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L551-L557

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (ew)
 *           e0
 *     (lt) /  \ (lt)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1318.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L600-L606

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (ew)
 *           e0
 *     (et) /  \ (et)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1319.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L649-L655

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (p)
 *           e0
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_132.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/include/asm/dma.h#L41-L87

```c
/*
 * NOTES about DMA transfers:
 *
 *  controller 1: channels 0-3, byte operations, ports 00-1F
 *  controller 2: channels 4-7, word operations, ports C0-DF
 *
 *  - ALL registers are 8 bits only, regardless of transfer size
 *  - channel 4 is not used - cascades 1 into 2.
 *  - channels 0-3 are byte - addresses/counts are for physical bytes
 *  - channels 5-7 are word - addresses/counts are for physical words
 *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
 *  - transfer count loaded to registers is 1 less than actual count
 *  - controller 2 offsets are all even (2x offsets for controller 1)
 *  - page registers for 5-7 don't use data bit 0, represent 128K pages
 *  - page registers for 0-3 use bit 0, represent 64K pages
 *
 * On CHRP, the W83C553F (and VLSI Tollgate?) support full 32 bit addressing.
 * Note that addresses loaded into registers must be _physical_ addresses,
 * not logical addresses (which may differ if paging is active).
 *
< ASCII >
 *  Address mapping for channels 0-3:
 *
 *   A23 ... A16 A15 ... A8  A7 ... A0    (Physical addresses)
 *    |  ...  |   |  ... |   |  ... |
 *    |  ...  |   |  ... |   |  ... |
 *    |  ...  |   |  ... |   |  ... |
 *   P7  ...  P0  A7 ... A0  A7 ... A0
 * |    Page    | Addr MSB | Addr LSB |   (DMA registers)
 *
< ASCII >
< ASCII >
 *  Address mapping for channels 5-7:
 *
 *   A23 ... A17 A16 A15 ... A9 A8 A7 ... A1 A0    (Physical addresses)
 *    |  ...  |   \   \   ... \  \  \  ... \  \
 *    |  ...  |    \   \   ... \  \  \  ... \  (not used)
 *    |  ...  |     \   \   ... \  \  \  ... \
 *   P7  ...  P1 (0) A7 A6  ... A0 A7 A6 ... A0
 * |      Page      |  Addr MSB   |  Addr LSB  |   (DMA registers)
< ASCII >
 *
 * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
 * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
 * the hardware level, so odd-byte transfers aren't possible).
 *
 * Transfer count (_not # bytes_) is limited to 64K, represented as actual
 * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
 * and up to 128K bytes may be transferred on channels 5-7 in one operation.
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_1320.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L692-L698

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (p)
 *           e0
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1321.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L735-L741

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (p)
 *           e0
 *     (lt) /  \ (lt)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1322.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L784-L790

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (p)
 *           e0
 *     (et) /  \ (et)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1323.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L833-L841

```c
/*
< ASCII >
 *          t0
 *           | (ew)
 *          e0
 *           | (lt)
 *          e1
 *           | (lt)
 *          s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1324.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L873-L881

```c
/*
< ASCII >
 *          t0
 *           | (ew)
 *          e0
 *           | (lt)
 *          e1
 *           | (et)
 *          s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1325.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L913-L921

```c
/*
< ASCII >
 *           t0
 *            | (ew)
 *           e0
 *            | (et)
 *           e1
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1326.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L953-L961

```c
/*
< ASCII >
 *           t0
 *            | (ew)
 *           e0
 *            | (et)
 *           e1
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1327.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L993-L1001

```c
/*
< ASCII >
 *          t0
 *           | (p)
 *          e0
 *           | (lt)
 *          e1
 *           | (lt)
 *          s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1328.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1041-L1049

```c
/*
< ASCII >
 *          t0
 *           | (p)
 *          e0
 *           | (lt)
 *          e1
 *           | (et)
 *          s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1329.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1089-L1097

```c
/*
< ASCII >
 *          t0
 *           | (p)
 *          e0
 *           | (et)
 *          e1
 *           | (lt)
 *          s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_133.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/include/asm/kvm_ppc.h#L444-L517

```c
/*
 * To avoid the need to unnecessarily exit fully to the host kernel, an IPI to
 * a CPU thread that's running/napping inside of a guest is by default regarded
 * as a request to wake the CPU (if needed) and continue execution within the
 * guest, potentially to process new state like externally-generated
 * interrupts or IPIs sent from within the guest itself (e.g. H_PROD/H_IPI).
 *
 * To force an exit to the host kernel, kvmppc_set_host_ipi() must be called
 * prior to issuing the IPI to set the corresponding 'host_ipi' flag in the
 * target CPU's PACA. To avoid unnecessary exits to the host, this flag should
 * be immediately cleared via kvmppc_clear_host_ipi() by the IPI handler on
 * the receiving side prior to processing the IPI work.
 *
 * NOTE:
 *
 * We currently issue an smp_mb() at the beginning of kvmppc_set_host_ipi().
 * This is to guard against sequences such as the following:
 *
< ASCII >
 *      CPU
 *        X: smp_muxed_ipi_set_message():
 *        X:   smp_mb()
 *        X:   message[RESCHEDULE] = 1
 *        X: doorbell_global_ipi(42):
 *        X:   kvmppc_set_host_ipi(42)
 *        X:   ppc_msgsnd_sync()/smp_mb()
 *        X:   ppc_msgsnd() -> 42
 *       42: doorbell_exception(): // from CPU X
 *       42:   ppc_msgsync()
 *      105: smp_muxed_ipi_set_message():
 *      105:   smb_mb()
 *           // STORE DEFERRED DUE TO RE-ORDERING
 *    --105:   message[CALL_FUNCTION] = 1
 *    | 105: doorbell_global_ipi(42):
 *    | 105:   kvmppc_set_host_ipi(42)
 *    |  42:   kvmppc_clear_host_ipi(42)
 *    |  42: smp_ipi_demux_relaxed()
 *    |  42: // returns to executing guest
 *    |      // RE-ORDERED STORE COMPLETES
 *    ->105:   message[CALL_FUNCTION] = 1
 *      105:   ppc_msgsnd_sync()/smp_mb()
 *      105:   ppc_msgsnd() -> 42
 *       42: local_paca->kvm_hstate.host_ipi == 0 // IPI ignored
 *      105: // hangs waiting on 42 to process messages/call_single_queue
< ASCII >
 *
 * We also issue an smp_mb() at the end of kvmppc_clear_host_ipi(). This is
 * to guard against sequences such as the following (as well as to create
 * a read-side pairing with the barrier in kvmppc_set_host_ipi()):
 *
< ASCII >
 *      CPU
 *        X: smp_muxed_ipi_set_message():
 *        X:   smp_mb()
 *        X:   message[RESCHEDULE] = 1
 *        X: doorbell_global_ipi(42):
 *        X:   kvmppc_set_host_ipi(42)
 *        X:   ppc_msgsnd_sync()/smp_mb()
 *        X:   ppc_msgsnd() -> 42
 *       42: doorbell_exception(): // from CPU X
 *       42:   ppc_msgsync()
 *           // STORE DEFERRED DUE TO RE-ORDERING
 *    -- 42:   kvmppc_clear_host_ipi(42)
 *    |  42: smp_ipi_demux_relaxed()
 *    | 105: smp_muxed_ipi_set_message():
 *    | 105:   smb_mb()
 *    | 105:   message[CALL_FUNCTION] = 1
 *    | 105: doorbell_global_ipi(42):
 *    | 105:   kvmppc_set_host_ipi(42)
 *    |      // RE-ORDERED STORE COMPLETES
 *    -> 42:   kvmppc_clear_host_ipi(42)
 *       42: // returns to executing guest
 *      105:   ppc_msgsnd_sync()/smp_mb()
 *      105:   ppc_msgsnd() -> 42
 *       42: local_paca->kvm_hstate.host_ipi == 0 // IPI ignored
 *      105: // hangs waiting on 42 to process messages/call_single_queue
< ASCII >
 */
```
## Visual type:
- #sequence


== ./linux/linux_1330.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1137-L1145

```c
/*
< ASCII >
 *          t0
 *           | (p)
 *          e0
 *           | (et)
 *          e1
 *           | (et)
 *          s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1331.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1185-L1193

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (ew)
 *           e0
 *            | (lt)
 *           e1
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1332.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1237-L1245

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (ew)
 *           e0
 *            | (lt)
 *           e1
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1333.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1289-L1297

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (ew)
 *           e0
 *            | (et)
 *           e1
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1334.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1341-L1349

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (ew)
 *           e0
 *            | (et)
 *           e1
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1335.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1393-L1401

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (p)
 *           e0
 *            | (lt)
 *           e1
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1336.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1444-L1452

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (p)
 *           e0
 *            | (lt)
 *           e1
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1337.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1495-L1503

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (p)
 *           e0
 *            | (et)
 *           e1
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1338.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1546-L1554

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (p)
 *           e0
 *            | (et)
 *           e1
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1339.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1597-L1605

```c
/*
< ASCII >
 *        t0   t1
 *    (ew) |    | (ew)
 *         |   e0
 *          \  / (lt)
 *           e1
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_134.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/include/asm/book3s/64/hash.h#L52-L76

```c
/*
< ASCII >
 * +------------------------------+
 * |                              |
 * |                              |
 * |                              |
 * +------------------------------+  Kernel virtual map end (0xc00e000000000000)
 * |                              |
 * |                              |
 * |      512TB/16TB of vmemmap   |
 * |                              |
 * |                              |
 * +------------------------------+  Kernel vmemmap  start
 * |                              |
 * |      512TB/16TB of IO map    |
 * |                              |
 * +------------------------------+  Kernel IO map start
 * |                              |
 * |      512TB/16TB of vmap      |
 * |                              |
 * +------------------------------+  Kernel virt start (0xc008000000000000)
 * |                              |
 * |                              |
 * |                              |
 * +------------------------------+  Kernel linear (0xc.....)
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1340.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1649-L1657

```c
/*
< ASCII >
 *        t0   t1
 *    (ew) |    | (ew)
 *         |   e0
 *          \  / (lt)
 *           e1
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1341.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1701-L1709

```c
/*
< ASCII >
 *        t0   t1
 *    (ew) |    | (ew)
 *         |   e0
 *          \  / (et)
 *           e1
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1342.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1753-L1761

```c
/*
< ASCII >
 *        t0   t1
 *    (ew) |    | (ew)
 *         |   e0
 *          \  / (et)
 *           e1
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1343.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1805-L1813

```c
/*
< ASCII >
 *        t0   t1
 *     (p) |    | (ew)
 *         |   e0
 *          \  / (lt)
 *           e1
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1344.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1862-L1870

```c
/*
< ASCII >
 *        t0   t1
 *     (p) |    | (ew)
 *         |   e0
 *          \  / (lt)
 *           e1
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1345.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1919-L1927

```c
/*
< ASCII >
 *        t0   t1
 *     (p) |    | (ew)
 *         |   e0
 *          \  / (et)
 *           e1
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1346.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L1976-L1984

```c
/*
< ASCII >
 *        t0   t1
 *     (p) |    | (ew)
 *         |   e0
 *          \  / (et)
 *           e1
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1347.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2033-L2041

```c
/*
< ASCII >
 *        t0   t1
 *    (ew) |    | (p)
 *         |   e0
 *          \  / (lt)
 *           e1
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1348.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2085-L2093

```c
/*
< ASCII >
 *        t0   t1
 *    (ew) |    | (p)
 *         |   e0
 *          \  / (lt)
 *           e1
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1349.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2137-L2145

```c
/*
< ASCII >
 *        t0   t1
 *    (ew) |    | (p)
 *         |   e0
 *          \  / (et)
 *           e1
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_135.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/include/asm/book3s/64/mmu-hash.h#L625-L649

```c
/*
 * This should be computed such that protovosid * vsid_mulitplier
 * doesn't overflow 64 bits. The vsid_mutliplier should also be
 * co-prime to vsid_modulus. We also need to make sure that number
 * of bits in multiplied result (dividend) is less than twice the number of
 * protovsid bits for our modulus optmization to work.
 *
< ASCII >
 * The below table shows the current values used.
 * |-------+------------+----------------------+------------+-------------------|
 * |       | Prime Bits | proto VSID_BITS_65VA | Total Bits | 2* prot VSID_BITS |
 * |-------+------------+----------------------+------------+-------------------|
 * | 1T    |         24 |                   25 |         49 |                50 |
 * |-------+------------+----------------------+------------+-------------------|
 * | 256MB |         24 |                   37 |         61 |                74 |
 * |-------+------------+----------------------+------------+-------------------|
 *
 * |-------+------------+----------------------+------------+--------------------|
 * |       | Prime Bits | proto VSID_BITS_68VA | Total Bits | 2* proto VSID_BITS |
 * |-------+------------+----------------------+------------+--------------------|
 * | 1T    |         24 |                   28 |         52 |                 56 |
 * |-------+------------+----------------------+------------+--------------------|
 * | 256MB |         24 |                   40 |         64 |                 80 |
 * |-------+------------+----------------------+------------+--------------------|
< ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_1350.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2189-L2197

```c
/*
< ASCII >
 *        t0   t1
 *    (ew) |    | (p)
 *         |   e0
 *          \  / (et)
 *           e1
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1351.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2241-L2249

```c
/*
< ASCII >
 *        t0   t1
 *     (p) |    | (p)
 *         |   e0
 *          \  / (lt)
 *           e1
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1352.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2298-L2306

```c
/*
< ASCII >
 *        t0   t1
 *     (p) |    | (p)
 *         |   e0
 *          \  / (lt)
 *           e1
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1353.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2350-L2358

```c
/*
< ASCII >
 *        t0   t1
 *     (p) |    | (p)
 *         |   e0
 *          \  / (et)
 *           e1
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1354.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2407-L2415

```c
/*
< ASCII >
 *        t0   t1
 *     (p) |    | (p)
 *         |   e0
 *          \  / (et)
 *           e1
 *            | (et)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1355.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2459-L2467

```c
/*
< ASCII >
 *           t0
 *            | (ew)
 *           e0
 *     (lt) /  \ (lt)
 *        e1    e2
 *    (lt) |     | (lt)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1356.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2513-L2521

```c
/*
< ASCII >
 *           t0
 *            | (ew)
 *           e0
 *     (et) /  \ (et)
 *        e1    e2
 *    (lt) |     | (lt)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1357.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2567-L2575

```c
/*
< ASCII >
 *           t0
 *            | (p)
 *           e0
 *     (lt) /  \ (lt)
 *        e1    e2
 *    (lt) |     | (lt)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1358.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2629-L2637

```c
/*
< ASCII >
 *           t0
 *            | (p)
 *           e0
 *     (et) /  \ (et)
 *        e1    e2
 *    (lt) |     | (lt)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1359.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2691-L2699

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (ew)
 *           e0
 *     (lt) /  \ (lt)
 *        e1    e2
 *    (lt) |     | (lt)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_136.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/include/asm/book3s/64/mmu-hash.h#L807-L822

```c
/*
 * For kernel space, we use context ids as
 * below. Range is 512TB per context.
< ASCII >
 *
 * 0x00001 -  [ 0xc000000000000000 - 0xc001ffffffffffff]
 * 0x00002 -  [ 0xc002000000000000 - 0xc003ffffffffffff]
 * 0x00003 -  [ 0xc004000000000000 - 0xc005ffffffffffff]
 * 0x00004 -  [ 0xc006000000000000 - 0xc007ffffffffffff]
 *
 * vmap, IO, vmemap
 *
 * 0x00005 -  [ 0xc008000000000000 - 0xc009ffffffffffff]
 * 0x00006 -  [ 0xc00a000000000000 - 0xc00bffffffffffff]
 * 0x00007 -  [ 0xc00c000000000000 - 0xc00dffffffffffff]
< ASCII >
 *
 */
```
## Visual type:



== ./linux/linux_1360.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2756-L2764

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (ew)
 *           e0
 *     (et) /  \ (et)
 *        e1    e2
 *    (lt) |     | (lt)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1361.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2821-L2829

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (p)
 *           e0
 *     (lt) /  \ (lt)
 *        e1    e2
 *    (lt) |     | (lt)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1362.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2886-L2894

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (p)
 *           e0
 *     (et) /  \ (et)
 *        e1    e2
 *    (lt) |     | (lt)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1363.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L2951-L2959

```c
/*
< ASCII >
 *        t0    t1
 *      (p) \  / (p)
 *           e0
 *     (lt) /  \ (lt)
 *        e1    e2
 *    (lt) |     | (lt)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1364.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L3021-L3029

```c
/*
< ASCII >
 *        t0    t1
 *      (p) \  / (p)
 *           e0
 *     (et) /  \ (et)
 *        e1    e2
 *    (lt) |     | (lt)
 *        s0    s2
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1365.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L3109-L3117

```c
/*
< ASCII >
 *        t0
 *      (p) \
 *           e0
 *     (et) /
 *        e0
< ASCII >
 *
 * Based on https://bugzilla.kernel.org/show_bug.cgi?id=205933
 */
```
## Visual type:
- #tree


== ./linux/linux_1366.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/filesystems/epoll/epoll_wakeup_test.c#L3452-L3458

```c
/*
< ASCII >
 *        t0    t1
 *     (ew) \  / (ew)
 *           e0
 *            | (lt)
 *           s0
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1367.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/kvm/include/aarch64/processor.h#L31-L40

```c
/*
< ASCII >
 * Default MAIR
 *                  index   attribute
 * DEVICE_nGnRnE      0     0000:0000
 * DEVICE_nGnRE       1     0000:0100
 * DEVICE_GRE         2     0000:1100
 * NORMAL_NC          3     0100:0100
 * NORMAL             4     1111:1111
 * NORMAL_WT          5     1011:1011
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_1368.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/landlock/fs_test.c#L66-L90

```c
/*
< ASCII >
 * layout1 hierarchy:
 *
 * tmp
 * ├── s1d1
 * │   ├── f1
 * │   ├── f2
 * │   └── s1d2
 * │       ├── f1
 * │       ├── f2
 * │       └── s1d3
 * │           ├── f1
 * │           └── f2
 * ├── s2d1
 * │   ├── f1
 * │   └── s2d2
 * │       ├── f1
 * │       └── s2d3
 * │           ├── f1
 * │           └── f2
 * └── s3d1
 *     ├── f1
 *     └── s3d2
 *         └── s3d3
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1369.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/landlock/fs_test.c#L3651-L3675

```c
/*
< ASCII >
 * layout1_bind hierarchy:
 *
 * tmp
 * ├── s1d1
 * │   ├── f1
 * │   ├── f2
 * │   └── s1d2
 * │       ├── f1
 * │       ├── f2
 * │       └── s1d3
 * │           ├── f1
 * │           └── f2
 * ├── s2d1
 * │   ├── f1
 * │   └── s2d2
 * │       ├── f1
 * │       ├── f2
 * │       └── s1d3
 * │           ├── f1
 * │           └── f2
 * └── s3d1
 *     └── s3d2
 *         └── s3d3
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_137.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/include/asm/book3s/64/radix.h#L50-L97

```c
/*
 * We support 52 bit address space, Use top bit for kernel
 * virtual mapping. Also make sure kernel fit in the top
 * quadrant.
< ASCII >
 *
 *           +------------------+
 *           +------------------+  Kernel virtual map (0xc008000000000000)
 *           |                  |
 *           |                  |
 *           |                  |
 * 0b11......+------------------+  Kernel linear map (0xc....)
 *           |                  |
 *           |     2 quadrant   |
 *           |                  |
 * 0b10......+------------------+
 *           |                  |
 *           |    1 quadrant    |
 *           |                  |
 * 0b01......+------------------+
 *           |                  |
 *           |    0 quadrant    |
 *           |                  |
 * 0b00......+------------------+
< ASCII >
 *
 *
 * 3rd quadrant expanded:
< ASCII >
 * +------------------------------+  Highest address (0xc010000000000000)
 * +------------------------------+  KASAN shadow end (0xc00fc00000000000)
 * |                              |
 * |                              |
 * +------------------------------+  Kernel vmemmap end/shadow start (0xc00e000000000000)
 * |                              |
 * |           512TB		  |
 * |                              |
 * +------------------------------+  Kernel IO map end/vmemap start
 * |                              |
 * |           512TB		  |
 * |                              |
 * +------------------------------+  Kernel vmap end/ IO map start
 * |                              |
 * |           512TB		  |
 * |                              |
 * +------------------------------+  Kernel virt start (0xc008000000000000)
 * |                              |
 * |                              |
 * |                              |
 * +------------------------------+  Kernel linear (0xc.....)
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1370.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/landlock/fs_test.c#L3959-L3996

```c
/*
 * layout2_overlay hierarchy:
< ASCII >
 *
 * tmp
 * ├── lower
 * │   └── data
 * │       ├── dl1
 * │       │   └── fl2
 * │       ├── do1
 * │       │   ├── fl3
 * │       │   └── fo2
 * │       ├── fl1
 * │       └── fo1
 * ├── merge
 * │   └── data
 * │       ├── dl1
 * │       │   └── fl2
 * │       ├── do1
 * │       │   ├── fl3
 * │       │   ├── fo2
 * │       │   └── fu3
 * │       ├── du1
 * │       │   └── fu2
 * │       ├── fl1
 * │       ├── fo1
 * │       └── fu1
 * └── upper
 *     ├── data
 *     │   ├── do1
 *     │   │   ├── fo2
 *     │   │   └── fu3
 *     │   ├── du1
 *     │   │   └── fu2
 *     │   ├── fo1
 *     │   └── fu1
 *     └── work
 *         └── work
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1371.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/landlock/ptrace_test.c#L83-L89

```c
/*
< ASCII >
 *        No domain
 *
 *   P1-.               P1 -> P2 : allow
 *       \              P2 -> P1 : allow
 *        'P2
< ASCII >
 */
```
## Visual type:



== ./linux/linux_1372.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/landlock/ptrace_test.c#L98-L106

```c
/*
< ASCII >
 *        Child domain
 *
 *   P1--.              P1 -> P2 : allow
 *        \             P2 -> P1 : deny
 *        .'-----.
 *        |  P2  |
 *        '------'
< ASCII >
 */
```
## Visual type:



== ./linux/linux_1373.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/landlock/ptrace_test.c#L115-L122

```c
/*
< ASCII >
 *        Parent domain
 * .------.
 * |  P1  --.           P1 -> P2 : deny
 * '------'  \          P2 -> P1 : allow
 *            '
 *            P2
< ASCII >
 */
```
## Visual type:



== ./linux/linux_1374.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/landlock/ptrace_test.c#L131-L139

```c
/*
< ASCII >
 *        Parent + child domain (siblings)
 * .------.
 * |  P1  ---.          P1 -> P2 : deny
 * '------'   \         P2 -> P1 : deny
 *         .---'--.
 *         |  P2  |
 *         '------'
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1375.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/landlock/ptrace_test.c#L148-L156

```c
/*
< ASCII >
 *         Same domain (inherited)
 * .-------------.
 * | P1----.     |      P1 -> P2 : allow
 * |        \    |      P2 -> P1 : allow
 * |         '   |
 * |         P2  |
 * '-------------'
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1376.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/landlock/ptrace_test.c#L165-L174

```c
/*
< ASCII >
 *         Inherited + child domain
 * .-----------------.
 * |  P1----.        |  P1 -> P2 : allow
 * |         \       |  P2 -> P1 : deny
 * |        .-'----. |
 * |        |  P2  | |
 * |        '------' |
 * '-----------------'
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1377.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/landlock/ptrace_test.c#L183-L192

```c
/*
< ASCII >
 *         Inherited + parent domain
 * .-----------------.
 * |.------.         |  P1 -> P2 : deny
 * ||  P1  ----.     |  P2 -> P1 : allow
 * |'------'    \    |
 * |             '   |
 * |             P2  |
 * '-----------------'
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1378.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/landlock/ptrace_test.c#L201-L212

```c
/*
< ASCII >
 *         Inherited + parent and child domain (siblings)
 * .-----------------.
 * | .------.        |  P1 -> P2 : deny
 * | |  P1  .        |  P2 -> P1 : deny
 * | '------'\       |
 * |          \      |
 * |        .--'---. |
 * |        |  P2  | |
 * |        '------' |
 * '-----------------'
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1379.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/net/ipsec.c#L2123-L2139

```c
/*
< ASCII >
 * Some structures in xfrm uapi header differ in size between
 * 64-bit and 32-bit ABI:
 *
 *             32-bit UABI               |            64-bit UABI
 *  -------------------------------------|-------------------------------------
 *   sizeof(xfrm_usersa_info)     = 220  |  sizeof(xfrm_usersa_info)     = 224
 *   sizeof(xfrm_userpolicy_info) = 164  |  sizeof(xfrm_userpolicy_info) = 168
 *   sizeof(xfrm_userspi_info)    = 228  |  sizeof(xfrm_userspi_info)    = 232
 *   sizeof(xfrm_user_acquire)    = 276  |  sizeof(xfrm_user_acquire)    = 280
 *   sizeof(xfrm_user_expire)     = 224  |  sizeof(xfrm_user_expire)     = 232
 *   sizeof(xfrm_user_polexpire)  = 168  |  sizeof(xfrm_user_polexpire)  = 176
< ASCII >
 *
 * Check the affected by the UABI difference structures.
 * Also, check translation for xfrm_set_spdinfo: it has it's own attributes
 * which needs to be correctly copied, but not translated.
 */
```
## Visual type:
- #table


== ./linux/linux_138.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/include/uapi/asm/papr_pdsm.h#L16-L60

```c
/*
 * PDSM Envelope:
 *
 * The ioctl ND_CMD_CALL exchange data between user-space and kernel via
 * envelope which consists of 2 headers sections and payload sections as
 * illustrated below:
< ASCII >
 *  +-----------------+---------------+---------------------------+
 *  |   64-Bytes      |   8-Bytes     |       Max 184-Bytes       |
 *  +-----------------+---------------+---------------------------+
 *  | ND-HEADER       |  PDSM-HEADER  |      PDSM-PAYLOAD         |
 *  +-----------------+---------------+---------------------------+
 *  | nd_family       |               |                           |
 *  | nd_size_out     | cmd_status    |                           |
 *  | nd_size_in      | reserved      |     nd_pdsm_payload       |
 *  | nd_command      | payload   --> |                           |
 *  | nd_fw_size      |               |                           |
 *  | nd_payload ---> |               |                           |
 *  +---------------+-----------------+---------------------------+
< ASCII >
 *
 * ND Header:
 * This is the generic libnvdimm header described as 'struct nd_cmd_pkg'
 * which is interpreted by libnvdimm before passed on to papr_scm. Important
 * member fields used are:
 * 'nd_family'		: (In) NVDIMM_FAMILY_PAPR_SCM
 * 'nd_size_in'		: (In) PDSM-HEADER + PDSM-IN-PAYLOAD (usually 0)
 * 'nd_size_out'        : (In) PDSM-HEADER + PDSM-RETURN-PAYLOAD
 * 'nd_command'         : (In) One of PAPR_PDSM_XXX
 * 'nd_fw_size'         : (Out) PDSM-HEADER + size of actual payload returned
 *
 * PDSM Header:
 * This is papr-scm specific header that precedes the payload. This is defined
 * as nd_cmd_pdsm_pkg.  Following fields aare available in this header:
 *
 * 'cmd_status'		: (Out) Errors if any encountered while servicing PDSM.
 * 'reserved'		: Not used, reserved for future and should be set to 0.
 * 'payload'            : A union of all the possible payload structs
 *
 * PDSM Payload:
 *
 * The layout of the PDSM Payload is defined by various structs shared between
 * papr_scm and libndctl so that contents of payload can be interpreted. As such
 * its defined as a union of all possible payload structs as
 * 'union nd_pdsm_payload'. Based on the value of 'nd_cmd_pkg.nd_command'
 * appropriate member of the union is accessed.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1380.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/openat2/rename_attack_test.c#L28-L34

```c
/* Construct a test directory with the following structure:
 *
< ASCII >
 * root/
 * |-- a/
 * |   `-- c/
 * `-- b/
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1381.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/openat2/resolve_test.c#L20-L46

```c
/*
 * Construct a test directory with the following structure:
 *
< ASCII >
 * root/
 * |-- procexe -> /proc/self/exe
 * |-- procroot -> /proc/self/root
 * |-- root/
 * |-- mnt/ [mountpoint]
 * |   |-- self -> ../mnt/
 * |   `-- absself -> /mnt/
 * |-- etc/
 * |   `-- passwd
 * |-- creatlink -> /newfile3
 * |-- reletc -> etc/
 * |-- relsym -> etc/passwd
 * |-- absetc -> /etc/
 * |-- abssym -> /etc/passwd
 * |-- abscheeky -> /cheeky
 * `-- cheeky/
 *     |-- absself -> /
 *     |-- self -> ../../root/
 *     |-- garbageself -> /../../root/
 *     |-- passwd -> ../cheeky/../cheeky/../etc/../etc/passwd
 *     |-- abspasswd -> /../cheeky/../cheeky/../etc/../etc/passwd
 *     |-- dotdotlink -> ../../../../../../../../../../../../../../etc/passwd
 *     `-- garbagelink -> /../../../../../../../../../../../../../../etc/passwd
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_1382.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/powerpc/mm/tlbie_test.c#L161-L192

```c
/*
 * A "store-pattern" is the word-pattern that is stored into a word
 * location in the 4)STORE step of the rim-sequence.
 *
 * In the store-pattern, we shall encode:
 *
 *      - The thread-id of the rim_thread performing the store
 *        (The most significant THREAD_ID_BITS)
 *
 *      - The word-offset of the address into which the store is being
 *        performed (The next WORD_OFFSET_BITS)
 *
 *      - The sweep_id of the current sweep in which the store is
 *        being performed. (The lower SWEEP_ID_BITS)
 *
< ASCII >
 * Store Pattern: 32 bits
 * |------------------|--------------------|---------------------------------|
 * |    Thread id     |  Word offset       |         sweep_id                |
 * |------------------|--------------------|---------------------------------|
 *    THREAD_ID_BITS     WORD_OFFSET_BITS          SWEEP_ID_BITS
< ASCII >
 *
 * In the store pattern, the (Thread-id + Word-offset) uniquely identify the
 * address to which the store is being performed i.e,
 *    address == map1 +
 *              (Thread-id * RIM_CHUNK_SIZE) + (Word-offset * WORD_SIZE)
 *
 * And the sweep_id in the store pattern identifies the time when the
 * store was performed by the rim_thread.
 *
 * We shall use this property in the 3)COMPARE step of the
 * rim-sequence.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1383.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/powerpc/mm/tlbie_test.c#L330-L356

```c
/*
 * When a COMPARE step of a rim-sequence fails, the rim_thread informs
 * everyone else via the shared_memory pointed to by
 * corruption_found variable. On seeing this, every thread verifies the
 * content of its chunk as follows.
 *
 * Suppose a thread identified with @tid was about to store (but not
 * yet stored) to @next_store_addr in its current sweep identified
 * @cur_sweep_id. Let @prev_sweep_id indicate the previous sweep_id.
 *
 * This implies that for all the addresses @addr < @next_store_addr,
 * Thread @tid has already performed a store as part of its current
 * sweep. Hence we expect the content of such @addr to be:
< ASCII >
 *    |-------------------------------------------------|
 *    | tid   | word_offset(addr) |    cur_sweep_id     |
 *    |-------------------------------------------------|
< ASCII >
 *
 * Since Thread @tid is yet to perform stores on address
 * @next_store_addr and above, we expect the content of such an
 * address @addr to be:
< ASCII >
 *    |-------------------------------------------------|
 *    | tid   | word_offset(addr) |    prev_sweep_id    |
 *    |-------------------------------------------------|
 *
< ASCII >
 * The verifier function @verify_chunk does this verification and logs
 * any anamolies that it finds.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_1384.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/tools/testing/selftests/powerpc/pmu/ebb/ebb_handler.S#L16-L39

```c
/* Stack layout:
 *
< ASCII >
 *                   ^
 *  User stack       |
 *  Back chain ------+	<- r1		<-------+
 *  ...						|
 *  Red zone / ABI Gap				|
 *  ...						|
 *  vr63	<+				|
 *  vr0		 |				|
 *  VSCR	 |				|
 *  FSCR	 |				|
 *  r31		 | Save area			|
 *  r0		 |				|
 *  XER		 |				|
 *  CTR		 |				|
 *  LR		 |				|
 *  CCR		<+				|
 *  ...		<+				|
 *  LR		 | Caller frame			|
 *  CCR		 |				|
 *  Back chain	<+	<- updated r1	--------+
 *
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_1385.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/virt/kvm/binary_stats.c#L13-L51

```c
/**
 * kvm_stats_read() - Common function to read from the binary statistics
 * file descriptor.
 *
 * @id: identification string of the stats
 * @header: stats header for a vm or a vcpu
 * @desc: start address of an array of stats descriptors for a vm or a vcpu
 * @stats: start address of stats data block for a vm or a vcpu
 * @size_stats: the size of stats data block pointed by @stats
 * @user_buffer: start address of userspace buffer
 * @size: requested read size from userspace
 * @offset: the start position from which the content will be read for the
 *          corresponding vm or vcp file descriptor
 *
< ASCII >
 * The file content of a vm/vcpu file descriptor is now defined as below:
 * +-------------+
 * |   Header    |
 * +-------------+
 * |  id string  |
 * +-------------+
 * | Descriptors |
 * +-------------+
 * | Stats Data  |
 * +-------------+
< ASCII >
 * Although this function allows userspace to read any amount of data (as long
 * as in the limit) from any position, the typical usage would follow below
 * steps:
 * 1. Read header from offset 0. Get the offset of descriptors and stats data
 *    and some other necessary information. This is a one-time work for the
 *    lifecycle of the corresponding vm/vcpu stats fd.
 * 2. Read id string from its offset. This is a one-time work for the lifecycle
 *    of the corresponding vm/vcpu stats fd.
 * 3. Read descriptors from its offset and discover all the stats by parsing
 *    descriptors. This is a one-time work for the lifecycle of the
 *    corresponding vm/vcpu stats fd.
 * 4. Periodically read stats data from its offset using pread.
 *
 * Return: the number of bytes that has been successfully read
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_139.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/include/uapi/asm/sigcontext.h#L33-L86

```c
/*
 * To maintain compatibility with current implementations the sigcontext is
 * extended by appending a pointer (v_regs) to a quadword type (elf_vrreg_t)
 * followed by an unstructured (vmx_reserve) field of 101 doublewords. This
 * allows the array of vector registers to be quadword aligned independent of
 * the alignment of the containing sigcontext or ucontext. It is the
 * responsibility of the code setting the sigcontext to set this pointer to
 * either NULL (if this processor does not support the VMX feature) or the
 * address of the first quadword within the allocated (vmx_reserve) area.
 *
 * The pointer (v_regs) of vector type (elf_vrreg_t) is type compatible with
 * an array of 34 quadword entries (elf_vrregset_t).  The entries with
 * indexes 0-31 contain the corresponding vector registers.  The entry with
 * index 32 contains the vscr as the last word (offset 12) within the
 * quadword.  This allows the vscr to be stored as either a quadword (since
 * it must be copied via a vector register to/from storage) or as a word.
 * The entry with index 33 contains the vrsave as the first word (offset 0)
 * within the quadword.
 *
 * Part of the VSX data is stored here also by extending vmx_restore
 * by an additional 32 double words.  Architecturally the layout of
 * the VSR registers and how they overlap on top of the legacy FPR and
 * VR registers is shown below:
< ASCII >
 *
 *                    VSR doubleword 0               VSR doubleword 1
 *           ----------------------------------------------------------------
 *   VSR[0]  |             FPR[0]            |                              |
 *           ----------------------------------------------------------------
 *   VSR[1]  |             FPR[1]            |                              |
 *           ----------------------------------------------------------------
 *           |              ...              |                              |
 *           |              ...              |                              |
 *           ----------------------------------------------------------------
 *   VSR[30] |             FPR[30]           |                              |
 *           ----------------------------------------------------------------
 *   VSR[31] |             FPR[31]           |                              |
 *           ----------------------------------------------------------------
 *   VSR[32] |                             VR[0]                            |
 *           ----------------------------------------------------------------
 *   VSR[33] |                             VR[1]                            |
 *           ----------------------------------------------------------------
 *           |                              ...                             |
 *           |                              ...                             |
 *           ----------------------------------------------------------------
 *   VSR[62] |                             VR[30]                           |
 *           ----------------------------------------------------------------
 *   VSR[63] |                             VR[31]                           |
 *           ----------------------------------------------------------------
< ASCII >
 *
 * FPR/VSR 0-31 doubleword 0 is stored in fp_regs, and VMX/VSR 32-63
 * is stored at the start of vmx_reserve.  vmx_reserve is extended for
 * backwards compatility to store VSR 0-31 doubleword 1 after the VMX
 * registers and vscr/vrsave.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_14.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/core_polaris.c#L36-L64

```c
/*
 * Given a bus, device, and function number, compute resulting
 * configuration space address.  This is fairly straightforward
 * on POLARIS, since the chip itself generates Type 0 or Type 1
 * cycles automatically depending on the bus number (Bus 0 is
 * hardwired to Type 0, all others are Type 1.  Peer bridges
 * are not supported).
 *
< ASCII >
 * All types:
 *
 *  3 3 3 3|3 3 3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 
 *  9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |1|1|1|1|1|0|0|1|1|1|1|1|1|1|1|0|B|B|B|B|B|B|B|B|D|D|D|D|D|F|F|F|R|R|R|R|R|R|x|x|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 *	23:16	bus number (8 bits = 128 possible buses)
 *	15:11	Device number (5 bits)
 *	10:8	function number
 *	 7:2	register number
 *  
 * Notes:
 *	The function number selects which function of a multi-function device 
 *	(e.g., scsi and ethernet).
 * 
 *	The register selects a DWORD (32 bit) register offset.  Hence it
 *	doesn't get shifted by 2 bits as we want to "drop" the bottom two
 *	bits.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_140.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/kernel/hw_breakpoint.c#L416-L434

```c
/*
 * Watchpoint match range is always doubleword(8 bytes) aligned on
 * powerpc. If the given range is crossing doubleword boundary, we
 * need to increase the length such that next doubleword also get
 * covered. Ex,
< ASCII >
 *
 *          address   len = 6 bytes
 *                |=========.
 *   |------------v--|------v--------|
 *   | | | | | | | | | | | | | | | | |
 *   |---------------|---------------|
 *    <---8 bytes--->
< ASCII >
 *
 * In this case, we should configure hw as:
 *   start_addr = address & ~(HW_BREAKPOINT_SIZE - 1)
 *   len = 16 bytes
 *
 * @start_addr is inclusive but @end_addr is exclusive.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_141.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/kernel/nvram_64.c#L82-L106

```c
/*
 * For capturing and compressing an oops or panic report...

 * big_oops_buf[] holds the uncompressed text we're capturing.
 *
 * oops_buf[] holds the compressed text, preceded by a oops header.
 * oops header has u16 holding the version of oops header (to differentiate
 * between old and new format header) followed by u16 holding the length of
 * the compressed* text (*Or uncompressed, if compression fails.) and u64
 * holding the timestamp. oops_buf[] gets written to NVRAM.
 *
< ASCII >
 * oops_log_info points to the header. oops_data points to the compressed text.
 *
 * +- oops_buf
 * |                                   +- oops_data
 * v                                   v
 * +-----------+-----------+-----------+------------------------+
 * | version   | length    | timestamp | text                   |
 * | (2 bytes) | (2 bytes) | (8 bytes) | (oops_data_sz bytes)   |
 * +-----------+-----------+-----------+------------------------+
 * ^
 * +- oops_log_info
< ASCII >
 *
 * We preallocate these buffers during init to avoid kmalloc during oops/panic.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_142.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/kernel/nvram_64.c#L151-L179

```c
/* nvram_write_os_partition
 *
 * We need to buffer the error logs into nvram to ensure that we have
 * the failure information to decode.  If we have a severe error there
 * is no way to guarantee that the OS or the machine is in a state to
 * get back to user land and write the error to disk.  For example if
 * the SCSI device driver causes a Machine Check by writing to a bad
 * IO address, there is no way of guaranteeing that the device driver
 * is in any state that is would also be able to write the error data
 * captured to disk, thus we buffer it in NVRAM for analysis on the
 * next boot.
 *
 * In NVRAM the partition containing the error log buffer will looks like:
< ASCII >
 * Header (in bytes):
 * +-----------+----------+--------+------------+------------------+
 * | signature | checksum | length | name       | data             |
 * |0          |1         |2      3|4         15|16        length-1|
 * +-----------+----------+--------+------------+------------------+
 *
< ASCII >
< ASCII >
 * The 'data' section would look like (in bytes):
 * +--------------+------------+-----------------------------------+
 * | event_logged | sequence # | error log                         |
 * |0            3|4          7|8                  error_log_size-1|
 * +--------------+------------+-----------------------------------+
< ASCII >
 *
 * event_logged: 0 if event has not been logged to syslog, 1 if it has
 * sequence #: The unique sequence # for each event. (until it wraps)
 * error log: The error log from event_scan
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_143.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/kernel/pci_of_scan.c#L33-L60

```c
/**
 * pci_parse_of_flags - Parse the flags cell of a device tree PCI address
 * @addr0: value of 1st cell of a device tree PCI address.
 * @bridge: Set this flag if the address is from a bridge 'ranges' property
 *
< ASCII >
 * PCI Bus Binding to IEEE Std 1275-1994
 *
 * Bit#            33222222 22221111 11111100 00000000
 *                 10987654 32109876 54321098 76543210
 * phys.hi cell:   npt000ss bbbbbbbb dddddfff rrrrrrrr
 * phys.mid cell:  hhhhhhhh hhhhhhhh hhhhhhhh hhhhhhhh
 * phys.lo cell:   llllllll llllllll llllllll llllllll
 *
< ASCII >
 * where:
 * n        is 0 if the address is relocatable, 1 otherwise
 * p        is 1 if the addressable region is "prefetchable", 0 otherwise
 * t        is 1 if the address is aliased (for non-relocatable I/O),
 *          below 1 MB (for Memory),or below 64 KB (for relocatable I/O).
 * ss       is the space code, denoting the address space:
 *              00 denotes Configuration Space
 *              01 denotes I/O Space
 *              10 denotes 32-bit-address Memory Space
 *              11 denotes 64-bit-address Memory Space
 * bbbbbbbb is the 8-bit Bus Number
 * ddddd    is the 5-bit Device Number
 * fff      is the 3-bit Function Number
 * rrrrrrrr is the 8-bit Register Number
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_144.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/kvm/book3s_hv_uvmem.c#L104-L217

```c
/*
 * States of a GFN
 * ---------------
 * The GFN can be in one of the following states.
 *
 * (a) Secure - The GFN is secure. The GFN is associated with
 *	a Secure VM, the contents of the GFN is not accessible
 *	to the Hypervisor.  This GFN can be backed by a secure-PFN,
 *	or can be backed by a normal-PFN with contents encrypted.
 *	The former is true when the GFN is paged-in into the
 *	ultravisor. The latter is true when the GFN is paged-out
 *	of the ultravisor.
 *
 * (b) Shared - The GFN is shared. The GFN is associated with a
 *	a secure VM. The contents of the GFN is accessible to
 *	Hypervisor. This GFN is backed by a normal-PFN and its
 *	content is un-encrypted.
 *
 * (c) Normal - The GFN is a normal. The GFN is associated with
 *	a normal VM. The contents of the GFN is accessible to
 *	the Hypervisor. Its content is never encrypted.
 *
 * States of a VM.
 * ---------------
 *
 * Normal VM:  A VM whose contents are always accessible to
 *	the hypervisor.  All its GFNs are normal-GFNs.
 *
 * Secure VM: A VM whose contents are not accessible to the
 *	hypervisor without the VM's consent.  Its GFNs are
 *	either Shared-GFN or Secure-GFNs.
 *
 * Transient VM: A Normal VM that is transitioning to secure VM.
 *	The transition starts on successful return of
 *	H_SVM_INIT_START, and ends on successful return
 *	of H_SVM_INIT_DONE. This transient VM, can have GFNs
 *	in any of the three states; i.e Secure-GFN, Shared-GFN,
 *	and Normal-GFN.	The VM never executes in this state
 *	in supervisor-mode.
 *
 * Memory slot State.
 * -----------------------------
 *	The state of a memory slot mirrors the state of the
 *	VM the memory slot is associated with.
 *
 * VM State transition.
 * --------------------
 *
 *  A VM always starts in Normal Mode.
 *
 *  H_SVM_INIT_START moves the VM into transient state. During this
 *  time the Ultravisor may request some of its GFNs to be shared or
 *  secured. So its GFNs can be in one of the three GFN states.
 *
 *  H_SVM_INIT_DONE moves the VM entirely from transient state to
 *  secure-state. At this point any left-over normal-GFNs are
 *  transitioned to Secure-GFN.
 *
 *  H_SVM_INIT_ABORT moves the transient VM back to normal VM.
 *  All its GFNs are moved to Normal-GFNs.
 *
 *  UV_TERMINATE transitions the secure-VM back to normal-VM. All
 *  the secure-GFN and shared-GFNs are tranistioned to normal-GFN
 *  Note: The contents of the normal-GFN is undefined at this point.
 *
 * GFN state implementation:
 * -------------------------
 *
 * Secure GFN is associated with a secure-PFN; also called uvmem_pfn,
 * when the GFN is paged-in. Its pfn[] has KVMPPC_GFN_UVMEM_PFN flag
 * set, and contains the value of the secure-PFN.
 * It is associated with a normal-PFN; also called mem_pfn, when
 * the GFN is pagedout. Its pfn[] has KVMPPC_GFN_MEM_PFN flag set.
 * The value of the normal-PFN is not tracked.
 *
 * Shared GFN is associated with a normal-PFN. Its pfn[] has
 * KVMPPC_UVMEM_SHARED_PFN flag set. The value of the normal-PFN
 * is not tracked.
 *
 * Normal GFN is associated with normal-PFN. Its pfn[] has
 * no flag set. The value of the normal-PFN is not tracked.
 *
< ASCII >
 * Life cycle of a GFN
 * --------------------
 *
 * --------------------------------------------------------------
 * |        |     Share  |  Unshare | SVM       |H_SVM_INIT_DONE|
 * |        |operation   |operation | abort/    |               |
 * |        |            |          | terminate |               |
 * -------------------------------------------------------------
 * |        |            |          |           |               |
 * | Secure |     Shared | Secure   |Normal     |Secure         |
 * |        |            |          |           |               |
 * | Shared |     Shared | Secure   |Normal     |Shared         |
 * |        |            |          |           |               |
 * | Normal |     Shared | Secure   |Normal     |Secure         |
 * --------------------------------------------------------------
 *
< ASCII >
< ASCII >
 * Life cycle of a VM
 * --------------------
 *
 * --------------------------------------------------------------------
 * |         |  start    |  H_SVM_  |H_SVM_   |H_SVM_     |UV_SVM_    |
 * |         |  VM       |INIT_START|INIT_DONE|INIT_ABORT |TERMINATE  |
 * |         |           |          |         |           |           |
 * --------- ----------------------------------------------------------
 * |         |           |          |         |           |           |
 * | Normal  | Normal    | Transient|Error    |Error      |Normal     |
 * |         |           |          |         |           |           |
 * | Secure  |   Error   | Error    |Error    |Error      |Normal     |
 * |         |           |          |         |           |           |
 * |Transient|   N/A     | Error    |Secure   |Normal     |Normal     |
 * --------------------------------------------------------------------
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_145.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/mm/book3s64/hash_pgtable.c#L27-L101

```c
/*
 * vmemmap is the starting address of the virtual address space where
 * struct pages are allocated for all possible PFNs present on the system
 * including holes and bad memory (hence sparse). These virtual struct
 * pages are stored in sequence in this virtual address space irrespective
 * of the fact whether the corresponding PFN is valid or not. This achieves
 * constant relationship between address of struct page and its PFN.
 *
 * During boot or memory hotplug operation when a new memory section is
 * added, physical memory allocation (including hash table bolting) will
 * be performed for the set of struct pages which are part of the memory
 * section. This saves memory by not allocating struct pages for PFNs
 * which are not valid.
 *
< ASCII >
 *		----------------------------------------------
 *		| PHYSICAL ALLOCATION OF VIRTUAL STRUCT PAGES|
 *		----------------------------------------------
 *
 *	   f000000000000000                  c000000000000000
 * vmemmap +--------------+                  +--------------+
 *  +      |  page struct | +--------------> |  page struct |
 *  |      +--------------+                  +--------------+
 *  |      |  page struct | +--------------> |  page struct |
 *  |      +--------------+ |                +--------------+
 *  |      |  page struct | +       +------> |  page struct |
 *  |      +--------------+         |        +--------------+
 *  |      |  page struct |         |   +--> |  page struct |
 *  |      +--------------+         |   |    +--------------+
 *  |      |  page struct |         |   |
 *  |      +--------------+         |   |
 *  |      |  page struct |         |   |
 *  |      +--------------+         |   |
 *  |      |  page struct |         |   |
 *  |      +--------------+         |   |
 *  |      |  page struct |         |   |
 *  |      +--------------+         |   |
 *  |      |  page struct | +-------+   |
 *  |      +--------------+             |
 *  |      |  page struct | +-----------+
 *  |      +--------------+
 *  |      |  page struct | No mapping
 *  |      +--------------+
 *  |      |  page struct | No mapping
 *  v      +--------------+
 *
< ASCII >
< ASCII >
 *		-----------------------------------------
 *		| RELATION BETWEEN STRUCT PAGES AND PFNS|
 *		-----------------------------------------
 *
 * vmemmap +--------------+                 +---------------+
 *  +      |  page struct | +-------------> |      PFN      |
 *  |      +--------------+                 +---------------+
 *  |      |  page struct | +-------------> |      PFN      |
 *  |      +--------------+                 +---------------+
 *  |      |  page struct | +-------------> |      PFN      |
 *  |      +--------------+                 +---------------+
 *  |      |  page struct | +-------------> |      PFN      |
 *  |      +--------------+                 +---------------+
 *  |      |              |
 *  |      +--------------+
 *  |      |              |
 *  |      +--------------+
 *  |      |              |
 *  |      +--------------+                 +---------------+
 *  |      |  page struct | +-------------> |      PFN      |
 *  |      +--------------+                 +---------------+
 *  |      |              |
 *  |      +--------------+
 *  |      |              |
 *  |      +--------------+                 +---------------+
 *  |      |  page struct | +-------------> |      PFN      |
 *  |      +--------------+                 +---------------+
 *  |      |  page struct | +-------------> |      PFN      |
 *  v      +--------------+                 +---------------+
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_146.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/net/bpf_jit_comp32.c#L21-L29

```c
/*
< ASCII >
 * Stack layout:
 *
 *		[	prev sp		] <-------------
 *		[   nv gpr save area	] 16 * 4	|
 * fp (r31) -->	[   ebpf stack space	] upto 512	|
 *		[     frame header	] 16		|
 * sp (r1) --->	[    stack pointer	] --------------
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_147.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/net/bpf_jit_comp64.c#L22-L34

```c
/*
 * Stack layout:
 * Ensure the top half (upto local_tmp_var) stays consistent
 * with our redzone usage.
< ASCII >
 *
 *		[	prev sp		] <-------------
 *		[   nv gpr save area	] 5*8		|
 *		[    tail_call_cnt	] 8		|
 *		[    local_tmp_var	] 16		|
 * fp (r31) -->	[   ebpf stack space	] upto 512	|
 *		[     frame header	] 32/112	|
 * sp (r1) --->	[    stack pointer	] --------------
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_148.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/net/bpf_jit_comp64.c#L86-L96

```c
/*
< ASCII >
 * When not setting up our own stackframe, the redzone usage is:
 *
 *		[	prev sp		] <-------------
 *		[	  ...       	] 		|
 * sp (r1) --->	[    stack pointer	] --------------
 *		[   nv gpr save area	] 5*8
 *		[    tail_call_cnt	] 8
 *		[    local_tmp_var	] 16
 *		[   unused red zone	] 208 bytes protected
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_149.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/perf/imc-pmu.c#L893-L913

```c
/*
 * Allocates a page of memory for each of the online cpus, and load
 * LDBAR with 0.
 * The physical base address of the page allocated for a cpu will be
 * written to the LDBAR for that cpu, when the thread-imc event
 * is added.
 *
< ASCII >
 * LDBAR Register Layout:
 *
 *  0          4         8         12        16        20        24        28
 * | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - |
 *   | |       [   ]    [                   Counter Address [8:50]
 *   | * Mode    |
 *   |           * PB Scope
 *   * Enable/Disable
 *
 *  32        36        40        44        48        52        56        60
 * | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - |
 *           Counter Address [8:50]              ]
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_15.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/core_t2.c#L98-L138

```c
/*
 * Given a bus, device, and function number, compute resulting
 * configuration space address and setup the T2_HAXR2 register
 * accordingly.  It is therefore not safe to have concurrent
 * invocations to configuration space access routines, but there
 * really shouldn't be any need for this.
 *
< ASCII >
 * Type 0:
 *
 *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 
 *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | | |D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|0|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *	31:11	Device select bit.
 * 	10:8	Function number
 * 	 7:2	Register number
 *
< ASCII >
< ASCII >
 * Type 1:
 *
 *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 
 *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | | | | | | | | | | |B|B|B|B|B|B|B|B|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|1|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *	31:24	reserved
 *	23:16	bus number (8 bits = 128 possible buses)
 *	15:11	Device number (5 bits)
 *	10:8	function number
 *	 7:2	register number
 *  
< ASCII >
 * Notes:
 *	The function number selects which function of a multi-function device 
 *	(e.g., SCSI and Ethernet).
 * 
 *	The register selects a DWORD (32 bit) register offset.  Hence it
 *	doesn't get shifted by 2 bits as we want to "drop" the bottom two
 *	bits.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_150.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/perf/isa207-common.h#L125-L147

```c
/*
< ASCII >
 * Layout of constraint bits:
 *
 *        60        56        52        48        44        40        36        32
 * | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - |
 *   [   fab_match   ]         [       thresh_cmp      ] [   thresh_ctl    ] [   ]
 *                                          |                                  |
 *                           [  thresh_cmp bits for p10]           thresh_sel -*
 *
 *        28        24        20        16        12         8         4         0
 * | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - |
 *               [ ] |   [ ] |  [  sample ]   [     ]   [6] [5]   [4] [3]   [2] [1]
 *                |  |    |  |                  |
 *      BHRB IFM -*  |    |  |*radix_scope      |      Count of events for each PMC.
 *              EBB -*    |                     |        p1, p2, p3, p4, p5, p6.
 *      L1 I/D qualifier -*                     |
 *                     nc - number of counters -*
< ASCII >
 *
 * The PMC fields P1..P6, and NC, are adder fields. As we accumulate constraints
 * we want the low bit of each field to be added to any existing value.
 *
 * Everything else is a value field.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_151.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/perf/power10-pmu.c#L13-L73

```c
/*
< ASCII >
 * Raw event encoding for Power10:
 *
 *        60        56        52        48        44        40        36        32
 * | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - |
 *   | | [ ]   [ src_match ] [  src_mask ]   | [ ] [ l2l3_sel ]  [  thresh_ctl   ]
 *   | |  |                                  |  |                         |
 *   | |  *- IFM (Linux)                     |  |        thresh start/stop -*
 *   | *- BHRB (Linux)                       |  src_sel
 *   *- EBB (Linux)                          *invert_bit
 *
 *        28        24        20        16        12         8         4         0
 * | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - |
 *   [   ] [  sample ]   [ ] [ ]   [ pmc ]   [unit ]   [ ] |  m   [    pmcxsel    ]
 *     |        |        |    |                        |   |  |
 *     |        |        |    |                        |   |  *- mark
 *     |        |        |    *- L1/L2/L3 cache_sel    |   |*-radix_scope_qual
 *     |        |        sdar_mode                     |
 *     |        *- sampling mode for marked events     *- combine
 *     |
 *     *- thresh_sel
< ASCII >
 *
 * Below uses IBM bit numbering.
 *
 * MMCR1[x:y] = unit    (PMCxUNIT)
 * MMCR1[24]   = pmc1combine[0]
 * MMCR1[25]   = pmc1combine[1]
 * MMCR1[26]   = pmc2combine[0]
 * MMCR1[27]   = pmc2combine[1]
 * MMCR1[28]   = pmc3combine[0]
 * MMCR1[29]   = pmc3combine[1]
 * MMCR1[30]   = pmc4combine[0]
 * MMCR1[31]   = pmc4combine[1]
 *
 * if pmc == 3 and unit == 0 and pmcxsel[0:6] == 0b0101011
 *	MMCR1[20:27] = thresh_ctl
 * else if pmc == 4 and unit == 0xf and pmcxsel[0:6] == 0b0101001
 *	MMCR1[20:27] = thresh_ctl
 * else
 *	MMCRA[48:55] = thresh_ctl   (THRESH START/END)
 *
 * if thresh_sel:
 *	MMCRA[45:47] = thresh_sel
 *
 * if l2l3_sel:
 * MMCR2[56:60] = l2l3_sel[0:4]
 *
 * MMCR1[16] = cache_sel[0]
 * MMCR1[17] = cache_sel[1]
 * MMCR1[18] = radix_scope_qual
 *
 * if mark:
 *	MMCRA[63]    = 1		(SAMPLE_ENABLE)
 *	MMCRA[57:59] = sample[0:2]	(RAND_SAMP_ELIG)
 *	MMCRA[61:62] = sample[3:4]	(RAND_SAMP_MODE)
 *
 * if EBB and BHRB:
 *	MMCRA[32:33] = IFM
 *
 * MMCRA[SDAR_MODE]  = sdar_mode[0:1]
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_152.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/perf/power8-pmu.c#L30-L92

```c
/*
< ASCII >
 * Raw event encoding for PowerISA v2.07 (Power8):
 *
 *        60        56        52        48        44        40        36        32
 * | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - |
 *   | | [ ]                           [      thresh_cmp     ]   [  thresh_ctl   ]
 *   | |  |                                                              |
 *   | |  *- IFM (Linux)                 thresh start/stop OR FAB match -*
 *   | *- BHRB (Linux)
 *   *- EBB (Linux)
 *
 *        28        24        20        16        12         8         4         0
 * | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - |
 *   [   ] [  sample ]   [cache]   [ pmc ]   [unit ]   c     m   [    pmcxsel    ]
 *     |        |           |                          |     |
 *     |        |           |                          |     *- mark
 *     |        |           *- L1/L2/L3 cache_sel      |
 *     |        |                                      |
 *     |        *- sampling mode for marked events     *- combine
 *     |
 *     *- thresh_sel
< ASCII >
 *
 * Below uses IBM bit numbering.
 *
 * MMCR1[x:y] = unit    (PMCxUNIT)
 * MMCR1[x]   = combine (PMCxCOMB)
 *
 * if pmc == 3 and unit == 0 and pmcxsel[0:6] == 0b0101011
 *	# PM_MRK_FAB_RSP_MATCH
 *	MMCR1[20:27] = thresh_ctl   (FAB_CRESP_MATCH / FAB_TYPE_MATCH)
 * else if pmc == 4 and unit == 0xf and pmcxsel[0:6] == 0b0101001
 *	# PM_MRK_FAB_RSP_MATCH_CYC
 *	MMCR1[20:27] = thresh_ctl   (FAB_CRESP_MATCH / FAB_TYPE_MATCH)
 * else
 *	MMCRA[48:55] = thresh_ctl   (THRESH START/END)
 *
 * if thresh_sel:
 *	MMCRA[45:47] = thresh_sel
 *
 * if thresh_cmp:
 *	MMCRA[22:24] = thresh_cmp[0:2]
 *	MMCRA[25:31] = thresh_cmp[3:9]
 *
 * if unit == 6 or unit == 7
 *	MMCRC[53:55] = cache_sel[1:3]      (L2EVENT_SEL)
 * else if unit == 8 or unit == 9:
 *	if cache_sel[0] == 0: # L3 bank
 *		MMCRC[47:49] = cache_sel[1:3]  (L3EVENT_SEL0)
 *	else if cache_sel[0] == 1:
 *		MMCRC[50:51] = cache_sel[2:3]  (L3EVENT_SEL1)
 * else if cache_sel[1]: # L1 event
 *	MMCR1[16] = cache_sel[2]
 *	MMCR1[17] = cache_sel[3]
 *
 * if mark:
 *	MMCRA[63]    = 1		(SAMPLE_ENABLE)
 *	MMCRA[57:59] = sample[0:2]	(RAND_SAMP_ELIG)
 *	MMCRA[61:62] = sample[3:4]	(RAND_SAMP_MODE)
 *
 * if EBB and BHRB:
 *	MMCRA[32:33] = IFM
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_153.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/perf/power9-pmu.c#L14-L74

```c
/*
< ASCII >
 * Raw event encoding for Power9:
 *
 *        60        56        52        48        44        40        36        32
 * | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - |
 *   | | [ ]                       [ ] [      thresh_cmp     ]   [  thresh_ctl   ]
 *   | |  |                         |                                     |
 *   | |  *- IFM (Linux)            |	               thresh start/stop -*
 *   | *- BHRB (Linux)              *sm
 *   *- EBB (Linux)
 *
 *        28        24        20        16        12         8         4         0
 * | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - | - - - - |
 *   [   ] [  sample ]   [cache]   [ pmc ]   [unit ]   []    m   [    pmcxsel    ]
 *     |        |           |                          |     |
 *     |        |           |                          |     *- mark
 *     |        |           *- L1/L2/L3 cache_sel      |
 *     |        |                                      |
 *     |        *- sampling mode for marked events     *- combine
 *     |
 *     *- thresh_sel
< ASCII >
 *
 * Below uses IBM bit numbering.
 *
 * MMCR1[x:y] = unit    (PMCxUNIT)
 * MMCR1[24]   = pmc1combine[0]
 * MMCR1[25]   = pmc1combine[1]
 * MMCR1[26]   = pmc2combine[0]
 * MMCR1[27]   = pmc2combine[1]
 * MMCR1[28]   = pmc3combine[0]
 * MMCR1[29]   = pmc3combine[1]
 * MMCR1[30]   = pmc4combine[0]
 * MMCR1[31]   = pmc4combine[1]
 *
 * if pmc == 3 and unit == 0 and pmcxsel[0:6] == 0b0101011
 *	MMCR1[20:27] = thresh_ctl
 * else if pmc == 4 and unit == 0xf and pmcxsel[0:6] == 0b0101001
 *	MMCR1[20:27] = thresh_ctl
 * else
 *	MMCRA[48:55] = thresh_ctl   (THRESH START/END)
 *
 * if thresh_sel:
 *	MMCRA[45:47] = thresh_sel
 *
 * if thresh_cmp:
 *	MMCRA[9:11] = thresh_cmp[0:2]
 *	MMCRA[12:18] = thresh_cmp[3:9]
 *
 * MMCR1[16] = cache_sel[2]
 * MMCR1[17] = cache_sel[3]
 *
 * if mark:
 *	MMCRA[63]    = 1		(SAMPLE_ENABLE)
 *	MMCRA[57:59] = sample[0:2]	(RAND_SAMP_ELIG)
 *	MMCRA[61:62] = sample[3:4]	(RAND_SAMP_MODE)
 *
 * if EBB and BHRB:
 *	MMCRA[32:33] = IFM
 *
 * MMCRA[SDAR_MODE]  = sm
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_154.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/platforms/powernv/subcore.c#L27-L123

```c
/*
 * Split/unsplit procedure:
 *
 * A core can be in one of three states, unsplit, 2-way split, and 4-way split.
 *
< ASCII >
 * The mapping to subcores_per_core is simple:
 *
 *  State       | subcores_per_core
 *  ------------|------------------
 *  Unsplit     |        1
 *  2-way split |        2
 *  4-way split |        4
< ASCII >
 *
 * The core is split along thread boundaries, the mapping between subcores and
 * threads is as follows:
< ASCII >
 *
 *  Unsplit:
 *          ----------------------------
 *  Subcore |            0             |
 *          ----------------------------
 *  Thread  |  0  1  2  3  4  5  6  7  |
 *          ----------------------------
 *
 *  2-way split:
 *          -------------------------------------
 *  Subcore |        0        |        1        |
 *          -------------------------------------
 *  Thread  |  0   1   2   3  |  4   5   6   7  |
 *          -------------------------------------
 *
 *  4-way split:
 *          -----------------------------------------
 *  Subcore |    0    |    1    |    2    |    3    |
 *          -----------------------------------------
 *  Thread  |  0   1  |  2   3  |  4   5  |  6   7  |
 *          -----------------------------------------
< ASCII >
 *
 *
 * Transitions
 * -----------
 *
 * It is not possible to transition between either of the split states, the
 * core must first be unsplit. The legal transitions are:
< ASCII >
 *
 *  -----------          ---------------
 *  |         |  <---->  | 2-way split |
 *  |         |          ---------------
 *  | Unsplit |
 *  |         |          ---------------
 *  |         |  <---->  | 4-way split |
 *  -----------          ---------------
< ASCII >
 *
 * Unsplitting
 * -----------
 *
 * Unsplitting is the simpler procedure. It requires thread 0 to request the
 * unsplit while all other threads NAP.
 *
 * Thread 0 clears HID0_POWER8_DYNLPARDIS (Dynamic LPAR Disable). This tells
 * the hardware that if all threads except 0 are napping, the hardware should
 * unsplit the core.
 *
 * Non-zero threads are sent to a NAP loop, they don't exit the loop until they
 * see the core unsplit.
 *
 * Core 0 spins waiting for the hardware to see all the other threads napping
 * and perform the unsplit.
 *
 * Once thread 0 sees the unsplit, it IPIs the secondary threads to wake them
 * out of NAP. They will then see the core unsplit and exit the NAP loop.
 *
 * Splitting
 * ---------
 *
 * The basic splitting procedure is fairly straight forward. However it is
 * complicated by the fact that after the split occurs, the newly created
 * subcores are not in a fully initialised state.
 *
 * Most notably the subcores do not have the correct value for SDR1, which
 * means they must not be running in virtual mode when the split occurs. The
 * subcores have separate timebases SPRs but these are pre-synchronised by
 * opal.
 *
 * To begin with secondary threads are sent to an assembly routine. There they
 * switch to real mode, so they are immune to the uninitialised SDR1 value.
 * Once in real mode they indicate that they are in real mode, and spin waiting
 * to see the core split.
 *
 * Thread 0 waits to see that all secondaries are in real mode, and then begins
 * the splitting procedure. It firstly sets HID0_POWER8_DYNLPARDIS, which
 * prevents the hardware from unsplitting. Then it sets the appropriate HID bit
 * to request the split, and spins waiting to see that the split has happened.
 *
 * Concurrently the secondaries will notice the split. When they do they set up
 * their SPRs, notably SDR1, and then they can return to virtual mode and exit
 * the procedure.
 */
```
## Visual type:
- #custom


== ./linux/linux_155.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/platforms/pseries/vphn.c#L5-L24

```c
/*
 * The associativity domain numbers are returned from the hypervisor as a
 * stream of mixed 16-bit and 32-bit fields. The stream is terminated by the
 * special value of "all ones" (aka. 0xffff) and its size may not exceed 48
 * bytes.
< ASCII >
 *
 *    --- 16-bit fields -->
 *  _________________________
 *  |  0  |  1  |  2  |  3  |   be_packed[0]
 *  ------+-----+-----+------
 *  _________________________
 *  |  4  |  5  |  6  |  7  |   be_packed[1]
 *  -------------------------
 *            ...
 *  _________________________
 *  | 20  | 21  | 22  | 23  |   be_packed[5]
 *  -------------------------
< ASCII >
 *
 * Convert to the sequence they would appear in the ibm,associativity property.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_156.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/powerpc/xmon/spu-insns.h#L10-L113

```c
/* SPU Opcode Table

< ASCII >
-=-=-= FORMAT =-=-=-
                                             		                                             
       +----+-------+-------+-------+-------+  		       +------------+-------+-------+-------+
RRR    | op |  RC   |  RB   |  RA   |  RT   |		RI7    | op         |  I7   |  RA   |  RT   |
       +----+-------+-------+-------+-------+		       +------------+-------+-------+-------+
        0  3       1       1       2       3		        0          1       1       2       3 
                   0       7       4       1		                   0       7       4       1 

       +-----------+--------+-------+-------+		       +---------+----------+-------+-------+
RI8    | op        |   I8   |  RA   |  RT   |		RI10   | op      |   I10    |  RA   |  RT   |
       +-----------+--------+-------+-------+		       +---------+----------+-------+-------+
        0         9        1       2       3		        0       7          1       2       3 
                           7       4       1		                           7       4       1 

       +----------+-----------------+-------+		       +--------+-------------------+-------+
RI16   | op       |       I16       |  RT   |		RI18   | op     |       I18         |  RT   |
       +----------+-----------------+-------+		       +--------+-------------------+-------+
        0        8                 2       3		        0      6                   2       3 
                                   4       1		                                   4       1 

       +------------+-------+-------+-------+		       +-------+--+-----------------+-------+
RR     | op         |  RB   |  RA   |  RT   |		LBT    | op    |RO|       I16       |  RO   |
       +------------+-------+-------+-------+		       +-------+--+-----------------+-------+
        0          1       1       2       3		        0     6  8                 2       3 
                   0       7       4       1		                                   4       1 

							       +------------+----+--+-------+-------+
							LBTI   | op         | // |RO|  RA   |  RO   |
							       +------------+----+--+-------+-------+
							        0          1    1  1       2       3
							                   0    5  7       4       1
< ASCII >

-=-=-= OPCODE =-=-=-

OPCODE field specifies the most significant 11bit of the instruction. Some formats don't have 11bits for opcode field, and in this
case, bit field other than op are defined as 0s. For example, opcode of fma instruction which is RRR format is defined as 0x700,
since 0x700 -> 11'b11100000000, this means opcode is 4'b1110, and other 7bits are defined as 7'b0000000.

-=-=-= ASM_FORMAT =-=-=-

< ASCII >
RRR category						RI7 category                               
	ASM_RRR		mnemonic RC, RA, RB, RT		        ASM_RI4         mnemonic RT, RA, I4
							        ASM_RI7         mnemonic RT, RA, I7

RI8 category						RI10 category                               
	ASM_RUI8	mnemonic RT, RA, UI8		        ASM_AI10        mnemonic RA, I10    
							        ASM_RI10        mnemonic RT, RA, R10
							        ASM_RI10IDX     mnemonic RT, I10(RA)

RI16 category						RI18 category                           
	ASM_I16W	mnemonic I16W			        ASM_RI18        mnemonic RT, I18
	ASM_RI16	mnemonic RT, I16
	ASM_RI16W	mnemonic RT, I16W

RR category						LBT category                                    
	ASM_MFSPR	mnemonic RT, SA			        ASM_LBT         mnemonic brinst, brtarg 
	ASM_MTSPR	mnemonic SA, RT			                                                
	ASM_NOOP	mnemonic			LBTI category                                   
	ASM_RA		mnemonic RA			        ASM_LBTI        mnemonic brinst, RA     
	ASM_RAB		mnemonic RA, RB
	ASM_RDCH	mnemonic RT, CA
	ASM_RR		mnemonic RT, RA, RB
	ASM_RT		mnemonic RT
	ASM_RTA		mnemonic RT, RA
	ASM_WRCH	mnemonic CA, RT
< ASCII >

Note that RRR instructions have the names for RC and RT reversed from
what's in the ISA, in order to put RT in the same position it appears
for other formats.

-=-=-= DEPENDENCY =-=-=-

DEPENDENCY filed consists of 5 digits. This represents which register is used as source and which register is used as target.
The first(most significant) digit is always 0. Then it is followd by RC, RB, RA and RT digits.
If the digit is 0, this means the corresponding register is not used in the instruction.
If the digit is 1, this means the corresponding register is used as a source in the instruction.
If the digit is 2, this means the corresponding register is used as a target in the instruction.
If the digit is 3, this means the corresponding register is used as both source and target in the instruction.
For example, fms instruction has 00113 as the DEPENDENCY field. This means RC is not used in this operation, RB and RA are
used as sources and RT is the target.

-=-=-= PIPE =-=-=-

This field shows which execution pipe is used for the instruction

pipe0 execution pipelines:
	FP6	SP floating pipeline
	FP7	integer operations executed in SP floating pipeline
	FPD	DP floating pipeline
	FX2	FXU pipeline
	FX3	Rotate/Shift pipeline
	FXB	Byte pipeline
	NOP	No pipeline

pipe1 execution pipelines:
	BR	Branch pipeline
	LNOP	No pipeline
	LS	Load/Store pipeline
	SHUF	Shuffle pipeline
	SPR	SPR/CH pipeline

*/
```
## Visual type:
- #memory-layout


== ./linux/linux_157.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/riscv/include/asm/pgtable-32.h#L20-L24

```c
/*
< ASCII >
 * rv32 PTE format:
 * | XLEN-1  10 | 9             8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0
 *       PFN      reserved for SW   D   A   G   U   X   W   R   V
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_158.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/riscv/include/asm/pgtable-64.h#L74-L78

```c
/*
< ASCII >
 * rv64 PTE format:
 * | 63 | 62 61 | 60 54 | 53  10 | 9             8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0
 *   N      MT     RSV    PFN      reserved for SW   D   A   G   U   X   W   R   V
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_159.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/riscv/net/bpf_jit_comp32.c#L16-L41

```c
/*
< ASCII >
 * Stack layout during BPF program execution:
 *
 *                     high
 *     RV32 fp =>  +----------+
 *                 | saved ra |
 *                 | saved fp | RV32 callee-saved registers
 *                 |   ...    |
 *                 +----------+ <= (fp - 4 * NR_SAVED_REGISTERS)
 *                 |  hi(R6)  |
 *                 |  lo(R6)  |
 *                 |  hi(R7)  | JIT scratch space for BPF registers
 *                 |  lo(R7)  |
 *                 |   ...    |
 *  BPF_REG_FP =>  +----------+ <= (fp - 4 * NR_SAVED_REGISTERS
 *                 |          |        - 4 * BPF_JIT_SCRATCH_REGS)
 *                 |          |
 *                 |   ...    | BPF program stack
 *                 |          |
 *     RV32 sp =>  +----------+
 *                 |          |
 *                 |   ...    | Function call stack
 *                 |          |
 *                 +----------+
 *                     low
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_16.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/core_titan.c#L80-L112

```c
/*
 * Given a bus, device, and function number, compute resulting
 * configuration space address
 * accordingly.  It is therefore not safe to have concurrent
 * invocations to configuration space access routines, but there
 * really shouldn't be any need for this.
 *
 * Note that all config space accesses use Type 1 address format.
 *
 * Note also that type 1 is determined by non-zero bus number.
 *
< ASCII >
 * Type 1:
 *
 *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 
 *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | | | | | | | | | | |B|B|B|B|B|B|B|B|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|1|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
< ASCII >
 *	31:24	reserved
 *	23:16	bus number (8 bits = 128 possible buses)
 *	15:11	Device number (5 bits)
 *	10:8	function number
 *	 7:2	register number
 *  
 * Notes:
 *	The function number selects which function of a multi-function device 
 *	(e.g., SCSI and Ethernet).
 * 
 *	The register selects a DWORD (32 bit) register offset.  Hence it
 *	doesn't get shifted by 2 bits as we want to "drop" the bottom two
 *	bits.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_160.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/s390/include/asm/alternative.h#L21-L41

```c
/*
< ASCII >
 * +---------------------------------+
 * |661:			     |662:
 * | oldinstr			     |
 * +---------------------------------+
 *
 * .altinstr_replacement section
 * +---------------------------------+
 * |6641:			     |6651:
 * | alternative instr 1	     |
 * +---------------------------------+
 * |6642:			     |6652:
 * | alternative instr 2	     |
 * +---------------------------------+
 *
 * .altinstructions section
 * +---------------------------------+
 * | alt_instr entries for each      |
 * | alternative instr		     |
 * +---------------------------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_161.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/s390/include/asm/pgtable.h#L112-L161

```c
/*
< ASCII >
 * A 64 bit pagetable entry of S390 has following format:
 * |			 PFRA			      |0IPC|  OS  |
 * 0000000000111111111122222222223333333333444444444455555555556666
 * 0123456789012345678901234567890123456789012345678901234567890123
< ASCII >
 *
 * I Page-Invalid Bit:    Page is not available for address-translation
 * P Page-Protection Bit: Store access not possible for page
 * C Change-bit override: HW is not required to set change bit
 *
< ASCII >
 * A 64 bit segmenttable entry of S390 has following format:
 * |        P-table origin                              |      TT
 * 0000000000111111111122222222223333333333444444444455555555556666
 * 0123456789012345678901234567890123456789012345678901234567890123
< ASCII >
 *
 * I Segment-Invalid Bit:    Segment is not available for address-translation
 * C Common-Segment Bit:     Segment is not private (PoP 3-30)
 * P Page-Protection Bit: Store access not possible for page
 * TT Type 00
 *
< ASCII >
 * A 64 bit region table entry of S390 has following format:
 * |        S-table origin                             |   TF  TTTL
 * 0000000000111111111122222222223333333333444444444455555555556666
 * 0123456789012345678901234567890123456789012345678901234567890123
< ASCII >
 *
 * I Segment-Invalid Bit:    Segment is not available for address-translation
 * TT Type 01
 * TF
 * TL Table length
 *
< ASCII >
 * The 64 bit regiontable origin of S390 has following format:
 * |      region table origon                          |       DTTL
 * 0000000000111111111122222222223333333333444444444455555555556666
 * 0123456789012345678901234567890123456789012345678901234567890123
< ASCII >
 *
 * X Space-Switch event:
 * G Segment-Invalid Bit:  
 * P Private-Space Bit:    
 * S Storage-Alteration:
 * R Real space
 * TL Table-Length:
 *
< ASCII >
 * A storage key has the following format:
 * | ACC |F|R|C|0|
 *  0   3 4 5 6 7
< ASCII >
 * ACC: access key
 * F  : fetch protection bit
 * R  : referenced bit
 * C  : changed bit
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_162.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/s390/mm/fault.c#L319-L329

```c
/*
 * This routine handles page faults.  It determines the address,
 * and the problem, and then passes it off to one of the appropriate
 * routines.
 *
< ASCII >
 * interruption code (int_code):
 *   04       Protection           ->  Write-Protection  (suppression)
 *   10       Segment translation  ->  Not present       (nullification)
 *   11       Page translation     ->  Not present       (nullification)
 *   3b       Region third trans.  ->  Not present       (nullification)
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_163.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/s390/mm/pgalloc.c#L178-L248

```c
/*
 * A 2KB-pgtable is either upper or lower half of a normal page.
 * The second half of the page may be unused or used as another
 * 2KB-pgtable.
 *
 * Whenever possible the parent page for a new 2KB-pgtable is picked
 * from the list of partially allocated pages mm_context_t::pgtable_list.
 * In case the list is empty a new parent page is allocated and added to
 * the list.
 *
 * When a parent page gets fully allocated it contains 2KB-pgtables in both
 * upper and lower halves and is removed from mm_context_t::pgtable_list.
 *
 * When 2KB-pgtable is freed from to fully allocated parent page that
 * page turns partially allocated and added to mm_context_t::pgtable_list.
 *
 * If 2KB-pgtable is freed from the partially allocated parent page that
 * page turns unused and gets removed from mm_context_t::pgtable_list.
 * Furthermore, the unused parent page is released.
 *
 * As follows from the above, no unallocated or fully allocated parent
 * pages are contained in mm_context_t::pgtable_list.
 *
 * The upper byte (bits 24-31) of the parent page _refcount is used
 * for tracking contained 2KB-pgtables and has the following format:
 *
< ASCII >
 *   PP  AA
 * 01234567    upper byte (bits 24-31) of struct page::_refcount
 *   ||  ||
 *   ||  |+--- upper 2KB-pgtable is allocated
 *   ||  +---- lower 2KB-pgtable is allocated
 *   |+------- upper 2KB-pgtable is pending for removal
 *   +-------- lower 2KB-pgtable is pending for removal
< ASCII >
 *
 * (See commit 620b4e903179 ("s390: use _refcount for pgtables") on why
 * using _refcount is possible).
 *
 * When 2KB-pgtable is allocated the corresponding AA bit is set to 1.
 * The parent page is either:
 *   - added to mm_context_t::pgtable_list in case the second half of the
 *     parent page is still unallocated;
 *   - removed from mm_context_t::pgtable_list in case both hales of the
 *     parent page are allocated;
 * These operations are protected with mm_context_t::lock.
 *
 * When 2KB-pgtable is deallocated the corresponding AA bit is set to 0
 * and the corresponding PP bit is set to 1 in a single atomic operation.
 * Thus, PP and AA bits corresponding to the same 2KB-pgtable are mutually
 * exclusive and may never be both set to 1!
 * The parent page is either:
 *   - added to mm_context_t::pgtable_list in case the second half of the
 *     parent page is still allocated;
 *   - removed from mm_context_t::pgtable_list in case the second half of
 *     the parent page is unallocated;
 * These operations are protected with mm_context_t::lock.
 *
 * It is important to understand that mm_context_t::lock only protects
 * mm_context_t::pgtable_list and AA bits, but not the parent page itself
 * and PP bits.
 *
 * Releasing the parent page happens whenever the PP bit turns from 1 to 0,
 * while both AA bits and the second PP bit are already unset. Then the
 * parent page does not contain any 2KB-pgtable fragment anymore, and it has
 * also been removed from mm_context_t::pgtable_list. It is safe to release
 * the page therefore.
 *
 * PGSTE memory spaces use full 4KB-pgtables and do not need most of the
 * logic described above. Both AA bits are set to 1 to denote a 4KB-pgtable
 * while the PP bits are never used, nor such a page is added to or removed
 * from mm_context_t::pgtable_list.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_164.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/s390/net/bpf_jit.h#L21-L47

```c
/*
< ASCII >
 * Stackframe layout (packed stack):
 *
 *				    ^ high
 *	      +---------------+     |
 *	      | old backchain |     |
 *	      +---------------+     |
 *	      |   r15 - r6    |     |
 *	      +---------------+     |
 *	      | 4 byte align  |     |
 *	      | tail_call_cnt |     |
 * BFP	   -> +===============+     |
 *	      |		      |     |
 *	      |   BPF stack   |     |
 *	      |		      |     |
 * R15+160 -> +---------------+     |
 *	      | new backchain |     |
 * R15+152 -> +---------------+     |
 *	      | + 152 byte SA |     |
 * R15	   -> +---------------+     + low
< ASCII >
 *
 * We get 160 bytes stack space from calling function, but only use
 * 12 * 8 byte for old backchain, r15..r6, and tail_call_cnt.
 *
 * The stack size used by the BPF program ("BPF stack" above) is passed
 * via "aux->stack_depth".
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_165.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sh/boards/board-urquell.c#L27-L50

```c
/*
< ASCII >
 * bit  1234 5678
 *----------------------------
 * SW1  0101 0010  -> Pck 33MHz version
 *     (1101 0010)    Pck 66MHz version
 * SW2  0x1x xxxx  -> little endian
 *                    29bit mode
 * SW47 0001 1000  -> CS0 : on-board flash
 *                    CS1 : SRAM, registers, LAN, PCMCIA
 *                    38400 bps for SCIF1
 *
 * Address
 * 0x00000000 - 0x04000000  (CS0)     Nor Flash
 * 0x04000000 - 0x04200000  (CS1)     SRAM
 * 0x05000000 - 0x05800000  (CS1)     on board register
 * 0x05800000 - 0x06000000  (CS1)     LAN91C111
 * 0x06000000 - 0x06400000  (CS1)     PCMCIA
 * 0x08000000 - 0x10000000  (CS2-CS3) DDR3
 * 0x10000000 - 0x14000000  (CS4)     PCIe
 * 0x14000000 - 0x14800000  (CS5)     Core0 LRAM/URAM
 * 0x14800000 - 0x15000000  (CS5)     Core1 LRAM/URAM
 * 0x18000000 - 0x1C000000  (CS6)     ATA/NAND-Flash
 * 0x1C000000 -             (CS7)     SH7786 Control register
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_166.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sh/boards/mach-ecovec24/setup.c#L50-L59

```c
/*
< ASCII >
 *  Address      Interface        BusWidth
 *-----------------------------------------
 *  0x0000_0000  uboot            16bit
 *  0x0004_0000  Linux romImage   16bit
 *  0x0014_0000  MTD for Linux    16bit
 *  0x0400_0000  Internal I/O     16/32bit
 *  0x0800_0000  DRAM             32bit
 *  0x1800_0000  MFI              16bit
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_167.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sh/boards/mach-migor/setup.c#L40-L46

```c
< ASCII >
/* Address     IRQ  Size  Bus  Description
 * 0x00000000       64MB  16   NOR Flash (SP29PL256N)
 * 0x0c000000       64MB  64   SDRAM (2xK4M563233G)
 * 0x10000000  IRQ0       16   Ethernet (SMC91C111)
 * 0x14000000  IRQ4       16   USB 2.0 Host Controller (M66596)
 * 0x18000000       8GB    8   NAND Flash (K9K8G08U0A)
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_168.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sh/drivers/dma/dmabrg.c#L15-L54

```c
/*
 * The DMABRG is a special DMA unit within the SH7760. It does transfers
 * from USB-SRAM/Audio units to main memory (and also the LCDC; but that
 * part is sensibly placed  in the LCDC  registers and requires no irqs)
 * It has 3 IRQ lines which trigger 10 events, and works independently
 * from the traditional SH DMAC (although it blocks usage of DMAC 0)
< ASCII >
 *
 * BRGIRQID   | component | dir | meaning      | source
 * -----------------------------------------------------
 *     0      | USB-DMA   | ... | xfer done    | DMABRGI1
 *     1      | USB-UAE   | ... | USB addr err.| DMABRGI0
 *     2      | HAC0/SSI0 | play| all done     | DMABRGI1
 *     3      | HAC0/SSI0 | play| half done    | DMABRGI2
 *     4      | HAC0/SSI0 | rec | all done     | DMABRGI1
 *     5      | HAC0/SSI0 | rec | half done    | DMABRGI2
 *     6      | HAC1/SSI1 | play| all done     | DMABRGI1
 *     7      | HAC1/SSI1 | play| half done    | DMABRGI2
 *     8      | HAC1/SSI1 | rec | all done     | DMABRGI1
 *     9      | HAC1/SSI1 | rec | half done    | DMABRGI2
< ASCII >
 *
 * all can be enabled/disabled in the DMABRGCR register,
 * as well as checked if they occurred.
 *
 * DMABRGI0 services  USB  DMA  Address  errors,  but it still must be
 * enabled/acked in the DMABRGCR register.  USB-DMA complete indicator
 * is grouped together with the audio buffer end indicators, too bad...
 *
 * DMABRGCR:	Bits 31-24: audio-dma ENABLE flags,
 *		Bits 23-16: audio-dma STATUS flags,
 *		Bits  9-8:  USB error/xfer ENABLE,
 *		Bits  1-0:  USB error/xfer STATUS.
 *	Ack an IRQ by writing 0 to the STATUS flag.
 *	Mask IRQ by writing 0 to ENABLE flag.
 *
 * Usage is almost like with any other IRQ:
 *  dmabrg_request_irq(BRGIRQID, handler, data)
 *  dmabrg_free_irq(BRGIRQID)
 *
 * handler prototype:  void brgirqhandler(void *data)
 */
```
## Visual type:
- #table


== ./linux/linux_169.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sh/include/asm/addrspace.h#L15-L21

```c
/*
< ASCII >
   [ P0/U0 (virtual) ]		0x00000000     <------ User space
   [ P1 (fixed)   cached ]	0x80000000     <------ Kernel space
   [ P2 (fixed)  non-cachable]	0xA0000000     <------ Physical access
   [ P3 (virtual) cached]	0xC0000000     <------ vmalloced area
   [ P4 control   ]		0xE0000000
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_17.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/core_tsunami.c#L57-L89

```c
/*
 * Given a bus, device, and function number, compute resulting
 * configuration space address
 * accordingly.  It is therefore not safe to have concurrent
 * invocations to configuration space access routines, but there
 * really shouldn't be any need for this.
 *
 * Note that all config space accesses use Type 1 address format.
 *
 * Note also that type 1 is determined by non-zero bus number.
 *
< ASCII >
 * Type 1:
 *
 *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 
 *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | | | | | | | | | | |B|B|B|B|B|B|B|B|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|1|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 *	31:24	reserved
 *	23:16	bus number (8 bits = 128 possible buses)
 *	15:11	Device number (5 bits)
 *	10:8	function number
 *	 7:2	register number
 *  
 * Notes:
 *	The function number selects which function of a multi-function device 
 *	(e.g., SCSI and Ethernet).
 * 
 *	The register selects a DWORD (32 bit) register offset.  Hence it
 *	doesn't get shifted by 2 bits as we want to "drop" the bottom two
 *	bits.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_170.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sh/include/asm/watchdog.h#L35-L51

```c
/*
 * CKS0-2 supports a number of clock division ratios. At the time the watchdog
 * is enabled, it defaults to a 41 usec overflow period .. we overload this to
 * something a little more reasonable, and really can't deal with anything
 * lower than WTCSR_CKS_1024, else we drop back into the usec range.
 *
< ASCII >
 * Clock Division Ratio         Overflow Period
 * --------------------------------------------
 *     1/32 (initial value)       41 usecs
 *     1/64                       82 usecs
 *     1/128                     164 usecs
 *     1/256                     328 usecs
 *     1/512                     656 usecs
 *     1/1024                   1.31 msecs
 *     1/2048                   2.62 msecs
 *     1/4096                   5.25 msecs
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_171.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sh/include/mach-common/mach/urquell.h#L5-L22

```c
/*
< ASCII >
 * ------ 0x00000000 ------------------------------------
 *  CS0 | (SW1,SW47)    EEPROM, SRAM, NOR FLASH
 * -----+ 0x04000000 ------------------------------------
 *  CS1 | (SW47)        SRAM, SRAM-LAN-PCMCIA, NOR FLASH
 * -----+ 0x08000000 ------------------------------------
 *  CS2 |               DDR3
 *  CS3 |
 * -----+ 0x10000000 ------------------------------------
 *  CS4 |               PCIe
 * -----+ 0x14000000 ------------------------------------
 *  CS5 | (SW47)        LRAM/URAM, SRAM-LAN-PCMCIA
 * -----+ 0x18000000 ------------------------------------
 *  CS6 |               ATA, NAND FLASH
 * -----+ 0x1c000000 ------------------------------------
 *  CS7 |               SH7786 register
 * -----+------------------------------------------------
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_172.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sh/kernel/ftrace.c#L30-L47

```c
/*
 * If we're trying to nop out a call to a function, we instead
 * place a call to the address after the memory table.
 *
< ASCII >
 * 8c011060 <a>:
 * 8c011060:       02 d1           mov.l   8c01106c <a+0xc>,r1
 * 8c011062:       22 4f           sts.l   pr,@-r15
 * 8c011064:       02 c7           mova    8c011070 <a+0x10>,r0
 * 8c011066:       2b 41           jmp     @r1
 * 8c011068:       2a 40           lds     r0,pr
 * 8c01106a:       09 00           nop
 * 8c01106c:       68 24           .word 0x2468     <--- ip
 * 8c01106e:       1d 8c           .word 0x8c1d
 * 8c011070:       26 4f           lds.l   @r15+,pr <--- ip + MCOUNT_INSN_SIZE
< ASCII >
 *
 * We write 0x8c011070 to 0x8c01106c so that on entry to a() we branch
 * past the _mcount call and continue executing code like normal.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_173.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sh/kernel/head_32.S#L90-L136

```c
/*
 * Reconfigure the initial PMB mappings setup by the hardware.
 *
 * When we boot in 32-bit MMU mode there are 2 PMB entries already
 * setup for us.
 *
< ASCII >
 * Entry       VPN	   PPN	    V	SZ	C	UB	WT
 * ---------------------------------------------------------------
 *   0	    0x80000000 0x00000000   1  512MB	1	0	1
 *   1	    0xA0000000 0x00000000   1  512MB	0	0	0
< ASCII >
 *
 * But we reprogram them here because we want complete control over
 * our address space and the initial mappings may not map PAGE_OFFSET
 * to __MEMORY_START (or even map all of our RAM).
 *
 * Once we've setup cached and uncached mappings we clear the rest of the
 * PMB entries. This clearing also deals with the fact that PMB entries
 * can persist across reboots. The PMB could have been left in any state
 * when the reboot occurred, so to be safe we clear all entries and start
 * with with a clean slate.
 *
 * The uncached mapping is constructed using the smallest possible
 * mapping with a single unbufferable page. Only the kernel text needs to
 * be covered via the uncached mapping so that certain functions can be
 * run uncached.
 *
 * Drivers and the like that have previously abused the 1:1 identity
 * mapping are unsupported in 32-bit mode and must specify their caching
 * preference when page tables are constructed.
 *
 * This frees up the P2 space for more nefarious purposes.
 *
 * Register utilization is as follows:
 *
 *	r0 = PMB_DATA data field
 *	r1 = PMB_DATA address field
 *	r2 = PMB_ADDR data field
 *	r3 = PMB_ADDR address field
 *	r4 = PMB_E_SHIFT
 *	r5 = remaining amount of RAM to map
 *	r6 = PMB mapping size we're trying to use
 *	r7 = cached_to_uncached
 *	r8 = scratch register
 *	r9 = scratch register
 *	r10 = number of PMB entries we've setup
 *	r11 = scratch register
 */
```
## Visual type:
- #table


== ./linux/linux_174.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/auxio_64.h#L12-L33

```c
/* AUXIO implementations:
 * sbus-based NCR89C105 "Slavio"
 *	LED/Floppy (AUX1) register
 *	Power (AUX2) register
 *
 * ebus-based auxio on PCIO
 *	LED Auxio Register
 *	Power Auxio Register
 *
 * Register definitions from NCR _NCR89C105 Chip Specification_
 *
< ASCII >
 * SLAVIO AUX1 @ 0x1900000
 * -------------------------------------------------
 * | (R) | (R) |  D  | (R) |  E  |  M  |  T  |  L  |
 * -------------------------------------------------
< ASCII >
 * (R) - bit 7:6,4 are reserved and should be masked in s/w
 *  D  - Floppy Density Sense (1=high density) R/O
 *  E  - Link Test Enable, directly reflected on AT&T 7213 LTE pin
 *  M  - Monitor/Mouse Mux, directly reflected on MON_MSE_MUX pin
 *  T  - Terminal Count: sends TC pulse to 82077 floppy controller
 *  L  - System LED on front panel (0=off, 1=on)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_175.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/auxio_64.h#L41-L49

```c
/* SLAVIO AUX2 @ 0x1910000
< ASCII >
 * -------------------------------------------------
 * | (R) | (R) |  D  | (R) | (R) | (R) |  C  |  F  |
 * -------------------------------------------------
< ASCII >
 * (R) - bits 7:6,4:2 are reserved and should be masked in s/w
 *  D  - Power Failure Detect (1=power fail)
 *  C  - Clear Power Failure Detect Int (1=clear)
 *  F  - Power Off (1=power off)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_176.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/auxio_64.h#L55-L63

```c
/* Register definitions from Sun Microsystems _PCIO_ p/n 802-7837
 *
< ASCII >
 * PCIO LED Auxio @ 0x726000
 * -------------------------------------------------
 * |             31:1 Unused                 | LED |
 * -------------------------------------------------
< ASCII >
 * Bits 31:1 unused
 * LED - System LED on front panel (0=off, 1=on)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_177.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/auxio_64.h#L66-L73

```c
/* PCIO Power Auxio @ 0x724000
< ASCII >
 * -------------------------------------------------
 * |             31:2 Unused           | CPO | SPO |
 * -------------------------------------------------
< ASCII >
 * Bits 31:2 unused
 * CPO - Courtesy Power Off (1=off)
 * SPO - System Power Off   (1=off)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_178.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/ecc.h#L20-L31

```c
/* ECC MBus Arbiter Enable register:
 *
< ASCII >
 * ----------------------------------------
 * |              |SBUS|MOD3|MOD2|MOD1|RSV|
 * ----------------------------------------
 *  31           5   4   3    2    1    0
< ASCII >
 *
 * SBUS: Enable MBus Arbiter on the SBus 0=off 1=on
 * MOD3: Enable MBus Arbiter on MBus module 3  0=off 1=on
 * MOD2: Enable MBus Arbiter on MBus module 2  0=off 1=on
 * MOD1: Enable MBus Arbiter on MBus module 1  0=off 1=on
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_179.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/ecc.h#L38-L47

```c
/* ECC Fault Control Register layout:
 *
< ASCII >
 * -----------------------------
 * |    RESV   | ECHECK | EINT |
 * -----------------------------
 *  31        2     1       0
< ASCII >
 *
 * ECHECK:  Enable ECC checking.  0=off 1=on
 * EINT:  Enable Interrupts for correctable errors. 0=off 1=on
 */ 
```
## Visual type:
- #memory-layout


== ./linux/linux_18.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/pci_impl.h#L77-L113

```c
/* 
 * A small note about bridges and interrupts.  The DECchip 21050 (and
 * later) adheres to the PCI-PCI bridge specification.  This says that
 * the interrupts on the other side of a bridge are swizzled in the
 * following manner:
 *
< ASCII >
 * Dev    Interrupt   Interrupt 
 *        Pin on      Pin on 
 *        Device      Connector
 *
 *   4    A           A
 *        B           B
 *        C           C
 *        D           D
 * 
 *   5    A           B
 *        B           C
 *        C           D
 *        D           A
 *
 *   6    A           C
 *        B           D
 *        C           A
 *        D           B
 *
 *   7    A           D
 *        B           A
 *        C           B
 *        D           C
< ASCII >
 *
 *   Where A = pin 1, B = pin 2 and so on and pin=0 = default = A.
 *   Thus, each swizzle is ((pin-1) + (device#-4)) % 4
 *
 *   pci_swizzle_interrupt_pin() swizzles for exactly one bridge.  The routine
 *   pci_common_swizzle() handles multiple bridges.  But there are a
 *   couple boards that do strange things.
 */
```
## Visual type:
- #table


== ./linux/linux_180.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/ecc.h#L51-L75

```c
/* ECC Fault Address Register Zero layout:
 *
< ASCII >
 * -----------------------------------------------------
 * | MID | S | RSV |  VA   | BM |AT| C| SZ |TYP| PADDR |
 * -----------------------------------------------------
 *  31-28  27 26-22  21-14   13  12 11 10-8 7-4   3-0
< ASCII >
 *
 * MID: ModuleID of the faulting processor. ie. who did it?
 * S: Supervisor/Privileged access? 0=no 1=yes
 * VA: Bits 19-12 of the virtual faulting address, these are the
 *     superset bits in the virtual cache and can be used for
 *     a flush operation if necessary.
 * BM: Boot mode? 0=no 1=yes  This is just like the SRMMU boot
 *     mode bit.
 * AT: Did this fault happen during an atomic instruction? 0=no
 *     1=yes.  This means either an 'ldstub' or 'swap' instruction
 *     was in progress (but not finished) when this fault happened.
 *     This indicated whether the bus was locked when the fault
 *     occurred.
 * C: Did the pte for this access indicate that it was cacheable?
 *    0=no 1=yes
 * SZ: The size of the transaction.
 * TYP: The transaction type.
 * PADDR: Bits 35-32 of the physical address for the fault.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_181.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/ecc.h#L86-L95

```c
/* ECC Fault Address Register One layout:
 *
< ASCII >
 * -------------------------------------
 * |          Physical Address 31-0    |
 * -------------------------------------
 *  31                               0
< ASCII >
 *
 * You get the upper 4 bits of the physical address from the
 * PADDR field in ECC Fault Address Zero register.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_182.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/ecc.h#L97-L112

```c
/* ECC Fault Status Register layout:
 *
< ASCII >
 * ----------------------------------------------
 * | RESV|C2E|MULT|SYNDROME|DWORD|UNC|TIMEO|BS|C|
 * ----------------------------------------------
 *  31-18  17  16    15-8    7-4   3    2    1 0
< ASCII >
 *
 * C2E: A C2 graphics error occurred. 0=no 1=yes (SS10 only)
 * MULT: Multiple errors occurred ;-O 0=no 1=prom_panic(yes)
 * SYNDROME: Controller is mentally unstable.
 * DWORD:
 * UNC: Uncorrectable error.  0=no 1=yes
 * TIMEO: Timeout occurred. 0=no 1=yes
 * BS: C2 graphics bad slot access. 0=no 1=yes (SS10 only)
 * C: Correctable error? 0=no 1=yes
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_183.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/hypervisor.h#L5-L51

```c
/* Sun4v hypervisor interfaces and defines.
 *
 * Hypervisor calls are made via traps to software traps number 0x80
 * and above.  Registers %o0 to %o5 serve as argument, status, and
 * return value registers.
 *
 * There are two kinds of these traps.  First there are the normal
 * "fast traps" which use software trap 0x80 and encode the function
 * to invoke by number in register %o5.  Argument and return value
 * handling is as follows:
 *
< ASCII >
 * -----------------------------------------------
 * |  %o5  | function number |     undefined     |
 * |  %o0  |   argument 0    |   return status   |
 * |  %o1  |   argument 1    |   return value 1  |
 * |  %o2  |   argument 2    |   return value 2  |
 * |  %o3  |   argument 3    |   return value 3  |
 * |  %o4  |   argument 4    |   return value 4  |
 * -----------------------------------------------
< ASCII >
 *
 * The second type are "hyper-fast traps" which encode the function
 * number in the software trap number itself.  So these use trap
 * numbers > 0x80.  The register usage for hyper-fast traps is as
 * follows:
 *
< ASCII >
 * -----------------------------------------------
 * |  %o0  |   argument 0    |   return status   |
 * |  %o1  |   argument 1    |   return value 1  |
 * |  %o2  |   argument 2    |   return value 2  |
 * |  %o3  |   argument 3    |   return value 3  |
 * |  %o4  |   argument 4    |   return value 4  |
 * -----------------------------------------------
< ASCII >
 *
 * Registers providing explicit arguments to the hypervisor calls
 * are volatile across the call.  Upon return their values are
 * undefined unless explicitly specified as containing a particular
 * return value by the specific call.  The return status is always
 * returned in register %o0, zero indicates a successful execution of
 * the hypervisor call and other values indicate an error status as
 * defined below.  So, for example, if a hyper-fast trap takes
 * arguments 0, 1, and 2, then %o0, %o1, and %o2 are volatile across
 * the call and %o3, %o4, and %o5 would be preserved.
 *
 * If the hypervisor trap is invalid, or the fast trap function number
 * is invalid, HV_EBADTRAP will be returned in %o0.  Also, all 64-bits
 * of the argument and return values are significant.
 */
```
## Visual type:
- #table


== ./linux/linux_184.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/machines.h#L16-L25

```c
/* The machine type in the idprom area looks like this:
 *
< ASCII >
 * ---------------
 * | ARCH | MACH |
 * ---------------
 *  7    4 3    0
< ASCII >
 *
 * The ARCH field determines the architecture line (sun4m, etc).
 * The MACH field determines the machine make within that architecture.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_185.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/mxcc.h#L26-L39

```c
/* The MXCC Control Register:
 *
< ASCII >
 * ----------------------------------------------------------------------
 * |                                   | RRC | RSV |PRE|MCE|PARE|ECE|RSV|
 * ----------------------------------------------------------------------
 *  31                              10    9    8-6   5   4    3   2  1-0
< ASCII >
 *
 * RRC: Controls what you read from MXCC_RMCOUNT reg.
 *      0=Misses 1=References
 * PRE: Prefetch enable
 * MCE: Multiple Command Enable
 * PARE: Parity enable
 * ECE: External cache enable
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_186.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/mxcc.h#L47-L64

```c
/* The MXCC Error Register:
 *
< ASCII >
 * --------------------------------------------------------
 * |ME| RSV|CE|PEW|PEE|ASE|EIV| MOPC|ECODE|PRIV|RSV|HPADDR|
 * --------------------------------------------------------
 *  31   30 29  28  27  26  25 24-15  14-7   6  5-3   2-0
< ASCII >
 *
 * ME: Multiple Errors have occurred
 * CE: Cache consistency Error
 * PEW: Parity Error during a Write operation
 * PEE: Parity Error involving the External cache
 * ASE: ASynchronous Error
 * EIV: This register is toast
 * MOPC: MXCC Operation Code for instance causing error
 * ECODE: The Error CODE
 * PRIV: A privileged mode error? 0=no 1=yes
 * HPADDR: High PhysicalADDRess bits (35-32)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_187.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/mxcc.h#L77-L85

```c
/* The MXCC Port register:
 *
< ASCII >
 * -----------------------------------------------------
 * |                | MID |                            |
 * -----------------------------------------------------
 *  31            21 20-18 17                         0
< ASCII >
 *
 * MID: The moduleID of the cpu your read this from.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_188.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/obio.h#L13-L14

```c
/* This weird monster likes to use the very upper parts of
   36bit PA for these things :) */
```
## Visual type:



== ./linux/linux_189.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/obio.h#L29-L34

```c
/* ECSR space (not for each XDBUS)
< ASCII >
 *  ------------------------------------------------------------------------
 *  |   0xF  | DEVID[7:1] |                			           |
 *  ------------------------------------------------------------------------
 *  35     32 31        25 24                 				  0
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_19.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/ptrace.c#L46-L61

```c
/*
< ASCII >
 * Processes always block with the following stack-layout:
 *
 *  +================================+ <---- task + 2*PAGE_SIZE
 *  | PALcode saved frame (ps, pc,   | ^
 *  | gp, a0, a1, a2)		     | |
 *  +================================+ | struct pt_regs
 *  |	        		     | |
 *  | frame generated by SAVE_ALL    | |
 *  |	        		     | v
 *  +================================+
 *  |	        		     | ^
 *  | frame saved by do_switch_stack | | struct switch_stack
 *  |	        		     | v
 *  +================================+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_190.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/ross.h#L18-L42

```c
/* The MMU control register fields on the HyperSparc.
< ASCII >
 *
 * -----------------------------------------------------------------
 * |implvers| RSV |CWR|SE|WBE| MID |BM| C|CS|MR|CM|RSV|CE|RSV|NF|ME|
 * -----------------------------------------------------------------
 *  31    24 23-22 21  20  19 18-15 14 13 12 11 10  9   8 7-2  1  0
< ASCII >
 *
 * Phew, lots of fields there ;-)
 *
 * CWR: Cache Wrapping Enabled, if one cache wrapping is on.
 * SE: Snoop Enable, turns on bus snooping for cache activity if one.
 * WBE: Write Buffer Enable, one turns it on.
 * MID: The ModuleID of the chip for MBus transactions.
 * BM: Boot-Mode. One indicates the MMU is in boot mode.
 * C: Indicates whether accesses are cachable while the MMU is
 *    disabled.
 * CS: Cache Size -- 0 = 128k, 1 = 256k
 * MR: Memory Reflection, one indicates that the memory bus connected
 *     to the MBus supports memory reflection.
 * CM: Cache Mode -- 0 = write-through, 1 = copy-back
 * CE: Cache Enable -- 0 = no caching, 1 = cache is on
 * NF: No Fault -- 0 = faults trap the CPU from supervisor mode
 *                 1 = faults from supervisor mode do not generate traps
 * ME: MMU Enable -- 0 = MMU is off, 1 = MMU is on
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_191.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/ross.h#L58-L93

```c
/* The ICCR instruction cache register on the HyperSparc.
 *
< ASCII >
 * -----------------------------------------------
 * |                                 | FTD | ICE |
 * -----------------------------------------------
 *  31                                  1     0
< ASCII >
 *
 * This register is accessed using the V8 'wrasr' and 'rdasr'
 * opcodes, since not all assemblers understand them and those
 * that do use different semantics I will just hard code the
 * instruction with a '.word' statement.
 *
 * FTD:  If set to one flush instructions executed during an
 *       instruction cache hit occurs, the corresponding line
 *       for said cache-hit is invalidated.  If FTD is zero,
 *       an unimplemented 'flush' trap will occur when any
 *       flush is executed by the processor.
 *
 * ICE:  If set to one, the instruction cache is enabled.  If
 *       zero, the cache will not be used for instruction fetches.
 *
 * All other bits are read as zeros, and writes to them have no
 * effect.
 *
 * Wheee, not many assemblers understand the %iccr register nor
 * the generic asr r/w instructions.
< ASCII >
 *
 *  1000 0011 0100 0111 1100 0000 0000 0000   ! rd %iccr, %g1
 *
 * 0x  8    3    4    7    c    0    0    0   ! 0x8347c000
 *
 *  1011 1111 1000 0000 0110 0000 0000 0000   ! wr %g1, 0x0, %iccr
 *
 * 0x  b    f    8    0    6    0    0    0   ! 0xbf806000
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_192.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/sbi.h#L56-L64

```c
/* intr_state has 4 bits for slots 0 .. 3 and these bits are repeated for each sbus irq level
< ASCII >
 *
 *		   +-------+-------+-------+-------+-------+-------+-------+-------+
 *  SBUS IRQ LEVEL |   7   |   6   |   5   |   4   |   3   |   2   |   1   |       |
 *		   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Reser |
 *  SLOT #         |3|2|1|0|3|2|1|0|3|2|1|0|3|2|1|0|3|2|1|0|3|2|1|0|3|2|1|0|  ved  |
 *                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-------+
 *  Bits           31      27      23      19      15      11      7       3      0
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_193.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/sfafsr.h#L48-L58

```c
/* The trap handlers for asynchronous errors encode the AFSR and
 * other pieces of information into a 64-bit argument for C code
 * encoded as follows:
 *
< ASCII >
 * -----------------------------------------------
 * |  UDB_H  |  UDB_L  | TL>1  |  TT  |   AFSR   |
 * -----------------------------------------------
 *  63     54 53     44    42   41  33 32       0
< ASCII >
 *
 * The AFAR is passed in unchanged.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_194.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/spinlock_32.h#L53-L78

```c
/* Read-write spinlocks, allowing multiple readers
 * but only one writer.
 *
 * NOTE! it is quite common to have readers in interrupts
 * but no interrupt writers. For those circumstances we
 * can "mix" irq-safe locks - any writer needs to get a
 * irq-safe write-lock, but readers can get non-irqsafe
 * read-locks.
 *
 * XXX This might create some problems with my dual spinlock
 * XXX scheme, deadlocks etc. -DaveM
 *
 * Sort of like atomic_t's on Sparc, but even more clever.
 *
< ASCII >
 *	------------------------------------
 *	| 24-bit counter           | wlock |  arch_rwlock_t
 *	------------------------------------
 *	 31                       8 7     0
< ASCII >
 *
 * wlock signifies the one writer is in or somebody is updating
 * counter. For a writer, if he successfully acquires the wlock,
 * but counter is non-zero, he has to release the lock and wait,
 * till both counter and wlock are zero.
 *
 * Unfortunately this scheme limits us to ~16,000,000 cpus.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_195.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/tsb.h#L5-L46

```c
/* The sparc64 TSB is similar to the powerpc hashtables.  It's a
 * power-of-2 sized table of TAG/PTE pairs.  The cpu precomputes
 * pointers into this table for 8K and 64K page sizes, and also a
 * comparison TAG based upon the virtual address and context which
 * faults.
 *
 * TLB miss trap handler software does the actual lookup via something
 * of the form:
 *
 * 	ldxa		[%g0] ASI_{D,I}MMU_TSB_8KB_PTR, %g1
 * 	ldxa		[%g0] ASI_{D,I}MMU, %g6
 *	sllx		%g6, 22, %g6
 *	srlx		%g6, 22, %g6
 * 	ldda		[%g1] ASI_NUCLEUS_QUAD_LDD, %g4
 * 	cmp		%g4, %g6
 * 	bne,pn	%xcc, tsb_miss_{d,i}tlb
 * 	 mov		FAULT_CODE_{D,I}TLB, %g3
 * 	stxa		%g5, [%g0] ASI_{D,I}TLB_DATA_IN
 * 	retry
 *
 *
 * Each 16-byte slot of the TSB is the 8-byte tag and then the 8-byte
 * PTE.  The TAG is of the same layout as the TLB TAG TARGET mmu
 * register which is:
 *
< ASCII >
 * -------------------------------------------------
 * |  -  |  CONTEXT |  -  |    VADDR bits 63:22    |
 * -------------------------------------------------
 *  63 61 60      48 47 42 41                     0
< ASCII >
 *
 * But actually, since we use per-mm TSB's, we zero out the CONTEXT
 * field.
 *
 * Like the powerpc hashtables we need to use locking in order to
 * synchronize while we update the entries.  PTE updates need locking
 * as well.
 *
 * We need to carefully choose a lock bits for the TSB entry.  We
 * choose to use bit 47 in the tag.  Also, since we never map anything
 * at page zero in context zero, we use zero as an invalid tag entry.
 * When the lock bit is set, this forces a tag comparison failure.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_196.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/tsunami.h#L13-L33

```c
/* The MMU control register on the Tsunami:
 *
< ASCII >
 * -----------------------------------------------------------------------
 * | implvers |SW|AV|DV|MV| RSV |PC|ITD|ALC| RSV |PE| RC |IE|DE|RSV|NF|ME|
 * -----------------------------------------------------------------------
 *  31      24 23 22 21 20 19-18 17  16 14  13-12 11 10-9  8  7 6-2  1  0
< ASCII >
 *
 * SW: Enable Software Table Walks  0=off 1=on
 * AV: Address View bit
 * DV: Data View bit
 * MV: Memory View bit
 * PC: Parity Control
 * ITD: ITBR disable
 * ALC: Alternate Cacheable
 * PE: Parity Enable   0=off 1=on
 * RC: Refresh Control
 * IE: Instruction cache Enable  0=off 1=on
 * DE: Data cache Enable  0=off 1=on
 * NF: No Fault, same as all other SRMMUs
 * ME: MMU Enable, same as all other SRMMUs
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_197.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/turbosparc.h#L14-L34

```c
/* Bits in the SRMMU control register for TurboSparc modules.
 *
< ASCII >
 * -------------------------------------------------------------------
 * |impl-vers| RSV| PMC |PE|PC| RSV |BM| RFR |IC|DC|PSO|RSV|ICS|NF|ME|
 * -------------------------------------------------------------------
 *  31    24 23-21 20-19 18 17 16-15 14 13-10  9  8  7  6-3   2  1  0
< ASCII >
 *
 * BM: Boot Mode -- 0 = not in boot mode, 1 = in boot mode
 *
 * This indicates whether the TurboSparc is in boot-mode or not.
 *
 * IC: Instruction Cache -- 0 = off, 1 = on
 * DC: Data Cache -- 0 = off, 1 = 0n
 *
 * These bits enable the on-cpu TurboSparc split I/D caches.
 *
 * ICS: ICache Snooping -- 0 = disable, 1 = enable snooping of icache
 * NF: No Fault -- 0 = faults generate traps, 1 = faults don't trap
 * ME: MMU enable -- 0 = mmu not translating, 1 = mmu translating
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_198.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/turbosparc.h#L46-L53

```c
/* Bits in the CPU configuration register for TurboSparc modules.
 *
< ASCII >
 * -------------------------------------------------------
 * |IOClk|SNP|AXClk| RAH |  WS |  RSV  |SBC|WT|uS2|SE|SCC|
 * -------------------------------------------------------
 *    31   30 29-28 27-26 25-23   22-8  7-6  5  4   3 2-0
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_199.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/asm/viking.h#L16-L85

```c
/* Bits in the SRMMU control register for GNU/Viking modules.
 *
< ASCII >
 * -----------------------------------------------------------
 * |impl-vers| RSV |TC|AC|SP|BM|PC|MBM|SB|IC|DC|PSO|RSV|NF|ME|
 * -----------------------------------------------------------
 *  31     24 23-17 16 15 14 13 12 11  10  9  8  7  6-2  1  0
< ASCII >
 *
 * TC: Tablewalk Cacheable -- 0 = Twalks are not cacheable in E-cache
 *                            1 = Twalks are cacheable in E-cache
 *
 * GNU/Viking will only cache tablewalks in the E-cache (mxcc) if present
 * and never caches them internally (or so states the docs).  Therefore
 * for machines lacking an E-cache (ie. in MBUS mode) this bit must
 * remain cleared.
 *
 * AC: Alternate Cacheable -- 0 = Passthru physical accesses not cacheable
 *                            1 = Passthru physical accesses cacheable
 *
 * This indicates whether accesses are cacheable when no cachable bit
 * is present in the pte when the processor is in boot-mode or the
 * access does not need pte's for translation (ie. pass-thru ASI's).
 * "Cachable" is only referring to E-cache (if present) and not the
 * on chip split I/D caches of the GNU/Viking.
 *
 * SP: SnooP Enable -- 0 = bus snooping off, 1 = bus snooping on
 *
 * This enables snooping on the GNU/Viking bus.  This must be on
 * for the hardware cache consistency mechanisms of the GNU/Viking
 * to work at all.  On non-mxcc GNU/Viking modules the split I/D
 * caches will snoop regardless of whether they are enabled, this
 * takes care of the case where the I or D or both caches are turned
 * off yet still contain valid data.  Note also that this bit does
 * not affect GNU/Viking store-buffer snoops, those happen if the
 * store-buffer is enabled no matter what.
 *
 * BM: Boot Mode -- 0 = not in boot mode, 1 = in boot mode
 *
 * This indicates whether the GNU/Viking is in boot-mode or not,
 * if it is then all instruction fetch physical addresses are
 * computed as 0xff0000000 + low 28 bits of requested address.
 * GNU/Viking boot-mode does not affect data accesses.  Also,
 * in boot mode instruction accesses bypass the split on chip I/D
 * caches, they may be cached by the GNU/MXCC if present and enabled.
 *
 * MBM: MBus Mode -- 0 = not in MBus mode, 1 = in MBus mode
 *
 * This indicated the GNU/Viking configuration present.  If in
 * MBUS mode, the GNU/Viking lacks a GNU/MXCC E-cache.  If it is
 * not then the GNU/Viking is on a module VBUS connected directly
 * to a GNU/MXCC cache controller.  The GNU/MXCC can be thus connected
 * to either an GNU/MBUS (sun4m) or the packet-switched GNU/XBus (sun4d).
 *
 * SB: StoreBuffer enable -- 0 = store buffer off, 1 = store buffer on
 *
 * The GNU/Viking store buffer allows the chip to continue execution
 * after a store even if the data cannot be placed in one of the
 * caches during that cycle.  If disabled, all stores operations
 * occur synchronously.
 *
 * IC: Instruction Cache -- 0 = off, 1 = on
 * DC: Data Cache -- 0 = off, 1 = 0n
 *
 * These bits enable the on-cpu GNU/Viking split I/D caches.  Note,
 * as mentioned above, these caches will snoop the bus in GNU/MBUS
 * configurations even when disabled to avoid data corruption.
 *
 * NF: No Fault -- 0 = faults generate traps, 1 = faults don't trap
 * ME: MMU enable -- 0 = mmu not translating, 1 = mmu translating
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_2.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/include/asm/core_irongate.h#L129-L135

```c
/*
< ASCII >
 * PCI Configuration space accesses are formed like so:
 *
 * 0x1FE << 24 |  : 2 2 2 2 1 1 1 1 : 1 1 1 1 1 1 0 0 : 0 0 0 0 0 0 0 0 :
 *                : 3 2 1 0 9 8 7 6 : 5 4 3 2 1 0 9 8 : 7 6 5 4 3 2 1 0 :
 *                  ---bus numer---   -device-- -fun-   ---register----
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_20.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/smc37c669.c#L272-L287

```c
/*
** CR03 - default value 0x78
**
< ASCII >
**  CR03<7>	CR03<2>	    Pin 94
**  -------	-------	    ------
**     0	   X	    DRV2 (input)
**     1	   0	    ADRX
**     1	   1	    IRQ_B
**
**  CR03<6>	CR03<5>	    Op Mode
**  -------	-------	    -------
**     0	   0	    Model 30
**     0	   1	    PS/2
**     1	   0	    Reserved
**     1	   1	    AT Mode
< ASCII >
*/
```
## Visual type:
- #table


== ./linux/linux_200.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/uapi/asm/display7seg.h#L20-L38

```c
/*
 * ioctl flag definitions
 *
 * POINT	- Toggle decimal point	(0=absent 1=present)
 * ALARM	- Toggle alarm LED 		(0=green  1=red)
 * FLIP		- Toggle inverted mode 	(0=normal 1=flipped)
 * bits 0-4	- Character displayed	(see definitions below)
 *
 * Display segments are defined as follows,
 * subject to D7S_FLIP register state:
 *
< ASCII >
 *    a
 *   ---
 * f|   |b
 *   -g-
 * e|   |c
 *   ---
 *    d
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_201.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/uapi/asm/psr.h#L15-L21

```c
/* The Sparc PSR fields are laid out as the following:
 *
< ASCII >
 *  ------------------------------------------------------------------------
 *  | impl  | vers  | icc   | resv  | EC | EF | PIL  | S | PS | ET |  CWP  |
 *  | 31-28 | 27-24 | 23-20 | 19-14 | 13 | 12 | 11-8 | 7 | 6  | 5  |  4-0  |
 *  ------------------------------------------------------------------------
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_202.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/uapi/asm/pstate.h#L7-L13

```c
/* The V9 PSTATE Register (with SpitFire extensions).
 *
< ASCII >
 * -----------------------------------------------------------------------
 * | Resv | IG | MG | CLE | TLE |  MM  | RED | PEF | AM | PRIV | IE | AG |
 * -----------------------------------------------------------------------
 *  63  12  11   10    9     8    7   6   5     4     3     2     1    0
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_203.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/uapi/asm/pstate.h#L34-L40

```c
/* The V9 TSTATE Register (with SpitFire and Linux extensions).
 *
< ASCII >
 * ---------------------------------------------------------------------
 * |  Resv |  GL  |  CCR  |  ASI  |  %pil  |  PSTATE  |  Resv  |  CWP  |
 * ---------------------------------------------------------------------
 *  63   43 42  40 39   32 31   24 23    20 19       8 7      5 4     0
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_204.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/uapi/asm/pstate.h#L78-L84

```c
/* Floating-Point Registers State Register.
 *
< ASCII >
 * --------------------------------
 * |  Resv  |  FEF  |  DU  |  DL  |
 * --------------------------------
 *  63     3    2       1      0
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_205.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/include/uapi/asm/pstate.h#L89-L95

```c
/* Version Register.
 *
< ASCII >
 * ------------------------------------------------------
 * | MANUF | IMPL | MASK | Resv | MAXTL | Resv | MAXWIN |
 * ------------------------------------------------------
 *  63   48 47  32 31  24 23  16 15    8 7    5 4      0
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_206.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/kernel/pci_schizo.c#L66-L73

```c
/* Schizo config space address format is nearly identical to
 * that of PSYCHO:
 *
< ASCII >
 *  32             24 23 16 15    11 10       8 7   2  1 0
 * ---------------------------------------------------------
 * |0 0 0 0 0 0 0 0 0| bus | device | function | reg | 0 0 |
 * ---------------------------------------------------------
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_207.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/kernel/psycho_common.h#L5-L12

```c
/* U2P Programmer's Manual, page 13-55, configuration space
 * address format:
 * 
< ASCII >
 *  32             24 23 16 15    11 10       8 7   2  1 0
 * ---------------------------------------------------------
 * |0 0 0 0 0 0 0 0 1| bus | device | function | reg | 0 0 |
 * ---------------------------------------------------------
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_208.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/sparc/kernel/sun4d_smp.c#L224-L228

```c
< ASCII >
/* +-------+-------------+-----------+------------------------------------+
 * | bcast |  devid      |   sid     |              levels mask           |
 * +-------+-------------+-----------+------------------------------------+
 *  31      30         23 22       15 14                                 0
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_209.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/boot/compressed/efi_mixed.S#L25-L47

```c
/*
 * When booting in 64-bit mode on 32-bit EFI firmware, startup_64_mixed_mode()
 * is the first thing that runs after switching to long mode. Depending on
 * whether the EFI handover protocol or the compat entry point was used to
 * enter the kernel, it will either branch to the 64-bit EFI handover
 * entrypoint at offset 0x390 in the image, or to the 64-bit EFI PE/COFF
 * entrypoint efi_pe_entry(). In the former case, the bootloader must provide a
 * struct bootparams pointer as the third argument, so the presence of such a
 * pointer is used to disambiguate.
< ASCII >
 *
 *                                                             +--------------+
 *  +------------------+     +------------+            +------>| efi_pe_entry |
 *  | efi32_pe_entry   |---->|            |            |       +-----------+--+
 *  +------------------+     |            |     +------+----------------+  |
 *                           | startup_32 |---->| startup_64_mixed_mode |  |
 *  +------------------+     |            |     +------+----------------+  V
 *  | efi32_stub_entry |---->|            |            |     +------------------+
 *  +------------------+     +------------+            +---->| efi64_stub_entry |
 *                                                           +-------------+----+
 *                           +------------+     +----------+               |
 *                           | startup_64 |<----| efi_main |<--------------+
 *                           +------------+     +----------+
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_21.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/smc37c669.c#L581-L596

```c
/*
** CR1F - default value 0x00
**
< ASCII >
**  DT0 DT1 DRVDEN0 DRVDEN1 Drive Type
**  --- --- ------- ------- ----------
**   0   0  DENSEL  DRATE0  4/2/1 MB 3.5"
**                          2/1 MB 5.25"
**                          2/1.6/1 MB 3.5" (3-mode)
**   0   1  DRATE1  DRATE0
**   1   0  nDENSEL DRATE0  PS/2
**   1   1  DRATE0  DRATE1
**
**  Note: DENSEL, DRATE1, and DRATE0 map onto two output
**	  pins - DRVDEN0 and DRVDEN1.
< ASCII >
**
*/
```
## Visual type:
- #table


== ./linux/linux_210.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/boot/compressed/kaslr.c#L307-L382

```c
/*
 * In theory, KASLR can put the kernel anywhere in the range of [16M, MAXMEM)
 * on 64-bit, and [16M, KERNEL_IMAGE_SIZE) on 32-bit.
 *
 * The mem_avoid array is used to store the ranges that need to be avoided
 * when KASLR searches for an appropriate random address. We must avoid any
 * regions that are unsafe to overlap with during decompression, and other
 * things like the initrd, cmdline and boot_params. This comment seeks to
 * explain mem_avoid as clearly as possible since incorrect mem_avoid
 * memory ranges lead to really hard to debug boot failures.
 *
 * The initrd, cmdline, and boot_params are trivial to identify for
 * avoiding. They are MEM_AVOID_INITRD, MEM_AVOID_CMDLINE, and
 * MEM_AVOID_BOOTPARAMS respectively below.
 *
 * What is not obvious how to avoid is the range of memory that is used
 * during decompression (MEM_AVOID_ZO_RANGE below). This range must cover
 * the compressed kernel (ZO) and its run space, which is used to extract
 * the uncompressed kernel (VO) and relocs.
 *
 * ZO's full run size sits against the end of the decompression buffer, so
 * we can calculate where text, data, bss, etc of ZO are positioned more
 * easily.
 *
 * For additional background, the decompression calculations can be found
 * in header.S, and the memory diagram is based on the one found in misc.c.
 *
 * The following conditions are already enforced by the image layouts and
 * associated code:
 *  - input + input_size >= output + output_size
 *  - kernel_total_size <= init_size
 *  - kernel_total_size <= output_size (see Note below)
 *  - output + init_size >= output + output_size
 *
 * (Note that kernel_total_size and output_size have no fundamental
 * relationship, but output_size is passed to choose_random_location
 * as a maximum of the two. The diagram is showing a case where
 * kernel_total_size is larger than output_size, but this case is
 * handled by bumping output_size.)
 *
< ASCII >
 * The above conditions can be illustrated by a diagram:
 *
 * 0   output            input            input+input_size    output+init_size
 * |     |                 |                             |             |
 * |     |                 |                             |             |
 * |-----|--------|--------|--------------|-----------|--|-------------|
 *                |                       |           |
 *                |                       |           |
 * output+init_size-ZO_INIT_SIZE  output+output_size  output+kernel_total_size
< ASCII >
 *
 * [output, output+init_size) is the entire memory range used for
 * extracting the compressed image.
 *
 * [output, output+kernel_total_size) is the range needed for the
 * uncompressed kernel (VO) and its run size (bss, brk, etc).
 *
 * [output, output+output_size) is VO plus relocs (i.e. the entire
 * uncompressed payload contained by ZO). This is the area of the buffer
 * written to during decompression.
 *
 * [output+init_size-ZO_INIT_SIZE, output+init_size) is the worst-case
 * range of the copied ZO and decompression code. (i.e. the range
 * covered backwards of size ZO_INIT_SIZE, starting from output+init_size.)
 *
 * [input, input+input_size) is the original copied compressed image (ZO)
 * (i.e. it does not include its run size). This range must be avoided
 * because it contains the data used for decompression.
 *
 * [input+input_size, output+init_size) is [_text, _end) for ZO. This
 * range includes ZO's heap and stack, and must be avoided since it
 * performs the decompression.
 *
 * Since the above two ranges need to be avoided and they are adjacent,
 * they can be merged, resulting in: [input, output+init_size) which
 * becomes the MEM_AVOID_ZO_RANGE below.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_211.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/boot/compressed/misc.c#L333-L349

```c
/*
 * The compressed kernel image (ZO), has been moved so that its position
 * is against the end of the buffer used to hold the uncompressed kernel
 * image (VO) and the execution environment (.bss, .brk), which makes sure
 * there is room to do the in-place decompression. (See header.S for the
 * calculations.)
 *
< ASCII >
 *                             |-----compressed kernel image------|
 *                             V                                  V
 * 0                       extract_offset                      +INIT_SIZE
 * |-----------|---------------|-------------------------|--------|
 *             |               |                         |        |
 *           VO__text      startup_32 of ZO          VO__end    ZO__end
 *             ^                                         ^
 *             |-------uncompressed kernel image---------|
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_212.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/crypto/aesni-intel_asm.S#L1510-L1589

```c
/*****************************************************************************
* void aesni_gcm_dec(void *aes_ctx,    // AES Key schedule. Starts on a 16 byte boundary.
*                   struct gcm_context_data *data
*                                      // Context data
*                   u8 *out,           // Plaintext output. Encrypt in-place is allowed.
*                   const u8 *in,      // Ciphertext input
*                   u64 plaintext_len, // Length of data in bytes for decryption.
*                   u8 *iv,            // Pre-counter block j0: 4 byte salt (from Security Association)
*                                      // concatenated with 8 byte Initialisation Vector (from IPSec ESP Payload)
*                                      // concatenated with 0x00000001. 16-byte aligned pointer.
*                   u8 *hash_subkey,   // H, the Hash sub key input. Data starts on a 16-byte boundary.
*                   const u8 *aad,     // Additional Authentication Data (AAD)
*                   u64 aad_len,       // Length of AAD in bytes. With RFC4106 this is going to be 8 or 12 bytes
*                   u8  *auth_tag,     // Authenticated Tag output. The driver will compare this to the
*                                      // given authentication tag and only return the plaintext if they match.
*                   u64 auth_tag_len); // Authenticated Tag Length in bytes. Valid values are 16
*                                      // (most likely), 12 or 8.
*
* Assumptions:
*
* keys:
*       keys are pre-expanded and aligned to 16 bytes. we are using the first
*       set of 11 keys in the data structure void *aes_ctx
*
< ASCII >
* iv:
*       0                   1                   2                   3
*       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                             Salt  (From the SA)               |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                     Initialization Vector                     |
*       |         (This is the sequence number from IPSec header)       |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                              0x1                              |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
*
*
*
* AAD:
*       AAD padded to 128 bits with 0
*       for example, assume AAD is a u32 vector
*
*       if AAD is 8 bytes:
*       AAD[3] = {A0, A1};
*       padded AAD in xmm register = {A1 A0 0 0}
< ASCII >
*
*       0                   1                   2                   3
*       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                               SPI (A1)                        |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                     32-bit Sequence Number (A0)               |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                              0x0                              |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*
*                                       AAD Format with 32-bit Sequence Number
< ASCII >
*
*       if AAD is 12 bytes:
*       AAD[3] = {A0, A1, A2};
*       padded AAD in xmm register = {A2 A1 A0 0}
< ASCII >
*
*       0                   1                   2                   3
*       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                               SPI (A2)                        |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                 64-bit Extended Sequence Number {A1,A0}       |
*       |                                                               |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                              0x0                              |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*
*                        AAD Format with 64-bit Extended Sequence Number
< ASCII >
*
* poly = x^128 + x^127 + x^126 + x^121 + 1
*
*****************************************************************************/
```
## Visual type:
- #memory-layout


== ./linux/linux_213.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/crypto/aesni-intel_asm.S#L1601-L1677

```c
/*****************************************************************************
* void aesni_gcm_enc(void *aes_ctx,      // AES Key schedule. Starts on a 16 byte boundary.
*                    struct gcm_context_data *data
*                                        // Context data
*                    u8 *out,            // Ciphertext output. Encrypt in-place is allowed.
*                    const u8 *in,       // Plaintext input
*                    u64 plaintext_len,  // Length of data in bytes for encryption.
*                    u8 *iv,             // Pre-counter block j0: 4 byte salt (from Security Association)
*                                        // concatenated with 8 byte Initialisation Vector (from IPSec ESP Payload)
*                                        // concatenated with 0x00000001. 16-byte aligned pointer.
*                    u8 *hash_subkey,    // H, the Hash sub key input. Data starts on a 16-byte boundary.
*                    const u8 *aad,      // Additional Authentication Data (AAD)
*                    u64 aad_len,        // Length of AAD in bytes. With RFC4106 this is going to be 8 or 12 bytes
*                    u8 *auth_tag,       // Authenticated Tag output.
*                    u64 auth_tag_len);  // Authenticated Tag Length in bytes. Valid values are 16 (most likely),
*                                        // 12 or 8.
*
* Assumptions:
*
* keys:
*       keys are pre-expanded and aligned to 16 bytes. we are using the
*       first set of 11 keys in the data structure void *aes_ctx
*
*
< ASCII >
* iv:
*       0                   1                   2                   3
*       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                             Salt  (From the SA)               |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                     Initialization Vector                     |
*       |         (This is the sequence number from IPSec header)       |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                              0x1                              |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
*
*
*
* AAD:
*       AAD padded to 128 bits with 0
*       for example, assume AAD is a u32 vector
*
*       if AAD is 8 bytes:
*       AAD[3] = {A0, A1};
*       padded AAD in xmm register = {A1 A0 0 0}
*
< ASCII >
*       0                   1                   2                   3
*       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                               SPI (A1)                        |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                     32-bit Sequence Number (A0)               |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                              0x0                              |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*
*                                 AAD Format with 32-bit Sequence Number
< ASCII >
*
*       if AAD is 12 bytes:
*       AAD[3] = {A0, A1, A2};
*       padded AAD in xmm register = {A2 A1 A0 0}
*
< ASCII >
*       0                   1                   2                   3
*       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                               SPI (A2)                        |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                 64-bit Extended Sequence Number {A1,A0}       |
*       |                                                               |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*       |                              0x0                              |
*       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*
*                         AAD Format with 64-bit Extended Sequence Number
< ASCII >
*
* poly = x^128 + x^127 + x^126 + x^121 + 1
***************************************************************************/
```
## Visual type:
- #memory-layout


== ./linux/linux_214.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/crypto/aria-aesni-avx-asm_64.S#L729-L738

```c
< ASCII >
/* AES inverse affine and S2 combined:
 *      1 1 0 0 0 0 0 1     x0     0
 *      0 1 0 0 1 0 0 0     x1     0
 *      1 1 0 0 1 1 1 1     x2     0
 *      0 1 1 0 1 0 0 1     x3     1
 *      0 1 0 0 1 1 0 0  *  x4  +  0
 *      0 1 0 1 1 0 0 0     x5     0
 *      0 0 0 0 0 1 0 1     x6     0
 *      1 1 1 0 0 1 1 1     x7     1
< ASCII >
 */
```
## Visual type:
- #matrix


== ./linux/linux_215.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/crypto/aria-aesni-avx-asm_64.S#L744-L753

```c
< ASCII >
/* X2 and AES forward affine combined:
 *      1 0 1 1 0 0 0 1     x0     0
 *      0 1 1 1 1 0 1 1     x1     0
 *      0 0 0 1 1 0 1 0     x2     1
 *      0 1 0 0 0 1 0 0     x3     0
 *      0 0 1 1 1 0 1 1  *  x4  +  0
 *      0 1 0 0 1 0 0 0     x5     0
 *      1 1 0 1 0 0 1 1     x6     0
 *      0 1 0 0 1 0 1 0     x7     0
< ASCII >
 */
```
## Visual type:
- #matrix


== ./linux/linux_216.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/events/perf_event.h#L23-L36

```c
/*
< ASCII >
 *          |   NHM/WSM    |      SNB     |
 * register -------------------------------
 *          |  HT  | no HT |  HT  | no HT |
 *-----------------------------------------
 * offcore  | core | core  | cpu  | core  |
 * lbr_sel  | core | core  | cpu  | core  |
 * ld_lat   | cpu  | core  | cpu  | core  |
 *-----------------------------------------
< ASCII >
 *
 * Given that there is a small number of shared regs,
 * we can pre-allocate their slot in the per-cpu
 * per-core reg tables.
 */
```
## Visual type:
- #table


== ./linux/linux_217.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/events/intel/uncore_snbep.c#L277-L296

```c
/*
 * The CPU_BUS_NUMBER MSR returns the values of the respective CPUBUSNO CSR
 * that BIOS programmed. MSR has package scope.
< ASCII >
 * |  Bit  |  Default  |  Description
 * | [63]  |    00h    | VALID - When set, indicates the CPU bus
 *                       numbers have been initialized. (RO)
 * |[62:48]|    ---    | Reserved
 * |[47:40]|    00h    | BUS_NUM_5 - Return the bus number BIOS assigned
 *                       CPUBUSNO(5). (RO)
 * |[39:32]|    00h    | BUS_NUM_4 - Return the bus number BIOS assigned
 *                       CPUBUSNO(4). (RO)
 * |[31:24]|    00h    | BUS_NUM_3 - Return the bus number BIOS assigned
 *                       CPUBUSNO(3). (RO)
 * |[23:16]|    00h    | BUS_NUM_2 - Return the bus number BIOS assigned
 *                       CPUBUSNO(2). (RO)
 * |[15:8] |    00h    | BUS_NUM_1 - Return the bus number BIOS assigned
 *                       CPUBUSNO(1). (RO)
 * | [7:0] |    00h    | BUS_NUM_0 - Return the bus number BIOS assigned
 *                       CPUBUSNO(0). (RO)
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_218.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/events/intel/uncore_snbep.c#L4296-L4301

```c
/*
< ASCII >
 * UPI Link Parameter 0
 * |  Bit  |  Default  |  Description
 * | 19:16 |     0h    | base_nodeid - The NodeID of the sending socket.
 * | 12:8  |    00h    | sending_port - The processor die port number of the sending port.
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_219.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/events/intel/uncore_snbep.c#L4304-L4309

```c
/*
< ASCII >
 * UPI Pcode Status. This register is used by PCode to store the link training status.
 * |  Bit  |  Default  |  Description
 * |   4   |     0h    | ll_status_valid — Bit indicates the valid training status
 *                       logged from PCode to the BIOS.
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_22.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/sys_cabriolet.c#L249-L289

```c
/*
 * The PC164 and LX164 have 19 PCI interrupts, four from each of the four
 * PCI slots, the SIO, PCI/IDE, and USB.
 * 
 * Each of the interrupts can be individually masked. This is
 * accomplished by setting the appropriate bit in the mask register.
 * A bit is set by writing a "1" to the desired position in the mask
 * register and cleared by writing a "0". There are 3 mask registers
 * located at ISA address 804h, 805h and 806h.
 * 
 * An I/O read at ISA address 804h, 805h, 806h will return the
 * state of the 11 PCI interrupts and not the state of the MASKED
 * interrupts.
 * 
 * Note: A write to I/O 804h, 805h, and 806h the mask register will be
 * updated.
 * 
 * 
< ASCII >
 * 				ISA DATA<7:0>
 * ISA     +--------------------------------------------------------------+
 * ADDRESS |   7   |   6   |   5   |   4   |   3   |   2  |   1   |   0   |
 *         +==============================================================+
 * 0x804   | INTB0 |  USB  |  IDE  |  SIO  | INTA3 |INTA2 | INTA1 | INTA0 |
 *         +--------------------------------------------------------------+
 * 0x805   | INTD0 | INTC3 | INTC2 | INTC1 | INTC0 |INTB3 | INTB2 | INTB1 |
 *         +--------------------------------------------------------------+
 * 0x806   | Rsrv  | Rsrv  | Rsrv  | Rsrv  | Rsrv  |INTD3 | INTD2 | INTD1 |
 *         +--------------------------------------------------------------+
 *         * Rsrv = reserved bits
 *         Note: The mask register is write-only.
< ASCII >
 * 
 * IdSel	
 *   5	 32 bit PCI option slot 2
 *   6	 64 bit PCI option slot 0
 *   7	 64 bit PCI option slot 1
 *   8	 Saturn I/O
 *   9	 32 bit PCI option slot 3
 *  10	 USB
 *  11	 IDE
 * 
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_220.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/include/asm/dma.h#L23-L69

```c
/*
 * NOTES about DMA transfers:
 *
 *  controller 1: channels 0-3, byte operations, ports 00-1F
 *  controller 2: channels 4-7, word operations, ports C0-DF
 *
 *  - ALL registers are 8 bits only, regardless of transfer size
 *  - channel 4 is not used - cascades 1 into 2.
 *  - channels 0-3 are byte - addresses/counts are for physical bytes
 *  - channels 5-7 are word - addresses/counts are for physical words
 *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
 *  - transfer count loaded to registers is 1 less than actual count
 *  - controller 2 offsets are all even (2x offsets for controller 1)
 *  - page registers for 5-7 don't use data bit 0, represent 128K pages
 *  - page registers for 0-3 use bit 0, represent 64K pages
 *
 * DMA transfers are limited to the lower 16MB of _physical_ memory.
 * Note that addresses loaded into registers must be _physical_ addresses,
 * not logical addresses (which may differ if paging is active).
 *
< ASCII >
 *  Address mapping for channels 0-3:
 *
 *   A23 ... A16 A15 ... A8  A7 ... A0    (Physical addresses)
 *    |  ...  |   |  ... |   |  ... |
 *    |  ...  |   |  ... |   |  ... |
 *    |  ...  |   |  ... |   |  ... |
 *   P7  ...  P0  A7 ... A0  A7 ... A0
 * |    Page    | Addr MSB | Addr LSB |   (DMA registers)
< ASCII >
< ASCII >
 *
 *  Address mapping for channels 5-7:
 *
 *   A23 ... A17 A16 A15 ... A9 A8 A7 ... A1 A0    (Physical addresses)
 *    |  ...  |   \   \   ... \  \  \  ... \  \
 *    |  ...  |    \   \   ... \  \  \  ... \  (not used)
 *    |  ...  |     \   \   ... \  \  \  ... \
 *   P7  ...  P1 (0) A7 A6  ... A0 A7 A6 ... A0
 * |      Page      |  Addr MSB   |  Addr LSB  |   (DMA registers)
< ASCII >
 *
 * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
 * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
 * the hardware level, so odd-byte transfers aren't possible).
 *
 * Transfer count (_not # bytes_) is limited to 64K, represented as actual
 * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
 * and up to 128K bytes may be transferred on channels 5-7 in one operation.
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_221.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/include/asm/elf.h#L264-L287

```c
/*
 * An executable for which elf_read_implies_exec() returns TRUE will
 * have the READ_IMPLIES_EXEC personality flag set automatically.
 *
< ASCII >
 * The decision process for determining the results are:
 *
 *                 CPU: | lacks NX*  | has NX, ia32     | has NX, x86_64 |
 * ELF:                 |            |                  |                |
 * ---------------------|------------|------------------|----------------|
 * missing PT_GNU_STACK | exec-all   | exec-all         | exec-none      |
 * PT_GNU_STACK == RWX  | exec-stack | exec-stack       | exec-stack     |
 * PT_GNU_STACK == RW   | exec-none  | exec-none        | exec-none      |
< ASCII >
 *
 *  exec-all  : all PROT_READ user mappings are executable, except when
 *              backed by files on a noexec-filesystem.
 *  exec-none : only PROT_EXEC user mappings are executable.
 *  exec-stack: only the stack and PROT_EXEC user mappings are executable.
 *
 *  *this column has no architectural effect: NX markings are ignored by
 *   hardware, but may have behavioral effects when "wants X" collides with
 *   "cannot be X" constraints in memory permission flags, as in
 *   https://lkml.kernel.org/r/20190418055759.GA3155@mellanox.com
 *
 */
```
## Visual type:
- #table


== ./linux/linux_222.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/include/asm/highmem.h#L39-L56

```c
/*
 * Ordering is:
 *
< ASCII >
 * high memory on:			              high_memory off:
 *    FIXADDR_TOP                                        FIXADDR_TOP
 *        fixed addresses                                    fixed addresses
 *    FIXADDR_START                                      FIXADDR_START
 *        temp fixed addresses/persistent kmap area      VMALLOC_END
 *    PKMAP_BASE                                             temp fixed addresses/vmalloc area
 *    VMALLOC_END                                        VMALLOC_START
 *        vmalloc area                                   high_memory
 *    VMALLOC_START
 *    high_memory
< ASCII >
 *
 * The temp fixed area is only used during boot for early_ioremap(), and
 * it is unused when the ioremap() is functional. vmalloc/pkmap area become
 * available after early boot so the temp fixed area is available for re-use.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_223.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/include/asm/mwait.h#L54-L79

```c
/*
 * MWAITX allows for a timer expiration to get the core out a wait state in
 * addition to the default MWAIT exit condition of a store appearing at a
 * monitored virtual address.
 *
 * Registers:
 *
 * MWAITX ECX[1]: enable timer if set
 * MWAITX EBX[31:0]: max wait time expressed in SW P0 clocks. The software P0
 * frequency is the same as the TSC frequency.
 *
< ASCII >
 * Below is a comparison between MWAIT and MWAITX on AMD processors:
 *
 *                 MWAIT                           MWAITX
 * opcode          0f 01 c9           |            0f 01 fb
 * ECX[0]                  value of RFLAGS.IF seen by instruction
 * ECX[1]          unused/#GP if set  |            enable timer if set
 * ECX[31:2]                     unused/#GP if set
 * EAX                           unused (reserve for hint)
 * EBX[31:0]       unused             |            max wait time (P0 clocks)
 *
 *                 MONITOR                         MONITORX
 * opcode          0f 01 c8           |            0f 01 fa
 * EAX                     (logical) address to monitor
 * ECX                     #GP if not zero
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_224.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/include/asm/nospec-branch.h#L17-L53

```c
/*
 * Call depth tracking for Intel SKL CPUs to address the RSB underflow
 * issue in software.
 *
 * The tracking does not use a counter. It uses uses arithmetic shift
 * right on call entry and logical shift left on return.
 *
 * The depth tracking variable is initialized to 0x8000.... when the call
 * depth is zero. The arithmetic shift right sign extends the MSB and
 * saturates after the 12th call. The shift count is 5 for both directions
 * so the tracking covers 12 nested calls.
 *
< ASCII >
 *  Call
 *  0: 0x8000000000000000	0x0000000000000000
 *  1: 0xfc00000000000000	0xf000000000000000
 * ...
 * 11: 0xfffffffffffffff8	0xfffffffffffffc00
 * 12: 0xffffffffffffffff	0xffffffffffffffe0
< ASCII >
 *
 * After a return buffer fill the depth is credited 12 calls before the
 * next stuffing has to take place.
 *
 * There is a inaccuracy for situations like this:
 *
 *  10 calls
 *   5 returns
 *   3 calls
 *   4 returns
 *   3 calls
 *   ....
 *
 * The shift count might cause this to be off by one in either direction,
 * but there is still a cushion vs. the RSB depth. The algorithm does not
 * claim to be perfect and it can be speculated around by the CPU, but it
 * is considered that it obfuscates the problem enough to make exploitation
 * extremly difficult.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_225.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/include/asm/perf_event_p4.h#L821-L874

```c
/*
 * Notes on internal configuration of ESCR+CCCR tuples
 *
 * Since P4 has quite the different architecture of
 * performance registers in compare with "architectural"
 * once and we have on 64 bits to keep configuration
 * of performance event, the following trick is used.
 *
 * 1) Since both ESCR and CCCR registers have only low
 *    32 bits valuable, we pack them into a single 64 bit
 *    configuration. Low 32 bits of such config correspond
 *    to low 32 bits of CCCR register and high 32 bits
 *    correspond to low 32 bits of ESCR register.
 *
 * 2) The meaning of every bit of such config field can
 *    be found in Intel SDM but it should be noted that
 *    we "borrow" some reserved bits for own usage and
 *    clean them or set to a proper value when we do
 *    a real write to hardware registers.
 *
 * 3) The format of bits of config is the following
 *    and should be either 0 or set to some predefined
 *    values:
 *
< ASCII >
 *    Low 32 bits
 *    -----------
 *      0-6: P4_PEBS_METRIC enum
 *     7-11:                    reserved
 *       12:                    reserved (Enable)
 *    13-15:                    reserved (ESCR select)
 *    16-17: Active Thread
 *       18: Compare
 *       19: Complement
 *    20-23: Threshold
 *       24: Edge
 *       25:                    reserved (FORCE_OVF)
 *       26:                    reserved (OVF_PMI_T0)
 *       27:                    reserved (OVF_PMI_T1)
 *    28-29:                    reserved
 *       30:                    reserved (Cascade)
 *       31:                    reserved (OVF)
 *
< ASCII >
< ASCII >
 *    High 32 bits
 *    ------------
 *        0:                    reserved (T1_USR)
 *        1:                    reserved (T1_OS)
 *        2:                    reserved (T0_USR)
 *        3:                    reserved (T0_OS)
 *        4: Tag Enable
 *      5-8: Tag Value
 *     9-24: Event Mask (may use P4_ESCR_EMASK_BIT helper)
 *    25-30: enum P4_EVENTS
 *       31:                    reserved (HT thread)
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_226.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/include/asm/pgtable_64.h#L184-L213

```c
/*
< ASCII >
 * Encode and de-code a swap entry
 *
 * |     ...            | 11| 10|  9|8|7|6|5| 4| 3|2| 1|0| <- bit number
 * |     ...            |SW3|SW2|SW1|G|L|D|A|CD|WT|U| W|P| <- bit names
 * | TYPE (59-63) | ~OFFSET (9-58)  |0|0|X|X| X| E|F|SD|0| <- swp entry
< ASCII >
 *
 * G (8) is aliased and used as a PROT_NONE indicator for
 * !present ptes.  We need to start storing swap entries above
 * there.  We also need to avoid using A and D because of an
 * erratum where they can be incorrectly set by hardware on
 * non-present PTEs.
 *
 * SD Bits 1-4 are not used in non-present format and available for
 * special use described below:
 *
 * SD (1) in swp entry is used to store soft dirty bit, which helps us
 * remember soft dirty over page migration
 *
 * F (2) in swp entry is used to record when a pagetable is
 * writeprotected by userfaultfd WP support.
 *
 * E (3) in swp entry is used to rememeber PG_anon_exclusive.
 *
 * Bit 7 in swp entry should be 0 because pmd_present checks not only P,
 * but also L and G.
 *
 * The offset is inverted by a binary not operation to make the high
 * physical bits set.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_227.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/include/asm/pgtable_64_types.h#L154-L168

```c
/*
 * In KMSAN builds vmalloc area is four times smaller, and the remaining 3/4
 * are used to keep the metadata for virtual pages. The memory formerly
 * belonging to vmalloc area is now laid out as follows:
 *
< ASCII >
 * 1st quarter: VMALLOC_START to VMALLOC_END - new vmalloc area
 * 2nd quarter: KMSAN_VMALLOC_SHADOW_START to
 *              VMALLOC_END+KMSAN_VMALLOC_SHADOW_OFFSET - vmalloc area shadow
 * 3rd quarter: KMSAN_VMALLOC_ORIGIN_START to
 *              VMALLOC_END+KMSAN_VMALLOC_ORIGIN_OFFSET - vmalloc area origins
 * 4th quarter: KMSAN_MODULES_SHADOW_START to KMSAN_MODULES_ORIGIN_START
 *              - shadow for modules,
 *              KMSAN_MODULES_ORIGIN_START to
 *              KMSAN_MODULES_ORIGIN_START + MODULES_LEN - origins for modules.
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_228.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/include/asm/segment.h#L60-L103

```c
/*
< ASCII >
 * The layout of the per-CPU GDT under Linux:
 *
 *   0 - null								<=== cacheline #1
 *   1 - reserved
 *   2 - reserved
 *   3 - reserved
 *
 *   4 - unused								<=== cacheline #2
 *   5 - unused
 *
< ASCII >
< ASCII >
 *  ------- start of TLS (Thread-Local Storage) segments:
 *
 *   6 - TLS segment #1			[ glibc's TLS segment ]
 *   7 - TLS segment #2			[ Wine's %fs Win32 segment ]
 *   8 - TLS segment #3							<=== cacheline #3
 *   9 - reserved
 *  10 - reserved
 *  11 - reserved
 *
< ASCII >
< ASCII >
 *  ------- start of kernel segments:
 *
 *  12 - kernel code segment						<=== cacheline #4
 *  13 - kernel data segment
 *  14 - default user CS
 *  15 - default user DS
 *  16 - TSS								<=== cacheline #5
 *  17 - LDT
 *  18 - PNPBIOS support (16->32 gate)
 *  19 - PNPBIOS support
 *  20 - PNPBIOS support						<=== cacheline #6
 *  21 - PNPBIOS support
 *  22 - PNPBIOS support
 *  23 - APM BIOS support
 *  24 - APM BIOS support						<=== cacheline #7
 *  25 - APM BIOS support
 *
 *  26 - ESPFIX small SS
 *  27 - per-cpu			[ offset to per-cpu data area ]
 *  28 - unused
 *  29 - unused
 *  30 - unused
 *  31 - TSS for double fault handler
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_229.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/include/asm/syscall_wrapper.h#L14-L53

```c
/*
 * Instead of the generic __SYSCALL_DEFINEx() definition, the x86 version takes
 * struct pt_regs *regs as the only argument of the syscall stub(s) named as:
 * __x64_sys_*()         - 64-bit native syscall
 * __ia32_sys_*()        - 32-bit native syscall or common compat syscall
 * __ia32_compat_sys_*() - 32-bit compat syscall
 * __x64_compat_sys_*()  - 64-bit X32 compat syscall
 *
 * The registers are decoded according to the ABI:
 * 64-bit: RDI, RSI, RDX, R10, R8, R9
 * 32-bit: EBX, ECX, EDX, ESI, EDI, EBP
 *
 * The stub then passes the decoded arguments to the __se_sys_*() wrapper to
 * perform sign-extension (omitted for zero-argument syscalls).  Finally the
 * arguments are passed to the __do_sys_*() function which is the actual
 * syscall.  These wrappers are marked as inline so the compiler can optimize
 * the functions where appropriate.
 *
 * Example assembly (slightly re-ordered for better readability):
 *
 * <__x64_sys_recv>:		<-- syscall with 4 parameters
 *	callq	<__fentry__>
 *
 *	mov	0x70(%rdi),%rdi	<-- decode regs->di
 *	mov	0x68(%rdi),%rsi	<-- decode regs->si
 *	mov	0x60(%rdi),%rdx	<-- decode regs->dx
 *	mov	0x38(%rdi),%rcx	<-- decode regs->r10
 *
 *	xor	%r9d,%r9d	<-- clear %r9
 *	xor	%r8d,%r8d	<-- clear %r8
 *
 *	callq	__sys_recvfrom	<-- do the actual work in __sys_recvfrom()
 *				    which takes 6 arguments
 *
 *	cltq			<-- extend return value to 64-bit
 *	retq			<-- return
 *
 * This approach avoids leaking random user-provided register content down
 * the call chain.
 */
```
## Visual type:
- #ignore


== ./linux/linux_23.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/sys_ruffian.c#L100-L119

```c
/*
< ASCII >
 *  Interrupt routing:
 *
 *		Primary bus
 *	  IdSel		INTA	INTB	INTC	INTD
 * 21052   13		  -	  -	  -	  -
 * SIO	   14		 23	  -	  -	  -
 * 21143   15		 44	  -	  -	  -
 * Slot 0  17		 43	 42	 41	 40
 *
 *		Secondary bus
 *	  IdSel		INTA	INTB	INTC	INTD
 * Slot 0   8 (18)	 19	 18	 17	 16
 * Slot 1   9 (19)	 31	 30	 29	 28
 * Slot 2  10 (20)	 27	 26	 25	 24
 * Slot 3  11 (21)	 39	 38	 37	 36
 * Slot 4  12 (22)	 35	 34	 33	 32
 * 53c875  13 (23)	 20	  -	  -	  -
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_230.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/include/asm/trap_pf.h#L5-L15

```c
/*
< ASCII >
 * Page fault error code bits:
 *
 *   bit 0 ==	 0: no page found	1: protection fault
 *   bit 1 ==	 0: read access		1: write access
 *   bit 2 ==	 0: kernel-mode access	1: user-mode access
 *   bit 3 ==				1: use of reserved bit detected
 *   bit 4 ==				1: fault was an instruction fetch
 *   bit 5 ==				1: protection keys block access
 *   bit 15 ==				1: SGX MMU page-fault
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_231.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/include/asm/uv/uv_hub.h#L30-L108

```c
/*
 * Addressing Terminology
 *
 *	M       - The low M bits of a physical address represent the offset
 *		  into the blade local memory. RAM memory on a blade is physically
 *		  contiguous (although various IO spaces may punch holes in
 *		  it)..
 *
 *	N	- Number of bits in the node portion of a socket physical
 *		  address.
 *
 *	NASID   - network ID of a router, Mbrick or Cbrick. Nasid values of
 *		  routers always have low bit of 1, C/MBricks have low bit
 *		  equal to 0. Most addressing macros that target UV hub chips
 *		  right shift the NASID by 1 to exclude the always-zero bit.
 *		  NASIDs contain up to 15 bits.
 *
 *	GNODE   - NASID right shifted by 1 bit. Most mmrs contain gnodes instead
 *		  of nasids.
 *
 *	PNODE   - the low N bits of the GNODE. The PNODE is the most useful variant
 *		  of the nasid for socket usage.
 *
 *	GPA	- (global physical address) a socket physical address converted
 *		  so that it can be used by the GRU as a global address. Socket
 *		  physical addresses 1) need additional NASID (node) bits added
 *		  to the high end of the address, and 2) unaliased if the
 *		  partition does not have a physical address 0. In addition, on
 *		  UV2 rev 1, GPAs need the gnode left shifted to bits 39 or 40.
 *
 *
< ASCII >
 *  NumaLink Global Physical Address Format:
 *  +--------------------------------+---------------------+
 *  |00..000|      GNODE             |      NodeOffset     |
 *  +--------------------------------+---------------------+
 *          |<-------53 - M bits --->|<--------M bits ----->
< ASCII >
 *
 *	M - number of node offset bits (35 .. 40)
 *
 *
< ASCII >
 *  Memory/UV-HUB Processor Socket Address Format:
 *  +----------------+---------------+---------------------+
 *  |00..000000000000|   PNODE       |      NodeOffset     |
 *  +----------------+---------------+---------------------+
 *                   <--- N bits --->|<--------M bits ----->
< ASCII >
 *
 *	M - number of node offset bits (35 .. 40)
 *	N - number of PNODE bits (0 .. 10)
 *
 *		Note: M + N cannot currently exceed 44 (x86_64) or 46 (IA64).
 *		The actual values are configuration dependent and are set at
 *		boot time. M & N values are set by the hardware/BIOS at boot.
 *
 *
 * APICID format
 *	NOTE!!!!!! This is the current format of the APICID. However, code
 *	should assume that this will change in the future. Use functions
 *	in this file for all APICID bit manipulations and conversion.
 *
< ASCII >
 *		1111110000000000
 *		5432109876543210
 *		pppppppppplc0cch	Nehalem-EX (12 bits in hdw reg)
 *		ppppppppplcc0cch	Westmere-EX (12 bits in hdw reg)
 *		pppppppppppcccch	SandyBridge (15 bits in hdw reg)
 *		sssssssssss
< ASCII >
 *
 *			p  = pnode bits
 *			l =  socket number on board
 *			c  = core
 *			h  = hyperthread
 *			s  = bits that are in the SOCKET_ID CSR
 *
 *	Note: Processor may support fewer bits in the APICID register. The ACPI
 *	      tables hold all 16 bits. Software needs to be aware of this.
 *
 *	      Unless otherwise specified, all references to APICID refer to
 *	      the FULL value contained in ACPI tables, not the subset in the
 *	      processor APICID register.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_232.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/kernel/alternative.c#L767-L792

```c
/*
 * kCFI						FineIBT
 *
 * __cfi_\func:					__cfi_\func:
 *	movl   $0x12345678,%eax		// 5	     endbr64			// 4
 *	nop					     subl   $0x12345678,%r10d   // 7
 *	nop					     jz     1f			// 2
 *	nop					     ud2			// 2
 *	nop					1:   nop			// 1
 *	nop
 *	nop
 *	nop
 *	nop
 *	nop
 *	nop
 *	nop
 *
 *
 * caller:					caller:
 *	movl	$(-0x12345678),%r10d	 // 6	     movl   $0x12345678,%r10d	// 6
 *	addl	$-15(%r11),%r10d	 // 4	     sub    $16,%r11		// 4
 *	je	1f			 // 2	     nop4			// 4
 *	ud2				 // 2
 * 1:	call	__x86_indirect_thunk_r11 // 5	     call   *%r11; nop2;	// 5
 *
 */
```
## Visual type:



== ./linux/linux_233.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/kernel/apm_32.c#L2003-L2017

```c
/*
 *  Check for clue free BIOS implementations who use
 *  the following QA technique
 *
< ASCII >
 *      [ Write BIOS Code ]<------
 *               |                ^
 *      < Does it Compile >----N--
 *               |Y               ^
 *	< Does it Boot Win98 >-N--
 *               |Y
 *           [Ship It]
< ASCII >
 *
 *	Phoenix A04  08/24/2000 is known bad (Dell Inspiron 5000e)
 *	Phoenix A07  09/29/2000 is known good (Dell Inspiron 5000)
 */
```
## Visual type:
- #flowchart


== ./linux/linux_234.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/kernel/signal.c#L165-L179

```c
/*
 * The frame data is composed of the following areas and laid out as:
 *
< ASCII >
 * -------------------------
 * | alignment padding     |
 * -------------------------
 * | (f)xsave frame        |
 * -------------------------
 * | fsave header          |
 * -------------------------
 * | alignment padding     |
 * -------------------------
 * | siginfo + ucontext    |
 * -------------------------
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_235.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/kvm/mmu/spte.h#L362-L427

```c
/*
 * A shadow-present leaf SPTE may be non-writable for 4 possible reasons:
 *
 *  1. To intercept writes for dirty logging. KVM write-protects huge pages
 *     so that they can be split down into the dirty logging
 *     granularity (4KiB) whenever the guest writes to them. KVM also
 *     write-protects 4KiB pages so that writes can be recorded in the dirty log
 *     (e.g. if not using PML). SPTEs are write-protected for dirty logging
 *     during the VM-iotcls that enable dirty logging.
 *
 *  2. To intercept writes to guest page tables that KVM is shadowing. When a
 *     guest writes to its page table the corresponding shadow page table will
 *     be marked "unsync". That way KVM knows which shadow page tables need to
 *     be updated on the next TLB flush, INVLPG, etc. and which do not.
 *
 *  3. To prevent guest writes to read-only memory, such as for memory in a
 *     read-only memslot or guest memory backed by a read-only VMA. Writes to
 *     such pages are disallowed entirely.
 *
 *  4. To emulate the Accessed bit for SPTEs without A/D bits.  Note, in this
 *     case, the SPTE is access-protected, not just write-protected!
 *
 * For cases #1 and #4, KVM can safely make such SPTEs writable without taking
 * mmu_lock as capturing the Accessed/Dirty state doesn't require taking it.
 * To differentiate #1 and #4 from #2 and #3, KVM uses two software-only bits
 * in the SPTE:
 *
 *  shadow_mmu_writable_mask, aka MMU-writable -
 *    Cleared on SPTEs that KVM is currently write-protecting for shadow paging
 *    purposes (case 2 above).
 *
 *  shadow_host_writable_mask, aka Host-writable -
 *    Cleared on SPTEs that are not host-writable (case 3 above)
 *
 * Note, not all possible combinations of PT_WRITABLE_MASK,
 * shadow_mmu_writable_mask, and shadow_host_writable_mask are valid. A given
 * SPTE can be in only one of the following states, which map to the
 * aforementioned 3 cases:
< ASCII >
 *
 *   shadow_host_writable_mask | shadow_mmu_writable_mask | PT_WRITABLE_MASK
 *   ------------------------- | ------------------------ | ----------------
 *   1                         | 1                        | 1       (writable)
 *   1                         | 1                        | 0       (case 1)
 *   1                         | 0                        | 0       (case 2)
 *   0                         | 0                        | 0       (case 3)
< ASCII >
 *
 * The valid combinations of these bits are checked by
 * check_spte_writable_invariants() whenever an SPTE is modified.
 *
 * Clearing the MMU-writable bit is always done under the MMU lock and always
 * accompanied by a TLB flush before dropping the lock to avoid corrupting the
 * shadow page tables between vCPUs. Write-protecting an SPTE for dirty logging
 * (which does not clear the MMU-writable bit), does not flush TLBs before
 * dropping the lock, as it only needs to synchronize guest writes with the
 * dirty bitmap. Similarly, making the SPTE inaccessible (and non-writable) for
 * access-tracking via the clear_young() MMU notifier also does not flush TLBs.
 *
 * So, there is the problem: clearing the MMU-writable bit can encounter a
 * write-protected SPTE while CPUs still have writable mappings for that SPTE
 * cached in their TLB. To address this, KVM always flushes TLBs when
 * write-protecting SPTEs if the MMU-writable bit is set on the old SPTE.
 *
 * The Host-writable bit is not modified on present SPTEs, it is only set or
 * cleared when an SPTE is first faulted in from non-present and then remains
 * immutable.
 */
```
## Visual type:
- #table


== ./linux/linux_236.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/math-emu/div_Xsig.S#L15-L29

```c
< ASCII >
/*---------------------------------------------------------------------------+
 | Divide the 96 bit quantity pointed to by a, by that pointed to by b, and  |
 | put the 96 bit result at the location d.                                  |
 |                                                                           |
 | The result may not be accurate to 96 bits. It is intended for use where   |
 | a result better than 64 bits is required. The result should usually be    |
 | good to at least 94 bits.                                                 |
 | The returned result is actually divided by one half. This is done to      |
 | prevent overflow.                                                         |
 |                                                                           |
 |  .aaaaaaaaaaaaaa / .bbbbbbbbbbbbb  ->  .dddddddddddd                      |
 |                                                                           |
 |  void div_Xsig(Xsig *a, Xsig *b, Xsig *dest)                              |
 |                                                                           |
 +---------------------------------------------------------------------------*/
< ASCII >
```
## Visual type:
- #formula


== ./linux/linux_237.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/math-emu/div_Xsig.S#L98-L110

```c
< ASCII >
/*---------------------------------------------------------------------------+
 |  Divide:   Return  arg1/arg2 to arg3.                                     |
 |                                                                           |
 |  The maximum returned value is (ignoring exponents)                       |
 |               .ffffffff ffffffff                                          |
 |               ------------------  =  1.ffffffff fffffffe                  |
 |               .80000000 00000000                                          |
 | and the minimum is                                                        |
 |               .80000000 00000000                                          |
 |               ------------------  =  .80000000 00000001   (rounded)       |
 |               .ffffffff ffffffff                                          |
 |                                                                           |
 +---------------------------------------------------------------------------*/
< ASCII >
```
## Visual type:
- #formula


== ./linux/linux_238.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/math-emu/get_address.c#L194-L208

```c
/*
< ASCII >
       MOD R/M byte:  MOD == 3 has a special use for the FPU
                      SIB byte used iff R/M = 100b

       7   6   5   4   3   2   1   0
       .....   .........   .........
        MOD    OPCODE(2)     R/M

       SIB byte

       7   6   5   4   3   2   1   0
       .....   .........   .........
        SS      INDEX        BASE
< ASCII >

*/
```
## Visual type:
- #memory-layout


== ./linux/linux_239.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/math-emu/reg_u_sub.S#L183-L189

```c
/*
< ASCII >
 *	 A rare case, the only one which is non-zero if we got here
 *         is:           1000000 .... 0000
 *                      -0111111 .... 1111 1
 *                       -------------------- 
 *                       0000000 .... 0000 1 
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_24.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/sys_rx164.c#L113-L133

```c
/*
 * The RX164 changed its interrupt routing between pass1 and pass2...
 *
< ASCII >
 * PASS1:
 *
 *      Slot    IDSEL   INTA    INTB    INTC    INTD    
 *      0       6       5       10      15      20
 *      1       7       4       9       14      19
 *      2       5       3       8       13      18
 *      3       9       2       7       12      17
 *      4       10      1       6       11      16
 *
 * PASS2:
 *      Slot    IDSEL   INTA    INTB    INTC    INTD    
 *      0       5       1       7       12      17
 *      1       6       2       8       13      18
 *      2       8       3       9       14      19
 *      3       9       4       10      15      20
 *      4       10      5       11      16      6
< ASCII >
 *      
 */
```
## Visual type:
- #table


== ./linux/linux_240.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/math-emu/wm_sqrt.S#L40-L45

```c
/*
< ASCII >
 * The de-normalised argument:
 *                  sq_2                  sq_1              sq_0
 *        b b b b b b b ... b b b   b b b .... b b b   b 0 0 0 ... 0
 *           ^ binary point here
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_241.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/math-emu/wm_sqrt.S#L63-L67

```c
< ASCII >
/* The de-normalised argument:
                    sq_2                  sq_1              sq_0
          b b b b b b b ... b b b   b b b .... b b b   b 0 0 0 ... 0
             ^ binary point here
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_242.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/net/bpf_jit_comp32.c#L21-L49

```c
/*
< ASCII >
 * eBPF prog stack layout:
 *
 *                         high
 * original ESP =>        +-----+
 *                        |     | callee saved registers
 *                        +-----+
 *                        | ... | eBPF JIT scratch space
 * BPF_FP,IA32_EBP  =>    +-----+
 *                        | ... | eBPF prog stack
 *                        +-----+
 *                        |RSVD | JIT scratchpad
 * current ESP =>         +-----+
 *                        |     |
 *                        | ... | Function call stack
 *                        |     |
 *                        +-----+
 *                          low
 *
 * The callee saved registers:
 *
 *                                high
 * original ESP =>        +------------------+ \
 *                        |        ebp       | |
 * current EBP =>         +------------------+ } callee saved registers
 *                        |    ebx,esi,edi   | |
 *                        +------------------+ /
 *                                low
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_243.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/x86/xen/p2m.c#L3-L62

```c
/*
 * Xen leaves the responsibility for maintaining p2m mappings to the
 * guests themselves, but it must also access and update the p2m array
 * during suspend/resume when all the pages are reallocated.
 *
 * The logical flat p2m table is mapped to a linear kernel memory area.
 * For accesses by Xen a three-level tree linked via mfns only is set up to
 * allow the address space to be sparse.
< ASCII >
 *
 *               Xen
 *                |
 *          p2m_top_mfn
 *              /   \
 * p2m_mid_mfn p2m_mid_mfn
 *         /           /
 *  p2m p2m p2m ...
< ASCII >
 *
 * The p2m_mid_mfn pages are mapped by p2m_top_mfn_p.
 *
 * The p2m_top_mfn level is limited to 1 page, so the maximum representable
 * pseudo-physical address space is:
 *  P2M_TOP_PER_PAGE * P2M_MID_PER_PAGE * P2M_PER_PAGE pages
 *
 * P2M_PER_PAGE depends on the architecture, as a mfn is always
 * unsigned long (8 bytes on 64-bit, 4 bytes on 32), leading to
 * 512 and 1024 entries respectively.
 *
 * In short, these structures contain the Machine Frame Number (MFN) of the PFN.
 *
 * However not all entries are filled with MFNs. Specifically for all other
 * leaf entries, or for the top  root, or middle one, for which there is a void
 * entry, we assume it is  "missing". So (for example)
 *  pfn_to_mfn(0x90909090)=INVALID_P2M_ENTRY.
 * We have a dedicated page p2m_missing with all entries being
 * INVALID_P2M_ENTRY. This page may be referenced multiple times in the p2m
 * list/tree in case there are multiple areas with P2M_PER_PAGE invalid pfns.
 *
 * We also have the possibility of setting 1-1 mappings on certain regions, so
 * that:
 *  pfn_to_mfn(0xc0000)=0xc0000
 *
 * The benefit of this is, that we can assume for non-RAM regions (think
 * PCI BARs, or ACPI spaces), we can create mappings easily because we
 * get the PFN value to match the MFN.
 *
 * For this to work efficiently we have one new page p2m_identity. All entries
 * in p2m_identity are set to INVALID_P2M_ENTRY type (Xen toolstack only
 * recognizes that and MFNs, no other fancy value).
 *
 * On lookup we spot that the entry points to p2m_identity and return the
 * identity value instead of dereferencing and returning INVALID_P2M_ENTRY.
 * If the entry points to an allocated page, we just proceed as before and
 * return the PFN. If the PFN has IDENTITY_FRAME_BIT set we unmask that in
 * appropriate functions (pfn_to_mfn).
 *
 * The reason for having the IDENTITY_FRAME_BIT instead of just returning the
 * PFN is that we could find ourselves where pfn_to_mfn(pfn)==pfn for a
 * non-identity pfn. To protect ourselves against we elect to set (and get) the
 * IDENTITY_FRAME_BIT on all identity mapped PFNs.
 */
```
## Visual type:
- #tree


== ./linux/linux_244.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/xtensa/include/asm/asmmacro.h#L176-L184

```c
/*
 * Load 2 lowest address bits of r into SAR for __src_b to extract unaligned
 * word starting at r from two registers loaded from consecutive aligned
 * addresses covering r regardless of machine endianness.
 *
< ASCII >
 *      r   0   1   2   3
 * LE SAR   0   8  16  24
 * BE SAR  32  24  16   8
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_245.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/xtensa/include/asm/page.h#L38-L64

```c
/*
 * Cache aliasing:
 *
 * If the cache size for one way is greater than the page size, we have to
 * deal with cache aliasing. The cache index is wider than the page size:
 *
< ASCII >
 * |    |cache| cache index
 * | pfn  |off|	virtual address
 * |xxxx:X|zzz|
 * |    : |   |
 * | \  / |   |
 * |trans.|   |
 * | /  \ |   |
 * |yyyy:Y|zzz|	physical address
< ASCII >
 *
 * When the page number is translated to the physical page address, the lowest
 * bit(s) (X) that are part of the cache index are also translated (Y).
 * If this translation changes bit(s) (X), the cache index is also afected,
 * thus resulting in a different cache line than before.
 * The kernel does not provide a mechanism to ensure that the page color
 * (represented by this bit) remains the same when allocated or when pages
 * are remapped. When user pages are mapped into kernel space, the color of
 * the page might also change.
 *
 * We use the address space VMALLOC_END ... VMALLOC_END + DCACHE_WAY_SIZE * 2
 * to temporarily map a patch so we can match the color.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_246.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/xtensa/include/asm/pgtable.h#L85-L131

```c
/*
< ASCII >
 * For the Xtensa architecture, the PTE layout is as follows:
 *
 *		31------12  11  10-9   8-6  5-4  3-2  1-0
 *		+-----------------------------------------+
 *		|           |   Software   |   HARDWARE   |
 *		|    PPN    |          ADW | RI |Attribute|
 *		+-----------------------------------------+
 *   pte_none	|             MBZ          | 01 | 11 | 00 |
 *		+-----------------------------------------+
 *   present	|    PPN    | 0 | 00 | ADW | RI | CA | wx |
 *		+- - - - - - - - - - - - - - - - - - - - -+
 *   (PAGE_NONE)|    PPN    | 0 | 00 | ADW | 01 | 11 | 11 |
 *		+-----------------------------------------+
 *   swap	|     index     |   type   | 01 | 11 | 00 |
 *		+-----------------------------------------+
 *
 * For T1050 hardware and earlier the layout differs for present and (PAGE_NONE)
 *		+-----------------------------------------+
 *   present	|    PPN    | 0 | 00 | ADW | RI | CA | w1 |
 *		+-----------------------------------------+
 *   (PAGE_NONE)|    PPN    | 0 | 00 | ADW | 01 | 01 | 00 |
 *		+-----------------------------------------+
< ASCII >
 *
 *  Legend:
 *   PPN        Physical Page Number
 *   ADW	software: accessed (young) / dirty / writable
 *   RI         ring (0=privileged, 1=user, 2 and 3 are unused)
 *   CA		cache attribute: 00 bypass, 01 writeback, 10 writethrough
 *		(11 is invalid and used to mark pages that are not present)
 *   w		page is writable (hw)
 *   x		page is executable (hw)
 *   index      swap offset / PAGE_SIZE (bit 11-31: 21 bits -> 8 GB)
 *		(note that the index is always non-zero)
 *   type       swap type (5 bits -> 32 types)
 *
 *  Notes:
 *   - (PROT_NONE) is a special case of 'present' but causes an exception for
 *     any access (read, write, and execute).
 *   - 'multihit-exception' has the highest priority of all MMU exceptions,
 *     so the ring must be set to 'RING_USER' even for 'non-present' pages.
 *   - on older hardware, the exectuable flag was not supported and
 *     used as a 'valid' flag, so it needs to be always set.
 *   - we need to keep track of certain flags in software (dirty and young)
 *     to do this, we use write exceptions and have a separate software w-flag.
 *   - attribute value 1101 (and 1111 on T1050 and earlier) is reserved
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_247.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/xtensa/include/asm/ptrace.h#L16-L40

```c
/*
< ASCII >
 * Kernel stack
 *
 *		+-----------------------+  -------- STACK_SIZE
 *		|     register file     |  |
 *		+-----------------------+  |
 *		|    struct pt_regs     |  |
 *		+-----------------------+  | ------ PT_REGS_OFFSET
 * double	:  16 bytes spill area  :  |  ^
 * excetion	:- - - - - - - - - - - -:  |  |
 * frame	:    struct pt_regs     :  |  |
 *		:- - - - - - - - - - - -:  |  |
 *		|                       |  |  |
 *		|     memory stack      |  |  |
 *		|                       |  |  |
 *		~                       ~  ~  ~
 *		~                       ~  ~  ~
 *		|                       |  |  |
 *		|                       |  |  |
 *		+-----------------------+  |  | --- STACK_BIAS
 *		|  struct task_struct   |  |  |  ^
 *  current --> +-----------------------+  |  |  |
 *		|  struct thread_info   |  |  |  |
 *		+-----------------------+ --------
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_248.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/xtensa/kernel/align.S#L33-L59

```c
/* Big and little endian 16-bit values are located in
 * different halves of a register.  HWORD_START helps to
 * abstract the notion of extracting a 16-bit value from a
 * register.
 * We also have to define new shifting instructions because
 * lsb and msb are on 'opposite' ends in a register for
 * different endian machines.
 *
< ASCII >
 * Assume a memory region in ascending address:
 *   	0 1 2 3|4 5 6 7
 *
 * When loading one word into a register, the content of that register is:
 *  LE	3 2 1 0, 7 6 5 4
 *  BE  0 1 2 3, 4 5 6 7
 *
 * Masking the bits of the higher/lower address means:
 *  LE  X X 0 0, 0 0 X X
 *  BE	0 0 X X, X X 0 0
 *
 * Shifting to higher/lower addresses, means:
 *  LE  shift left / shift right
 *  BE  shift right / shift left
 *
 * Extracting 16 bits from a 32 bit reg. value to higher/lower address means:
 *  LE  mask 0 0 X X / shift left
 *  BE  shift left / mask 0 0 X X
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_249.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/xtensa/kernel/align.S#L93-L127

```c
/*
< ASCII >
 *	xxxx xxxx = imm8 field
 *	     yyyy = imm4 field
 *	     ssss = s field
 *	     tttt = t field
 *
 *	       		 16		    0
 *		          -------------------
 *	L32I.N		  yyyy ssss tttt 1000
 *	S32I.N	          yyyy ssss tttt 1001
 *
 *	       23			    0
 *		-----------------------------
 *	res	          0000           0010
 *	L16UI	xxxx xxxx 0001 ssss tttt 0010
 *	L32I	xxxx xxxx 0010 ssss tttt 0010
 *	XXX	          0011 ssss tttt 0010
 *	XXX	          0100 ssss tttt 0010
 *	S16I	xxxx xxxx 0101 ssss tttt 0010
 *	S32I	xxxx xxxx 0110 ssss tttt 0010
 *	XXX	          0111 ssss tttt 0010
 *	XXX	          1000 ssss tttt 0010
 *	L16SI	xxxx xxxx 1001 ssss tttt 0010
 *	XXX	          1010           0010
 *      **L32AI	xxxx xxxx 1011 ssss tttt 0010 unsupported
 *	XXX	          1100           0010
 *	XXX	          1101           0010
 *	XXX	          1110           0010
 *	**S32RI	xxxx xxxx 1111 ssss tttt 0010 unsupported
 *		-----------------------------
 *                           ^         ^    ^
 *    sub-opcode (NIBBLE_R) -+         |    |
 *       t field (NIBBLE_T) -----------+    |
 *  major opcode (NIBBLE_OP0) --------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_25.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arc/include/asm/entry-arcv2.h#L11-L47

```c
/*
 * Interrupt/Exception stack layout (pt_regs) for ARCv2
 *   (End of struct aligned to end of page [unless nested])
 *
< ASCII >
 *  INTERRUPT                          EXCEPTION
 *
 *    manual    ---------------------  manual
 *              |      orig_r0      |
 *              |      event/ECR    |
 *              |      bta          |
 *              |      user_r25     |
 *              |      gp           |
 *              |      fp           |
 *              |      sp           |
 *              |      r12          |
 *              |      r30          |
 *              |      r58          |
 *              |      r59          |
 *  hw autosave ---------------------
 *    optional  |      r0           |
 *              |      r1           |
 *              ~                   ~
 *              |      r9           |
 *              |      r10          |
 *              |      r11          |
 *              |      blink        |
 *              |      lpe          |
 *              |      lps          |
 *              |      lpc          |
 *              |      ei base      |
 *              |      ldi base     |
 *              |      jli base     |
 *              ---------------------
 *  hw autosave |       pc / eret   |
 *   mandatory  | stat32 / erstatus |
 *              ---------------------
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_250.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/xtensa/kernel/process.c#L224-L264

```c
/*
 * Copy thread.
 *
 * There are two modes in which this function is called:
 * 1) Userspace thread creation,
 *    regs != NULL, usp_thread_fn is userspace stack pointer.
 *    It is expected to copy parent regs (in case CLONE_VM is not set
 *    in the clone_flags) and set up passed usp in the childregs.
 * 2) Kernel thread creation,
 *    regs == NULL, usp_thread_fn is the function to run in the new thread
 *    and thread_fn_arg is its parameter.
 *    childregs are not used for the kernel threads.
 *
< ASCII >
 * The stack layout for the new thread looks like this:
 *
 *	+------------------------+
 *	|       childregs        |
 *	+------------------------+ <- thread.sp = sp in dummy-frame
 *	|      dummy-frame       |    (saved in dummy-frame spill-area)
 *	+------------------------+
< ASCII >
 *
 * We create a dummy frame to return to either ret_from_fork or
 *   ret_from_kernel_thread:
 *   a0 points to ret_from_fork/ret_from_kernel_thread (simulating a call4)
 *   sp points to itself (thread.sp)
 *   a2, a3 are unused for userspace threads,
 *   a2 points to thread_fn, a3 holds thread_fn arg for kernel threads.
 *
 * Note: This is a pristine frame, so we don't need any spill region on top of
 *       childregs.
 *
 * The fun part:  if we're keeping the same VM (i.e. cloning a thread,
 * not an entire process), we're normally given a new usp, and we CANNOT share
 * any live address register windows.  If we just copy those live frames over,
 * the two threads (parent and child) will overflow the same frames onto the
 * parent stack at different times, likely corrupting the parent stack (esp.
 * if the parent returns from functions that called clone() and calls new
 * ones, before the child overflows its now old copies of its parent windows).
 * One solution is to spill windows to the parent stack, but that's fairly
 * involved.  Much simpler to just not copy those live frames across.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_251.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/ata/pata_hpt366.c#L358-L377

```c
/**
 *	hpt36x_init_one		-	Initialise an HPT366/368
 *	@dev: PCI device
 *	@id: Entry in match table
 *
 *	Initialise an HPT36x device. There are some interesting complications
 *	here. Firstly the chip may report 366 and be one of several variants.
 *	Secondly all the timings depend on the clock for the chip which we must
 *	detect and look up
 *
 *	This is the known chip mappings. It may be missing a couple of later
 *	releases.
 *
< ASCII >
 *	Chip version		PCI		Rev	Notes
 *	HPT366			4 (HPT366)	0	UDMA66
 *	HPT366			4 (HPT366)	1	UDMA66
 *	HPT368			4 (HPT366)	2	UDMA66
 *	HPT37x/30x		4 (HPT366)	3+	Other driver
< ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_252.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/ata/pata_icside.c#L163-L187

```c
/*
 * Configure the IOMD to give the appropriate timings for the transfer
 * mode being requested.  We take the advice of the ATA standards, and
 * calculate the cycle time based on the transfer mode, and the EIDE
 * MW DMA specs that the drive provides in the IDENTIFY command.
 *
< ASCII >
 * We have the following IOMD DMA modes to choose from:
 *
 *	Type	Active		Recovery	Cycle
 *	A	250 (250)	312 (550)	562 (800)
 *	B	187 (200)	250 (550)	437 (750)
 *	C	125 (125)	125 (375)	250 (500)
 *	D	62  (50)	125 (375)	187 (425)
< ASCII >
 *
 * (figures in brackets are actual measured timings on DIOR/DIOW)
 *
< ASCII >
 * However, we also need to take care of the read/write active and
 * recovery timings:
 *
 *			Read	Write
 *  	Mode	Active	-- Recovery --	Cycle	IOMD type
 *	MW0	215	50	215	480	A
 *	MW1	80	50	50	150	C
 *	MW2	70	25	25	120	C
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_253.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/ata/sata_gemini.c#L50-L78

```c
/*
 * Values of IDE IOMUX bits in the misc control register
 *
 * Bits 26:24 are "IDE IO Select", which decides what SATA
 * adapters are connected to which of the two IDE/ATA
 * controllers in the Gemini. We can connect the two IDE blocks
 * to one SATA adapter each, both acting as master, or one IDE
 * blocks to two SATA adapters so the IDE block can act in a
 * master/slave configuration.
 *
 * We also bring out different blocks on the actual IDE
 * pins (not SATA pins) if (and only if) these are muxed in.
 *
< ASCII >
 * 111-100 - Reserved
 * Mode 0: 000 - ata0 master <-> sata0
 *               ata1 master <-> sata1
 *               ata0 slave interface brought out on IDE pads
 * Mode 1: 001 - ata0 master <-> sata0
 *               ata1 master <-> sata1
 *               ata1 slave interface brought out on IDE pads
 * Mode 2: 010 - ata1 master <-> sata1
 *               ata1 slave  <-> sata0
 *               ata0 master and slave interfaces brought out
 *                    on IDE pads
 * Mode 3: 011 - ata0 master <-> sata0
 *               ata1 slave  <-> sata1
 *               ata1 master and slave interfaces brought out
 *                    on IDE pads
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_254.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/block/floppy.c#L359-L373

```c
/* NOTE: the time values in jiffies should be in msec!
< ASCII >
 CMOS drive type
  |     Maximum data rate supported by drive type
  |     |   Head load time, msec
  |     |   |   Head unload time, msec (not used)
  |     |   |   |     Step rate interval, usec
  |     |   |   |     |       Time needed for spinup time (jiffies)
  |     |   |   |     |       |      Timeout for spinning down (jiffies)
  |     |   |   |     |       |      |   Spindown offset (where disk stops)
  |     |   |   |     |       |      |   |     Select delay
  |     |   |   |     |       |      |   |     |     RPS
  |     |   |   |     |       |      |   |     |     |    Max number of tracks
  |     |   |   |     |       |      |   |     |     |    |     Interrupt timeout
  |     |   |   |     |       |      |   |     |     |    |     |   Max nonintlv. sectors
  |     |   |   |     |       |      |   |     |     |    |     |   | -Max Errors- flags */
< ASCII >
```
## Visual type:
- #annotation


== ./linux/linux_255.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/block/floppy.c#L394-L397

```c
< ASCII >
/*    |  --autodetected formats---    |      |      |
 *    read_track                      |      |    Name printed when booting
 *				      |     Native format
 *	            Frequency of disk change checks */
< ASCII >
```
## Visual type:
- #custom


== ./linux/linux_256.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/block/floppy.c#L430-L439

```c
/*
< ASCII >
	    Size
	     |  Sectors per track
	     |  | Head
	     |  | |  Tracks
	     |  | |  | Stretch
	     |  | |  | |  Gap 1 size
	     |  | |  | |    |  Data rate, | 0x40 for perp
	     |  | |  | |    |    |  Spec1 (stepping rate, head unload
	     |  | |  | |    |    |    |    /fmt gap (gap2) 
< ASCII >*/
```
## Visual type:
- #annotation


== ./linux/linux_257.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/block/rbd.c#L243-L267

```c
/*
< ASCII >
 * Writes go through the following state machine to deal with
 * layering:
 *
 *            . . . . . RBD_OBJ_WRITE_GUARD. . . . . . . . . . . . . .
 *            .                 |                                    .
 *            .                 v                                    .
 *            .    RBD_OBJ_WRITE_READ_FROM_PARENT. . .               .
 *            .                 |                    .               .
 *            .                 v                    v (deep-copyup  .
 *    (image  .   RBD_OBJ_WRITE_COPYUP_EMPTY_SNAPC   .  not needed)  .
 * flattened) v                 |                    .               .
 *            .                 v                    .               .
 *            . . . .RBD_OBJ_WRITE_COPYUP_OPS. . . . .      (copyup  .
 *                              |                        not needed) v
 *                              v                                    .
 *                            done . . . . . . . . . . . . . . . . . .
 *                              ^
 *                              |
 *                     RBD_OBJ_WRITE_FLAT
< ASCII >
 *
 * Writes start in RBD_OBJ_WRITE_GUARD or _FLAT, depending on whether
 * assert_exists guard is needed or not (in some cases it's not needed
 * even if there is a parent).
 */
```
## Visual type:
- #state-machine


== ./linux/linux_258.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/block/drbd/drbd_int.h#L1089-L1117

```c
/* Meta data layout
 *
 * We currently have two possible layouts.
 * Offsets in (512 byte) sectors.
< ASCII >
 * external:
 *   |----------- md_size_sect ------------------|
 *   [ 4k superblock ][ activity log ][  Bitmap  ]
 *   | al_offset == 8 |
 *   | bm_offset = al_offset + X      |
 *  ==> bitmap sectors = md_size_sect - bm_offset
< ASCII >
 *
 *  Variants:
 *     old, indexed fixed size meta data:
 *
< ASCII >
 * internal:
 *            |----------- md_size_sect ------------------|
 * [data.....][  Bitmap  ][ activity log ][ 4k superblock ][padding*]
 *                        | al_offset < 0 |
 *            | bm_offset = al_offset - Y |
 *  ==> bitmap sectors = Y = al_offset - bm_offset
< ASCII >
 *
 *  [padding*] are zero or up to 7 unused 512 Byte sectors to the
 *  end of the device, so that the [4k superblock] will be 4k aligned.
 *
 *  The activity log consists of 4k transaction blocks,
 *  which are written in a ring-buffer, or striped ring-buffer like fashion,
 *  which are writtensize used to be fixed 32kB,
 *  but is about to become configurable.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_259.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/block/drbd/drbd_int.h#L1222-L1234

```c
/* the extent in "PER_EXTENT" below is an activity log extent
 * we need that many (long words/bytes) to store the bitmap
 *		     of one AL_EXTENT_SIZE chunk of storage.
 * we can store the bitmap for that many AL_EXTENTS within
 * one sector of the _on_disk_ bitmap:
< ASCII >
 * bit	 0	  bit 37   bit 38	     bit (512*8)-1
 *	     ...|........|........|.. // ..|........|
 * sect. 0	 `296	  `304			   ^(512*8*8)-1
< ASCII >
 *
#define BM_WORDS_PER_EXT    ( (AL_EXT_SIZE/BM_BLOCK_SIZE) / BITS_PER_LONG )
#define BM_BYTES_PER_EXT    ( (AL_EXT_SIZE/BM_BLOCK_SIZE) / 8 )  // 128
#define BM_EXT_PER_SECT	    ( 512 / BM_BYTES_PER_EXTENT )	 //   4
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_26.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arc/include/asm/pgtable-levels.h#L15-L31

```c
/*
 * 2 level paging setup for software walked MMUv3 (ARC700) and MMUv4 (HS)
< ASCII >
 *
 * [31]            32 bit virtual address              [0]
 * -------------------------------------------------------
 * |               | <---------- PGDIR_SHIFT ----------> |
 * |               |                | <-- PAGE_SHIFT --> |
 * -------------------------------------------------------
 *       |                  |                |
 *       |                  |                --> off in page frame
 *       |                  ---> index into Page Table
 *       ----> index into Page Directory
< ASCII >
 *
 * Given software walk, the vaddr split is arbitrary set to 11:8:13
 * However enabling of super page in a 2 level regime pegs PGDIR_SHIFT to
 * super page size.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_260.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/block/drbd/drbd_nl.c#L807-L827

```c
/* Initializes the md.*_offset members, so we are able to find
 * the on disk meta data.
 *
 * We currently have two possible layouts:
< ASCII >
 * external:
 *   |----------- md_size_sect ------------------|
 *   [ 4k superblock ][ activity log ][  Bitmap  ]
 *   | al_offset == 8 |
 *   | bm_offset = al_offset + X      |
 *  ==> bitmap sectors = md_size_sect - bm_offset
< ASCII >
< ASCII >
 *
 * internal:
 *            |----------- md_size_sect ------------------|
 * [data.....][  Bitmap  ][ activity log ][ 4k superblock ]
 *                        | al_offset < 0 |
 *            | bm_offset = al_offset - Y |
 *  ==> bitmap sectors = Y = al_offset - bm_offset
< ASCII >
 *
 *  Activity log size used to be fixed 32kB,
 *  but is about to become configurable.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_261.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/block/drbd/drbd_vli.h#L67-L90

```c
/*
 * encoding is "visualised" as
 * __little endian__ bitstream, least significant bit first (left most)
 *
 * this particular encoding is chosen so that the prefix code
 * starts as unary encoding the level, then modified so that
 * 10 levels can be described in 8bit, with minimal overhead
 * for the smaller levels.
 *
 * Number of data bits follow fibonacci sequence, with the exception of the
 * last level (+1 data bit, so it makes 64bit total).  The only worse code when
 * encoding bit polarity runlength is 1 plain bits => 2 code bits.
< ASCII >
prefix    data bits                                    max val  Nº data bits
0 x                                                         0x2            1
10 x                                                        0x4            1
110 xx                                                      0x8            2
1110 xxx                                                   0x10            3
11110 xxx xx                                               0x30            5
111110 xx xxxxxx                                          0x130            8
11111100  xxxxxxxx xxxxx                                 0x2130           13
11111110  xxxxxxxx xxxxxxxx xxxxx                      0x202130           21
11111101  xxxxxxxx xxxxxxxx xxxxxxxx  xxxxxxxx xx   0x400202130           34
11111111  xxxxxxxx xxxxxxxx xxxxxxxx  xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx 56
< ASCII >
 * maximum encodable value: 0x100000400202130 == 2**56 + some */
```
## Visual type:
- #table


== ./linux/linux_262.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/block/drbd/drbd_vli.h#L92-L110

```c
/* < ASCII >
compression "table":
 transmitted   x                                0.29
 as plaintext x                                  ........................
             x                                   ........................
            x                                    ........................
           x    0.59                         0.21........................
          x      ........................................................
         x       .. c ...................................................
        x    0.44.. o ...................................................
       x .......... d ...................................................
      x  .......... e ...................................................
     X.............   ...................................................
    x.............. b ...................................................
2.0x............... i ...................................................
 #X................ t ...................................................
 #................. s ...........................  plain bits  ..........
-+-----------------------------------------------------------------------
 1             16              32                              64
< ASCII >
*/
```
## Visual type:
- #custom


== ./linux/linux_263.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/char/ipmi/bt-bmc.c#L162-L174

```c
/*
 * The BT (Block Transfer) interface means that entire messages are
 * buffered by the host before a notification is sent to the BMC that
 * there is data to be read. The first byte is the length and the
 * message data follows. The read operation just tries to capture the
 * whole before returning it to userspace.
 *
< ASCII >
 * BT Message format :
 *
 *    Byte 1  Byte 2     Byte 3  Byte 4  Byte 5:N
 *    Length  NetFn/LUN  Seq     Cmd     Data
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_264.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/char/ipmi/bt-bmc.c#L235-L240

```c
/*
< ASCII >
 * BT Message response format :
 *
 *    Byte 1  Byte 2     Byte 3  Byte 4  Byte 5  Byte 6:N
 *    Length  NetFn/LUN  Seq     Cmd     Code    Data
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_265.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/char/tpm/tpm_ibmvtpm.c#L51-L86

```c
/**
 * ibmvtpm_send_crq() - Send a CRQ request
 *
 * @vdev:	vio device struct
 * @valid:	Valid field
 * @msg:	Type field
 * @len:	Length field
 * @data:	Data field
 *
< ASCII >
 * The ibmvtpm crq is defined as follows:
 *
 * Byte  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7
 * -----------------------------------------------------------------------
 * Word0 | Valid | Type  |     Length    |              Data
 * -----------------------------------------------------------------------
 * Word1 |                Reserved
 * -----------------------------------------------------------------------
< ASCII >
 *
 * Which matches the following structure (on bigendian host):
 *
 * struct ibmvtpm_crq {
 *         u8 valid;
 *         u8 msg;
 *         __be16 len;
 *         __be32 data;
 *         __be64 reserved;
 * } __attribute__((packed, aligned(8)));
 *
 * However, the value is passed in a register so just compute the numeric value
 * to load into the register avoiding byteswap altogether. Endian only affects
 * memory loads and stores - registers are internally represented the same.
 *
 * Return:
 *	0 (H_SUCCESS) - Success
 *	Non-zero - Failure
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_266.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/clk/berlin/berlin2-div.c#L18-L49

```c
/*
 * Clock dividers in Berlin2 SoCs comprise a complex cell to select
 * input pll and divider. The virtual structure as it is used in Marvell
 * BSP code can be seen as:
 *
< ASCII >
 *                      +---+
 * pll0 --------------->| 0 |                   +---+
 *           +---+      |(B)|--+--------------->| 0 |      +---+
 * pll1.0 -->| 0 |  +-->| 1 |  |   +--------+   |(E)|----->| 0 |   +---+
 * pll1.1 -->| 1 |  |   +---+  +-->|(C) 1:M |-->| 1 |      |(F)|-->|(G)|->
 * ...    -->|(A)|--+          |   +--------+   +---+  +-->| 1 |   +---+
 * ...    -->|   |             +-->|(D) 1:3 |----------+   +---+
 * pll1.N -->| N |                 +---------
 *           +---+
< ASCII >
 *
 * (A) input pll clock mux controlled by               <PllSelect[1:n]>
 * (B) input pll bypass mux controlled by              <PllSwitch>
 * (C) programmable clock divider controlled by        <Select[1:n]>
 * (D) constant div-by-3 clock divider
 * (E) programmable clock divider bypass controlled by <Switch>
 * (F) constant div-by-3 clock mux controlled by       <D3Switch>
 * (G) clock gate controlled by                        <Enable>
 *
 * For whatever reason, above control signals come in two flavors:
 * - single register dividers with all bits in one register
 * - shared register dividers with bits spread over multiple registers
 *   (including signals for the same cell spread over consecutive registers)
 *
 * Also, clock gate and pll mux is not available on every div cell, so
 * we have to deal with those, too. We reuse common clock composite driver
 * for it.
 */
```
## Visual type:
- #schematic


== ./linux/linux_267.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/clk/imx/clk-imx6q.c#L289-L317

```c
/*
 * We have to follow a strict procedure when changing the LDB clock source,
 * otherwise we risk introducing a glitch that can lock up the LDB divider.
 * Things to keep in mind:
 *
 * 1. The current and new parent clock inputs to the mux must be disabled.
 * 2. The default clock input for ldb_di0/1_clk_sel is mmdc_ch1_axi, which
 *    has no CG bit.
 * 3. pll2_pfd2_396m can not be gated if it is used as memory clock.
 * 4. In the RTL implementation of the LDB_DI_CLK_SEL muxes the top four
 *    options are in one mux and the PLL3 option along with three unused
 *    inputs is in a second mux. There is a third mux with two inputs used
 *    to decide between the first and second 4-port mux:
 *
< ASCII >
 *    pll5_video_div 0 --|\
 *    pll2_pfd0_352m 1 --| |_
 *    pll2_pfd2_396m 2 --| | `-|\
 *    mmdc_ch1_axi   3 --|/    | |
 *                             | |--
 *    pll3_usb_otg   4 --|\    | |
 *                   5 --| |_,-|/
 *                   6 --| |
 *                   7 --|/
< ASCII >
 *
 * The ldb_di0/1_clk_sel[1:0] bits control both 4-port muxes at the same time.
 * The ldb_di0/1_clk_sel[2] bit controls the 2-port mux. The code below
 * switches the parent to the bottom mux first and then manipulates the top
 * mux to ensure that no glitch will enter the divider.
 */
```
## Visual type:
- #schematic


== ./linux/linux_268.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/clk/meson/clk-dualdiv.c#L8-L22

```c
/*
 * The AO Domain embeds a dual/divider to generate a more precise
 * 32,768KHz clock for low-power suspend mode and CEC.
< ASCII >
 *     ______   ______
 *    |      | |      |
 *    | Div1 |-| Cnt1 |
 *   /|______| |______|\
 * -|  ______   ______  X--> Out
 *   \|      | |      |/
 *    | Div2 |-| Cnt2 |
 *    |______| |______|
< ASCII >
 *
 * The dividing can be switched to single or dual, with a counter
 * for each divider to set when the switching is done.
 */
```
## Visual type:
- #schematic


== ./linux/linux_269.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/clk/meson/clk-pll.c#L10-L27

```c
/*
 * In the most basic form, a Meson PLL is composed as follows:
 *
< ASCII >
 *                     PLL
 *        +--------------------------------+
 *        |                                |
 *        |             +--+               |
 *  in >>-----[ /N ]--->|  |      +-----+  |
 *        |             |  |------| DCO |---->> out
 *        |  +--------->|  |      +--v--+  |
 *        |  |          +--+         |     |
 *        |  |                       |     |
 *        |  +--[ *(M + (F/Fmax) ]<--+     |
 *        |                                |
 *        +--------------------------------+
< ASCII >
 *
 * out = in * (m + frac / frac_max) / n
 */
```
## Visual type:
- #schematic


== ./linux/linux_27.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arc/kernel/entry.S#L10-L22

```c
/* < ASCII >
------------------------------------------------------------------
 *    Function                            ABI
 *------------------------------------------------------------------
 *
 *  Arguments                           r0 - r7
 *  Caller Saved Registers              r0 - r12
 *  Callee Saved Registers              r13- r25
 *  Global Pointer (gp)                 r26
 *  Frame Pointer (fp)                  r27
 *  Stack Pointer (sp)                  r28
 *  Branch link register (blink)        r31
 *------------------------------------------------------------------
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_270.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/clk/pxa/clk-pxa.h#L89-L104

```c
/*
 * CKEN clock type
 * This clock takes it source from 2 possible parents :
 *  - a low power parent
 *  - a normal parent
< ASCII >
 *
 *  +------------+     +-----------+
 *  |  Low Power | --- | x mult_lp |
 *  |    Clock   |     | / div_lp  |\
 *  +------------+     +-----------+ \+-----+   +-----------+
 *                                    | Mux |---| CKEN gate |
 *  +------------+     +-----------+ /+-----+   +-----------+
 *  | High Power |     | x mult_hp |/
 *  |    Clock   | --- | / div_hp  |
 *  +------------+     +-----------+
< ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_271.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/clk/qcom/clk-cpu-8996.c#L6-L50

```c
/*
 * Each of the CPU clusters (Power and Perf) on msm8996 are
 * clocked via 2 PLLs, a primary and alternate. There are also
 * 2 Mux'es, a primary and secondary all connected together
 * as shown below
< ASCII >
 *
 *                              +-------+
 *               XO             |       |
 *           +------------------>0      |
 *                              |       |
 *                    PLL/2     | SMUX  +----+
 *                      +------->1      |    |
 *                      |       |       |    |
 *                      |       +-------+    |    +-------+
 *                      |                    +---->0      |
 *                      |                         |       |
 * +---------------+    |             +----------->1      | CPU clk
 * |Primary PLL    +----+ PLL_EARLY   |           |       +------>
 * |               +------+-----------+    +------>2 PMUX |
 * +---------------+      |                |      |       |
 *                        |   +------+     |   +-->3      |
 *                        +--^+  ACD +-----+   |  +-------+
 * +---------------+          +------+         |
 * |Alt PLL        |                           |
 * |               +---------------------------+
 * +---------------+         PLL_EARLY
< ASCII >
 *
 * The primary PLL is what drives the CPU clk, except for times
 * when we are reprogramming the PLL itself (for rate changes) when
 * we temporarily switch to an alternate PLL.
 *
 * The primary PLL operates on a single VCO range, between 600MHz
 * and 3GHz. However the CPUs do support OPPs with frequencies
 * between 300MHz and 600MHz. In order to support running the CPUs
 * at those frequencies we end up having to lock the PLL at twice
 * the rate and drive the CPU clk via the PLL/2 output and SMUX.
 *
 * So for frequencies above 600MHz we follow the following path
 *  Primary PLL --> PLL_EARLY --> PMUX(1) --> CPU clk
 * and for frequencies between 300MHz and 600MHz we follow
 *  Primary PLL --> PLL/2 --> SMUX(1) --> PMUX(0) --> CPU clk
 *
 * ACD stands for Adaptive Clock Distribution and is used to
 * detect voltage droops.
 */
```
## Visual type:
- #schematic


== ./linux/linux_272.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/clk/qcom/gcc-msm8916.c#L959-L974

```c
/*
 * This is a frequency table for "General Purpose" clocks.
 * These clocks can be muxed to the SoC pins and may be used by
 * external devices. They're often used as PWM source.
 *
 * Please note that MND divider must be enabled for duty-cycle
 * control to be possible. (M != N) Also since D register is configured
 * with a value multiplied by 2, and duty cycle is calculated as
< ASCII >
 *                             (2 * D) % 2^W
 *                DutyCycle = ----------------
 *                              2 * (N % 2^W)
< ASCII >
 * (where W = .mnd_width)
 * N must be half or less than maximum value for the register.
 * Otherwise duty-cycle control would be limited.
 * (e.g. for 8-bit NMD N should be less than 128)
 */
```
## Visual type:
- #formula


== ./linux/linux_273.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/clk/rockchip/clk-half-divider.c#L148-L157

```c
/*
 * Register a clock branch.
 * Most clock branches have a form like
 *
< ASCII >
 * src1 --|--\
 *        |M |--[GATE]-[DIV]-
 * src2 --|--/
< ASCII >
 *
 * sometimes without one of those components.
 */
```
## Visual type:
- #schematic


== ./linux/linux_274.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/clk/rockchip/clk.c#L28-L37

```c
/*
 * Register a clock branch.
 * Most clock branches have a form like
 *
< ASCII >
 * src1 --|--\
 *        |M |--[GATE]-[DIV]-
 * src2 --|--/
< ASCII >
 *
 * sometimes without one of those components.
 */
```
## Visual type:
- #schematic


== ./linux/linux_275.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/clk/sunxi/clk-a20-gmac.c#L18-L41

```c
/**
 * sun7i_a20_gmac_clk_setup - Setup function for A20/A31 GMAC clock module
 *
< ASCII >
 * This clock looks something like this
 *                               ________________________
 *  MII TX clock from PHY >-----|___________    _________|----> to GMAC core
 *  GMAC Int. RGMII TX clk >----|___________\__/__gate---|----> to PHY
 *  Ext. 125MHz RGMII TX clk >--|__divider__/            |
 *                              |________________________|
< ASCII >
 *
 * The external 125 MHz reference is optional, i.e. GMAC can use its
 * internal TX clock just fine. The A31 GMAC clock module does not have
 * the divider controls for the external reference.
 *
 * To keep it simple, let the GMAC use either the MII TX clock for MII mode,
 * and its internal TX clock for GMII and RGMII modes. The GMAC driver should
 * select the appropriate source and gate/ungate the output to the PHY.
 *
 * Only the GMAC should use this clock. Altering the clock so that it doesn't
 * match the GMAC's operation parameters will result in the GMAC not being
 * able to send traffic out. The GMAC driver should set the clock rate and
 * enable/disable this clock to configure the required state. The clock
 * driver then responds by auto-reparenting the clock.
 */
```
## Visual type:
- #schematic


== ./linux/linux_276.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/clk/sunxi/clk-sunxi.c#L932-L941

```c
/*
 * sunxi_divs_clk_setup() - Setup function for leaf divisors on clocks
 *
< ASCII >
 * These clocks look something like this
 *            ________________________
 *           |         ___divisor 1---|----> to consumer
 * parent >--|  pll___/___divisor 2---|----> to consumer
 *           |        \_______________|____> to consumer
 *           |________________________|
< ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_277.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/clocksource/timer-microchip-pit64b.c#L247-L282

```c
/**
 * mchp_pit64b_init_mode() - prepare PIT64B mode register value to be used at
 *			     runtime; this includes prescaler and SGCLK bit
 * @timer: pointer to pit64b timer to init
 * @max_rate: maximum rate that timer's clock could use
 *
 * PIT64B timer may be fed by gclk or pclk. When gclk is used its rate has to
 * be at least 3 times lower that pclk's rate. pclk rate is fixed, gclk rate
 * could be changed via clock APIs. The chosen clock (pclk or gclk) could be
 * divided by the internal PIT64B's divider.
 *
 * This function, first tries to use GCLK by requesting the desired rate from
 * PMC and then using the internal PIT64B prescaler, if any, to reach the
 * requested rate. If PCLK/GCLK < 3 (condition requested by PIT64B hardware)
 * then the function falls back on using PCLK as clock source for PIT64B timer
 * choosing the highest prescaler in case it doesn't locate one to match the
 * requested frequency.
 *
< ASCII >
 * Below is presented the PIT64B block in relation with PMC:
 *
 *                                PIT64B
 *  PMC             +------------------------------------+
 * +----+           |   +-----+                          |
 * |    |-->gclk -->|-->|     |    +---------+  +-----+  |
 * |    |           |   | MUX |--->| Divider |->|timer|  |
 * |    |-->pclk -->|-->|     |    +---------+  +-----+  |
 * +----+           |   +-----+                          |
 *                  |      ^                             |
 *                  |     sel                            |
 *                  +------------------------------------+
< ASCII >
 *
 * Where:
 *	- gclk rate <= pclk rate/3
 *	- gclk rate could be requested from PMC
 *	- pclk rate is fixed (cannot be requested from PMC)
 */
```
## Visual type:
- #schematic


== ./linux/linux_278.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/comedi/drivers/amplc_dio200.c#L13-L185

```c
/*
 * Driver: amplc_dio200
 * Description: Amplicon 200 Series ISA Digital I/O
 * Author: Ian Abbott <abbotti@mev.co.uk>
 * Devices: [Amplicon] PC212E (pc212e), PC214E (pc214e), PC215E (pc215e),
 *   PC218E (pc218e), PC272E (pc272e)
 * Updated: Mon, 18 Mar 2013 14:40:41 +0000
 *
 * Status: works
 *
 * Configuration options:
 *   [0] - I/O port base address
 *   [1] - IRQ (optional, but commands won't work without it)
 *
 * Passing a zero for an option is the same as leaving it unspecified.
 *
< ASCII >
 * SUBDEVICES
 *
 *                     PC212E         PC214E         PC215E
 *                  -------------  -------------  -------------
 *   Subdevices           6              4              5
 *    0                 PPI-X          PPI-X          PPI-X
 *    1                 CTR-Y1         PPI-Y          PPI-Y
 *    2                 CTR-Y2         CTR-Z1*        CTR-Z1
 *    3                 CTR-Z1       INTERRUPT*       CTR-Z2
 *    4                 CTR-Z2                      INTERRUPT
 *    5               INTERRUPT
 *
 *                     PC218E         PC272E
 *                  -------------  -------------
 *   Subdevices           7              4
 *    0                 CTR-X1         PPI-X
 *    1                 CTR-X2         PPI-Y
 *    2                 CTR-Y1         PPI-Z
 *    3                 CTR-Y2       INTERRUPT
 *    4                 CTR-Z1
 *    5                 CTR-Z2
 *    6               INTERRUPT
< ASCII >
 *
 * Each PPI is a 8255 chip providing 24 DIO channels.  The DIO channels
 * are configurable as inputs or outputs in four groups:
 *
 *   Port A  - channels  0 to  7
 *   Port B  - channels  8 to 15
 *   Port CL - channels 16 to 19
 *   Port CH - channels 20 to 23
 *
 * Only mode 0 of the 8255 chips is supported.
 *
 * Each CTR is a 8254 chip providing 3 16-bit counter channels.  Each
 * channel is configured individually with INSN_CONFIG instructions.  The
 * specific type of configuration instruction is specified in data[0].
 * Some configuration instructions expect an additional parameter in
 * data[1]; others return a value in data[1].  The following configuration
 * instructions are supported:
 *
 *   INSN_CONFIG_SET_COUNTER_MODE.  Sets the counter channel's mode and
 *     BCD/binary setting specified in data[1].
 *
 *   INSN_CONFIG_8254_READ_STATUS.  Reads the status register value for the
 *     counter channel into data[1].
 *
 *   INSN_CONFIG_SET_CLOCK_SRC.  Sets the counter channel's clock source as
 *     specified in data[1] (this is a hardware-specific value).  Not
 *     supported on PC214E.  For the other boards, valid clock sources are
 *     0 to 7 as follows:
 *
 *       0.  CLK n, the counter channel's dedicated CLK input from the SK1
 *         connector.  (N.B. for other values, the counter channel's CLKn
 *         pin on the SK1 connector is an output!)
 *       1.  Internal 10 MHz clock.
 *       2.  Internal 1 MHz clock.
 *       3.  Internal 100 kHz clock.
 *       4.  Internal 10 kHz clock.
 *       5.  Internal 1 kHz clock.
 *       6.  OUT n-1, the output of counter channel n-1 (see note 1 below).
 *       7.  Ext Clock, the counter chip's dedicated Ext Clock input from
 *         the SK1 connector.  This pin is shared by all three counter
 *         channels on the chip.
 *
 *   INSN_CONFIG_GET_CLOCK_SRC.  Returns the counter channel's current
 *     clock source in data[1].  For internal clock sources, data[2] is set
 *     to the period in ns.
 *
 *   INSN_CONFIG_SET_GATE_SRC.  Sets the counter channel's gate source as
 *     specified in data[2] (this is a hardware-specific value).  Not
 *     supported on PC214E.  For the other boards, valid gate sources are 0
 *     to 7 as follows:
 *
 *       0.  VCC (internal +5V d.c.), i.e. gate permanently enabled.
 *       1.  GND (internal 0V d.c.), i.e. gate permanently disabled.
 *       2.  GAT n, the counter channel's dedicated GAT input from the SK1
 *         connector.  (N.B. for other values, the counter channel's GATn
 *         pin on the SK1 connector is an output!)
 *       3.  /OUT n-2, the inverted output of counter channel n-2 (see note
 *         2 below).
 *       4.  Reserved.
 *       5.  Reserved.
 *       6.  Reserved.
 *       7.  Reserved.
 *
 *   INSN_CONFIG_GET_GATE_SRC.  Returns the counter channel's current gate
 *     source in data[2].
 *
 * Clock and gate interconnection notes:
 *
 *   1.  Clock source OUT n-1 is the output of the preceding channel on the
 *   same counter subdevice if n > 0, or the output of channel 2 on the
 *   preceding counter subdevice (see note 3) if n = 0.
 *
 *   2.  Gate source /OUT n-2 is the inverted output of channel 0 on the
 *   same counter subdevice if n = 2, or the inverted output of channel n+1
 *   on the preceding counter subdevice (see note 3) if n < 2.
 *
 *   3.  The counter subdevices are connected in a ring, so the highest
 *   counter subdevice precedes the lowest.
 *
 * The 'INTERRUPT' subdevice pretends to be a digital input subdevice.  The
 * digital inputs come from the interrupt status register.  The number of
 * channels matches the number of interrupt sources.  The PC214E does not
 * have an interrupt status register; see notes on 'INTERRUPT SOURCES'
 * below.
 *
< ASCII >
 * INTERRUPT SOURCES
 *
 *                     PC212E         PC214E         PC215E
 *                  -------------  -------------  -------------
 *   Sources              6              1              6
 *    0               PPI-X-C0       JUMPER-J5      PPI-X-C0
 *    1               PPI-X-C3                      PPI-X-C3
 *    2              CTR-Y1-OUT1                    PPI-Y-C0
 *    3              CTR-Y2-OUT1                    PPI-Y-C3
 *    4              CTR-Z1-OUT1                   CTR-Z1-OUT1
 *    5              CTR-Z2-OUT1                   CTR-Z2-OUT1
 *
 *                     PC218E         PC272E
 *                  -------------  -------------
 *   Sources              6              6
 *    0              CTR-X1-OUT1     PPI-X-C0
 *    1              CTR-X2-OUT1     PPI-X-C3
 *    2              CTR-Y1-OUT1     PPI-Y-C0
 *    3              CTR-Y2-OUT1     PPI-Y-C3
 *    4              CTR-Z1-OUT1     PPI-Z-C0
 *    5              CTR-Z2-OUT1     PPI-Z-C3
< ASCII >
 *
 * When an interrupt source is enabled in the interrupt source enable
 * register, a rising edge on the source signal latches the corresponding
 * bit to 1 in the interrupt status register.
 *
 * When the interrupt status register value as a whole (actually, just the
 * 6 least significant bits) goes from zero to non-zero, the board will
 * generate an interrupt.  No further interrupts will occur until the
 * interrupt status register is cleared to zero.  To clear a bit to zero in
 * the interrupt status register, the corresponding interrupt source must
 * be disabled in the interrupt source enable register (there is no
 * separate interrupt clear register).
 *
 * The PC214E does not have an interrupt source enable register or an
 * interrupt status register; its 'INTERRUPT' subdevice has a single
 * channel and its interrupt source is selected by the position of jumper
 * J5.
 *
 * COMMANDS
 *
 * The driver supports a read streaming acquisition command on the
 * 'INTERRUPT' subdevice.  The channel list selects the interrupt sources
 * to be enabled.  All channels will be sampled together (convert_src ==
 * TRIG_NOW).  The scan begins a short time after the hardware interrupt
 * occurs, subject to interrupt latencies (scan_begin_src == TRIG_EXT,
 * scan_begin_arg == 0).  The value read from the interrupt status register
 * is packed into a short value, one bit per requested channel, in the
 * order they appear in the channel list.
 */
```
## Visual type:
- #table


== ./linux/linux_279.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/comedi/drivers/amplc_dio200_pci.c#L12-L213

```c
/*
 * Driver: amplc_dio200_pci
 * Description: Amplicon 200 Series PCI Digital I/O
 * Author: Ian Abbott <abbotti@mev.co.uk>
 * Devices: [Amplicon] PCI215 (amplc_dio200_pci), PCIe215, PCIe236,
 *   PCI272, PCIe296
 * Updated: Mon, 18 Mar 2013 15:03:50 +0000
 * Status: works
 *
 * Configuration options:
 *   none
 *
 * Manual configuration of PCI(e) cards is not supported; they are configured
 * automatically.
 *
< ASCII >
 * SUBDEVICES
 *
 *                     PCI215         PCIe215        PCIe236
 *                  -------------  -------------  -------------
 *   Subdevices           5              8              8
 *    0                 PPI-X          PPI-X          PPI-X
 *    1                 PPI-Y          UNUSED         UNUSED
 *    2                 CTR-Z1         PPI-Y          UNUSED
 *    3                 CTR-Z2         UNUSED         UNUSED
 *    4               INTERRUPT        CTR-Z1         CTR-Z1
 *    5                                CTR-Z2         CTR-Z2
 *    6                                TIMER          TIMER
 *    7                              INTERRUPT      INTERRUPT
 *
 *
 *                     PCI272         PCIe296
 *                  -------------  -------------
 *   Subdevices           4              8
 *    0                 PPI-X          PPI-X1
 *    1                 PPI-Y          PPI-X2
 *    2                 PPI-Z          PPI-Y1
 *    3               INTERRUPT        PPI-Y2
 *    4                                CTR-Z1
 *    5                                CTR-Z2
 *    6                                TIMER
 *    7                              INTERRUPT
< ASCII >
 *
 * Each PPI is a 8255 chip providing 24 DIO channels.  The DIO channels
 * are configurable as inputs or outputs in four groups:
 *
 *   Port A  - channels  0 to  7
 *   Port B  - channels  8 to 15
 *   Port CL - channels 16 to 19
 *   Port CH - channels 20 to 23
 *
 * Only mode 0 of the 8255 chips is supported.
 *
 * Each CTR is a 8254 chip providing 3 16-bit counter channels.  Each
 * channel is configured individually with INSN_CONFIG instructions.  The
 * specific type of configuration instruction is specified in data[0].
 * Some configuration instructions expect an additional parameter in
 * data[1]; others return a value in data[1].  The following configuration
 * instructions are supported:
 *
 *   INSN_CONFIG_SET_COUNTER_MODE.  Sets the counter channel's mode and
 *     BCD/binary setting specified in data[1].
 *
 *   INSN_CONFIG_8254_READ_STATUS.  Reads the status register value for the
 *     counter channel into data[1].
 *
 *   INSN_CONFIG_SET_CLOCK_SRC.  Sets the counter channel's clock source as
 *     specified in data[1] (this is a hardware-specific value).  Not
 *     supported on PC214E.  For the other boards, valid clock sources are
 *     0 to 7 as follows:
 *
 *       0.  CLK n, the counter channel's dedicated CLK input from the SK1
 *         connector.  (N.B. for other values, the counter channel's CLKn
 *         pin on the SK1 connector is an output!)
 *       1.  Internal 10 MHz clock.
 *       2.  Internal 1 MHz clock.
 *       3.  Internal 100 kHz clock.
 *       4.  Internal 10 kHz clock.
 *       5.  Internal 1 kHz clock.
 *       6.  OUT n-1, the output of counter channel n-1 (see note 1 below).
 *       7.  Ext Clock, the counter chip's dedicated Ext Clock input from
 *         the SK1 connector.  This pin is shared by all three counter
 *         channels on the chip.
 *
 *     For the PCIe boards, clock sources in the range 0 to 31 are allowed
 *     and the following additional clock sources are defined:
 *
 *       8.  HIGH logic level.
 *       9.  LOW logic level.
 *      10.  "Pattern present" signal.
 *      11.  Internal 20 MHz clock.
 *
 *   INSN_CONFIG_GET_CLOCK_SRC.  Returns the counter channel's current
 *     clock source in data[1].  For internal clock sources, data[2] is set
 *     to the period in ns.
 *
 *   INSN_CONFIG_SET_GATE_SRC.  Sets the counter channel's gate source as
 *     specified in data[2] (this is a hardware-specific value).  Not
 *     supported on PC214E.  For the other boards, valid gate sources are 0
 *     to 7 as follows:
 *
 *       0.  VCC (internal +5V d.c.), i.e. gate permanently enabled.
 *       1.  GND (internal 0V d.c.), i.e. gate permanently disabled.
 *       2.  GAT n, the counter channel's dedicated GAT input from the SK1
 *         connector.  (N.B. for other values, the counter channel's GATn
 *         pin on the SK1 connector is an output!)
 *       3.  /OUT n-2, the inverted output of counter channel n-2 (see note
 *         2 below).
 *       4.  Reserved.
 *       5.  Reserved.
 *       6.  Reserved.
 *       7.  Reserved.
 *
 *     For the PCIe boards, gate sources in the range 0 to 31 are allowed;
 *     the following additional clock sources and clock sources 6 and 7 are
 *     (re)defined:
 *
 *       6.  /GAT n, negated version of the counter channel's dedicated
 *         GAT input (negated version of gate source 2).
 *       7.  OUT n-2, the non-inverted output of counter channel n-2
 *         (negated version of gate source 3).
 *       8.  "Pattern present" signal, HIGH while pattern present.
 *       9.  "Pattern occurred" latched signal, latches HIGH when pattern
 *         occurs.
 *      10.  "Pattern gone away" latched signal, latches LOW when pattern
 *         goes away after it occurred.
 *      11.  Negated "pattern present" signal, LOW while pattern present
 *         (negated version of gate source 8).
 *      12.  Negated "pattern occurred" latched signal, latches LOW when
 *         pattern occurs (negated version of gate source 9).
 *      13.  Negated "pattern gone away" latched signal, latches LOW when
 *         pattern goes away after it occurred (negated version of gate
 *         source 10).
 *
 *   INSN_CONFIG_GET_GATE_SRC.  Returns the counter channel's current gate
 *     source in data[2].
 *
 * Clock and gate interconnection notes:
 *
 *   1.  Clock source OUT n-1 is the output of the preceding channel on the
 *   same counter subdevice if n > 0, or the output of channel 2 on the
 *   preceding counter subdevice (see note 3) if n = 0.
 *
 *   2.  Gate source /OUT n-2 is the inverted output of channel 0 on the
 *   same counter subdevice if n = 2, or the inverted output of channel n+1
 *   on the preceding counter subdevice (see note 3) if n < 2.
 *
 *   3.  The counter subdevices are connected in a ring, so the highest
 *   counter subdevice precedes the lowest.
 *
 * The 'TIMER' subdevice is a free-running 32-bit timer subdevice.
 *
 * The 'INTERRUPT' subdevice pretends to be a digital input subdevice.  The
 * digital inputs come from the interrupt status register.  The number of
 * channels matches the number of interrupt sources.  The PC214E does not
 * have an interrupt status register; see notes on 'INTERRUPT SOURCES'
 * below.
 *
< ASCII >
 * INTERRUPT SOURCES
 *
 *                     PCI215         PCIe215        PCIe236
 *                  -------------  -------------  -------------
 *   Sources              6              6              6
 *    0               PPI-X-C0       PPI-X-C0       PPI-X-C0
 *    1               PPI-X-C3       PPI-X-C3       PPI-X-C3
 *    2               PPI-Y-C0       PPI-Y-C0        unused
 *    3               PPI-Y-C3       PPI-Y-C3        unused
 *    4              CTR-Z1-OUT1    CTR-Z1-OUT1    CTR-Z1-OUT1
 *    5              CTR-Z2-OUT1    CTR-Z2-OUT1    CTR-Z2-OUT1
 *
 *                     PCI272         PCIe296
 *                  -------------  -------------
 *   Sources              6              6
 *    0               PPI-X-C0       PPI-X1-C0
 *    1               PPI-X-C3       PPI-X1-C3
 *    2               PPI-Y-C0       PPI-Y1-C0
 *    3               PPI-Y-C3       PPI-Y1-C3
 *    4               PPI-Z-C0      CTR-Z1-OUT1
 *    5               PPI-Z-C3      CTR-Z2-OUT1
< ASCII >
 *
 * When an interrupt source is enabled in the interrupt source enable
 * register, a rising edge on the source signal latches the corresponding
 * bit to 1 in the interrupt status register.
 *
 * When the interrupt status register value as a whole (actually, just the
 * 6 least significant bits) goes from zero to non-zero, the board will
 * generate an interrupt.  The interrupt will remain asserted until the
 * interrupt status register is cleared to zero.  To clear a bit to zero in
 * the interrupt status register, the corresponding interrupt source must
 * be disabled in the interrupt source enable register (there is no
 * separate interrupt clear register).
 *
 * COMMANDS
 *
 * The driver supports a read streaming acquisition command on the
 * 'INTERRUPT' subdevice.  The channel list selects the interrupt sources
 * to be enabled.  All channels will be sampled together (convert_src ==
 * TRIG_NOW).  The scan begins a short time after the hardware interrupt
 * occurs, subject to interrupt latencies (scan_begin_src == TRIG_EXT,
 * scan_begin_arg == 0).  The value read from the interrupt status register
 * is packed into a short value, one bit per requested channel, in the
 * order they appear in the channel list.
 */
```
## Visual type:
- #table


== ./linux/linux_28.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arc/kernel/process.c#L131-L164

```c
/*
 * Copy architecture-specific thread state
 *
< ASCII >
 * Layout of Child kernel mode stack as setup at the end of this function is
 *
 * |     ...        |
 * |     ...        |
 * |    unused      |
 * |                |
 * ------------------
 * |     r25        |   <==== top of Stack (thread.ksp)
 * ~                ~
 * |    --to--      |   (CALLEE Regs of kernel mode)
 * |     r13        |
 * ------------------
 * |     fp         |
 * |    blink       |   @ret_from_fork
 * ------------------
 * |                |
 * ~                ~
 * ~                ~
 * |                |
 * ------------------
 * |     r12        |
 * ~                ~
 * |    --to--      |   (scratch Regs of user mode)
 * |     r0         |
 * ------------------
 * |      SP        |
 * |    orig_r0     |
 * |    event/ECR   |
 * |    user_r25    |
 * ------------------  <===== END of PAGE
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_280.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/comedi/drivers/amplc_pci224.c#L217-L227

```c
/*
< ASCII >
 * Summary of CLK_OUTNM1 and GAT_NOUTNM2 connections for PCI224 and PCI234:
 *
 *              Channel's       Channel's
 *              clock input     gate input
 * Channel      CLK_OUTNM1      GAT_NOUTNM2
 * -------      ----------      -----------
 * Z2-CT0       Z2-CT2-OUT      /Z2-CT1-OUT
 * Z2-CT1       Z2-CT0-OUT      /Z2-CT2-OUT
 * Z2-CT2       Z2-CT1-OUT      /Z2-CT0-OUT
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_281.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/comedi/drivers/amplc_pci230.c#L12-L165

```c
/*
 * Driver: amplc_pci230
 * Description: Amplicon PCI230, PCI260 Multifunction I/O boards
 * Author: Allan Willcox <allanwillcox@ozemail.com.au>,
 *   Steve D Sharples <steve.sharples@nottingham.ac.uk>,
 *   Ian Abbott <abbotti@mev.co.uk>
 * Updated: Mon, 01 Sep 2014 10:09:16 +0000
 * Devices: [Amplicon] PCI230 (amplc_pci230), PCI230+, PCI260, PCI260+
 * Status: works
 *
 * Configuration options:
 *   none
 *
 * Manual configuration of PCI cards is not supported; they are configured
 * automatically.
 *
 * The PCI230+ and PCI260+ have the same PCI device IDs as the PCI230 and
 * PCI260, but can be distinguished by the size of the PCI regions.  A
 * card will be configured as a "+" model if detected as such.
 *
< ASCII >
 * Subdevices:
 *
 *                 PCI230(+)    PCI260(+)
 *                 ---------    ---------
 *   Subdevices       3            1
 *         0          AI           AI
 *         1          AO
 *         2          DIO
< ASCII >
 *
 * AI Subdevice:
 *
 *   The AI subdevice has 16 single-ended channels or 8 differential
 *   channels.
 *
 *   The PCI230 and PCI260 cards have 12-bit resolution.  The PCI230+ and
 *   PCI260+ cards have 16-bit resolution.
 *
 *   For differential mode, use inputs 2N and 2N+1 for channel N (e.g. use
 *   inputs 14 and 15 for channel 7).  If the card is physically a PCI230
 *   or PCI260 then it actually uses a "pseudo-differential" mode where the
 *   inputs are sampled a few microseconds apart.  The PCI230+ and PCI260+
 *   use true differential sampling.  Another difference is that if the
 *   card is physically a PCI230 or PCI260, the inverting input is 2N,
 *   whereas for a PCI230+ or PCI260+ the inverting input is 2N+1.  So if a
 *   PCI230 is physically replaced by a PCI230+ (or a PCI260 with a
 *   PCI260+) and differential mode is used, the differential inputs need
 *   to be physically swapped on the connector.
 *
 *   The following input ranges are supported:
 *
 *     0 => [-10, +10] V
 *     1 => [-5, +5] V
 *     2 => [-2.5, +2.5] V
 *     3 => [-1.25, +1.25] V
 *     4 => [0, 10] V
 *     5 => [0, 5] V
 *     6 => [0, 2.5] V
 *
< ASCII >
 * AI Commands:
 *
 *   +=========+==============+===========+============+==========+
 *   |start_src|scan_begin_src|convert_src|scan_end_src| stop_src |
 *   +=========+==============+===========+============+==========+
 *   |TRIG_NOW | TRIG_FOLLOW  |TRIG_TIMER | TRIG_COUNT |TRIG_NONE |
 *   |TRIG_INT |              |TRIG_EXT(3)|            |TRIG_COUNT|
 *   |         |              |TRIG_INT   |            |          |
 *   |         |--------------|-----------|            |          |
 *   |         | TRIG_TIMER(1)|TRIG_TIMER |            |          |
 *   |         | TRIG_EXT(2)  |           |            |          |
 *   |         | TRIG_INT     |           |            |          |
 *   +---------+--------------+-----------+------------+----------+
< ASCII >
 *
 *   Note 1: If AI command and AO command are used simultaneously, only
 *           one may have scan_begin_src == TRIG_TIMER.
 *
 *   Note 2: For PCI230 and PCI230+, scan_begin_src == TRIG_EXT uses
 *           DIO channel 16 (pin 49) which will need to be configured as
 *           a digital input.  For PCI260+, the EXTTRIG/EXTCONVCLK input
 *           (pin 17) is used instead.  For PCI230, scan_begin_src ==
 *           TRIG_EXT is not supported.  The trigger is a rising edge
 *           on the input.
 *
 *   Note 3: For convert_src == TRIG_EXT, the EXTTRIG/EXTCONVCLK input
 *           (pin 25 on PCI230(+), pin 17 on PCI260(+)) is used.  The
 *           convert_arg value is interpreted as follows:
 *
 *             convert_arg == (CR_EDGE | 0) => rising edge
 *             convert_arg == (CR_EDGE | CR_INVERT | 0) => falling edge
 *             convert_arg == 0 => falling edge (backwards compatibility)
 *             convert_arg == 1 => rising edge (backwards compatibility)
 *
 *   All entries in the channel list must use the same analogue reference.
 *   If the analogue reference is not AREF_DIFF (not differential) each
 *   pair of channel numbers (0 and 1, 2 and 3, etc.) must use the same
 *   input range.  The input ranges used in the sequence must be all
 *   bipolar (ranges 0 to 3) or all unipolar (ranges 4 to 6).  The channel
 *   sequence must consist of 1 or more identical subsequences.  Within the
 *   subsequence, channels must be in ascending order with no repeated
 *   channels.  For example, the following sequences are valid: 0 1 2 3
 *   (single valid subsequence), 0 2 3 5 0 2 3 5 (repeated valid
 *   subsequence), 1 1 1 1 (repeated valid subsequence).  The following
 *   sequences are invalid: 0 3 2 1 (invalid subsequence), 0 2 3 5 0 2 3
 *   (incompletely repeated subsequence).  Some versions of the PCI230+ and
 *   PCI260+ have a bug that requires a subsequence longer than one entry
 *   long to include channel 0.
 *
 * AO Subdevice:
 *
 *   The AO subdevice has 2 channels with 12-bit resolution.
 *   The following output ranges are supported:
 *     0 => [0, 10] V
 *     1 => [-10, +10] V
 *
< ASCII >
 * AO Commands:
 *
 *   +=========+==============+===========+============+==========+
 *   |start_src|scan_begin_src|convert_src|scan_end_src| stop_src |
 *   +=========+==============+===========+============+==========+
 *   |TRIG_INT | TRIG_TIMER(1)| TRIG_NOW  | TRIG_COUNT |TRIG_NONE |
 *   |         | TRIG_EXT(2)  |           |            |TRIG_COUNT|
 *   |         | TRIG_INT     |           |            |          |
 *   +---------+--------------+-----------+------------+----------+
< ASCII >
 *
 *   Note 1: If AI command and AO command are used simultaneously, only
 *           one may have scan_begin_src == TRIG_TIMER.
 *
 *   Note 2: scan_begin_src == TRIG_EXT is only supported if the card is
 *           configured as a PCI230+ and is only supported on later
 *           versions of the card.  As a card configured as a PCI230+ is
 *           not guaranteed to support external triggering, please consider
 *           this support to be a bonus.  It uses the EXTTRIG/ EXTCONVCLK
 *           input (PCI230+ pin 25).  Triggering will be on the rising edge
 *           unless the CR_INVERT flag is set in scan_begin_arg.
 *
 *   The channels in the channel sequence must be in ascending order with
 *   no repeats.  All entries in the channel sequence must use the same
 *   output range.
 *
 * DIO Subdevice:
 *
 *   The DIO subdevice is a 8255 chip providing 24 DIO channels.  The DIO
 *   channels are configurable as inputs or outputs in four groups:
 *
 *     Port A  - channels  0 to  7
 *     Port B  - channels  8 to 15
 *     Port CL - channels 16 to 19
 *     Port CH - channels 20 to 23
 *
 *   Only mode 0 of the 8255 chip is supported.
 *
 *   Bit 0 of port C (DIO channel 16) is also used as an external scan
 *   trigger input for AI commands on PCI230 and PCI230+, so would need to
 *   be configured as an input to use it for that purpose.
 */
```
## Visual type:
- #table


== ./linux/linux_282.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/comedi/drivers/amplc_pci230.c#L387-L397

```c
/*
 * Summary of CLK_OUTNM1 and GAT_NOUTNM2 connections for PCI230 and PCI260:
 *
< ASCII >
 *              Channel's       Channel's
 *              clock input     gate input
 * Channel      CLK_OUTNM1      GAT_NOUTNM2
 * -------      ----------      -----------
 * Z2-CT0       Z2-CT2-OUT      /Z2-CT1-OUT
 * Z2-CT1       Z2-CT0-OUT      /Z2-CT2-OUT
 * Z2-CT2       Z2-CT1-OUT      /Z2-CT0-OUT
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_283.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/comedi/drivers/comedi_parport.c#L13-L56

```c
/*
 * Driver: comedi_parport
 * Description: Standard PC parallel port
 * Author: ds
 * Status: works in immediate mode
 * Devices: [standard] parallel port (comedi_parport)
 * Updated: Tue, 30 Apr 2002 21:11:45 -0700
 *
 * A cheap and easy way to get a few more digital I/O lines. Steal
 * additional parallel ports from old computers or your neighbors'
 * computers.
 *
 * Option list:
 *   0: I/O port base for the parallel port.
 *   1: IRQ (optional)
 *
< ASCII >
 * Parallel Port Lines:
 *
 *	 pin   subdev  chan  type  name
 *	-----  ------  ----  ----  --------------
 *	  1      2       0    DO   strobe
 *	  2      0       0    DIO  data 0
 *	  3      0       1    DIO  data 1
 *	  4      0       2    DIO  data 2
 *	  5      0       3    DIO  data 3
 *	  6      0       4    DIO  data 4
 *	  7      0       5    DIO  data 5
 *	  8      0       6    DIO  data 6
 *	  9      0       7    DIO  data 7
 *	 10      1       3    DI   ack
 *	 11      1       4    DI   busy
 *	 12      1       2    DI   paper out
 *	 13      1       1    DI   select in
 *	 14      2       1    DO   auto LF
 *	 15      1       0    DI   error
 *	 16      2       2    DO   init
 *	 17      2       3    DO   select printer
 *	18-25                      ground
< ASCII >
 *
 * When an IRQ is configured subdevice 3 pretends to be a digital
 * input subdevice, but it always returns 0 when read. However, if
 * you run a command with scan_begin_src=TRIG_EXT, it uses pin 10
 * as a external trigger, which can be used to wake up tasks.
 */
```
## Visual type:
- #table


== ./linux/linux_284.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/comedi/drivers/dac02.c#L30-L49

```c
/*
 * The output range is selected by jumpering pins on the I/O connector.
 *
< ASCII >
 *	    Range      Chan #   Jumper pins        Output
 *	-------------  ------  -------------  -----------------
 *	   0 to 5V       0        21 to 22      24
 *	                 1        15 to 16      18
 *	   0 to 10V      0        20 to 22      24
 *	                 1        14 to 16      18
 *	    +/-5V        0        21 to 22      23
 *	                 1        15 to 16      17
 *	    +/-10V       0        20 to 22      23
 *	                 1        14 to 16      17
 *	  4 to 20mA      0        21 to 22      25
 *	                 1        15 to 16      19
 *	AC reference     0      In on pin 22    24 (2-quadrant)
 *	                        In on pin 22    23 (4-quadrant)
 *	                 1      In on pin 16    18 (2-quadrant)
 *	                        In on pin 16    17 (4-quadrant)
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_285.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/comedi/drivers/daqboard2000.c#L25-L94

```c
/*
 * This card was obviously never intended to leave the Windows world,
 * since it lacked all kind of hardware documentation (except for cable
 * pinouts, plug and pray has something to catch up with yet).
 *
 * With some help from our swedish distributor, we got the Windows sourcecode
 * for the card, and here are the findings so far.
 *
 * 1. A good document that describes the PCI interface chip is 9080db-106.pdf
 *    available from http://www.plxtech.com/products/io/pci9080
 *
 * 2. The initialization done so far is:
 *      a. program the FPGA (windows code sans a lot of error messages)
 *      b.
 *
 * 3. Analog out seems to work OK with DAC's disabled, if DAC's are enabled,
 *    you have to output values to all enabled DAC's until result appears, I
 *    guess that it has something to do with pacer clocks, but the source
 *    gives me no clues. I'll keep it simple so far.
 *
 * 4. Analog in.
 *    Each channel in the scanlist seems to be controlled by four
 *    control words:
 *
< ASCII >
 *	Word0:
 *	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *	  ! | | | ! | | | ! | | | ! | | | !
 *	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
< ASCII >
 *
 *	Word1:
 *	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *	  ! | | | ! | | | ! | | | ! | | | !
 *	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *	   |             |       | | | | |
 *	   +------+------+       | | | | +-- Digital input (??)
 *		  |		 | | | +---- 10 us settling time
 *		  |		 | | +------ Suspend acquisition (last to scan)
 *		  |		 | +-------- Simultaneous sample and hold
 *		  |		 +---------- Signed data format
 *		  +------------------------- Correction offset low
< ASCII >
< ASCII >
 *
 *	Word2:
 *	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *	  ! | | | ! | | | ! | | | ! | | | !
 *	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *	   |     | |     | | | | | |     |
 *	   +-----+ +--+--+ +++ +++ +--+--+
 *	      |       |     |   |     +----- Expansion channel
 *	      |       |     |   +----------- Expansion gain
 *	      |       |     +--------------- Channel (low)
 *	      |       +--------------------- Correction offset high
 *	      +----------------------------- Correction gain low
< ASCII >
< ASCII >
 *	Word3:
 *	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *	  ! | | | ! | | | ! | | | ! | | | !
 *	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *	   |             | | | |   | | | |
 *	   +------+------+ | | +-+-+ | | +-- Low bank enable
 *		  |	   | |   |   | +---- High bank enable
 *		  |	   | |   |   +------ Hi/low select
 *		  |	   | |   +---------- Gain (1,?,2,4,8,16,32,64)
 *		  |	   | +-------------- differential/single ended
 *		  |	   +---------------- Unipolar
 *		  +------------------------- Correction gain high
< ASCII >
 *
 * 999. The card seems to have an incredible amount of capabilities, but
 *      trying to reverse engineer them from the Windows source is beyond my
 *      patience.
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_286.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/comedi/drivers/ni_usb6501.c#L23-L85

```c
/*
 * NI-6501 - USB PROTOCOL DESCRIPTION
 *
 * Every command is composed by two USB packets:
 *	- request (out)
 *	- response (in)
 *
 * Every packet is at least 12 bytes long, here is the meaning of
 * every field (all values are hex):
 *
 *	byte 0 is always 00
 *	byte 1 is always 01
 *	byte 2 is always 00
 *	byte 3 is the total packet length
 *
 *	byte 4 is always 00
 *	byte 5 is the total packet length - 4
 *	byte 6 is always 01
 *	byte 7 is the command
 *
 *	byte 8 is 02 (request) or 00 (response)
 *	byte 9 is 00 (response) or 10 (port request) or 20 (counter request)
 *	byte 10 is always 00
 *	byte 11 is 00 (request) or 02 (response)
 *
< ASCII >
 * PORT PACKETS
 *
 *	CMD: 0xE READ_PORT
 *	REQ: 00 01 00 10 00 0C 01 0E 02 10 00 00 00 03 <PORT> 00
 *	RES: 00 01 00 10 00 0C 01 00 00 00 00 02 00 03 <BMAP> 00
 *
 *	CMD: 0xF WRITE_PORT
 *	REQ: 00 01 00 14 00 10 01 0F 02 10 00 00 00 03 <PORT> 00 03 <BMAP> 00 00
 *	RES: 00 01 00 0C 00 08 01 00 00 00 00 02
 *
 *	CMD: 0x12 SET_PORT_DIR (0 = input, 1 = output)
 *	REQ: 00 01 00 18 00 14 01 12 02 10 00 00
 *	     00 05 <PORT 0> <PORT 1> <PORT 2> 00 05 00 00 00 00 00
 *	RES: 00 01 00 0C 00 08 01 00 00 00 00 02
< ASCII >
< ASCII >
 *
 * COUNTER PACKETS
 *
 *	CMD 0x9: START_COUNTER
 *	REQ: 00 01 00 0C 00 08 01 09 02 20 00 00
 *	RES: 00 01 00 0C 00 08 01 00 00 00 00 02
 *
 *	CMD 0xC: STOP_COUNTER
 *	REQ: 00 01 00 0C 00 08 01 0C 02 20 00 00
 *	RES: 00 01 00 0C 00 08 01 00 00 00 00 02
 *
 *	CMD 0xE: READ_COUNTER
 *	REQ: 00 01 00 0C 00 08 01 0E 02 20 00 00
 *	RES: 00 01 00 10 00 0C 01 00 00 00 00 02 <u32 counter value, Big Endian>
 *
 *	CMD 0xF: WRITE_COUNTER
 *	REQ: 00 01 00 10 00 0C 01 0F 02 20 00 00 <u32 counter value, Big Endian>
 *	RES: 00 01 00 0C 00 08 01 00 00 00 00 02
< ASCII >
 *
 *
 *	Please  visit https://www.brickedbrain.com if you need
 *	additional information or have any questions.
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_287.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/counter/stm32-lptimer-cnt.c#L110-L127

```c
/*
 * In non-quadrature mode, device counts up on active edge.
< ASCII >
 * In quadrature mode, encoder counting scenarios are as follows:
 * +---------+----------+--------------------+--------------------+
 * | Active  | Level on |      IN1 signal    |     IN2 signal     |
 * | edge    | opposite +----------+---------+----------+---------+
 * |         | signal   |  Rising  | Falling |  Rising  | Falling |
 * +---------+----------+----------+---------+----------+---------+
 * | Rising  | High ->  |   Down   |    -    |   Up     |    -    |
 * | edge    | Low  ->  |   Up     |    -    |   Down   |    -    |
 * +---------+----------+----------+---------+----------+---------+
 * | Falling | High ->  |    -     |   Up    |    -     |   Down  |
 * | edge    | Low  ->  |    -     |   Down  |    -     |   Up    |
 * +---------+----------+----------+---------+----------+---------+
 * | Both    | High ->  |   Down   |   Up    |   Up     |   Down  |
 * | edges   | Low  ->  |   Up     |   Down  |   Down   |   Up    |
 * +---------+----------+----------+---------+----------+---------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_288.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/cpuidle/cpuidle-pseries.c#L106-L144

```c
/*
 * If the platform supports the cede latency settings information system
 * parameter it must provide the following information in the NULL terminated
 * parameter string:
 *
 * a. The first byte is the length “N” of each cede latency setting record minus
 *    one (zero indicates a length of 1 byte).
 *
 * b. For each supported cede latency setting a cede latency setting record
 *    consisting of the first “N” bytes as per the following table.
 *
< ASCII >
 *    -----------------------------
 *    | Field           | Field   |
 *    | Name            | Length  |
 *    -----------------------------
 *    | Cede Latency    | 1 Byte  |
 *    | Specifier Value |         |
 *    -----------------------------
 *    | Maximum wakeup  |         |
 *    | latency in      | 8 Bytes |
 *    | tb-ticks        |         |
 *    -----------------------------
 *    | Responsive to   |         |
 *    | external        | 1 Byte  |
 *    | interrupts      |         |
 *    -----------------------------
< ASCII >
 *
 * This version has cede latency record size = 10.
 *
 * The structure xcede_latency_payload represents a) and b) with
 * xcede_latency_record representing the table in b).
 *
 * xcede_latency_parameter is what gets returned by
 * ibm,get-systems-parameter RTAS call when made with
 * CEDE_LATENCY_TOKEN.
 *
 * These structures are only used to represent the data obtained by the RTAS
 * call. The data is in big-endian.
 */
```
## Visual type:
- #table


== ./linux/linux_289.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/crypto/axis/artpec6_crypto.c#L198-L220

```c
/* The PDMA is a DMA-engine tightly coupled with a ciphering engine.
 * It operates on a descriptor array with up to 64 descriptor entries.
 * The arrays must be 64 byte aligned in memory.
 *
 * The ciphering unit has no registers and is completely controlled by
 * a 4-byte metadata that is inserted at the beginning of each dma packet.
 *
 * A dma packet is a sequence of descriptors terminated by setting the .eop
 * field in the final descriptor of the packet.
 *
 * Multiple packets are used for providing context data, key data and
 * the plain/ciphertext.
 *
< ASCII >
 *   PDMA Descriptors (Array)
 *  +------+------+------+~~+-------+------+----
 *  |  0   |  1   |  2   |~~| 11 EOP|  12  |  ....
 *  +--+---+--+---+----+-+~~+-------+----+-+----
 *     |      |        |       |         |
 *     |      |        |       |         |
 *   __|__  +-------++-------++-------+ +----+
 *  | MD  | |Payload||Payload||Payload| | MD |
 *  +-----+ +-------++-------++-------+ +----+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_29.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arc/mm/dma.c#L33-L49

```c
/*
 * Cache operations depending on function and direction argument, inspired by
 * https://lore.kernel.org/lkml/20180518175004.GF17671@n2100.armlinux.org.uk
 * "dma_sync_*_for_cpu and direction=TO_DEVICE (was Re: [PATCH 02/20]
 * dma-mapping: provide a generic dma-noncoherent implementation)"
 *
< ASCII >
 *          |   map          ==  for_device     |   unmap     ==  for_cpu
 *          |----------------------------------------------------------------
 * TO_DEV   |   writeback        writeback      |   none          none
 * FROM_DEV |   invalidate       invalidate     |   invalidate*   invalidate*
 * BIDIR    |   writeback+inv    writeback+inv  |   invalidate    invalidate
< ASCII >
 *
 *     [*] needed for CPU speculative prefetches
 *
 * NOTE: we don't check the validity of direction argument as it is done in
 * upper layer functions (in include/linux/dma-mapping.h)
 */
```
## Visual type:
- #table


== ./linux/linux_290.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/crypto/cavium/nitrox/nitrox_reqmgr.c#L84-L106

```c
/**
 * create_sg_component - create SG componets for N5 device.
 * @sr: Request structure
 * @sgtbl: SG table
 * @map_nents: number of dma mapped entries
 *
< ASCII >
 * Component structure
 *
 *   63     48 47     32 31    16 15      0
 *   --------------------------------------
 *   |   LEN0  |  LEN1  |  LEN2  |  LEN3  |
 *   |-------------------------------------
 *   |               PTR0                 |
 *   --------------------------------------
 *   |               PTR1                 |
 *   --------------------------------------
 *   |               PTR2                 |
 *   --------------------------------------
 *   |               PTR3                 |
 *   --------------------------------------
< ASCII >
 *
 *   Returns 0 if success or a negative errno code on error.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_291.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/crypto/keembay/ocs-aes.c#L152-L162

```c
/*
 * CCM IV format from RFC 3610 section 2.3
 *
< ASCII >
 *   Octet Number   Contents
 *   ------------   ---------
 *   0              Flags
 *   1 ... 15-L     Nonce N
 *   16-L ... 15    Counter i
< ASCII >
 *
 * Flags = L' = L - 1
 */
```
## Visual type:
- #table


== ./linux/linux_292.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/crypto/marvell/cesa/cesa.h#L123-L137

```c
/*
< ASCII >
 * /-----------\ 0
 * | ACCEL CFG |	4 * 8
 * |-----------| 0x20
 * | CRYPT KEY |	8 * 4
 * |-----------| 0x40
 * |  IV   IN  |	4 * 4
 * |-----------| 0x40 (inplace)
 * |  IV BUF   |	4 * 4
 * |-----------| 0x80
 * |  DATA IN  |	16 * x (max ->max_req_size)
 * |-----------| 0x80 (inplace operation)
 * |  DATA OUT |	16 * x (max ->max_req_size)
 * \-----------/ SRAM size
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_293.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/crypto/marvell/cesa/cesa.h#L139-L152

```c
/*
< ASCII >
 * Hashing memory map:
 * /-----------\ 0
 * | ACCEL CFG |        4 * 8
 * |-----------| 0x20
 * | Inner IV  |        8 * 4
 * |-----------| 0x40
 * | Outer IV  |        8 * 4
 * |-----------| 0x60
 * | Output BUF|        8 * 4
 * |-----------| 0x80
 * |  DATA IN  |        64 * x (max ->max_req_size)
 * \-----------/ SRAM size
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_294.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/crypto/qat/qat_common/adf_pfvf_msg.h#L8-L83

```c
/*
 * PF<->VF Gen2 Messaging format
 *
 * The PF has an array of 32-bit PF2VF registers, one for each VF. The
 * PF can access all these registers while each VF can access only the one
 * register associated with that particular VF.
 *
 * The register functionally is split into two parts:
 * The bottom half is for PF->VF messages. In particular when the first
 * bit of this register (bit 0) gets set an interrupt will be triggered
 * in the respective VF.
 * The top half is for VF->PF messages. In particular when the first bit
 * of this half of register (bit 16) gets set an interrupt will be triggered
 * in the PF.
 *
 * The remaining bits within this register are available to encode messages.
 * and implement a collision control mechanism to prevent concurrent use of
 * the PF2VF register by both the PF and VF.
 *
< ASCII >
 *  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
 *  _______________________________________________
 * |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
 * +-----------------------------------------------+
 *  \___________________________/ \_________/ ^   ^
 *                ^                    ^      |   |
 *                |                    |      |   VF2PF Int
 *                |                    |      Message Origin
 *                |                    Message Type
 *                Message-specific Data/Reserved
 *
 *  15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
 *  _______________________________________________
 * |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
 * +-----------------------------------------------+
 *  \___________________________/ \_________/ ^   ^
 *                ^                    ^      |   |
 *                |                    |      |   PF2VF Int
 *                |                    |      Message Origin
 *                |                    Message Type
 *                Message-specific Data/Reserved
< ASCII >
 *
 * Message Origin (Should always be 1)
 * A legacy out-of-tree QAT driver allowed for a set of messages not supported
 * by this driver; these had a Msg Origin of 0 and are ignored by this driver.
 *
 * When a PF or VF attempts to send a message in the lower or upper 16 bits,
 * respectively, the other 16 bits are written to first with a defined
 * IN_USE_BY pattern as part of a collision control scheme (see function
 * adf_gen2_pfvf_send() in adf_pf2vf_msg.c).
 *
 *
 * PF<->VF Gen4 Messaging format
 *
 * Similarly to the gen2 messaging format, 32-bit long registers are used for
 * communication between PF and VFs. However, each VF and PF share a pair of
 * 32-bits register to avoid collisions: one for PV to VF messages and one
 * for VF to PF messages.
 *
 * Both the Interrupt bit and the Message Origin bit retain the same position
 * and meaning, although non-system messages are now deprecated and not
 * expected.
 *
< ASCII >
 *  31 30              9  8  7  6  5  4  3  2  1  0
 *  _______________________________________________
 * |  |  |   . . .   |  |  |  |  |  |  |  |  |  |  |
 * +-----------------------------------------------+
 *  \_____________________/ \_______________/  ^  ^
 *             ^                     ^         |  |
 *             |                     |         |  PF/VF Int
 *             |                     |         Message Origin
 *             |                     Message Type
 *             Message-specific Data/Reserved
< ASCII >
 *
 * For both formats, the message reception is acknowledged by lowering the
 * interrupt bit on the register where the message was sent.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_295.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/devfreq/imx8m-ddrc.c#L37-L64

```c
/*
< ASCII >
 * i.MX8M DRAM Controller clocks have the following structure (abridged):
 *
 * +----------+       |\            +------+
 * | dram_pll |-------|M| dram_core |      |
 * +----------+       |U|---------->| D    |
 *                 /--|X|           |  D   |
 *   dram_alt_root |  |/            |   R  |
 *                 |                |    C |
 *            +---------+           |      |
 *            |FIX DIV/4|           |      |
 *            +---------+           |      |
 *  composite:     |                |      |
 * +----------+    |                |      |
 * | dram_alt |----/                |      |
 * +----------+                     |      |
 * | dram_apb |-------------------->|      |
 * +----------+                     +------+
< ASCII >
 *
 * The dram_pll is used for higher rates and dram_alt is used for lower rates.
 *
 * Frequency switching is implemented in TF-A (via SMC call) and can change the
 * configuration of the clocks, including mux parents. The dram_alt and
 * dram_apb clocks are "imx composite" and their parent can change too.
 *
 * We need to prepare/enable the new mux parents head of switching and update
 * their information afterwards.
 */
```
## Visual type:
- #schematic


== ./linux/linux_296.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/edac/cpc925_edac.c#L418-L434

```c
/*
 * Revert DDR column/row/bank addresses into page frame number and
 * offset in page.
 *
< ASCII >
 * Suppose memory mode is 0x0111(128-bit mode, identical DIMM pairs),
 * physical address(PA) bits to column address(CA) bits mappings are:
 * CA	0   1   2   3   4   5   6   7   8   9   10
 * PA	59  58  57  56  55  54  53  52  51  50  49
 *
 * physical address(PA) bits to bank address(BA) bits mappings are:
 * BA	0   1
 * PA	43  44
 *
 * physical address(PA) bits to row address(RA) bits mappings are:
 * RA	0   1   2   3   4   5   6   7   8   9   10   11   12
 * PA	36  35  34  48  47  46  45  40  41  42  39   38   37
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_297.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/extcon/extcon-usb-gpio.c#L43-L59

```c
/*
 * "USB" = VBUS and "USB-HOST" = !ID, so we have:
 * Both "USB" and "USB-HOST" can't be set as active at the
 * same time so if "USB-HOST" is active (i.e. ID is 0)  we keep "USB" inactive
 * even if VBUS is on.
 *
< ASCII >
 *  State              |    ID   |   VBUS
 * ----------------------------------------
 *  [1] USB            |    H    |    H
 *  [2] none           |    H    |    L
 *  [3] USB-HOST       |    L    |    H
 *  [4] USB-HOST       |    L    |    L
< ASCII >
 *
 * In case we have only one of these signals:
 * - VBUS only - we want to distinguish between [1] and [2], so ID is always 1.
 * - ID only - we want to distinguish between [1] and [4], so VBUS = ID.
*/
```
## Visual type:
- #table


== ./linux/linux_298.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/firmware/arm_scmi/driver.c#L216-L274

```c
/**
 * scmi_xfer_token_set  - Reserve and set new token for the xfer at hand
 *
 * @minfo: Pointer to Tx/Rx Message management info based on channel type
 * @xfer: The xfer to act upon
 *
 * Pick the next unused monotonically increasing token and set it into
 * xfer->hdr.seq: picking a monotonically increasing value avoids immediate
 * reuse of freshly completed or timed-out xfers, thus mitigating the risk
 * of incorrect association of a late and expired xfer with a live in-flight
 * transaction, both happening to re-use the same token identifier.
 *
 * Since platform is NOT required to answer our request in-order we should
 * account for a few rare but possible scenarios:
 *
 *  - exactly 'next_token' may be NOT available so pick xfer_id >= next_token
 *    using find_next_zero_bit() starting from candidate next_token bit
 *
 *  - all tokens ahead upto (MSG_TOKEN_ID_MASK - 1) are used in-flight but we
 *    are plenty of free tokens at start, so try a second pass using
 *    find_next_zero_bit() and starting from 0.
 *
 *  X = used in-flight
 *
< ASCII >
 * Normal
 * ------
 *
 *		|- xfer_id picked
 *   -----------+----------------------------------------------------------
 *   | | |X|X|X| | | | | | ... ... ... ... ... ... ... ... ... ... ...|X|X|
 *   ----------------------------------------------------------------------
 *		^
 *		|- next_token
< ASCII >
< ASCII >
 *
 * Out-of-order pending at start
 * -----------------------------
 *
 *	  |- xfer_id picked, last_token fixed
 *   -----+----------------------------------------------------------------
 *   |X|X| | | | |X|X| ... ... ... ... ... ... ... ... ... ... ... ...|X| |
 *   ----------------------------------------------------------------------
 *    ^
 *    |- next_token
< ASCII >
< ASCII >
 *
 *
 * Out-of-order pending at end
 * ---------------------------
 *
 *	  |- xfer_id picked, last_token fixed
 *   -----+----------------------------------------------------------------
 *   |X|X| | | | |X|X| ... ... ... ... ... ... ... ... ... ... |X|X|X||X|X|
 *   ----------------------------------------------------------------------
 *								^
 *								|- next_token
< ASCII >
 *
 * Context: Assumes to be called with @xfer_lock already acquired.
 *
 * Return: 0 on Success or error
 */
```
## Visual type:
- #sequence


== ./linux/linux_299.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/fpga/altera-ps-spi.c#L49-L57

```c
< ASCII >
/*          |   Arria 10  |   Cyclone5  |   Stratix5  |
 * t_CF2ST0 |     [; 600] |     [; 600] |     [; 600] |ns
 * t_CFG    |        [2;] |        [2;] |        [2;] |µs
 * t_STATUS | [268; 3000] | [268; 1506] | [268; 1506] |µs
 * t_CF2ST1 |    [; 3000] |    [; 1506] |    [; 1506] |µs
 * t_CF2CK  |     [3010;] |     [1506;] |     [1506;] |µs
 * t_ST2CK  |       [10;] |        [2;] |        [2;] |µs
 * t_CD2UM  |  [175; 830] |  [175; 437] |  [175; 437] |µs
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_3.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/include/asm/core_mcpcia.h#L42-L74

```c
/* MCPCIA ADDRESS BIT DEFINITIONS
 *
< ASCII >
 *  3333 3333 3322 2222 2222 1111 1111 11
 *  9876 5432 1098 7654 3210 9876 5432 1098 7654 3210
 *  ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
 *  1                                             000
 *  ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
 *  |                                             |\|
 *  |                               Byte Enable --+ |
 *  |                             Transfer Length --+
 *  +-- IO space, not cached
 *
 *   Byte      Transfer
 *   Enable    Length    Transfer  Byte    Address
 *   adr<6:5>  adr<4:3>  Length    Enable  Adder
 *   ---------------------------------------------
 *      00        00      Byte      1110   0x000
 *      01        00      Byte      1101   0x020
 *      10        00      Byte      1011   0x040
 *      11        00      Byte      0111   0x060
 *
 *      00        01      Word      1100   0x008
 *      01        01      Word      1001   0x028 <= Not supported in this code.
 *      10        01      Word      0011   0x048
 *
 *      00        10      Tribyte   1000   0x010
 *      01        10      Tribyte   0001   0x030
 *
 *      10        11      Longword  0000   0x058
 *
 *      Note that byte enables are asserted low.
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_30.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/boot/dts/pxa3xx.dtsi#L81-L100

```c
/*
 * MFP low power mode for pins.
 * Example of use:
 *   pinctrl-single,low-power-mode = MFP_LPM(MFP_LPM_PULL_LOW|MFP_LPM_EDGE_FALL);
 *
 * Table that determines the low power modes outputs, with actual settings
 * used in parentheses for don't-care values. Except for the float output,
 * the configured driven and pulled levels match, so if there is a need for
 * non-LPM pulled output, the same configuration could probably be used.
 *
< ASCII >
 * Output value  sleep_oe_n  sleep_data  pullup_en  pulldown_en  pull_sel
 *                 (bit 7)    (bit 8)    (bit 14)     (bit 13)   (bit 15)
 *
 * Input            0          X(0)        X(0)        X(0)       0
 * Drive 0          0          0           0           X(1)       0
 * Drive 1          0          1           X(1)        0	  0
 * Pull hi (1)      1          X(1)        1           0	  0
 * Pull lo (0)      1          X(0)        0           1	  0
 * Z (float)        1          X(0)        0           0	  0
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_300.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/fsi/cf-fsi-fw.h#L59-L77

```c
/* Command/Status register:
 *
< ASCII >
 * +---------------------------+
 * | STAT | RLEN | CLEN | CMD  |
 * |   8  |   8  |   8  |   8  |
 * +---------------------------+
 *    |       |      |      |
 *    status  |      |      |
 * Response len      |      |
 * (in bits)         |      |
 *                   |      |
 *         Command len      |
 *         (in bits)        |
 *                          |
 *               Command code
< ASCII >
 *
 * Due to the big endian layout, that means that a byte read will
 * return the status byte
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_301.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpio/gpio-mvebu.c#L468-L492

```c
/*****************************************************************************
 * MVEBU GPIO IRQ
 *
 * GPIO_IN_POL register controls whether GPIO_DATA_IN will hold the same
 * value of the line or the opposite value.
 *
 * Level IRQ handlers: DATA_IN is used directly as cause register.
 *		       Interrupt are masked by LEVEL_MASK registers.
 * Edge IRQ handlers:  Change in DATA_IN are latched in EDGE_CAUSE.
 *		       Interrupt are masked by EDGE_MASK registers.
 * Both-edge handlers: Similar to regular Edge handlers, but also swaps
 *		       the polarity to catch the next line transaction.
 *		       This is a race condition that might not perfectly
 *		       work on some use cases.
 *
 * Every eight GPIO lines are grouped (OR'ed) before going up to main
 * cause register.
 *
< ASCII >
 *		      EDGE  cause    mask
 *	  data-in   /--------| |-----| |----\
 *     -----| |-----			     ---- to main cause reg
 *	     X	    \----------------| |----/
 *	  polarity    LEVEL	     mask
< ASCII >
 *
 ****************************************************************************/
```
## Visual type:
- #schematic


== ./linux/linux_302.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpio/gpio-pxa.c#L29-L48

```c
/*
 * We handle the GPIOs by banks, each bank covers up to 32 GPIOs with
 * one set of registers. The register offsets are organized below:
 *
< ASCII >
 *           GPLR    GPDR    GPSR    GPCR    GRER    GFER    GEDR
 * BANK 0 - 0x0000  0x000C  0x0018  0x0024  0x0030  0x003C  0x0048
 * BANK 1 - 0x0004  0x0010  0x001C  0x0028  0x0034  0x0040  0x004C
 * BANK 2 - 0x0008  0x0014  0x0020  0x002C  0x0038  0x0044  0x0050
 *
 * BANK 3 - 0x0100  0x010C  0x0118  0x0124  0x0130  0x013C  0x0148
 * BANK 4 - 0x0104  0x0110  0x011C  0x0128  0x0134  0x0140  0x014C
 * BANK 5 - 0x0108  0x0114  0x0120  0x012C  0x0138  0x0144  0x0150
 *
 * BANK 6 - 0x0200  0x020C  0x0218  0x0224  0x0230  0x023C  0x0248
< ASCII >
 *
 * NOTE:
 *   BANK 3 is only available on PXA27x and later processors.
 *   BANK 4 and 5 are only available on PXA935, PXA1928
 *   BANK 6 is only available on PXA1928
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_303.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpio/gpio-ts5500.c#L101-L121

```c
/*
< ASCII >
 * TS-5500 DIO1 block
 *
 *  value    control  dir    hw
 *  addr bit addr bit in out irq name     pin offset
 *
 *  0x7b  0  0x7a  0  x   x      DIO1_0   1   0
 *  0x7b  1  0x7a  0  x   x      DIO1_1   3   1
 *  0x7b  2  0x7a  0  x   x      DIO1_2   5   2
 *  0x7b  3  0x7a  0  x   x      DIO1_3   7   3
 *  0x7b  4  0x7a  1  x   x      DIO1_4   9   4
 *  0x7b  5  0x7a  1  x   x      DIO1_5   11  5
 *  0x7b  6  0x7a  1  x   x      DIO1_6   13  6
 *  0x7b  7  0x7a  1  x   x      DIO1_7   15  7
 *  0x7c  0  0x7a  5  x   x      DIO1_8   4   8
 *  0x7c  1  0x7a  5  x   x      DIO1_9   6   9
 *  0x7c  2  0x7a  5  x   x      DIO1_10  8   10
 *  0x7c  3  0x7a  5  x   x      DIO1_11  10  11
 *  0x7c  4           x          DIO1_12  12  12
 *  0x7c  5           x      7   DIO1_13  14  13
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_304.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpio/gpio-ts5500.c#L130-L149

```c
/*
< ASCII >
 * TS-5500 DIO2 block
 *
 *  value    control  dir    hw
 *  addr bit addr bit in out irq name     pin offset
 *
 *  0x7e  0  0x7d  0  x   x      DIO2_0   1   0
 *  0x7e  1  0x7d  0  x   x      DIO2_1   3   1
 *  0x7e  2  0x7d  0  x   x      DIO2_2   5   2
 *  0x7e  3  0x7d  0  x   x      DIO2_3   7   3
 *  0x7e  4  0x7d  1  x   x      DIO2_4   9   4
 *  0x7e  5  0x7d  1  x   x      DIO2_5   11  5
 *  0x7e  6  0x7d  1  x   x      DIO2_6   13  6
 *  0x7e  7  0x7d  1  x   x      DIO2_7   15  7
 *  0x7f  0  0x7d  5  x   x      DIO2_8   4   8
 *  0x7f  1  0x7d  5  x   x      DIO2_9   6   9
 *  0x7f  2  0x7d  5  x   x      DIO2_10  8   10
 *  0x7f  3  0x7d  5  x   x      DIO2_11  10  11
 *  0x7f  4           x      6   DIO2_13  14  12
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_305.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpio/gpio-ts5500.c#L157-L175

```c
/*
 * TS-5500 LCD port used as DIO block
 * TS-5600 LCD port is identical
 *
< ASCII >
 *  value    control  dir    hw
 *  addr bit addr bit in out irq name    pin offset
 *
 *  0x72  0  0x7d  2  x   x      LCD_0   8   0
 *  0x72  1  0x7d  2  x   x      LCD_1   7   1
 *  0x72  2  0x7d  2  x   x      LCD_2   10  2
 *  0x72  3  0x7d  2  x   x      LCD_3   9   3
 *  0x72  4  0x7d  3  x   x      LCD_4   12  4
 *  0x72  5  0x7d  3  x   x      LCD_5   11  5
 *  0x72  6  0x7d  3  x   x      LCD_6   14  6
 *  0x72  7  0x7d  3  x   x      LCD_7   13  7
 *  0x73  0               x      LCD_EN  5   8
 *  0x73  6           x          LCD_WR  6   9
 *  0x73  7           x      1   LCD_RS  3   10
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_306.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/drm_blend.c#L38-L204

```c
/**
 * DOC: overview
 *
 * The basic plane composition model supported by standard plane properties only
 * has a source rectangle (in logical pixels within the &drm_framebuffer), with
 * sub-pixel accuracy, which is scaled up to a pixel-aligned destination
 * rectangle in the visible area of a &drm_crtc. The visible area of a CRTC is
 * defined by the horizontal and vertical visible pixels (stored in @hdisplay
 * and @vdisplay) of the requested mode (stored in &drm_crtc_state.mode). These
 * two rectangles are both stored in the &drm_plane_state.
 *
 * For the atomic ioctl the following standard (atomic) properties on the plane object
 * encode the basic plane composition model:
 *
 * SRC_X:
 * 	X coordinate offset for the source rectangle within the
 * 	&drm_framebuffer, in 16.16 fixed point. Must be positive.
 * SRC_Y:
 * 	Y coordinate offset for the source rectangle within the
 * 	&drm_framebuffer, in 16.16 fixed point. Must be positive.
 * SRC_W:
 * 	Width for the source rectangle within the &drm_framebuffer, in 16.16
 * 	fixed point. SRC_X plus SRC_W must be within the width of the source
 * 	framebuffer. Must be positive.
 * SRC_H:
 * 	Height for the source rectangle within the &drm_framebuffer, in 16.16
 * 	fixed point. SRC_Y plus SRC_H must be within the height of the source
 * 	framebuffer. Must be positive.
 * CRTC_X:
 * 	X coordinate offset for the destination rectangle. Can be negative.
 * CRTC_Y:
 * 	Y coordinate offset for the destination rectangle. Can be negative.
 * CRTC_W:
 * 	Width for the destination rectangle. CRTC_X plus CRTC_W can extend past
 * 	the currently visible horizontal area of the &drm_crtc.
 * CRTC_H:
 * 	Height for the destination rectangle. CRTC_Y plus CRTC_H can extend past
 * 	the currently visible vertical area of the &drm_crtc.
 * FB_ID:
 * 	Mode object ID of the &drm_framebuffer this plane should scan out.
 * CRTC_ID:
 * 	Mode object ID of the &drm_crtc this plane should be connected to.
 *
 * Note that the source rectangle must fully lie within the bounds of the
 * &drm_framebuffer. The destination rectangle can lie outside of the visible
 * area of the current mode of the CRTC. It must be appropriately clipped by the
 * driver, which can be done by calling drm_plane_helper_check_update(). Drivers
 * are also allowed to round the subpixel sampling positions appropriately, but
 * only to the next full pixel. No pixel outside of the source rectangle may
 * ever be sampled, which is important when applying more sophisticated
 * filtering than just a bilinear one when scaling. The filtering mode when
 * scaling is unspecified.
 *
 * On top of this basic transformation additional properties can be exposed by
 * the driver:
 *
 * alpha:
 * 	Alpha is setup with drm_plane_create_alpha_property(). It controls the
 * 	plane-wide opacity, from transparent (0) to opaque (0xffff). It can be
 * 	combined with pixel alpha.
 *	The pixel values in the framebuffers are expected to not be
 *	pre-multiplied by the global alpha associated to the plane.
 *
 * rotation:
 *	Rotation is set up with drm_plane_create_rotation_property(). It adds a
 *	rotation and reflection step between the source and destination rectangles.
 *	Without this property the rectangle is only scaled, but not rotated or
 *	reflected.
 *
 *	Possbile values:
 *
 *	"rotate-<degrees>":
 *		Signals that a drm plane is rotated <degrees> degrees in counter
 *		clockwise direction.
 *
 *	"reflect-<axis>":
 *		Signals that the contents of a drm plane is reflected along the
 *		<axis> axis, in the same way as mirroring.
 *
< ASCII >
 *	reflect-x::
 *
 *			|o |    | o|
 *			|  | -> |  |
 *			| v|    |v |
 *
 *	reflect-y::
 *
 *			|o |    | ^|
 *			|  | -> |  |
 *			| v|    |o |
< ASCII >
 *
 * zpos:
 *	Z position is set up with drm_plane_create_zpos_immutable_property() and
 *	drm_plane_create_zpos_property(). It controls the visibility of overlapping
 *	planes. Without this property the primary plane is always below the cursor
 *	plane, and ordering between all other planes is undefined. The positive
 *	Z axis points towards the user, i.e. planes with lower Z position values
 *	are underneath planes with higher Z position values. Two planes with the
 *	same Z position value have undefined ordering. Note that the Z position
 *	value can also be immutable, to inform userspace about the hard-coded
 *	stacking of planes, see drm_plane_create_zpos_immutable_property(). If
 *	any plane has a zpos property (either mutable or immutable), then all
 *	planes shall have a zpos property.
 *
 * pixel blend mode:
 *	Pixel blend mode is set up with drm_plane_create_blend_mode_property().
 *	It adds a blend mode for alpha blending equation selection, describing
 *	how the pixels from the current plane are composited with the
 *	background.
 *
 *	 Three alpha blending equations are defined:
 *
 *	 "None":
 *		 Blend formula that ignores the pixel alpha::
 *
 *			 out.rgb = plane_alpha * fg.rgb +
 *				 (1 - plane_alpha) * bg.rgb
 *
 *	 "Pre-multiplied":
 *		 Blend formula that assumes the pixel color values
 *		 have been already pre-multiplied with the alpha
 *		 channel values::
 *
 *			 out.rgb = plane_alpha * fg.rgb +
 *				 (1 - (plane_alpha * fg.alpha)) * bg.rgb
 *
 *	 "Coverage":
 *		 Blend formula that assumes the pixel color values have not
 *		 been pre-multiplied and will do so when blending them to the
 *		 background color values::
 *
 *			 out.rgb = plane_alpha * fg.alpha * fg.rgb +
 *				 (1 - (plane_alpha * fg.alpha)) * bg.rgb
 *
 *	 Using the following symbols:
 *
 *	 "fg.rgb":
 *		 Each of the RGB component values from the plane's pixel
 *	 "fg.alpha":
 *		 Alpha component value from the plane's pixel. If the plane's
 *		 pixel format has no alpha component, then this is assumed to be
 *		 1.0. In these cases, this property has no effect, as all three
 *		 equations become equivalent.
 *	 "bg.rgb":
 *		 Each of the RGB component values from the background
 *	 "plane_alpha":
 *		 Plane alpha value set by the plane "alpha" property. If the
 *		 plane does not expose the "alpha" property, then this is
 *		 assumed to be 1.0
 *
 * Note that all the property extensions described here apply either to the
 * plane or the CRTC (e.g. for the background color, which currently is not
 * exposed and assumed to be black).
 *
 * SCALING_FILTER:
 *     Indicates scaling filter to be used for plane scaler
 *
 *     The value of this property can be one of the following:
 *
 *     Default:
 *             Driver's default scaling filter
 *     Nearest Neighbor:
 *             Nearest Neighbor scaling filter
 *
 * Drivers can set up this property for a plane by calling
 * drm_plane_create_scaling_filter_property
 */
```
## Visual type:
- #custom


== ./linux/linux_307.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/drm_vblank.c#L42-L144

```c
/**
 * DOC: vblank handling
 *
 * From the computer's perspective, every time the monitor displays
 * a new frame the scanout engine has "scanned out" the display image
 * from top to bottom, one row of pixels at a time. The current row
 * of pixels is referred to as the current scanline.
 *
 * In addition to the display's visible area, there's usually a couple of
 * extra scanlines which aren't actually displayed on the screen.
 * These extra scanlines don't contain image data and are occasionally used
 * for features like audio and infoframes. The region made up of these
 * scanlines is referred to as the vertical blanking region, or vblank for
 * short.
 *
 * For historical reference, the vertical blanking period was designed to
 * give the electron gun (on CRTs) enough time to move back to the top of
 * the screen to start scanning out the next frame. Similar for horizontal
 * blanking periods. They were designed to give the electron gun enough
 * time to move back to the other side of the screen to start scanning the
 * next scanline.
 *
 * ::
 *
 *
< ASCII >
 *    physical →   ⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽
 *    top of      |                                        |
 *    display     |                                        |
 *                |               New frame                |
 *                |                                        |
 *                |↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓|
 *                |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ← Scanline,
 *                |↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓|   updates the
 *                |                                        |   frame as it
 *                |                                        |   travels down
 *                |                                        |   ("scan out")
 *                |               Old frame                |
 *                |                                        |
 *                |                                        |
 *                |                                        |
 *                |                                        |   physical
 *                |                                        |   bottom of
 *    vertical    |⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽| ← display
 *    blanking    ┆xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┆
 *    region   →  ┆xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┆
 *                ┆xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┆
 *    start of →   ⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽
 *    new frame
< ASCII >
 *
 * "Physical top of display" is the reference point for the high-precision/
 * corrected timestamp.
 *
 * On a lot of display hardware, programming needs to take effect during the
 * vertical blanking period so that settings like gamma, the image buffer
 * buffer to be scanned out, etc. can safely be changed without showing
 * any visual artifacts on the screen. In some unforgiving hardware, some of
 * this programming has to both start and end in the same vblank. To help
 * with the timing of the hardware programming, an interrupt is usually
 * available to notify the driver when it can start the updating of registers.
 * The interrupt is in this context named the vblank interrupt.
 *
 * The vblank interrupt may be fired at different points depending on the
 * hardware. Some hardware implementations will fire the interrupt when the
 * new frame start, other implementations will fire the interrupt at different
 * points in time.
 *
 * Vertical blanking plays a major role in graphics rendering. To achieve
 * tear-free display, users must synchronize page flips and/or rendering to
 * vertical blanking. The DRM API offers ioctls to perform page flips
 * synchronized to vertical blanking and wait for vertical blanking.
 *
 * The DRM core handles most of the vertical blanking management logic, which
 * involves filtering out spurious interrupts, keeping race-free blanking
 * counters, coping with counter wrap-around and resets and keeping use counts.
 * It relies on the driver to generate vertical blanking interrupts and
 * optionally provide a hardware vertical blanking counter.
 *
 * Drivers must initialize the vertical blanking handling core with a call to
 * drm_vblank_init(). Minimally, a driver needs to implement
 * &drm_crtc_funcs.enable_vblank and &drm_crtc_funcs.disable_vblank plus call
 * drm_crtc_handle_vblank() in its vblank interrupt handler for working vblank
 * support.
 *
 * Vertical blanking interrupts can be enabled by the DRM core or by drivers
 * themselves (for instance to handle page flipping operations).  The DRM core
 * maintains a vertical blanking use count to ensure that the interrupts are not
 * disabled while a user still needs them. To increment the use count, drivers
 * call drm_crtc_vblank_get() and release the vblank reference again with
 * drm_crtc_vblank_put(). In between these two calls vblank interrupts are
 * guaranteed to be enabled.
 *
 * On many hardware disabling the vblank interrupt cannot be done in a race-free
 * manner, see &drm_driver.vblank_disable_immediate and
 * &drm_driver.max_vblank_count. In that case the vblank core only disables the
 * vblanks after a timer has expired, which can be configured through the
 * ``vblankoffdelay`` module parameter.
 *
 * Drivers for hardware without support for vertical-blanking interrupts
 * must not call drm_vblank_init(). For such drivers, atomic helpers will
 * automatically generate fake vblank events as part of the display update.
 * This functionality also can be controlled by the driver by enabling and
 * disabling struct drm_crtc_state.no_vblank.
 */
```
## Visual type:
- #custom


== ./linux/linux_308.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/amd/amdgpu/amdgv_sriovmsg.h#L32-L37

```c
/*
< ASCII >
 * layout
 * 0           64KB        65KB        66KB
 * |   VBIOS   |   PF2VF   |   VF2PF   |   Bad Page   | ...
 * |   64KB    |   1KB     |   1KB     |
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_309.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c#L2309-L2327

```c
/*******************************************************************************
 * In order to turn on/off specific surface we will program
 * Blender + CRTC
 *
 * In case that we have two surfaces and they have a different visibility
 * we can't turn off the CRTC since it will turn off the entire display
 *
< ASCII >
 * |----------------------------------------------- |
 * |bottom pipe|curr pipe  |              |         |
 * |Surface    |Surface    | Blender      |  CRCT   |
 * |visibility |visibility | Configuration|         |
 * |------------------------------------------------|
 * |   off     |    off    | CURRENT_PIPE | blank   |
 * |   off     |    on     | CURRENT_PIPE | unblank |
 * |   on      |    off    | OTHER_PIPE   | unblank |
 * |   on      |    on     | BLENDING     | unblank |
 * -------------------------------------------------|
< ASCII >
 *
 ******************************************************************************/
```
## Visual type:
- #table


== ./linux/linux_31.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/include/asm/bitops.h#L125-L148

```c
/*
 *  A note about Endian-ness.
 *  -------------------------
 *
 * When the ARM is put into big endian mode via CR15, the processor
 * merely swaps the order of bytes within words, thus:
 *
< ASCII >
 *          ------------ physical data bus bits -----------
 *          D31 ... D24  D23 ... D16  D15 ... D8  D7 ... D0
 * little     byte 3       byte 2       byte 1      byte 0
 * big        byte 0       byte 1       byte 2      byte 3
< ASCII >
 *
 * This means that reading a 32-bit word at address 0 returns the same
 * value irrespective of the endian mode bit.
 *
 * Peripheral devices should be connected with the data bus reversed in
 * "Big Endian" mode.  ARM Application Note 61 is applicable, and is
 * available from http://www.arm.com/.
 *
 * The following assumes that the data bus connectivity for big endian
 * mode has been followed.
 *
 * Note that bit 0 is defined to be 32-bit word bit 0, not byte 0 bit 0.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_310.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/amd/display/dc/dce60/dce60_hw_sequencer.c#L164-L180

```c
/*******************************************************************************
 * In order to turn on surface we will program
 * CRTC
 *
 * DCE6 has no bottom_pipe and no Blender HW
 * We need to set 'blank_target' to false in order to turn on the display
 *
< ASCII >
 * |-----------|------------|---------|
 * |curr pipe  | set_blank  |         |
 * |Surface    |blank_target|  CRCT   |
 * |visibility |  argument  |         |
 * |-----------|------------|---------|
 * |    off    |   true     | blank   |
 * |    on     |   false    | unblank |
 * |-----------|------------|---------|
< ASCII >
 *
 ******************************************************************************/
```
## Visual type:
- #table


== ./linux/linux_311.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/amd/display/dc/inc/hw/hw_shared.h#L292-L358

```c
/**
 * speakersToChannels
 *
 * @brief
 *  translate speakers to channels
 *
 *  FL  - Front Left
 *  FR  - Front Right
 *  RL  - Rear Left
 *  RR  - Rear Right
 *  RC  - Rear Center
 *  FC  - Front Center
 *  FLC - Front Left Center
 *  FRC - Front Right Center
 *  RLC - Rear Left Center
 *  RRC - Rear Right Center
 *  LFE - Low Freq Effect
 *
< ASCII >
 *               FC
 *          FLC      FRC
 *    FL                    FR
 *
 *                    LFE
 *              ()
 *
 *
 *    RL                    RR
 *          RLC      RRC
 *               RC
 *
 *             ch  8   7   6   5   4   3   2   1
 * 0b00000011      -   -   -   -   -   -   FR  FL
 * 0b00000111      -   -   -   -   -   LFE FR  FL
 * 0b00001011      -   -   -   -   FC  -   FR  FL
 * 0b00001111      -   -   -   -   FC  LFE FR  FL
 * 0b00010011      -   -   -   RC  -   -   FR  FL
 * 0b00010111      -   -   -   RC  -   LFE FR  FL
 * 0b00011011      -   -   -   RC  FC  -   FR  FL
 * 0b00011111      -   -   -   RC  FC  LFE FR  FL
 * 0b00110011      -   -   RR  RL  -   -   FR  FL
 * 0b00110111      -   -   RR  RL  -   LFE FR  FL
 * 0b00111011      -   -   RR  RL  FC  -   FR  FL
 * 0b00111111      -   -   RR  RL  FC  LFE FR  FL
 * 0b01110011      -   RC  RR  RL  -   -   FR  FL
 * 0b01110111      -   RC  RR  RL  -   LFE FR  FL
 * 0b01111011      -   RC  RR  RL  FC  -   FR  FL
 * 0b01111111      -   RC  RR  RL  FC  LFE FR  FL
 * 0b11110011      RRC RLC RR  RL  -   -   FR  FL
 * 0b11110111      RRC RLC RR  RL  -   LFE FR  FL
 * 0b11111011      RRC RLC RR  RL  FC  -   FR  FL
 * 0b11111111      RRC RLC RR  RL  FC  LFE FR  FL
 * 0b11000011      FRC FLC -   -   -   -   FR  FL
 * 0b11000111      FRC FLC -   -   -   LFE FR  FL
 * 0b11001011      FRC FLC -   -   FC  -   FR  FL
 * 0b11001111      FRC FLC -   -   FC  LFE FR  FL
 * 0b11010011      FRC FLC -   RC  -   -   FR  FL
 * 0b11010111      FRC FLC -   RC  -   LFE FR  FL
 * 0b11011011      FRC FLC -   RC  FC  -   FR  FL
 * 0b11011111      FRC FLC -   RC  FC  LFE FR  FL
 * 0b11110011      FRC FLC RR  RL  -   -   FR  FL
 * 0b11110111      FRC FLC RR  RL  -   LFE FR  FL
 * 0b11111011      FRC FLC RR  RL  FC  -   FR  FL
 * 0b11111111      FRC FLC RR  RL  FC  LFE FR  FL
< ASCII >
 *
 * @param
 *  speakers - speaker information as it comes from CEA audio block
 */
```
## Visual type:
- #custom


== ./linux/linux_312.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/amd/display/modules/power/power_helpers.c#L36-L39

```c
< ASCII >
/* Possible Min Reduction config from least aggressive to most aggressive
 *  0    1     2     3     4     5     6     7     8     9     10    11   12
 * 100  98.0 94.1  94.1  85.1  80.3  75.3  69.4  60.0  57.6  50.2  49.8  40.0 %
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_313.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/amd/display/modules/power/power_helpers.c#L43-L46

```c
< ASCII >
/* Possible Max Reduction configs from least aggressive to most aggressive
 *  0    1     2     3     4     5     6     7     8     9     10    11   12
 * 96.1 89.8 85.1  80.3  69.4  64.7  64.7  50.2  39.6  30.2  30.2  30.2  19.6 %
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_314.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/amd/display/modules/power/power_helpers.c#L50-L53

```c
< ASCII >
/* Possible ABM 2.2 Min Reduction configs from least aggressive to most aggressive
 *  0    1     2     3     4     5     6     7     8     9     10    11   12
 * 100  100   100   100   100   100   100   100  100  92.2  83.1  75.3  75.3 %
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_315.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/amd/display/modules/power/power_helpers.c#L57-L60

```c
< ASCII >
/* Possible ABM 2.2 Max Reduction configs from least aggressive to most aggressive
 *  0    1     2     3     4     5     6     7     8     9     10    11   12
 * 96.1 89.8 74.9  69.4  64.7  52.2  48.6  39.6  30.2  25.1  19.6  12.5  12.5 %
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_316.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/arm/display/komeda/komeda_pipeline_state.c#L913-L943

```c
/*
 * Split is introduced for workaround scaler's input/output size limitation.
 * The idea is simple, if one scaler can not fit the requirement, use two.
 * So split splits the big source image to two half parts (left/right) and do
 * the scaling by two scaler separately and independently.
 * But split also imports an edge problem in the middle of the image when
 * scaling, to avoid it, split isn't a simple half-and-half, but add an extra
 * pixels (overlap) to both side, after split the left/right will be:
 * - left: [0, src_length/2 + overlap]
 * - right: [src_length/2 - overlap, src_length]
 * The extra overlap do eliminate the edge problem, but which may also generates
 * unnecessary pixels when scaling, we need to crop them before scaler output
 * the result to the next stage. and for the how to crop, it depends on the
 * unneeded pixels, another words the position where overlay has been added.
 * - left: crop the right
 * - right: crop the left
 *
< ASCII >
 * The diagram for how to do the split
 *
 *  <---------------------left->out_w ---------------->
 * |--------------------------------|---right_crop-----| <- left after split
 *  \                                \                /
 *   \                                \<--overlap--->/
 *   |-----------------|-------------|(Middle)------|-----------------| <- src
 *                     /<---overlap--->\                               \
 *                    /                 \                               \
 * right after split->|-----left_crop---|--------------------------------|
 *                    ^<------------------- right->out_w --------------->^
 *
< ASCII >
 * NOTE: To consistent with HW the output_w always contains the crop size.
 */
```
## Visual type:
- #custom


== ./linux/linux_317.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/armada/armada_crtc.c#L26-L78

```c
/*
 * A note about interlacing.  Let's consider HDMI 1920x1080i.
 * The timing parameters we have from X are:
 *  Hact HsyA HsyI Htot  Vact VsyA VsyI Vtot
 *  1920 2448 2492 2640  1080 1084 1094 1125
 * Which get translated to:
 *  Hact HsyA HsyI Htot  Vact VsyA VsyI Vtot
 *  1920 2448 2492 2640   540  542  547  562
 *
 * This is how it is defined by CEA-861-D - line and pixel numbers are
 * referenced to the rising edge of VSYNC and HSYNC.  Total clocks per
 * line: 2640.  The odd frame, the first active line is at line 21, and
 * the even frame, the first active line is 584.
 *
< ASCII >
 * LN:    560     561     562     563             567     568    569
 * DE:    ~~~|____________________________//__________________________
 * HSYNC: ____|~|_____|~|_____|~|_____|~|_//__|~|_____|~|_____|~|_____
 * VSYNC: _________________________|~~~~~~//~~~~~~~~~~~~~~~|__________
 *  22 blanking lines.  VSYNC at 1320 (referenced to the HSYNC rising edge).
< ASCII >
< ASCII >
 *
 * LN:    1123   1124    1125      1               5       6      7
 * DE:    ~~~|____________________________//__________________________
 * HSYNC: ____|~|_____|~|_____|~|_____|~|_//__|~|_____|~|_____|~|_____
 * VSYNC: ____________________|~~~~~~~~~~~//~~~~~~~~~~|_______________
 *  23 blanking lines
< ASCII >
 *
 * The Armada LCD Controller line and pixel numbers are, like X timings,
 * referenced to the top left of the active frame.
 *
 * So, translating these to our LCD controller:
 *  Odd frame, 563 total lines, VSYNC at line 543-548, pixel 1128.
 *  Even frame, 562 total lines, VSYNC at line 542-547, pixel 2448.
 * Note: Vsync front porch remains constant!
 *
 * if (odd_frame) {
 *   vtotal = mode->crtc_vtotal + 1;
 *   vbackporch = mode->crtc_vsync_start - mode->crtc_vdisplay + 1;
 *   vhorizpos = mode->crtc_hsync_start - mode->crtc_htotal / 2
 * } else {
 *   vtotal = mode->crtc_vtotal;
 *   vbackporch = mode->crtc_vsync_start - mode->crtc_vdisplay;
 *   vhorizpos = mode->crtc_hsync_start;
 * }
 * vfrontporch = mode->crtc_vtotal - mode->crtc_vsync_end;
 *
 * So, we need to reprogram these registers on each vsync event:
 *  LCD_SPU_V_PORCH, LCD_SPU_ADV_REG, LCD_SPUT_V_H_TOTAL
 *
 * Note: we do not use the frame done interrupts because these appear
 * to happen too early, and lead to jitter on the display (presumably
 * they occur at the end of the last active line, before the vsync back
 * porch, which we're reprogramming.)
 */
```
## Visual type:
- #plot


== ./linux/linux_318.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i2c/tda998x_drv.c#L941-L964

```c
/*
 * In auto-CTS mode, the TDA998x uses a "measured time stamp" counter to
 * generate the CTS value.  It appears that the "measured time stamp" is
 * the number of TDMS clock cycles within a number of audio input clock
 * cycles defined by the k and N parameters defined below, in a similar
 * way to that which is set out in the CTS generation in the HDMI spec.
 *
< ASCII >
 *  tmdsclk ----> mts -> /m ---> CTS
 *                 ^
 *  sclk -> /k -> /N
< ASCII >
 *
 * CTS = mts / m, where m is 2^M.
 * /k is a divider based on the K value below, K+1 for K < 4, or 8 for K >= 4
 * /N is a divider based on the HDMI specified N value.
 *
 * This produces the following equation:
 *  CTS = tmds_clock * k * N / (sclk * m)
 *
 * When combined with the sink-side equation, and realising that sclk is
 * bclk_ratio * fs, we end up with:
 *  k = m * bclk_ratio / 128.
 *
 * Note: S/PDIF always uses a bclk_ratio of 64.
 */
```
## Visual type:



== ./linux/linux_319.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/i915_irq.c#L617-L665

```c
/*
 * This timing diagram depicts the video signal in and
 * around the vertical blanking period.
 *
 * Assumptions about the fictitious mode used in this example:
 *  vblank_start >= 3
 *  vsync_start = vblank_start + 1
 *  vsync_end = vblank_start + 2
 *  vtotal = vblank_start + 3
 *
< ASCII >
 *           start of vblank:
 *           latch double buffered registers
 *           increment frame counter (ctg+)
 *           generate start of vblank interrupt (gen4+)
 *           |
 *           |          frame start:
 *           |          generate frame start interrupt (aka. vblank interrupt) (gmch)
 *           |          may be shifted forward 1-3 extra lines via PIPECONF
 *           |          |
 *           |          |  start of vsync:
 *           |          |  generate vsync interrupt
 *           |          |  |
 * ___xxxx___    ___xxxx___    ___xxxx___    ___xxxx___    ___xxxx___    ___xxxx
 *       .   \hs/   .      \hs/          \hs/          \hs/   .      \hs/
 * ----va---> <-----------------vb--------------------> <--------va-------------
 *       |          |       <----vs----->                     |
 * -vbs-----> <---vbs+1---> <---vbs+2---> <-----0-----> <-----1-----> <-----2--- (scanline counter gen2)
 * -vbs-2---> <---vbs-1---> <---vbs-----> <---vbs+1---> <---vbs+2---> <-----0--- (scanline counter gen3+)
 * -vbs-2---> <---vbs-2---> <---vbs-1---> <---vbs-----> <---vbs+1---> <---vbs+2- (scanline counter hsw+ hdmi)
 *       |          |                                         |
 *       last visible pixel                                   first visible pixel
 *                  |                                         increment frame counter (gen3/4)
 *                  pixel counter = vblank_start * htotal     pixel counter = 0 (gen3/4)
< ASCII >
 *
 * x  = horizontal active
 * _  = horizontal blanking
 * hs = horizontal sync
 * va = vertical active
 * vb = vertical blanking
 * vs = vertical sync
 * vbs = vblank_start (number)
 *
 * Summary:
 * - most events happen at the start of horizontal sync
 * - frame start happens at the start of horizontal blank, 1-4 lines
 *   (depending on PIPECONF settings) after the start of vblank
 * - gen3/4 pixel and frame counter are synchronized with the start
 *   of horizontal active on the first line of vertical active
 */
```
## Visual type:
- #custom


== ./linux/linux_32.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/include/asm/kasan_def.h#L15-L72

```c
/*
 * Define KASAN_SHADOW_OFFSET,KASAN_SHADOW_START and KASAN_SHADOW_END for
 * the Arm kernel address sanitizer. We are "stealing" lowmem (the 4GB
 * addressable by a 32bit architecture) out of the virtual address
 * space to use as shadow memory for KASan as follows:
 *
< ASCII >
 * +----+ 0xffffffff
 * |    |							\
 * |    | |-> Static kernel image (vmlinux) BSS and page table
 * |    |/
 * +----+ PAGE_OFFSET
 * |    |							\
 * |    | |->  Loadable kernel modules virtual address space area
 * |    |/
 * +----+ MODULES_VADDR = KASAN_SHADOW_END
 * |    |						\
 * |    | |-> The shadow area of kernel virtual address.
 * |    |/
 * +----+->  TASK_SIZE (start of kernel space) = KASAN_SHADOW_START the
 * |    |\   shadow address of MODULES_VADDR
 * |    | |
 * |    | |
 * |    | |-> The user space area in lowmem. The kernel address
 * |    | |   sanitizer do not use this space, nor does it map it.
 * |    | |
 * |    | |
 * |    | |
 * |    | |
 * |    |/
 * ------ 0
< ASCII >
 *
 * 1) KASAN_SHADOW_START
 *   This value begins with the MODULE_VADDR's shadow address. It is the
 *   start of kernel virtual space. Since we have modules to load, we need
 *   to cover also that area with shadow memory so we can find memory
 *   bugs in modules.
 *
 * 2) KASAN_SHADOW_END
 *   This value is the 0x100000000's shadow address: the mapping that would
 *   be after the end of the kernel memory at 0xffffffff. It is the end of
 *   kernel address sanitizer shadow area. It is also the start of the
 *   module area.
 *
 * 3) KASAN_SHADOW_OFFSET:
 *   This value is used to map an address to the corresponding shadow
 *   address by the following formula:
 *
 *	shadow_addr = (address >> 3) + KASAN_SHADOW_OFFSET;
 *
 *  As you would expect, >> 3 is equal to dividing by 8, meaning each
 *  byte in the shadow memory covers 8 bytes of kernel memory, so one
 *  bit shadow memory per byte of kernel memory is used.
 *
 *  The KASAN_SHADOW_OFFSET is provided in a Kconfig option depending
 *  on the VMSPLIT layout of the system: the kernel and userspace can
 *  split up lowmem in different ways according to needs, so we calculate
 *  the shadow offset depending on this.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_320.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/i915_vgpu.c#L209-L252

```c
/**
 * intel_vgt_balloon - balloon out reserved graphics address trunks
 * @ggtt: the global GGTT from which to reserve
 *
 * This function is called at the initialization stage, to balloon out the
 * graphic address space allocated to other vGPUs, by marking these spaces as
 * reserved. The ballooning related knowledge(starting address and size of
 * the mappable/unmappable graphic memory) is described in the vgt_if structure
 * in a reserved mmio range.
 *
 * To give an example, the drawing below depicts one typical scenario after
 * ballooning. Here the vGPU1 has 2 pieces of graphic address spaces ballooned
 * out each for the mappable and the non-mappable part. From the vGPU1 point of
 * view, the total size is the same as the physical one, with the start address
 * of its graphic space being zero. Yet there are some portions ballooned out(
 * the shadow part, which are marked as reserved by drm allocator). From the
 * host point of view, the graphic address space is partitioned by multiple
 * vGPUs in different VMs. ::
 *
< ASCII >
 *                         vGPU1 view         Host view
 *              0 ------> +-----------+     +-----------+
 *                ^       |###########|     |   vGPU3   |
 *                |       |###########|     +-----------+
 *                |       |###########|     |   vGPU2   |
 *                |       +-----------+     +-----------+
 *         mappable GM    | available | ==> |   vGPU1   |
 *                |       +-----------+     +-----------+
 *                |       |###########|     |           |
 *                v       |###########|     |   Host    |
 *                +=======+===========+     +===========+
 *                ^       |###########|     |   vGPU3   |
 *                |       |###########|     +-----------+
 *                |       |###########|     |   vGPU2   |
 *                |       +-----------+     +-----------+
 *       unmappable GM    | available | ==> |   vGPU1   |
 *                |       +-----------+     +-----------+
 *                |       |###########|     |           |
 *                |       |###########|     |   Host    |
 *                v       |###########|     |           |
 *  total GM size ------> +-----------+     +-----------+
< ASCII >
 *
 * Returns:
 * zero on success, non-zero if configuration invalid or ballooning failed
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_321.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/display/intel_display_power_map.c#L1203-L1219

```c
/*
 * XE_LPD Power Domains
 *
 * Previous platforms required that PG(n-1) be enabled before PG(n).  That
 * dependency chain turns into a dependency tree on XE_LPD:
 *
< ASCII >
 *       PG0
 *        |
 *     --PG1--
 *    /       \
 *  PGA     --PG2--
 *         /   |   \
 *       PGB  PGC  PGD
< ASCII >
 *
 * Power wells must be enabled from top to bottom and disabled from bottom
 * to top.  This allows pipes to be power gated independently.
 */
```
## Visual type:
- #tree


== ./linux/linux_322.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/display/intel_dpio_phy.c#L34-L123

```c
/**
 * DOC: DPIO
 *
 * VLV, CHV and BXT have slightly peculiar display PHYs for driving DP/HDMI
 * ports. DPIO is the name given to such a display PHY. These PHYs
 * don't follow the standard programming model using direct MMIO
 * registers, and instead their registers must be accessed trough IOSF
 * sideband. VLV has one such PHY for driving ports B and C, and CHV
 * adds another PHY for driving port D. Each PHY responds to specific
 * IOSF-SB port.
 *
 * Each display PHY is made up of one or two channels. Each channel
 * houses a common lane part which contains the PLL and other common
 * logic. CH0 common lane also contains the IOSF-SB logic for the
 * Common Register Interface (CRI) ie. the DPIO registers. CRI clock
 * must be running when any DPIO registers are accessed.
 *
 * In addition to having their own registers, the PHYs are also
 * controlled through some dedicated signals from the display
 * controller. These include PLL reference clock enable, PLL enable,
 * and CRI clock selection, for example.
 *
 * Eeach channel also has two splines (also called data lanes), and
 * each spline is made up of one Physical Access Coding Sub-Layer
 * (PCS) block and two TX lanes. So each channel has two PCS blocks
 * and four TX lanes. The TX lanes are used as DP lanes or TMDS
 * data/clock pairs depending on the output type.
 *
 * Additionally the PHY also contains an AUX lane with AUX blocks
 * for each channel. This is used for DP AUX communication, but
 * this fact isn't really relevant for the driver since AUX is
 * controlled from the display controller side. No DPIO registers
 * need to be accessed during AUX communication,
 *
 * Generally on VLV/CHV the common lane corresponds to the pipe and
 * the spline (PCS/TX) corresponds to the port.
 *
 * For dual channel PHY (VLV/CHV):
 *
 *  pipe A == CMN/PLL/REF CH0
 *
 *  pipe B == CMN/PLL/REF CH1
 *
 *  port B == PCS/TX CH0
 *
 *  port C == PCS/TX CH1
 *
 * This is especially important when we cross the streams
 * ie. drive port B with pipe B, or port C with pipe A.
 *
 * For single channel PHY (CHV):
 *
 *  pipe C == CMN/PLL/REF CH0
 *
 *  port D == PCS/TX CH0
 *
 * On BXT the entire PHY channel corresponds to the port. That means
 * the PLL is also now associated with the port rather than the pipe,
 * and so the clock needs to be routed to the appropriate transcoder.
 * Port A PLL is directly connected to transcoder EDP and port B/C
 * PLLs can be routed to any transcoder A/B/C.
 *
 * Note: DDI0 is digital port B, DD1 is digital port C, and DDI2 is
 * digital port D (CHV) or port A (BXT). ::
 *
 *
< ASCII >
 *     Dual channel PHY (VLV/CHV/BXT)
 *     ---------------------------------
 *     |      CH0      |      CH1      |
 *     |  CMN/PLL/REF  |  CMN/PLL/REF  |
 *     |---------------|---------------| Display PHY
 *     | PCS01 | PCS23 | PCS01 | PCS23 |
 *     |-------|-------|-------|-------|
 *     |TX0|TX1|TX2|TX3|TX0|TX1|TX2|TX3|
 *     ---------------------------------
 *     |     DDI0      |     DDI1      | DP/HDMI ports
 *     ---------------------------------
 *
 *     Single channel PHY (CHV/BXT)
 *     -----------------
 *     |      CH0      |
 *     |  CMN/PLL/REF  |
 *     |---------------| Display PHY
 *     | PCS01 | PCS23 |
 *     |-------|-------|
 *     |TX0|TX1|TX2|TX3|
 *     -----------------
 *     |     DDI2      | DP/HDMI port
 *     -----------------
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_323.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/display/intel_hdmi.c#L629-L645

```c
/*
 * The data we write to the DIP data buffer registers is 1 byte bigger than the
 * HDMI infoframe size because of an ECC/reserved byte at position 3 (starting
 * at 0). It's also a byte used by DisplayPort so the same DIP registers can be
 * used for both technologies.
 *
< ASCII >
 * DW0: Reserved/ECC/DP | HB2 | HB1 | HB0
 * DW1:       DB3       | DB2 | DB1 | DB0
 * DW2:       DB7       | DB6 | DB5 | DB4
 * DW3: ...
< ASCII >
 *
 * (HB is Header Byte, DB is Data Byte)
 *
 * The hdmi pack() functions don't know about that hardware specific hole so we
 * trick them by giving an offset into the buffer and moving back the header
 * bytes by one.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_324.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/display/skl_scaler.c#L13-L52

```c
/*
 * The hardware phase 0.0 refers to the center of the pixel.
 * We want to start from the top/left edge which is phase
 * -0.5. That matches how the hardware calculates the scaling
 * factors (from top-left of the first pixel to bottom-right
 * of the last pixel, as opposed to the pixel centers).
 *
 * For 4:2:0 subsampled chroma planes we obviously have to
 * adjust that so that the chroma sample position lands in
 * the right spot.
 *
 * Note that for packed YCbCr 4:2:2 formats there is no way to
 * control chroma siting. The hardware simply replicates the
 * chroma samples for both of the luma samples, and thus we don't
 * actually get the expected MPEG2 chroma siting convention :(
 * The same behaviour is observed on pre-SKL platforms as well.
 *
 * Theory behind the formula (note that we ignore sub-pixel
 * source coordinates):
 * s = source sample position
 * d = destination sample position
 *
< ASCII >
 * Downscaling 4:1:
 * -0.5
 * | 0.0
 * | |     1.5 (initial phase)
 * | |     |
 * v v     v
 * | s | s | s | s |
 * |       d       |
 *
 * Upscaling 1:4:
 * -0.5
 * | -0.375 (initial phase)
 * | |     0.0
 * | |     |
 * v v     v
 * |       s       |
 * | d | d | d | d |
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_325.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/display/skl_scaler.c#L311-L346

```c
/*
 *  Theory behind setting nearest-neighbor integer scaling:
 *
 *  17 phase of 7 taps requires 119 coefficients in 60 dwords per set.
 *  The letter represents the filter tap (D is the center tap) and the number
 *  represents the coefficient set for a phase (0-16).
 *
< ASCII >
 *         +------------+------------------------+------------------------+
 *         |Index value | Data value coeffient 1 | Data value coeffient 2 |
 *         +------------+------------------------+------------------------+
 *         |   00h      |          B0            |          A0            |
 *         +------------+------------------------+------------------------+
 *         |   01h      |          D0            |          C0            |
 *         +------------+------------------------+------------------------+
 *         |   02h      |          F0            |          E0            |
 *         +------------+------------------------+------------------------+
 *         |   03h      |          A1            |          G0            |
 *         +------------+------------------------+------------------------+
 *         |   04h      |          C1            |          B1            |
 *         +------------+------------------------+------------------------+
 *         |   ...      |          ...           |          ...           |
 *         +------------+------------------------+------------------------+
 *         |   38h      |          B16           |          A16           |
 *         +------------+------------------------+------------------------+
 *         |   39h      |          D16           |          C16           |
 *         +------------+------------------------+------------------------+
 *         |   3Ah      |          F16           |          C16           |
 *         +------------+------------------------+------------------------+
 *         |   3Bh      |        Reserved        |          G16           |
 *         +------------+------------------------+------------------------+
< ASCII >
 *
 *  To enable nearest-neighbor scaling:  program scaler coefficents with
 *  the center tap (Dxx) values set to 1 and all other values set to 0 as per
 *  SCALER_COEFFICIENT_FORMAT
 *
 */
```
## Visual type:
- #table


== ./linux/linux_326.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gem/i915_gem_context.c#L7-L65

```c
/*
 * This file implements HW context support. On gen5+ a HW context consists of an
 * opaque GPU object which is referenced at times of context saves and restores.
 * With RC6 enabled, the context is also referenced as the GPU enters and exists
 * from RC6 (GPU has it's own internal power context, except on gen5). Though
 * something like a context does exist for the media ring, the code only
 * supports contexts for the render ring.
 *
 * In software, there is a distinction between contexts created by the user,
 * and the default HW context. The default HW context is used by GPU clients
 * that do not request setup of their own hardware context. The default
 * context's state is never restored to help prevent programming errors. This
 * would happen if a client ran and piggy-backed off another clients GPU state.
 * The default context only exists to give the GPU some offset to load as the
 * current to invoke a save of the context we actually care about. In fact, the
 * code could likely be constructed, albeit in a more complicated fashion, to
 * never use the default context, though that limits the driver's ability to
 * swap out, and/or destroy other contexts.
 *
 * All other contexts are created as a request by the GPU client. These contexts
 * store GPU state, and thus allow GPU clients to not re-emit state (and
 * potentially query certain state) at any time. The kernel driver makes
 * certain that the appropriate commands are inserted.
 *
 * The context life cycle is semi-complicated in that context BOs may live
 * longer than the context itself because of the way the hardware, and object
 * tracking works. Below is a very crude representation of the state machine
 * describing the context life.
< ASCII >
 *                                         refcount     pincount     active
 * S0: initial state                          0            0           0
 * S1: context created                        1            0           0
 * S2: context is currently running           2            1           X
 * S3: GPU referenced, but not current        2            0           1
 * S4: context is current, but destroyed      1            1           0
 * S5: like S3, but destroyed                 1            0           1
< ASCII >
 *
 * The most common (but not all) transitions:
 * S0->S1: client creates a context
 * S1->S2: client submits execbuf with context
 * S2->S3: other clients submits execbuf with context
 * S3->S1: context object was retired
 * S3->S2: clients submits another execbuf
 * S2->S4: context destroy called with current context
 * S3->S5->S0: destroy path
 * S4->S5->S0: destroy path on current context
 *
 * There are two confusing terms used above:
 *  The "current context" means the context which is currently running on the
 *  GPU. The GPU has loaded its state already and has stored away the gtt
 *  offset of the BO. The GPU is not actively referencing the data at this
 *  offset, but it will on the next context switch. The only way to avoid this
 *  is to do a GPU reset.
 *
 *  An "active context' is one which was previously the "current context" and is
 *  on the active list waiting for the next context switch to occur. Until this
 *  happens, the object must remain at the same gtt offset. It is therefore
 *  possible to destroy a context, but it is still active.
 *
 */
```
## Visual type:
- #table


== ./linux/linux_327.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/intel_wopcm.c#L9-L41

```c
/**
 * DOC: WOPCM Layout
 *
 * The layout of the WOPCM will be fixed after writing to GuC WOPCM size and
 * offset registers whose values are calculated and determined by HuC/GuC
 * firmware size and set of hardware requirements/restrictions as shown below:
 *
 * ::
 *
< ASCII >
 *    +=========> +====================+ <== WOPCM Top
 *    ^           |  HW contexts RSVD  |
 *    |     +===> +====================+ <== GuC WOPCM Top
 *    |     ^     |                    |
 *    |     |     |                    |
 *    |     |     |                    |
 *    |    GuC    |                    |
 *    |   WOPCM   |                    |
 *    |    Size   +--------------------+
 *  WOPCM   |     |    GuC FW RSVD     |
 *    |     |     +--------------------+
 *    |     |     |   GuC Stack RSVD   |
 *    |     |     +------------------- +
 *    |     v     |   GuC WOPCM RSVD   |
 *    |     +===> +====================+ <== GuC WOPCM base
 *    |           |     WOPCM RSVD     |
 *    |           +------------------- + <== HuC Firmware Top
 *    v           |      HuC FW        |
 *    +=========> +====================+ <== WOPCM Base
< ASCII >
 *
 * GuC accessible WOPCM starts at GuC WOPCM base and ends at GuC WOPCM top.
 * The top part of the WOPCM is reserved for hardware contexts (e.g. RC6
 * context).
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_328.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/intel_guc.c#L684-L716

```c
/**
 * DOC: GuC Memory Management
 *
 * GuC can't allocate any memory for its own usage, so all the allocations must
 * be handled by the host driver. GuC accesses the memory via the GGTT, with the
 * exception of the top and bottom parts of the 4GB address space, which are
 * instead re-mapped by the GuC HW to memory location of the FW itself (WOPCM)
 * or other parts of the HW. The driver must take care not to place objects that
 * the GuC is going to access in these reserved ranges. The layout of the GuC
 * address space is shown below:
 *
 * ::
 *
< ASCII >
 *     +===========> +====================+ <== FFFF_FFFF
 *     ^             |      Reserved      |
 *     |             +====================+ <== GUC_GGTT_TOP
 *     |             |                    |
 *     |             |        DRAM        |
 *    GuC            |                    |
 *  Address    +===> +====================+ <== GuC ggtt_pin_bias
 *   Space     ^     |                    |
 *     |       |     |                    |
 *     |      GuC    |        GuC         |
 *     |     WOPCM   |       WOPCM        |
 *     |      Size   |                    |
 *     |       |     |                    |
 *     v       v     |                    |
 *     +=======+===> +====================+ <== 0000_0000
< ASCII >
 *
 * The lower part of GuC Address Space [0, ggtt_pin_bias) is mapped to GuC WOPCM
 * while upper part of GuC Address Space [ggtt_pin_bias, GUC_GGTT_TOP) is mapped
 * to DRAM. The value of the GuC ggtt_pin_bias is the GuC WOPCM size.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_329.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/intel_guc_ads.c#L21-L56

```c
/*
 * The Additional Data Struct (ADS) has pointers for different buffers used by
 * the GuC. One single gem object contains the ADS struct itself (guc_ads) and
 * all the extra buffers indirectly linked via the ADS struct's entries.
 *
< ASCII >
 * Layout of the ADS blob allocated for the GuC:
 *
 *      +---------------------------------------+ <== base
 *      | guc_ads                               |
 *      +---------------------------------------+
 *      | guc_policies                          |
 *      +---------------------------------------+
 *      | guc_gt_system_info                    |
 *      +---------------------------------------+
 *      | guc_engine_usage                      |
 *      +---------------------------------------+ <== static
 *      | guc_mmio_reg[countA] (engine 0.0)     |
 *      | guc_mmio_reg[countB] (engine 0.1)     |
 *      | guc_mmio_reg[countC] (engine 1.0)     |
 *      |   ...                                 |
 *      +---------------------------------------+ <== dynamic
 *      | padding                               |
 *      +---------------------------------------+ <== 4K aligned
 *      | golden contexts                       |
 *      +---------------------------------------+
 *      | padding                               |
 *      +---------------------------------------+ <== 4K aligned
 *      | capture lists                         |
 *      +---------------------------------------+
 *      | padding                               |
 *      +---------------------------------------+ <== 4K aligned
 *      | private data                          |
 *      +---------------------------------------+
 *      | padding                               |
 *      +---------------------------------------+ <== 4K aligned
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_33.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/include/asm/pgalloc.h#L55-L70

```c
/*
 * Allocate one PTE table.
 *
 * This actually allocates two hardware PTE tables, but we wrap this up
 * into one table thus:
 *
< ASCII >
 *  +------------+
 *  | Linux pt 0 |
 *  +------------+
 *  | Linux pt 1 |
 *  +------------+
 *  |  h/w pt 0  |
 *  +------------+
 *  |  h/w pt 1  |
 *  +------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_330.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/intel_guc_ct.c#L47-L73

```c
/**
 * DOC: CTB Blob
 *
 * We allocate single blob to hold both CTB descriptors and buffers:
 *
< ASCII >
 *      +--------+-----------------------------------------------+------+
 *      | offset | contents                                      | size |
 *      +========+===============================================+======+
 *      | 0x0000 | H2G `CTB Descriptor`_ (send)                  |      |
 *      +--------+-----------------------------------------------+  4K  |
 *      | 0x0800 | G2H `CTB Descriptor`_ (recv)                  |      |
 *      +--------+-----------------------------------------------+------+
 *      | 0x1000 | H2G `CT Buffer`_ (send)                       | n*4K |
 *      |        |                                               |      |
 *      +--------+-----------------------------------------------+------+
 *      | 0x1000 | G2H `CT Buffer`_ (recv)                       | m*4K |
 *      | + n*4K |                                               |      |
 *      +--------+-----------------------------------------------+------+
< ASCII >
 *
 * Size of each `CT Buffer`_ must be multiple of 4K.
 * We don't expect too many messages in flight at any time, unless we are
 * using the GuC submission. In that case each request requires a minimum
 * 2 dwords which gives us a maximum 256 queue'd requests. Hopefully this
 * enough space to avoid backpressure on the driver. We increase the size
 * of the receive buffer (relative to the send) to ensure a G2H response
 * CTB has a landing spot.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_331.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.h#L23-L45

```c
/*
< ASCII >
 * +------------+---------------------------------------------------+
 * |   PHASE    |           FIRMWARE STATUS TRANSITIONS             |
 * +============+===================================================+
 * |            |               UNINITIALIZED                       |
 * +------------+-               /   |   \                         -+
 * |            |   DISABLED <--/    |    \--> NOT_SUPPORTED        |
 * | init_early |                    V                              |
 * |            |                 SELECTED                          |
 * +------------+-               /   |   \                         -+
 * |            |    MISSING <--/    |    \--> ERROR                |
 * |   fetch    |                    V                              |
 * |            |                 AVAILABLE                         |
 * +------------+-                   |   \                         -+
 * |            |                    |    \--> INIT FAIL            |
 * |   init     |                    V                              |
 * |            |        /------> LOADABLE <----<-----------\       |
 * +------------+-       \         /    \        \           \     -+
 * |            |    LOAD FAIL <--<      \--> TRANSFERRED     \     |
 * |   upload   |                  \           /   \          /     |
 * |            |                   \---------/     \--> RUNNING    |
 * +------------+---------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_332.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/intel_uc_fw_abi.h#L12-L47

```c
/**
 * DOC: Firmware Layout
 *
 * The GuC/HuC firmware layout looks like this::
 *
< ASCII >
 *      +======================================================================+
 *      |  Firmware blob                                                       |
 *      +===============+===============+============+============+============+
 *      |  CSS header   |     uCode     |  RSA key   |  modulus   |  exponent  |
 *      +===============+===============+============+============+============+
 *       <-header size->                 <---header size continued ----------->
 *       <--- size ----------------------------------------------------------->
 *                                       <-key size->
 *                                                    <-mod size->
 *                                                                 <-exp size->
< ASCII >
 *
 * The firmware may or may not have modulus key and exponent data. The header,
 * uCode and RSA signature are must-have components that will be used by driver.
 * Length of each components, which is all in dwords, can be found in header.
 * In the case that modulus and exponent are not present in fw, a.k.a truncated
 * image, the length value still appears in header.
 *
 * Driver will do some basic fw size validation based on the following rules:
 *
 * 1. Header, uCode and RSA are must-have components.
 * 2. All firmware components, if they present, are in the sequence illustrated
 *    in the layout table above.
 * 3. Length info of each component can be found in header, in dwords.
 * 4. Modulus and exponent key are not required by driver. They may not appear
 *    in fw. So driver will load a truncated firmware in this case.
 *
 * Starting from DG2, the HuC is loaded by the GSC instead of i915. The GSC
 * firmware performs all the required integrity checks, we just need to check
 * the version. Note that the header for GSC-managed blobs is different from the
 * CSS used for dma-loaded firmwares.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_333.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h#L9-L48

```c
/**
 * DOC: HOST2GUC_SELF_CFG
 *
 * This message is used by Host KMD to setup of the `GuC Self Config KLVs`_.
 *
 * This message must be sent as `MMIO HXG Message`_.
 *
< ASCII >
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 |    31 | ORIGIN = GUC_HXG_ORIGIN_HOST_                                |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 30:28 | TYPE = GUC_HXG_TYPE_REQUEST_                                 |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 27:16 | DATA0 = MBZ                                                  |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  15:0 | ACTION = _`GUC_ACTION_HOST2GUC_SELF_CFG` = 0x0508            |
 *  +---+-------+--------------------------------------------------------------+
 *  | 1 | 31:16 | **KLV_KEY** - KLV key, see `GuC Self Config KLVs`_           |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  15:0 | **KLV_LEN** - KLV length                                     |
 *  |   |       |                                                              |
 *  |   |       |   - 32 bit KLV = 1                                           |
 *  |   |       |   - 64 bit KLV = 2                                           |
 *  +---+-------+--------------------------------------------------------------+
 *  | 2 |  31:0 | **VALUE32** - Bits 31-0 of the KLV value                     |
 *  +---+-------+--------------------------------------------------------------+
 *  | 3 |  31:0 | **VALUE64** - Bits 63-32 of the KLV value (**KLV_LEN** = 2)  |
 *  +---+-------+--------------------------------------------------------------+
 *
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 |    31 | ORIGIN = GUC_HXG_ORIGIN_GUC_                                 |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 30:28 | TYPE = GUC_HXG_TYPE_RESPONSE_SUCCESS_                        |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  27:0 | DATA0 = **NUM** - 1 if KLV was parsed, 0 if not recognized   |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_334.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h#L61-L94

```c
/**
 * DOC: HOST2GUC_CONTROL_CTB
 *
 * This H2G action allows Vf Host to enable or disable H2G and G2H `CT Buffer`_.
 *
 * This message must be sent as `MMIO HXG Message`_.
 *
< ASCII >
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 |    31 | ORIGIN = GUC_HXG_ORIGIN_HOST_                                |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 30:28 | TYPE = GUC_HXG_TYPE_REQUEST_                                 |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 27:16 | DATA0 = MBZ                                                  |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  15:0 | ACTION = _`GUC_ACTION_HOST2GUC_CONTROL_CTB` = 0x4509         |
 *  +---+-------+--------------------------------------------------------------+
 *  | 1 |  31:0 | **CONTROL** - control `CTB based communication`_             |
 *  |   |       |                                                              |
 *  |   |       |   - _`GUC_CTB_CONTROL_DISABLE` = 0                           |
 *  |   |       |   - _`GUC_CTB_CONTROL_ENABLE` = 1                            |
 *  +---+-------+--------------------------------------------------------------+
 *
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 |    31 | ORIGIN = GUC_HXG_ORIGIN_GUC_                                 |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 30:28 | TYPE = GUC_HXG_TYPE_RESPONSE_SUCCESS_                        |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  27:0 | DATA0 = MBZ                                                  |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_335.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_actions_slpc_abi.h#L11-L35

```c
/**
 * DOC: SLPC SHARED DATA STRUCTURE
 *
< ASCII >
 *  +----+------+--------------------------------------------------------------+
 *  | CL | Bytes| Description                                                  |
 *  +====+======+==============================================================+
 *  | 1  | 0-3  | SHARED DATA SIZE                                             |
 *  |    +------+--------------------------------------------------------------+
 *  |    | 4-7  | GLOBAL STATE                                                 |
 *  |    +------+--------------------------------------------------------------+
 *  |    | 8-11 | DISPLAY DATA ADDRESS                                         |
 *  |    +------+--------------------------------------------------------------+
 *  |    | 12:63| PADDING                                                      |
 *  +----+------+--------------------------------------------------------------+
 *  |    | 0:63 | PADDING(PLATFORM INFO)                                       |
 *  +----+------+--------------------------------------------------------------+
 *  | 3  | 0-3  | TASK STATE DATA                                              |
 *  +    +------+--------------------------------------------------------------+
 *  |    | 4:63 | PADDING                                                      |
 *  +----+------+--------------------------------------------------------------+
 *  |4-21|0:1087| OVERRIDE PARAMS AND BIT FIELDS                               |
 *  +----+------+--------------------------------------------------------------+
 *  |    |      | PADDING + EXTRA RESERVED PAGE                                |
 *  +----+------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_336.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_actions_slpc_abi.h#L210-L234

```c
/**
 * DOC: SLPC H2G MESSAGE FORMAT
 *
< ASCII >
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 |    31 | ORIGIN = GUC_HXG_ORIGIN_HOST_                                |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 30:28 | TYPE = GUC_HXG_TYPE_REQUEST_                                 |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 27:16 | DATA0 = MBZ                                                  |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  15:0 | ACTION = _`GUC_ACTION_HOST2GUC_PC_SLPM_REQUEST` = 0x3003     |
 *  +---+-------+--------------------------------------------------------------+
 *  | 1 |  31:8 | **EVENT_ID**                                                 |
 *  +   +-------+--------------------------------------------------------------+
 *  |   |   7:0 | **EVENT_ARGC** - number of data arguments                    |
 *  +---+-------+--------------------------------------------------------------+
 *  | 2 |  31:0 | **EVENT_DATA1**                                              |
 *  +---+-------+--------------------------------------------------------------+
 *  |...|  31:0 | ...                                                          |
 *  +---+-------+--------------------------------------------------------------+
 *  |2+n|  31:0 | **EVENT_DATAn**                                              |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_337.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h#L20-L46

```c
/**
 * DOC: CTB Descriptor
 *
< ASCII >
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 |  31:0 | **HEAD** - offset (in dwords) to the last dword that was     |
 *  |   |       | read from the `CT Buffer`_.                                  |
 *  |   |       | It can only be updated by the receiver.                      |
 *  +---+-------+--------------------------------------------------------------+
 *  | 1 |  31:0 | **TAIL** - offset (in dwords) to the last dword that was     |
 *  |   |       | written to the `CT Buffer`_.                                 |
 *  |   |       | It can only be updated by the sender.                        |
 *  +---+-------+--------------------------------------------------------------+
 *  | 2 |  31:0 | **STATUS** - status of the CTB                               |
 *  |   |       |                                                              |
 *  |   |       |   - _`GUC_CTB_STATUS_NO_ERROR` = 0 (normal operation)        |
 *  |   |       |   - _`GUC_CTB_STATUS_OVERFLOW` = 1 (head/tail too large)     |
 *  |   |       |   - _`GUC_CTB_STATUS_UNDERFLOW` = 2 (truncated message)      |
 *  |   |       |   - _`GUC_CTB_STATUS_MISMATCH` = 4 (head/tail modified)      |
 *  |   |       |   - _`GUC_CTB_STATUS_UNUSED` = 8 (CTB is not in use)         |
 *  +---+-------+--------------------------------------------------------------+
 *  |...|       | RESERVED = MBZ                                               |
 *  +---+-------+--------------------------------------------------------------+
 *  | 15|  31:0 | RESERVED = MBZ                                               |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_338.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h#L61-L82

```c
/**
 * DOC: CTB Message
 *
< ASCII >
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 | 31:16 | **FENCE** - message identifier                               |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 15:12 | **FORMAT** - format of the CTB message                       |
 *  |   |       |  - _`GUC_CTB_FORMAT_HXG` = 0 - see `CTB HXG Message`_        |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  11:8 | **RESERVED**                                                 |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |   7:0 | **NUM_DWORDS** - length of the CTB message (w/o header)      |
 *  +---+-------+--------------------------------------------------------------+
 *  | 1 |  31:0 | optional (depends on FORMAT)                                 |
 *  +---+-------+                                                              |
 *  |...|       |                                                              |
 *  +---+-------+                                                              |
 *  | n |  31:0 |                                                              |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_339.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h#L93-L113

```c
/**
 * DOC: CTB HXG Message
 *
< ASCII >
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 | 31:16 | FENCE                                                        |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 15:12 | FORMAT = GUC_CTB_FORMAT_HXG_                                 |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  11:8 | RESERVED = MBZ                                               |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |   7:0 | NUM_DWORDS = length (in dwords) of the embedded HXG message  |
 *  +---+-------+--------------------------------------------------------------+
 *  | 1 |  31:0 |                                                              |
 *  +---+-------+                                                              |
 *  |...|       | [Embedded `HXG Message`_]                                    |
 *  +---+-------+                                                              |
 *  | n |  31:0 |                                                              |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_34.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/include/asm/pgtable-2level.h#L12-L69

```c
/*
 * Hardware-wise, we have a two level page table structure, where the first
 * level has 4096 entries, and the second level has 256 entries.  Each entry
 * is one 32-bit word.  Most of the bits in the second level entry are used
 * by hardware, and there aren't any "accessed" and "dirty" bits.
 *
 * Linux on the other hand has a three level page table structure, which can
 * be wrapped to fit a two level page table structure easily - using the PGD
 * and PTE only.  However, Linux also expects one "PTE" table per page, and
 * at least a "dirty" bit.
 *
 * Therefore, we tweak the implementation slightly - we tell Linux that we
 * have 2048 entries in the first level, each of which is 8 bytes (iow, two
 * hardware pointers to the second level.)  The second level contains two
 * hardware PTE tables arranged contiguously, preceded by Linux versions
 * which contain the state information Linux needs.  We, therefore, end up
 * with 512 entries in the "PTE" level.
 *
 * This leads to the page tables having the following layout:
 *
< ASCII >
 *    pgd             pte
 * |        |
 * +--------+
 * |        |       +------------+ +0
 * +- - - - +       | Linux pt 0 |
 * |        |       +------------+ +1024
 * +--------+ +0    | Linux pt 1 |
 * |        |-----> +------------+ +2048
 * +- - - - + +4    |  h/w pt 0  |
 * |        |-----> +------------+ +3072
 * +--------+ +8    |  h/w pt 1  |
 * |        |       +------------+ +4096
< ASCII >
 *
 * See L_PTE_xxx below for definitions of bits in the "Linux pt", and
 * PTE_xxx for definitions of bits appearing in the "h/w pt".
 *
 * PMD_xxx definitions refer to bits in the first level page table.
 *
 * The "dirty" bit is emulated by only granting hardware write permission
 * iff the page is marked "writable" and "dirty" in the Linux PTE.  This
 * means that a write to a clean page will cause a permission fault, and
 * the Linux MM layer will mark the page dirty via handle_pte_fault().
 * For the hardware to notice the permission change, the TLB entry must
 * be flushed, and ptep_set_access_flags() does that for us.
 *
 * The "accessed" or "young" bit is emulated by a similar method; we only
 * allow accesses to the page if the "young" bit is set.  Accesses to the
 * page will cause a fault, and handle_pte_fault() will set the young bit
 * for us as long as the page is marked present in the corresponding Linux
 * PTE entry.  Again, ptep_set_access_flags() will ensure that the TLB is
 * up to date.
 *
 * However, when the "young" bit is cleared, we deny access to the page
 * by clearing the hardware PTE.  Currently Linux does not flush the TLB
 * for us in this case, which means the TLB will retain the transation
 * until either the TLB entry is evicted under pressure, or a context
 * switch which changes the user space mapping occurs.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_340.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h#L118-L168

```c
/**
 * DOC: CTB based communication
 *
 * The CTB (command transport buffer) communication between Host and GuC
 * is based on u32 data stream written to the shared buffer. One buffer can
 * be used to transmit data only in one direction (one-directional channel).
 *
 * Current status of the each buffer is stored in the buffer descriptor.
 * Buffer descriptor holds tail and head fields that represents active data
 * stream. The tail field is updated by the data producer (sender), and head
 * field is updated by the data consumer (receiver)::
 *
< ASCII >
 *      +------------+
 *      | DESCRIPTOR |          +=================+============+========+
 *      +============+          |                 | MESSAGE(s) |        |
 *      | address    |--------->+=================+============+========+
 *      +------------+
 *      | head       |          ^-----head--------^
 *      +------------+
 *      | tail       |          ^---------tail-----------------^
 *      +------------+
 *      | size       |          ^---------------size--------------------^
 *      +------------+
< ASCII >
 *
 * Each message in data stream starts with the single u32 treated as a header,
 * followed by optional set of u32 data that makes message specific payload::
 *
< ASCII >
 *      +------------+---------+---------+---------+
 *      |         MESSAGE                          |
 *      +------------+---------+---------+---------+
 *      |   msg[0]   |   [1]   |   ...   |  [n-1]  |
 *      +------------+---------+---------+---------+
 *      |   MESSAGE  |       MESSAGE PAYLOAD       |
 *      +   HEADER   +---------+---------+---------+
 *      |            |    0    |   ...   |    n    |
 *      +======+=====+=========+=========+=========+
 *      | 31:16| code|         |         |         |
 *      +------+-----+         |         |         |
 *      |  15:5|flags|         |         |         |
 *      +------+-----+         |         |         |
 *      |   4:0|  len|         |         |         |
 *      +------+-----+---------+---------+---------+
 *
 *                   ^-------------len-------------^
< ASCII >
 *
 * The message header consists of:
 *
 * - **len**, indicates length of the message payload (in u32)
 * - **code**, indicates message code
 * - **flags**, holds various bits to control message handling
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_341.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h#L33-L47

```c
/**
 * DOC: MMIO HXG Message
 *
 * Format of the MMIO messages follows definitions of `HXG Message`_.
< ASCII >
 *
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 |  31:0 |                                                              |
 *  +---+-------+                                                              |
 *  |...|       | [Embedded `HXG Message`_]                                    |
 *  +---+-------+                                                              |
 *  | n |  31:0 |                                                              |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_342.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h#L11-L29

```c
/**
 * DOC: GuC KLV
 *
< ASCII >
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 | 31:16 | **KEY** - KLV key identifier                                 |
 *  |   |       |   - `GuC Self Config KLVs`_                                  |
 *  |   |       |                                                              |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  15:0 | **LEN** - length of VALUE (in 32bit dwords)                  |
 *  +---+-------+--------------------------------------------------------------+
 *  | 1 |  31:0 | **VALUE** - actual value of the KLV (format depends on KEY)  |
 *  +---+-------+                                                              |
 *  |...|       |                                                              |
 *  +---+-------+                                                              |
 *  | n |  31:0 |                                                              |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_343.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h#L9-L40

```c
/**
 * DOC: HXG Message
 *
 * All messages exchanged with GuC are defined using 32 bit dwords.
 * First dword is treated as a message header. Remaining dwords are optional.
 *
< ASCII >
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  |   |       |                                                              |
 *  | 0 |    31 | **ORIGIN** - originator of the message                       |
 *  |   |       |   - _`GUC_HXG_ORIGIN_HOST` = 0                               |
 *  |   |       |   - _`GUC_HXG_ORIGIN_GUC` = 1                                |
 *  |   |       |                                                              |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 30:28 | **TYPE** - message type                                      |
 *  |   |       |   - _`GUC_HXG_TYPE_REQUEST` = 0                              |
 *  |   |       |   - _`GUC_HXG_TYPE_EVENT` = 1                                |
 *  |   |       |   - _`GUC_HXG_TYPE_NO_RESPONSE_BUSY` = 3                     |
 *  |   |       |   - _`GUC_HXG_TYPE_NO_RESPONSE_RETRY` = 5                    |
 *  |   |       |   - _`GUC_HXG_TYPE_RESPONSE_FAILURE` = 6                     |
 *  |   |       |   - _`GUC_HXG_TYPE_RESPONSE_SUCCESS` = 7                     |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  27:0 | **AUX** - auxiliary data (depends on TYPE)                   |
 *  +---+-------+--------------------------------------------------------------+
 *  | 1 |  31:0 |                                                              |
 *  +---+-------+                                                              |
 *  |...|       | **PAYLOAD** - optional payload (depends on TYPE)             |
 *  +---+-------+                                                              |
 *  | n |  31:0 |                                                              |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_344.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h#L56-L85

```c
/**
 * DOC: HXG Request
 *
 * The `HXG Request`_ message should be used to initiate synchronous activity
 * for which confirmation or return data is expected.
 *
 * The recipient of this message shall use `HXG Response`_, `HXG Failure`_
 * or `HXG Retry`_ message as a definite reply, and may use `HXG Busy`_
 * message as a intermediate reply.
 *
 * Format of @DATA0 and all @DATAn fields depends on the @ACTION code.
 *
< ASCII >
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 |    31 | ORIGIN                                                       |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 30:28 | TYPE = GUC_HXG_TYPE_REQUEST_                                 |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 27:16 | **DATA0** - request data (depends on ACTION)                 |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  15:0 | **ACTION** - requested action code                           |
 *  +---+-------+--------------------------------------------------------------+
 *  | 1 |  31:0 |                                                              |
 *  +---+-------+                                                              |
 *  |...|       | **DATAn** - optional data (depends on ACTION)                |
 *  +---+-------+                                                              |
 *  | n |  31:0 |                                                              |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_345.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h#L92-L117

```c
/**
 * DOC: HXG Event
 *
 * The `HXG Event`_ message should be used to initiate asynchronous activity
 * that does not involves immediate confirmation nor data.
 *
 * Format of @DATA0 and all @DATAn fields depends on the @ACTION code.
 *
< ASCII >
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 |    31 | ORIGIN                                                       |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 30:28 | TYPE = GUC_HXG_TYPE_EVENT_                                   |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 27:16 | **DATA0** - event data (depends on ACTION)                   |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  15:0 | **ACTION** - event action code                               |
 *  +---+-------+--------------------------------------------------------------+
 *  | 1 |  31:0 |                                                              |
 *  +---+-------+                                                              |
 *  |...|       | **DATAn** - optional event  data (depends on ACTION)         |
 *  +---+-------+                                                              |
 *  | n |  31:0 |                                                              |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_346.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h#L124-L142

```c
/**
 * DOC: HXG Busy
 *
 * The `HXG Busy`_ message may be used to acknowledge reception of the `HXG Request`_
 * message if the recipient expects that it processing will be longer than default
 * timeout.
 *
 * The @COUNTER field may be used as a progress indicator.
 *
< ASCII >
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 |    31 | ORIGIN                                                       |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 30:28 | TYPE = GUC_HXG_TYPE_NO_RESPONSE_BUSY_                        |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  27:0 | **COUNTER** - progress indicator                             |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_347.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h#L147-L165

```c
/**
 * DOC: HXG Retry
 *
 * The `HXG Retry`_ message should be used by recipient to indicate that the
 * `HXG Request`_ message was dropped and it should be resent again.
 *
 * The @REASON field may be used to provide additional information.
 *
< ASCII >
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 |    31 | ORIGIN                                                       |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 30:28 | TYPE = GUC_HXG_TYPE_NO_RESPONSE_RETRY_                       |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  27:0 | **REASON** - reason for retry                                |
 *  |   |       |  - _`GUC_HXG_RETRY_REASON_UNSPECIFIED` = 0                   |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_348.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h#L171-L188

```c
/**
 * DOC: HXG Failure
 *
 * The `HXG Failure`_ message shall be used as a reply to the `HXG Request`_
 * message that could not be processed due to an error.
 *
< ASCII >
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 |    31 | ORIGIN                                                       |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 30:28 | TYPE = GUC_HXG_TYPE_RESPONSE_FAILURE_                        |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 27:16 | **HINT** - additional error hint                             |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  15:0 | **ERROR** - error/result code                                |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_349.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h#L194-L215

```c
/**
 * DOC: HXG Response
 *
 * The `HXG Response`_ message shall be used as a reply to the `HXG Request`_
 * message that was successfully processed without an error.
 *
< ASCII >
 *  +---+-------+--------------------------------------------------------------+
 *  |   | Bits  | Description                                                  |
 *  +===+=======+==============================================================+
 *  | 0 |    31 | ORIGIN                                                       |
 *  |   +-------+--------------------------------------------------------------+
 *  |   | 30:28 | TYPE = GUC_HXG_TYPE_RESPONSE_SUCCESS_                        |
 *  |   +-------+--------------------------------------------------------------+
 *  |   |  27:0 | **DATA0** - data (depends on ACTION from `HXG Request`_)     |
 *  +---+-------+--------------------------------------------------------------+
 *  | 1 |  31:0 |                                                              |
 *  +---+-------+                                                              |
 *  |...|       | **DATAn** - data (depends on ACTION from `HXG Request`_)     |
 *  +---+-------+                                                              |
 *  | n |  31:0 |                                                              |
 *  +---+-------+--------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_35.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/include/asm/pgtable.h#L273-L283

```c
/*
 * Encode and decode a swap entry.  Swap entries are stored in the Linux
 * page tables as follows:
 *
< ASCII >
 *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   <--------------- offset ------------------------> < type -> 0 0
< ASCII >
 *
 * This gives us up to 31 swap files and 128GB per swap file.  Note that
 * the offset field is always non-zero.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_350.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/lima/lima_dump.h#L9-L24

```c
/**
 * dump file format for all the information to start a lima task
 *
< ASCII >
 * top level format
 * | magic code "LIMA" | format version | num tasks | data size |
 * | reserved | reserved | reserved | reserved |
 * | task 1 ID | task 1 size | num chunks | reserved | task 1 data |
 * | task 2 ID | task 2 size | num chunks | reserved | task 2 data |
 * ...
< ASCII >
< ASCII >
 *
 * task data format
 * | chunk 1 ID | chunk 1 size | reserved | reserved | chunk 1 data |
 * | chunk 2 ID | chunk 2 size | reserved | reserved | chunk 2 data |
 * ...
< ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_351.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/mcde/mcde_drv.c#L8-L54

```c
/**
 * DOC: ST-Ericsson MCDE Driver
 *
 * The MCDE (short for multi-channel display engine) is a graphics
 * controller found in the Ux500 chipsets, such as NovaThor U8500.
 * It was initially conceptualized by ST Microelectronics for the
 * successor of the Nomadik line, STn8500 but productified in the
 * ST-Ericsson U8500 where is was used for mass-market deployments
 * in Android phones from Samsung and Sony Ericsson.
 *
 * It can do 1080p30 on SDTV CCIR656, DPI-2, DBI-2 or DSI for
 * panels with or without frame buffering and can convert most
 * input formats including most variants of RGB and YUV.
 *
 * The hardware has four display pipes, and the layout is a little
 * bit like this::
 *
< ASCII >
 *   Memory     -> Overlay -> Channel -> FIFO -> 8 formatters -> DSI/DPI
 *   External      0..5       0..3       A,B,    6 x DSI         bridge
 *   source 0..9                         C0,C1   2 x DPI
< ASCII >
 *
 * FIFOs A and B are for LCD and HDMI while FIFO CO/C1 are for
 * panels with embedded buffer.
 * 6 of the formatters are for DSI, 3 pairs for VID/CMD respectively.
 * 2 of the formatters are for DPI.
 *
 * Behind the formatters are the DSI or DPI ports that route to
 * the external pins of the chip. As there are 3 DSI ports and one
 * DPI port, it is possible to configure up to 4 display pipelines
 * (effectively using channels 0..3) for concurrent use.
 *
 * In the current DRM/KMS setup, we use one external source, one overlay,
 * one FIFO and one formatter which we connect to the simple DMA framebuffer
 * helpers. We then provide a bridge to the DSI port, and on the DSI port
 * bridge we connect hang a panel bridge or other bridge. This may be subject
 * to change as we exploit more of the hardware capabilities.
 *
 * TODO:
 *
 * - Enabled damaged rectangles using drm_plane_enable_fb_damage_clips()
 *   so we can selectively just transmit the damaged area to a
 *   command-only display.
 * - Enable mixing of more planes, possibly at the cost of moving away
 *   from using the simple framebuffer pipeline.
 * - Enable output to bridges such as the AV8100 HDMI encoder from
 *   the DSI bridge.
 */
```
## Visual type:
- #sequence


== ./linux/linux_352.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/meson/meson_dw_hdmi.c#L34-L90

```c
/**
 * DOC: HDMI Output
 *
 * HDMI Output is composed of :
 *
 * - A Synopsys DesignWare HDMI Controller IP
 * - A TOP control block controlling the Clocks and PHY
 * - A custom HDMI PHY in order convert video to TMDS signal
 *
 * .. code::
 *
< ASCII >
 *    ___________________________________
 *   |            HDMI TOP               |<= HPD
 *   |___________________________________|
 *   |                  |                |
 *   |  Synopsys HDMI   |   HDMI PHY     |=> TMDS
 *   |    Controller    |________________|
 *   |___________________________________|<=> DDC
< ASCII >
 *
 *
 * The HDMI TOP block only supports HPD sensing.
 * The Synopsys HDMI Controller interrupt is routed
 * through the TOP Block interrupt.
 * Communication to the TOP Block and the Synopsys
 * HDMI Controller is done a pair of addr+read/write
 * registers.
 * The HDMI PHY is configured by registers in the
 * HHI register block.
 *
 * Pixel data arrives in 4:4:4 format from the VENC
 * block and the VPU HDMI mux selects either the ENCI
 * encoder for the 576i or 480i formats or the ENCP
 * encoder for all the other formats including
 * interlaced HD formats.
 * The VENC uses a DVI encoder on top of the ENCI
 * or ENCP encoders to generate DVI timings for the
 * HDMI controller.
 *
 * GXBB, GXL and GXM embeds the Synopsys DesignWare
 * HDMI TX IP version 2.01a with HDCP and I2C & S/PDIF
 * audio source interfaces.
 *
 * We handle the following features :
 *
 * - HPD Rise & Fall interrupt
 * - HDMI Controller Interrupt
 * - HDMI PHY Init for 480i to 1080p60
 * - VENC & HDMI Clock setup for 480i to 1080p60
 * - VENC Mode setup for 480i to 1080p60
 *
 * What is missing :
 *
 * - PHY, Clock and Mode setup for 2k && 4k modes
 * - SDDC Scrambling mode for HDMI 2.0a
 * - HDCP Setup
 * - CEC Management
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_353.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/meson/meson_vclk.c#L15-L47

```c
/**
 * DOC: Video Clocks
 *
 * VCLK is the "Pixel Clock" frequency generator from a dedicated PLL.
 * We handle the following encodings :
 *
 * - CVBS 27MHz generator via the VCLK2 to the VENCI and VDAC blocks
 * - HDMI Pixel Clocks generation
 *
 * What is missing :
 *
 * - Genenate Pixel clocks for 2K/4K 10bit formats
 *
 * Clock generator scheme :
 *
 * .. code::
 *
< ASCII >
 *    __________   _________            _____
 *   |          | |         |          |     |--ENCI
 *   | HDMI PLL |-| PLL_DIV |--- VCLK--|     |--ENCL
 *   |__________| |_________| \        | MUX |--ENCP
 *                             --VCLK2-|     |--VDAC
 *                                     |_____|--HDMI-TX
< ASCII >
 *
 * Final clocks can take input for either VCLK or VCLK2, but
 * VCLK is the preferred path for HDMI clocking and VCLK2 is the
 * preferred path for CVBS VDAC clocking.
 *
 * VCLK and VCLK2 have fixed divided clocks paths for /1, /2, /4, /6 or /12.
 *
 * The PLL_DIV can achieve an additional fractional dividing like
 * 1.5, 3.5, 3.75... to generate special 2K and 4K 10bit clocks.
 */
```
## Visual type:
- #schematic


== ./linux/linux_354.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/meson/meson_venc.c#L17-L59

```c
/**
 * DOC: Video Encoder
 *
 * VENC Handle the pixels encoding to the output formats.
 * We handle the following encodings :
 *
 * - CVBS Encoding via the ENCI encoder and VDAC digital to analog converter
 * - TMDS/HDMI Encoding via ENCI_DIV and ENCP
 * - Setup of more clock rates for HDMI modes
 *
 * What is missing :
 *
 * - LCD Panel encoding via ENCL
 * - TV Panel encoding via ENCT
 *
 * VENC paths :
 *
 * .. code::
 *
< ASCII >
 *          _____   _____   ____________________
 *   vd1---|     |-|     | | VENC     /---------|----VDAC
 *   vd2---| VIU |-| VPP |-|-----ENCI/-ENCI_DVI-|-|
 *   osd1--|     |-|     | | \                  | X--HDMI-TX
 *   osd2--|_____|-|_____| |  |\-ENCP--ENCP_DVI-|-|
 *                         |  |                 |
 *                         |  \--ENCL-----------|----LVDS
 *                         |____________________|
< ASCII >
 *
 * The ENCI is designed for PAl or NTSC encoding and can go through the VDAC
 * directly for CVBS encoding or through the ENCI_DVI encoder for HDMI.
 * The ENCP is designed for Progressive encoding but can also generate
 * 1080i interlaced pixels, and was initially designed to encode pixels for
 * VDAC to output RGB ou YUV analog outputs.
 * It's output is only used through the ENCP_DVI encoder for HDMI.
 * The ENCL LVDS encoder is not implemented.
 *
 * The ENCI and ENCP encoders needs specially defined parameters for each
 * supported mode and thus cannot be determined from standard video timings.
 *
 * The ENCI end ENCP DVI encoders are more generic and can generate any timings
 * from the pixel data generated by ENCI or ENCP, so can use the standard video
 * timings are source for HW parameters.
 */
```
## Visual type:
- #schematic


== ./linux/linux_355.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/msm/disp/mdp5/mdp5_mixer.c#L8-L16

```c
/*
 * As of now, there are only 2 combinations possible for source split:
 *
< ASCII >
 * Left | Right
 * -----|------
 *  LM0 | LM1
 *  LM2 | LM5
< ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_356.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/msm/dsi/phy/dsi_phy_10nm.c#L14-L37

```c
/*
< ASCII >
 * DSI PLL 10nm - clock diagram (eg: DSI0):
 *
 *           dsi0_pll_out_div_clk  dsi0_pll_bit_clk
 *                              |                |
 *                              |                |
 *                 +---------+  |  +----------+  |  +----+
 *  dsi0vco_clk ---| out_div |--o--| divl_3_0 |--o--| /8 |-- dsi0_phy_pll_out_byteclk
 *                 +---------+  |  +----------+  |  +----+
 *                              |                |
 *                              |                |         dsi0_pll_by_2_bit_clk
 *                              |                |          |
 *                              |                |  +----+  |  |\  dsi0_pclk_mux
 *                              |                |--| /2 |--o--| \   |
 *                              |                |  +----+     |  \  |  +---------+
 *                              |                --------------|  |--o--| div_7_4 |-- dsi0_phy_pll_out_dsiclk
 *                              |------------------------------|  /     +---------+
 *                              |          +-----+             | /
 *                              -----------| /4? |--o----------|/
 *                                         +-----+  |           |
 *                                                  |           |dsiclk_sel
 *                                                  |
 *                                                  dsi0_pll_post_out_div_clk
< ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_357.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/msm/dsi/phy/dsi_phy_14nm.c#L16-L32

```c
/*
< ASCII >
 * DSI PLL 14nm - clock diagram (eg: DSI0):
 *
 *         dsi0n1_postdiv_clk
 *                         |
 *                         |
 *                 +----+  |  +----+
 *  dsi0vco_clk ---| n1 |--o--| /8 |-- dsi0pllbyte
 *                 +----+  |  +----+
 *                         |           dsi0n1_postdivby2_clk
 *                         |   +----+  |
 *                         o---| /2 |--o--|\
 *                         |   +----+     | \   +----+
 *                         |              |  |--| n2 |-- dsi0pll
 *                         o--------------| /   +----+
 *                                        |/
< ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_358.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/msm/dsi/phy/dsi_phy_28nm.c#L13-L29

```c
/*
< ASCII >
 * DSI PLL 28nm - clock diagram (eg: DSI0):
 *
 *         dsi0analog_postdiv_clk
 *                             |         dsi0indirect_path_div2_clk
 *                             |          |
 *                   +------+  |  +----+  |  |\   dsi0byte_mux
 *  dsi0vco_clk --o--| DIV1 |--o--| /2 |--o--| \   |
 *                |  +------+     +----+     | m|  |  +----+
 *                |                          | u|--o--| /4 |-- dsi0pllbyte
 *                |                          | x|     +----+
 *                o--------------------------| /
 *                |                          |/
 *                |          +------+
 *                o----------| DIV3 |------------------------- dsi0pll
 *                           +------+
< ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_359.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c#L13-L37

```c
/*
< ASCII >
 * DSI PLL 28nm (8960/A family) - clock diagram (eg: DSI1):
 *
 *
 *                        +------+
 *  dsi1vco_clk ----o-----| DIV1 |---dsi1pllbit (not exposed as clock)
 *  F * byte_clk    |     +------+
 *                  | bit clock divider (F / 8)
 *                  |
 *                  |     +------+
 *                  o-----| DIV2 |---dsi0pllbyte---o---> To byte RCG
 *                  |     +------+                 | (sets parent rate)
 *                  | byte clock divider (F)       |
 *                  |                              |
 *                  |                              o---> To esc RCG
 *                  |                                (doesn't set parent rate)
 *                  |
 *                  |     +------+
 *                  o-----| DIV3 |----dsi0pll------o---> To dsi RCG
 *                        +------+                 | (sets parent rate)
 *                  dsi clock divider (F * magic)  |
 *                                                 |
 *                                                 o---> To pixel rcg
 *                                                  (doesn't set parent rate)
< ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_36.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/include/uapi/asm/types.h#L7-L24

```c
/*
 * The C99 types uintXX_t that are usually defined in 'stdint.h' are not as
 * unambiguous on ARM as you would expect. For the types below, there is a
 * difference on ARM between GCC built for bare metal ARM, GCC built for glibc
 * and the kernel itself, which results in build errors if you try to build with
 * -ffreestanding and include 'stdint.h' (such as when you include 'arm_neon.h'
 * in order to use NEON intrinsics)
 *
 * As the typedefs for these types in 'stdint.h' are based on builtin defines
 * supplied by GCC, we can tweak these to align with the kernel's idea of those
 * types, so 'linux/types.h' and 'stdint.h' can be safely included from the same
 * source file (provided that -ffreestanding is used).
 *
< ASCII >
 *                    int32_t         uint32_t               uintptr_t
 * bare metal GCC     long            unsigned long          unsigned int
 * glibc GCC          int             unsigned int           unsigned int
 * kernel             int             unsigned int           unsigned long
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_360.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/msm/dsi/phy/dsi_phy_7nm.c#L14-L37

```c
/*
< ASCII >
 * DSI PLL 7nm - clock diagram (eg: DSI0): TODO: updated CPHY diagram
 *
 *           dsi0_pll_out_div_clk  dsi0_pll_bit_clk
 *                              |                |
 *                              |                |
 *                 +---------+  |  +----------+  |  +----+
 *  dsi0vco_clk ---| out_div |--o--| divl_3_0 |--o--| /8 |-- dsi0_phy_pll_out_byteclk
 *                 +---------+  |  +----------+  |  +----+
 *                              |                |
 *                              |                |         dsi0_pll_by_2_bit_clk
 *                              |                |          |
 *                              |                |  +----+  |  |\  dsi0_pclk_mux
 *                              |                |--| /2 |--o--| \   |
 *                              |                |  +----+     |  \  |  +---------+
 *                              |                --------------|  |--o--| div_7_4 |-- dsi0_phy_pll_out_dsiclk
 *                              |------------------------------|  /     +---------+
 *                              |          +-----+             | /
 *                              -----------| /4? |--o----------|/
 *                                         +-----+  |           |
 *                                                  |           |dsiclk_sel
 *                                                  |
 *                                                  dsi0_pll_post_out_div_clk
< ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_361.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/nouveau/dispnv50/disp.c#L2702-L2707

```c
< ASCII >
/****************************************************************
 *            Log2(block height) ----------------------------+  *
 *            Page Kind ----------------------------------+  |  *
 *            Gob Height/Page Kind Generation ------+     |  |  *
 *                          Sector layout -------+  |     |  |  *
 *                          Compression ------+  |  |     |  |  */
< ASCII >
```
## Visual type:
- #annotation


== ./linux/linux_362.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/nouveau/dispnv50/disp.c#L2731-L2736

```c
< ASCII >
/****************************************************************
 *            Log2(block height) ----------------------------+  *
 *            Page Kind ----------------------------------+  |  *
 *            Gob Height/Page Kind Generation ------+     |  |  *
 *                          Sector layout -------+  |     |  |  *
 *                          Compression ------+  |  |     |  |  */
< ASCII >
```
## Visual type:
- #annotation


== ./linux/linux_363.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/nouveau/dispnv50/wndwc57e.c#L196-L201

```c
< ASCII >
/****************************************************************
 *            Log2(block height) ----------------------------+  *
 *            Page Kind ----------------------------------+  |  *
 *            Gob Height/Page Kind Generation ------+     |  |  *
 *                          Sector layout -------+  |     |  |  *
 *                          Compression ------+  |  |     |  |  */
< ASCII >
```
## Visual type:
- #annotation


== ./linux/linux_364.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/panel/panel-ilitek-ili9322.c#L194-L250

```c
/**
 * struct ili9322_config - the system specific ILI9322 configuration
 * @width_mm: physical panel width [mm]
 * @height_mm: physical panel height [mm]
 * @flip_horizontal: flip the image horizontally (right-to-left scan)
 * (only in RGB and YUV modes)
 * @flip_vertical: flip the image vertically (down-to-up scan)
 * (only in RGB and YUV modes)
 * @input: the input/entry type used in this system, if this is set to
 * ILI9322_INPUT_UNKNOWN the driver will try to figure it out by probing
 * the hardware
 * @vreg1out_mv: the output in microvolts for the VREGOUT1 regulator used
 * to drive the physical display. Valid ranges are 3600 thru 6000 in 100
 * microvolt increments. If not specified, hardware defaults will be
 * used (4.5V).
 * @vcom_high_percent: the percentage of VREGOUT1 used for the peak
 * voltage on the communications link. Valid ranges are 37 thru 100
 * percent. If not specified, hardware defaults will be used (91%).
 * @vcom_amplitude_percent: the percentage of VREGOUT1 used for the
 * peak-to-peak amplitude of the communcation signals to the physical
 * display. Valid ranges are 70 thru 132 percent in increments if two
 * percent. Odd percentages will be truncated. If not specified, hardware
 * defaults will be used (114%).
 * @dclk_active_high: data/pixel clock active high, data will be clocked
 * in on the rising edge of the DCLK (this is usually the case).
 * @syncmode: The synchronization mode, what sync signals are emitted.
 * See the enum for details.
 * @de_active_high: DE (data entry) is active high
 * @hsync_active_high: HSYNC is active high
 * @vsync_active_high: VSYNC is active high
 * @gamma_corr_pos: a set of 8 nybbles describing positive
 * gamma correction for voltages V1 thru V8. Valid range 0..15
 * @gamma_corr_neg: a set of 8 nybbles describing negative
 * gamma correction for voltages V1 thru V8. Valid range 0..15
 *
 * These adjust what grayscale voltage will be output for input data V1 = 0,
 * V2 = 16, V3 = 48, V4 = 96, V5 = 160, V6 = 208, V7 = 240 and V8 = 255.
 * The curve is shaped like this:
< ASCII >
 *
 *  ^
 *  |                                                        V8
 *  |                                                   V7
 *  |                                          V6
 *  |                               V5
 *  |                    V4
 *  |            V3
 *  |     V2
 *  | V1
 *  +----------------------------------------------------------->
 *    0   16     48      96         160        208      240  255
< ASCII >
 *
 * The negative and postive gamma values adjust the V1 thru V8 up/down
 * according to the datasheet specifications. This is a property of the
 * physical display connected to the display controller and may vary.
 * If defined, both arrays must be supplied in full. If the properties
 * are not supplied, hardware defaults will be used.
 */
```
## Visual type:
- #plot


== ./linux/linux_365.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/panel/panel-novatek-nt35510.c#L127-L158

```c
/**
 * struct nt35510_config - the display-specific NT35510 configuration
 *
 * Some of the settings provide an array of bytes, A, B C which mean:
 * A = normal / idle off mode
 * B = idle on mode
 * C = partial / idle off mode
 *
 * Gamma correction arrays are 10bit numbers, two consecutive bytes
 * makes out one point on the gamma correction curve. The points are
 * not linearly placed along the X axis, we get points 0, 1, 3, 5
 * 7, 11, 15, 23, 31, 47, 63, 95, 127, 128, 160, 192, 208, 224, 232,
 * 240, 244, 248, 250, 252, 254, 255. The voltages tuples form
 * V0, V1, V3 ... V255, with 0x0000 being the lowest voltage and
 * 0x03FF being the highest voltage.
 *
 * Each value must be strictly higher than the previous value forming
 * a rising curve like this:
 *
< ASCII >
 * ^
 * |                                        V255
 * |                                 V254
 * |                         ....
 * |                    V5
 * |           V3
 * |     V1
 * | V0
 * +------------------------------------------->
< ASCII >
 *
 * The details about all settings can be found in the NT35510 Application
 * Note.
 */
```
## Visual type:
- #plot


== ./linux/linux_366.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/rockchip/rockchip_drm_vop.c#L495-L516

```c
/*
 * (1) each frame starts at the start of the Vsync pulse which is signaled by
 *     the "FRAME_SYNC" interrupt.
 * (2) the active data region of each frame ends at dsp_vact_end
 * (3) we should program this same number (dsp_vact_end) into dsp_line_frag_num,
 *      to get "LINE_FLAG" interrupt at the end of the active on screen data.
 *
< ASCII >
 * VOP_INTR_CTRL0.dsp_line_frag_num = VOP_DSP_VACT_ST_END.dsp_vact_end
 * Interrupts
 * LINE_FLAG -------------------------------+
 * FRAME_SYNC ----+                         |
 *                |                         |
 *                v                         v
 *                | Vsync | Vbp |  Vactive  | Vfp |
 *                        ^     ^           ^     ^
 *                        |     |           |     |
 *                        |     |           |     |
 * dsp_vs_end ------------+     |           |     |   VOP_DSP_VTOTAL_VS_END
 * dsp_vact_start --------------+           |     |   VOP_DSP_VACT_ST_END
 * dsp_vact_end ----------------------------+     |   VOP_DSP_VACT_ST_END
 * dsp_total -------------------------------------+   VOP_DSP_VTOTAL_VS_END
< ASCII >
 */
```
## Visual type:
- #sequence


== ./linux/linux_367.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/rockchip/rockchip_drm_vop2.c#L43-L71

```c
/*
< ASCII >
 * VOP2 architecture
 *
 +----------+   +-------------+                                                        +-----------+
 |  Cluster |   | Sel 1 from 6|                                                        | 1 from 3  |
 |  window0 |   |    Layer0   |                                                        |    RGB    |
 +----------+   +-------------+              +---------------+    +-------------+      +-----------+
 +----------+   +-------------+              |N from 6 layers|    |             |
 |  Cluster |   | Sel 1 from 6|              |   Overlay0    +--->| Video Port0 |      +-----------+
 |  window1 |   |    Layer1   |              |               |    |             |      | 1 from 3  |
 +----------+   +-------------+              +---------------+    +-------------+      |   LVDS    |
 +----------+   +-------------+                                                        +-----------+
 |  Esmart  |   | Sel 1 from 6|
 |  window0 |   |   Layer2    |              +---------------+    +-------------+      +-----------+
 +----------+   +-------------+              |N from 6 Layers|    |             | +--> | 1 from 3  |
 +----------+   +-------------+   -------->  |   Overlay1    +--->| Video Port1 |      |   MIPI    |
 |  Esmart  |   | Sel 1 from 6|   -------->  |               |    |             |      +-----------+
 |  Window1 |   |   Layer3    |              +---------------+    +-------------+
 +----------+   +-------------+                                                        +-----------+
 +----------+   +-------------+                                                        | 1 from 3  |
 |  Smart   |   | Sel 1 from 6|              +---------------+    +-------------+      |   HDMI    |
 |  Window0 |   |    Layer4   |              |N from 6 Layers|    |             |      +-----------+
 +----------+   +-------------+              |   Overlay2    +--->| Video Port2 |
 +----------+   +-------------+              |               |    |             |      +-----------+
 |  Smart   |   | Sel 1 from 6|              +---------------+    +-------------+      |  1 from 3 |
 |  Window1 |   |    Layer5   |                                                        |    eDP    |
 +----------+   +-------------+                                                        +-----------+
< ASCII >
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_368.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/rockchip/rockchip_drm_vop2.c#L719-L750

```c
/*
< ASCII >
 * colorspace path:
 *      Input        Win csc                     Output
 * 1. YUV(2020)  --> Y2R->2020To709->R2Y   --> YUV_OUTPUT(601/709)
 *    RGB        --> R2Y                  __/
 *
 * 2. YUV(2020)  --> bypasss               --> YUV_OUTPUT(2020)
 *    RGB        --> 709To2020->R2Y       __/
 *
 * 3. YUV(2020)  --> Y2R->2020To709        --> RGB_OUTPUT(709)
 *    RGB        --> R2Y                  __/
 *
 * 4. YUV(601/709)-> Y2R->709To2020->R2Y   --> YUV_OUTPUT(2020)
 *    RGB        --> 709To2020->R2Y       __/
 *
 * 5. YUV(601/709)-> bypass                --> YUV_OUTPUT(709)
 *    RGB        --> R2Y                  __/
 *
 * 6. YUV(601/709)-> bypass                --> YUV_OUTPUT(601)
 *    RGB        --> R2Y(601)             __/
 *
 * 7. YUV        --> Y2R(709)              --> RGB_OUTPUT(709)
 *    RGB        --> bypass               __/
 *
 * 8. RGB        --> 709To2020->R2Y        --> YUV_OUTPUT(2020)
 *
 * 9. RGB        --> R2Y(709)              --> YUV_OUTPUT(709)
 *
 * 10. RGB       --> R2Y(601)              --> YUV_OUTPUT(601)
 *
 * 11. RGB       --> bypass                --> RGB_OUTPUT(709)
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_369.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/tiny/st7586.c#L49-L61

```c
/*
 * The ST7586 controller has an unusual pixel format where 2bpp grayscale is
 * packed 3 pixels per byte with the first two pixels using 3 bits and the 3rd
 * pixel using only 2 bits.
< ASCII >
 *
 * |  D7  |  D6  |  D5  ||      |      || 2bpp |
 * | (D4) | (D3) | (D2) ||  D1  |  D0  || GRAY |
 * +------+------+------++------+------++------+
 * |  1   |  1   |  1   ||  1   |  1   || 0  0 | black
 * |  1   |  0   |  0   ||  1   |  0   || 0  1 | dark gray
 * |  0   |  1   |  0   ||  0   |  1   || 1  0 | light gray
 * |  0   |  0   |  0   ||  0   |  0   || 1  1 | white
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_37.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/kernel/elf.c#L80-L103

```c
/*
 * An executable for which elf_read_implies_exec() returns TRUE will
 * have the READ_IMPLIES_EXEC personality flag set automatically.
 *
 * The decision process for determining the results are:
 *
< ASCII >
 *                 CPU: | lacks NX*  | has NX     |
 * ELF:                 |            |            |
 * ---------------------|------------|------------|
 * missing PT_GNU_STACK | exec-all   | exec-all   |
 * PT_GNU_STACK == RWX  | exec-all   | exec-stack |
 * PT_GNU_STACK == RW   | exec-all   | exec-none  |
< ASCII >
 *
 *  exec-all  : all PROT_READ user mappings are executable, except when
 *              backed by files on a noexec-filesystem.
 *  exec-none : only PROT_EXEC user mappings are executable.
 *  exec-stack: only the stack and PROT_EXEC user mappings are executable.
 *
 *  *this column has no architectural effect: NX markings are ignored by
 *   hardware, but may have behavioral effects when "wants X" collides with
 *   "cannot be X" constraints in memory permission flags, as in
 *   https://lkml.kernel.org/r/20190418055759.GA3155@mellanox.com
 *
 */
```
## Visual type:
- #table


== ./linux/linux_370.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/drm/xlnx/zynqmp_disp.c#L31-L60

```c
/*
 * Overview
 * --------
 *
 * The display controller part of ZynqMP DP subsystem, made of the Audio/Video
 * Buffer Manager, the Video Rendering Pipeline (blender) and the Audio Mixer.
 *
< ASCII >
 *              +------------------------------------------------------------+
 * +--------+   | +----------------+     +-----------+                       |
 * | DPDMA  | --->|                | --> |   Video   | Video +-------------+ |
 * | 4x vid |   | |                |     | Rendering | -+--> |             | |   +------+
 * | 2x aud |   | |  Audio/Video   | --> | Pipeline  |  |    | DisplayPort |---> | PHY0 |
 * +--------+   | | Buffer Manager |     +-----------+  |    |   Source    | |   +------+
 *              | |    and STC     |     +-----------+  |    | Controller  | |   +------+
 * Live Video --->|                | --> |   Audio   | Audio |             |---> | PHY1 |
 *              | |                |     |   Mixer   | --+-> |             | |   +------+
 * Live Audio --->|                | --> |           |  ||   +-------------+ |
 *              | +----------------+     +-----------+  ||                   |
 *              +---------------------------------------||-------------------+
 *                                                      vv
 *                                                Blended Video and
 *                                                Mixed Audio to PL
< ASCII >
 *
 * Only non-live input from the DPDMA and output to the DisplayPort Source
 * Controller are currently supported. Interface with the programmable logic
 * for live streams is not implemented.
 *
 * The display controller code creates planes for the DPDMA video and graphics
 * layers, and a CRTC for the Video Rendering Pipeline.
 */
```
## Visual type:
- #flowchart


== ./linux/linux_371.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/gpu/ipu-v3/ipu-image-convert.c#L13-L61

```c
/*
 * The IC Resizer has a restriction that the output frame from the
 * resizer must be 1024 or less in both width (pixels) and height
 * (lines).
 *
 * The image converter attempts to split up a conversion when
 * the desired output (converted) frame resolution exceeds the
 * IC resizer limit of 1024 in either dimension.
 *
 * If either dimension of the output frame exceeds the limit, the
 * dimension is split into 1, 2, or 4 equal stripes, for a maximum
 * of 4*4 or 16 tiles. A conversion is then carried out for each
 * tile (but taking care to pass the full frame stride length to
 * the DMA channel's parameter memory!). IDMA double-buffering is used
 * to convert each tile back-to-back when possible (see note below
 * when double_buffering boolean is set).
 *
 * Note that the input frame must be split up into the same number
 * of tiles as the output frame:
 *
< ASCII >
 *                       +---------+-----+
 *   +-----+---+         |  A      | B   |
 *   | A   | B |         |         |     |
 *   +-----+---+   -->   +---------+-----+
 *   | C   | D |         |  C      | D   |
 *   +-----+---+         |         |     |
 *                       +---------+-----+
< ASCII >
 *
 * Clockwise 90° rotations are handled by first rescaling into a
 * reusable temporary tile buffer and then rotating with the 8x8
 * block rotator, writing to the correct destination:
 *
< ASCII >
 *                                         +-----+-----+
 *                                         |     |     |
 *   +-----+---+         +---------+       | C   | A   |
 *   | A   | B |         | A,B, |  |       |     |     |
 *   +-----+---+   -->   | C,D  |  |  -->  |     |     |
 *   | C   | D |         +---------+       +-----+-----+
 *   +-----+---+                           | D   | B   |
 *                                         |     |     |
 *                                         +-----+-----+
< ASCII >
 *
 * If the 8x8 block rotator is used, horizontal or vertical flipping
 * is done during the rotation step, otherwise flipping is done
 * during the scaling step.
 * With rotation or flipping, tile order changes between input and
 * output image. Tiles are numbered row major from top left to bottom
 * right for both input and output image.
 */
```
## Visual type:
- #custom


== ./linux/linux_372.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/hid/hid-picolcd_fb.c#L18-L37

```c
/* Framebuffer
 *
 * The PicoLCD use a Topway LCD module of 256x64 pixel
 * This display area is tiled over 4 controllers with 8 tiles
 * each. Each tile has 8x64 pixel, each data byte representing
 * a 1-bit wide vertical line of the tile.
 *
 * The display can be updated at a tile granularity.
< ASCII >
 *
 *       Chip 1           Chip 2           Chip 3           Chip 4
 * +----------------+----------------+----------------+----------------+
 * |     Tile 1     |     Tile 1     |     Tile 1     |     Tile 1     |
 * +----------------+----------------+----------------+----------------+
 * |     Tile 2     |     Tile 2     |     Tile 2     |     Tile 2     |
 * +----------------+----------------+----------------+----------------+
 *                                  ...
 * +----------------+----------------+----------------+----------------+
 * |     Tile 8     |     Tile 8     |     Tile 8     |     Tile 8     |
 * +----------------+----------------+----------------+----------------+
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_373.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/hid/hid-steam.c#L861-L925

```c
/*
 * The size for this message payload is 60.
 * The known values are:
 *  (* values are not sent through wireless)
 *  (* accelerator/gyro is disabled by default)
< ASCII >
 *  Offset| Type  | Mapped to |Meaning
 * -------+-------+-----------+--------------------------
 *  4-7   | u32   | --        | sequence number
 *  8-10  | 24bit | see below | buttons
 *  11    | u8    | ABS_HAT2Y | left trigger
 *  12    | u8    | ABS_HAT2X | right trigger
 *  13-15 | --    | --        | always 0
 *  16-17 | s16   | ABS_X/ABS_HAT0X     | X value
 *  18-19 | s16   | ABS_Y/ABS_HAT0Y     | Y value
 *  20-21 | s16   | ABS_RX    | right-pad X value
 *  22-23 | s16   | ABS_RY    | right-pad Y value
 *  24-25 | s16   | --        | * left trigger
 *  26-27 | s16   | --        | * right trigger
 *  28-29 | s16   | --        | * accelerometer X value
 *  30-31 | s16   | --        | * accelerometer Y value
 *  32-33 | s16   | --        | * accelerometer Z value
 *  34-35 | s16   | --        | gyro X value
 *  36-36 | s16   | --        | gyro Y value
 *  38-39 | s16   | --        | gyro Z value
 *  40-41 | s16   | --        | quaternion W value
 *  42-43 | s16   | --        | quaternion X value
 *  44-45 | s16   | --        | quaternion Y value
 *  46-47 | s16   | --        | quaternion Z value
 *  48-49 | --    | --        | always 0
 *  50-51 | s16   | --        | * left trigger (uncalibrated)
 *  52-53 | s16   | --        | * right trigger (uncalibrated)
 *  54-55 | s16   | --        | * joystick X value (uncalibrated)
 *  56-57 | s16   | --        | * joystick Y value (uncalibrated)
 *  58-59 | s16   | --        | * left-pad X value
 *  60-61 | s16   | --        | * left-pad Y value
 *  62-63 | u16   | --        | * battery voltage
 *
 * The buttons are:
 *  Bit  | Mapped to  | Description
 * ------+------------+--------------------------------
 *  8.0  | BTN_TR2    | right trigger fully pressed
 *  8.1  | BTN_TL2    | left trigger fully pressed
 *  8.2  | BTN_TR     | right shoulder
 *  8.3  | BTN_TL     | left shoulder
 *  8.4  | BTN_Y      | button Y
 *  8.5  | BTN_B      | button B
 *  8.6  | BTN_X      | button X
 *  8.7  | BTN_A      | button A
 *  9.0  | BTN_DPAD_UP    | lef-pad up
 *  9.1  | BTN_DPAD_RIGHT | lef-pad right
 *  9.2  | BTN_DPAD_LEFT  | lef-pad left
 *  9.3  | BTN_DPAD_DOWN  | lef-pad down
 *  9.4  | BTN_SELECT | menu left
 *  9.5  | BTN_MODE   | steam logo
 *  9.6  | BTN_START  | menu right
 *  9.7  | BTN_GEAR_DOWN | left back lever
 * 10.0  | BTN_GEAR_UP   | right back lever
 * 10.1  | --         | left-pad clicked
 * 10.2  | BTN_THUMBR | right-pad clicked
 * 10.3  | BTN_THUMB  | left-pad touched (but see explanation below)
 * 10.4  | BTN_THUMB2 | right-pad touched
 * 10.5  | --         | unknown
 * 10.6  | BTN_THUMBL | joystick clicked
 * 10.7  | --         | lpad_and_joy
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_374.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/hwmon/dme1737.c#L55-L71

```c
< ASCII >
/* ---------------------------------------------------------------------
 * Registers
 *
 * The sensors are defined as follows:
 *
 * Voltages                          Temperatures
 * --------                          ------------
 * in0   +5VTR (+5V stdby)           temp1   Remote diode 1
 * in1   Vccp  (proc core)           temp2   Internal temp
 * in2   VCC   (internal +3.3V)      temp3   Remote diode 2
 * in3   +5V
 * in4   +12V
 * in5   VTR   (+3.3V stby)
 * in6   Vbat
 * in7   Vtrip (sch5127 only)
 *
 * --------------------------------------------------------------------- */
< ASCII >
```
## Visual type:
- #table


== ./linux/linux_375.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/hwmon/ds1621.c#L44-L66

```c
/*
< ASCII >
 * The Configuration/Status register
 *
 * - DS1621:
 *   7    6    5    4    3    2    1    0
 * |Done|THF |TLF |NVB | X  | X  |POL |1SHOT|
 *
 * - DS1625:
 *   7    6    5    4    3    2    1    0
 * |Done|THF |TLF |NVB | 1  | 0  |POL |1SHOT|
 *
 * - DS1631, DS1731:
 *   7    6    5    4    3    2    1    0
 * |Done|THF |TLF |NVB | R1 | R0 |POL |1SHOT|
 *
 * - DS1721:
 *   7    6    5    4    3    2    1    0
 * |Done| X  | X  | U  | R1 | R0 |POL |1SHOT|
< ASCII >
 *
 * Where:
 * - 'X' is Reserved
 * - 'U' is Undefined
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_376.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/hwmon/ds620.c#L22-L29

```c
/*
< ASCII >
 * Many DS620 constants specified below
 *  15   14   13   12   11   10   09    08
 * |Done|NVB |THF |TLF |R1  |R0  |AUTOC|1SHOT|
 *
 *  07   06   05   04   03   02   01    00
 * |PO2 |PO1 |A2  |A1  |A0  |    |     |     |
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_377.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/hwmon/lm93.c#L1659-L1671

```c
/*
 * some tedious bit-twiddling here to deal with the register format:
 *
< ASCII >
 *	data->sf_tach_to_pwm: (tach to pwm mapping bits)
 *
 *		bit |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0
 *		     T4:P2 T4:P1 T3:P2 T3:P1 T2:P2 T2:P1 T1:P2 T1:P1
 *
 *	data->sfc2: (enable bits)
 *
 *		bit |  3  |  2  |  1  |  0
 *		       T4    T3    T2    T1
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_378.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/hwmon/vt1211.c#L43-L59

```c
/* ---------------------------------------------------------------------
 * Registers
 *
 * The sensors are defined as follows.
 *
< ASCII >
 * Sensor          Voltage Mode   Temp Mode   Notes (from the datasheet)
 * --------        ------------   ---------   --------------------------
 * Reading 1                      temp1       Intel thermal diode
 * Reading 3                      temp2       Internal thermal diode
 * UCH1/Reading2   in0            temp3       NTC type thermistor
 * UCH2            in1            temp4       +2.5V
 * UCH3            in2            temp5       VccP
 * UCH4            in3            temp6       +5V
 * UCH5            in4            temp7       +12V
 * 3.3V            in5                        Internal VDD (+3.3V)
< ASCII >
 *
 * --------------------------------------------------------------------- */
```
## Visual type:
- #table


== ./linux/linux_379.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/hwmon/vt1211.c#L732-L748

```c
/*
 * pwm[ix+1]_auto_point[ap+1]_temp mapping table:
 * Note that there is only a single set of temp auto points that controls both
 * PWM controllers. We still create 2 sets of sysfs files to make it look
 * more consistent even though they map to the same registers.
 *
< ASCII >
 * ix ap : description
 * -------------------
 * 0  0  : pwm1/2 off temperature        (pwm_auto_temp[0])
 * 0  1  : pwm1/2 low speed temperature  (pwm_auto_temp[1])
 * 0  2  : pwm1/2 high speed temperature (pwm_auto_temp[2])
 * 0  3  : pwm1/2 full speed temperature (pwm_auto_temp[3])
 * 1  0  : pwm1/2 off temperature        (pwm_auto_temp[0])
 * 1  1  : pwm1/2 low speed temperature  (pwm_auto_temp[1])
 * 1  2  : pwm1/2 high speed temperature (pwm_auto_temp[2])
 * 1  3  : pwm1/2 full speed temperature (pwm_auto_temp[3])
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_38.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/kernel/module.c#L72-L93

```c
/*
 * This implements the partitioning algorithm for group relocations as
 * documented in the ARM AArch32 ELF psABI (IHI 0044).
 *
 * A single PC-relative symbol reference is divided in up to 3 add or subtract
 * operations, where the final one could be incorporated into a load/store
 * instruction with immediate offset. E.g.,
 *
 *   ADD	Rd, PC, #...		or	ADD	Rd, PC, #...
 *   ADD	Rd, Rd, #...			ADD	Rd, Rd, #...
 *   LDR	Rd, [Rd, #...]			ADD	Rd, Rd, #...
 *
 * The latter has a guaranteed range of only 16 MiB (3x8 == 24 bits), so it is
 * of limited use in the kernel. However, the ADD/ADD/LDR combo has a range of
 * -/+ 256 MiB, (2x8 + 12 == 28 bits), which means it has sufficient range for
 * any in-kernel symbol reference (unless module PLTs are being used).
 *
 * The main advantage of this approach over the typical pattern using a literal
 * load is that literal loads may miss in the D-cache, and generally lead to
 * lower cache efficiency for variables that are referenced often from many
 * different places in the code.
 */
```
## Visual type:



== ./linux/linux_380.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/hwmon/vt1211.c#L797-L812

```c
/*
 * pwm[ix+1]_auto_point[ap+1]_pwm mapping table:
 * Note that the PWM auto points 0 & 3 are hard-wired in the VT1211 and can't
 * be changed.
 *
< ASCII >
 * ix ap : description
 * -------------------
 * 0  0  : pwm1 off                   (pwm_auto_pwm[0][0], hard-wired to 0)
 * 0  1  : pwm1 low speed duty cycle  (pwm_auto_pwm[0][1])
 * 0  2  : pwm1 high speed duty cycle (pwm_auto_pwm[0][2])
 * 0  3  : pwm1 full speed            (pwm_auto_pwm[0][3], hard-wired to 255)
 * 1  0  : pwm2 off                   (pwm_auto_pwm[1][0], hard-wired to 0)
 * 1  1  : pwm2 low speed duty cycle  (pwm_auto_pwm[1][1])
 * 1  2  : pwm2 high speed duty cycle (pwm_auto_pwm[1][2])
 * 1  3  : pwm2 full speed            (pwm_auto_pwm[1][3], hard-wired to 255)
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_381.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/hwmon/vt8231.c#L42-L62

```c
/*
 * The VT8231 registers
 *
 * The reset value for the input channel configuration is used (Reg 0x4A=0x07)
 * which sets the selected inputs marked with '*' below if multiple options are
 * possible:
 *
< ASCII >
 *		    Voltage Mode	  Temperature Mode
 *	Sensor	      Linux Id	      Linux Id	      VIA Id
 *	--------      --------	      --------	      ------
 *	CPU Diode	N/A		temp1		0
 *	UIC1		in0		temp2 *		1
 *	UIC2		in1 *		temp3		2
 *	UIC3		in2 *		temp4		3
 *	UIC4		in3 *		temp5		4
 *	UIC5		in4 *		temp6		5
 *	3.3V		in5		N/A
< ASCII >
 *
 * Note that the BIOS may set the configuration register to a different value
 * to match the motherboard configuration.
 */
```
## Visual type:
- #table


== ./linux/linux_382.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/hwtracing/coresight/coresight-catu.c#L38-L83

```c
/*
 * CATU uses a page size of 4KB for page tables as well as data pages.
 * Each 64bit entry in the table has the following format.
 *
< ASCII >
 *	63			12	1  0
 *	------------------------------------
 *	|	 Address [63-12] | SBZ	| V|
 *	------------------------------------
< ASCII >
 *
 * Where bit[0] V indicates if the address is valid or not.
 * Each 4K table pages have upto 256 data page pointers, taking upto 2K
 * size. There are two Link pointers, pointing to the previous and next
 * table pages respectively at the end of the 4K page. (i.e, entry 510
 * and 511).
 *  E.g, a table of two pages could look like :
< ASCII >
 *
 *                 Table Page 0               Table Page 1
 * SLADDR ===> x------------------x  x--> x-----------------x
 * INADDR    ->|  Page 0      | V |  |    | Page 256    | V | <- INADDR+1M
 *             |------------------|  |    |-----------------|
 * INADDR+4K ->|  Page 1      | V |  |    |                 |
 *             |------------------|  |    |-----------------|
 *             |  Page 2      | V |  |    |                 |
 *             |------------------|  |    |-----------------|
 *             |   ...        | V |  |    |    ...          |
 *             |------------------|  |    |-----------------|
 * INADDR+1020K|  Page 255    | V |  |    |   Page 511  | V |
 * SLADDR+2K==>|------------------|  |    |-----------------|
 *             |  UNUSED      |   |  |    |                 |
 *             |------------------|  |    |                 |
 *             |  UNUSED      |   |  |    |                 |
 *             |------------------|  |    |                 |
 *             |    ...       |   |  |    |                 |
 *             |------------------|  |    |-----------------|
 *             |   IGNORED    | 0 |  |    | Table Page 0| 1 |
 *             |------------------|  |    |-----------------|
 *             |  Table Page 1| 1 |--x    | IGNORED     | 0 |
 *             x------------------x       x-----------------x
 * SLADDR+4K==>
< ASCII >
 *
 * The base input address (used by the ETR, programmed in INADDR_{LO,HI})
 * must be aligned to 1MB (the size addressable by a single page table).
 * The CATU maps INADDR{LO:HI} to the first page in the table pointed
 * to by SLADDR{LO:HI} and so on.
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_383.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/hwtracing/coresight/coresight-tmc-etr.c#L53-L73

```c
/*
 * The TMC ETR SG has a page size of 4K. The SG table contains pointers
 * to 4KB buffers. However, the OS may use a PAGE_SIZE different from
 * 4K (i.e, 16KB or 64KB). This implies that a single OS page could
 * contain more than one SG buffer and tables.
 *
 * A table entry has the following format:
< ASCII >
 *
 * ---Bit31------------Bit4-------Bit1-----Bit0--
 * |     Address[39:12]    | SBZ |  Entry Type  |
 * ----------------------------------------------
< ASCII >
 *
 * Address: Bits [39:12] of a physical page address. Bits [11:0] are
 *	    always zero.
 *
 * Entry type:
 *	b00 - Reserved.
 *	b01 - Last entry in the tables, points to 4K page buffer.
 *	b10 - Normal entry, points to 4K page buffer.
 *	b11 - Link. The address points to the base of next table.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_384.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/hwtracing/coresight/coresight-trbe.c#L298-L339

```c
/*
 * TRBE Buffer Management
 *
 * The TRBE buffer spans from the base pointer till the limit pointer. When enabled,
 * it starts writing trace data from the write pointer onward till the limit pointer.
 * When the write pointer reaches the address just before the limit pointer, it gets
 * wrapped around again to the base pointer. This is called a TRBE wrap event, which
 * generates a maintenance interrupt when operated in WRAP or FILL mode. This driver
 * uses FILL mode, where the TRBE stops the trace collection at wrap event. The IRQ
 * handler updates the AUX buffer and re-enables the TRBE with updated WRITE and
 * LIMIT pointers.
 *
< ASCII >
 *	Wrap around with an IRQ
 *	------ < ------ < ------- < ----- < -----
 *	|					|
 *	------ > ------ > ------- > ----- > -----
 *
 *	+---------------+-----------------------+
 *	|		|			|
 *	+---------------+-----------------------+
 *	Base Pointer	Write Pointer		Limit Pointer
< ASCII >
 *
 * The base and limit pointers always needs to be PAGE_SIZE aligned. But the write
 * pointer can be aligned to the implementation defined TRBE trace buffer alignment
 * as captured in trbe_cpudata->trbe_align.
 *
 *
< ASCII >
 *		head		tail		wakeup
 *	+---------------------------------------+----- ~ ~ ------
 *	|$$$$$$$|################|$$$$$$$$$$$$$$|		|
 *	+---------------------------------------+----- ~ ~ ------
 *	Base Pointer	Write Pointer		Limit Pointer
< ASCII >
 *
 * The perf_output_handle indices (head, tail, wakeup) are monotonically increasing
 * values which tracks all the driver writes and user reads from the perf auxiliary
 * buffer. Generally [head..tail] is the area where the driver can write into unless
 * the wakeup is behind the tail. Enabled TRBE buffer span needs to be adjusted and
 * configured depending on the perf_output_handle indices, so that the driver does
 * not override into areas in the perf auxiliary buffer which is being or yet to be
 * consumed from the user space. The enabled TRBE buffer area is a moving subset of
 * the allocated perf auxiliary buffer.
 */
```
## Visual type:
- #custom


== ./linux/linux_385.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/i2c/busses/i2c-sis630.c#L7-L29

```c
/*
   Status: beta

   Supports:
	SIS 630
	SIS 730
	SIS 964

< ASCII >
   Notable differences between chips:
	+------------------------+--------------------+-------------------+
	|                        |     SIS630/730     |      SIS964       |
	+------------------------+--------------------+-------------------+
	| Clock                  | 14kHz/56kHz        | 55.56kHz/27.78kHz |
	| SMBus registers offset | 0x80               | 0xE0              |
	| SMB_CNT                | Bit 1 = Slave Busy | Bit 1 = Bus probe |
	|         (not used yet) | Bit 3 is reserved  | Bit 3 = Last byte |
	| SMB_PCOUNT		 | Offset + 0x06      | Offset + 0x14     |
	| SMB_COUNT              | 4:0 bits           | 5:0 bits          |
	+------------------------+--------------------+-------------------+
	(Other differences don't affect the functions provided by the driver)
< ASCII >

   Note: we assume there can only be one device, with one SMBus interface.
*/
```
## Visual type:
- #table


== ./linux/linux_386.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/i2c/muxes/i2c-mux-mlxcpld.c#L29-L55

```c
/* MUX logic description.
 * Driver can support different mux control logic, according to CPLD
 * implementation.
 *
 * Connectivity schema.
 *
< ASCII >
 * i2c-mlxcpld                                 Digital               Analog
 * driver
 * *--------*                                 * -> mux1 (virt bus2) -> mux -> |
 * | I2CLPC | i2c physical                    * -> mux2 (virt bus3) -> mux -> |
 * | bridge | bus 1                 *---------*                               |
 * | logic  |---------------------> * mux reg *                               |
 * | in CPLD|                       *---------*                               |
 * *--------*   i2c-mux-mlxpcld          ^    * -> muxn (virt busn) -> mux -> |
 *     |        driver                   |                                    |
 *     |        *---------------*        |                              Devices
 *     |        * CPLD (i2c bus)* select |
 *     |        * registers for *--------*
 *     |        * mux selection * deselect
 *     |        *---------------*
 *     |                 |
 * <-------->     <----------->
 * i2c cntrl      Board cntrl reg
 * reg space      space (mux select,
 *                IO, LED, WD, info)
< ASCII >
 *
 */
```
## Visual type:
- #schematic


== ./linux/linux_387.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/iio/adc/envelope-detector.c#L10-L27

```c
/*
 * The DAC is used to find the peak level of an alternating voltage input
 * signal by a binary search using the output of a comparator wired to
 * an interrupt pin. Like so:
< ASCII >
 *                           _
 *                          | \
 *     input +------>-------|+ \
 *                          |   \
 *            .-------.     |    }---.
 *            |       |     |   /    |
 *            |    dac|-->--|- /     |
 *            |       |     |_/      |
 *            |       |              |
 *            |       |              |
 *            |    irq|------<-------'
 *            |       |
 *            '-------'
< ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_388.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/iio/adc/stm32-adc-core.h#L13-L26

```c
/*
 * STM32 - ADC global register map
< ASCII >
 * ________________________________________________________
 * | Offset |                 Register                    |
 * --------------------------------------------------------
 * | 0x000  |                Master ADC1                  |
 * --------------------------------------------------------
 * | 0x100  |                Slave ADC2                   |
 * --------------------------------------------------------
 * | 0x200  |                Slave ADC3                   |
 * --------------------------------------------------------
 * | 0x300  |         Master & Slave common regs          |
 * --------------------------------------------------------
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_389.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/iio/adc/stm32-dfsdm.h#L14-L35

```c
/*
 * STM32 DFSDM - global register map
< ASCII >
 * ________________________________________________________
 * | Offset |                 Registers block             |
 * --------------------------------------------------------
 * | 0x000  |      CHANNEL 0 + COMMON CHANNEL FIELDS      |
 * --------------------------------------------------------
 * | 0x020  |                CHANNEL 1                    |
 * --------------------------------------------------------
 * | ...    |                .....                        |
 * --------------------------------------------------------
 * | 0x0E0  |                CHANNEL 7                    |
 * --------------------------------------------------------
 * | 0x100  |      FILTER  0 + COMMON  FILTER FIELDs      |
 * --------------------------------------------------------
 * | 0x200  |                FILTER  1                    |
 * --------------------------------------------------------
 * | 0x300  |                FILTER  2                    |
 * --------------------------------------------------------
 * | 0x400  |                FILTER  3                    |
 * --------------------------------------------------------
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_39.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/kernel/perf_event_v7.c#L1286-L1317

```c
/*
 * Krait Performance Monitor Region Event Selection Register (PMRESRn)
< ASCII >
 *
 *            31   30     24     16     8      0
 *            +--------------------------------+
 *  PMRESR0   | EN |  CC  |  CC  |  CC  |  CC  |   N = 1, R = 0
 *            +--------------------------------+
 *  PMRESR1   | EN |  CC  |  CC  |  CC  |  CC  |   N = 1, R = 1
 *            +--------------------------------+
 *  PMRESR2   | EN |  CC  |  CC  |  CC  |  CC  |   N = 1, R = 2
 *            +--------------------------------+
 *  VPMRESR0  | EN |  CC  |  CC  |  CC  |  CC  |   N = 2, R = ?
 *            +--------------------------------+
 *              EN | G=3  | G=2  | G=1  | G=0
< ASCII >
 *
 *  Event Encoding:
 *
 *      hwc->config_base = 0xNRCCG
 *
 *      N  = prefix, 1 for Krait CPU (PMRESRn), 2 for Venum VFP (VPMRESR)
 *      R  = region register
 *      CC = class of events the group G is choosing from
 *      G  = group or particular event
 *
 *  Example: 0x12021 is a Krait CPU event in PMRESR2's group 1 with code 2
 *
 *  A region (R) corresponds to a piece of the CPU (execution unit, instruction
 *  unit, etc.) while the event code (CC) corresponds to a particular class of
 *  events (interrupts for example). An event code is broken down into
 *  groups (G) that can be mapped into the PMU (irq, fiqs, and irq+fiqs for
 *  example).
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_390.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/iio/dac/dpot-dac.c#L10-L27

```c
/*
 * It is assumed that the dpot is used as a voltage divider between the
 * current dpot wiper setting and the maximum resistance of the dpot. The
 * divided voltage is provided by a vref regulator.
 *
< ASCII >
 *                   .------.
 *    .-----------.  |      |
 *    | vref      |--'    .---.
 *    | regulator |--.    |   |
 *    '-----------'  |    | d |
 *                   |    | p |
 *                   |    | o |  wiper
 *                   |    | t |<---------+
 *                   |    |   |
 *                   |    '---'       dac output voltage
 *                   |      |
 *                   '------+------------+
< ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_391.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/iio/imu/bno055/bno055_ser_core.c#L31-L102

```c
/*
 * Register writes cmd have the following format
< ASCII >
 * +------+------+-----+-----+----- ... ----+
 * | 0xAA | 0xOO | REG | LEN | payload[LEN] |
 * +------+------+-----+-----+----- ... ----+
< ASCII >
 *
 * Register write responses have the following format
< ASCII >
 * +------+----------+
 * | 0xEE | ERROCODE |
 * +------+----------+
< ASCII >
 *
 * .. except when writing the SYS_RST bit (i.e. triggering a system reset); in
 * case the IMU accepts the command, then it resets without responding. We don't
 * handle this (yet) here (so we inform the common bno055 code not to perform
 * sw resets - bno055 on serial bus basically requires the hw reset pin).
 *
 * Register read have the following format
< ASCII >
 * +------+------+-----+-----+
 * | 0xAA | 0xO1 | REG | LEN |
 * +------+------+-----+-----+
< ASCII >
 *
 * Successful register read response have the following format
< ASCII >
 * +------+-----+----- ... ----+
 * | 0xBB | LEN | payload[LEN] |
 * +------+-----+----- ... ----+
< ASCII >
 *
 * Failed register read response have the following format
< ASCII >
 * +------+--------+
 * | 0xEE | ERRCODE|  (ERRCODE always > 1)
 * +------+--------+
< ASCII >
 *
 * Error codes are
 * 01: OK
 * 02: read/write FAIL
 * 04: invalid address
 * 05: write on RO
 * 06: wrong start byte
 * 07: bus overrun
 * 08: len too high
 * 09: len too low
 * 10: bus RX byte timeout (timeout is 30mS)
 *
 *
 * **WORKAROUND ALERT**
 *
 * Serial communication seems very fragile: the BNO055 buffer seems to overflow
 * very easy; BNO055 seems able to sink few bytes, then it needs a brief pause.
 * On the other hand, it is also picky on timeout: if there is a pause > 30mS in
 * between two bytes then the transaction fails (IMU internal RX FSM resets).
 *
 * BNO055 has been seen also failing to process commands in case we send them
 * too close each other (or if it is somehow busy?)
 *
 * In particular I saw these scenarios:
 * 1) If we send 2 bytes per time, then the IMU never(?) overflows.
 * 2) If we send 4 bytes per time (i.e. the full header), then the IMU could
 *    overflow, but it seem to sink all 4 bytes, then it returns error.
 * 3) If we send more than 4 bytes, the IMU could overflow, and I saw it sending
 *    error after 4 bytes are sent; we have troubles in synchronizing again,
 *    because we are still sending data, and the IMU interprets it as the 1st
 *    byte of a new command.
 *
 * While we must avoid case 3, we could send 4 bytes per time and eventually
 * retry in case of failure; this seemed convenient for reads (which requires
 * TXing exactly 4 bytes), however it has been seen that, depending by the IMU
 * settings (e.g. LPF), failures became less or more frequent; in certain IMU
 * configurations they are very rare, but in certain others we keeps failing
 * even after like 30 retries.
 *
 * So, we just split TXes in [2-bytes + delay] steps, and still keep an eye on
 * the IMU response; in case it overflows (which is now unlikely), we retry.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_392.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/iio/proximity/srf08.c#L249-L259

```c
/*
 * set the range of the sensor to an even multiple of 43 mm
 * which corresponds to 1 LSB in the register
 *
< ASCII >
 * register value    corresponding range
 *         0x00             43 mm
 *         0x01             86 mm
 *         0x02            129 mm
 *         ...
 *         0xFF          11008 mm
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_393.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/infiniband/hw/hfi1/pio.h#L129-L188

```c
/*
 * The diagram below details the relationship of the mapping structures
 *
 * Since the mapping now allows for non-uniform send contexts per vl, the
 * number of send contexts for a vl is either the vl_scontexts[vl] or
 * a computation based on num_kernel_send_contexts/num_vls:
 *
 * For example:
 * nactual = vl_scontexts ? vl_scontexts[vl] : num_kernel_send_contexts/num_vls
 *
 * n = roundup to next highest power of 2 using nactual
 *
 * In the case where there are num_kernel_send_contexts/num_vls doesn't divide
 * evenly, the extras are added from the last vl downward.
 *
 * For the case where n > nactual, the send contexts are assigned
 * in a round robin fashion wrapping back to the first send context
 * for a particular vl.
 *
< ASCII >
 *               dd->pio_map
 *                    |                                   pio_map_elem[0]
 *                    |                                +--------------------+
 *                    v                                |       mask         |
 *               pio_vl_map                            |--------------------|
 *      +--------------------------+                   | ksc[0] -> sc 1     |
 *      |    list (RCU)            |                   |--------------------|
 *      |--------------------------|                 ->| ksc[1] -> sc 2     |
 *      |    mask                  |              --/  |--------------------|
 *      |--------------------------|            -/     |        *           |
 *      |    actual_vls (max 8)    |          -/       |--------------------|
 *      |--------------------------|       --/         | ksc[n-1] -> sc n   |
 *      |    vls (max 8)           |     -/            +--------------------+
 *      |--------------------------|  --/
 *      |    map[0]                |-/
 *      |--------------------------|                   +--------------------+
 *      |    map[1]                |---                |       mask         |
 *      |--------------------------|   \----           |--------------------|
 *      |           *              |        \--        | ksc[0] -> sc 1+n   |
 *      |           *              |           \----   |--------------------|
 *      |           *              |                \->| ksc[1] -> sc 2+n   |
 *      |--------------------------|                   |--------------------|
 *      |   map[vls - 1]           |-                  |         *          |
 *      +--------------------------+ \-                |--------------------|
 *                                     \-              | ksc[m-1] -> sc m+n |
 *                                       \             +--------------------+
 *                                        \-
 *                                          \
 *                                           \-        +----------------------+
 *                                             \-      |       mask           |
 *                                               \     |----------------------|
 *                                                \-   | ksc[0] -> sc 1+m+n   |
 *                                                  \- |----------------------|
 *                                                    >| ksc[1] -> sc 2+m+n   |
 *                                                     |----------------------|
 *                                                     |         *            |
 *                                                     |----------------------|
 *                                                     | ksc[o-1] -> sc o+m+n |
 *                                                     +----------------------+
< ASCII >
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_394.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/infiniband/hw/hfi1/sdma.h#L873-L933

```c
/*
 *
 * The diagram below details the relationship of the mapping structures
 *
 * Since the mapping now allows for non-uniform engines per vl, the
 * number of engines for a vl is either the vl_engines[vl] or
 * a computation based on num_sdma/num_vls:
 *
 * For example:
 * nactual = vl_engines ? vl_engines[vl] : num_sdma/num_vls
 *
 * n = roundup to next highest power of 2 using nactual
 *
 * In the case where there are num_sdma/num_vls doesn't divide
 * evenly, the extras are added from the last vl downward.
 *
 * For the case where n > nactual, the engines are assigned
 * in a round robin fashion wrapping back to the first engine
 * for a particular vl.
 *
< ASCII >
 *               dd->sdma_map
 *                    |                                   sdma_map_elem[0]
 *                    |                                +--------------------+
 *                    v                                |       mask         |
 *               sdma_vl_map                           |--------------------|
 *      +--------------------------+                   | sde[0] -> eng 1    |
 *      |    list (RCU)            |                   |--------------------|
 *      |--------------------------|                 ->| sde[1] -> eng 2    |
 *      |    mask                  |              --/  |--------------------|
 *      |--------------------------|            -/     |        *           |
 *      |    actual_vls (max 8)    |          -/       |--------------------|
 *      |--------------------------|       --/         | sde[n-1] -> eng n  |
 *      |    vls (max 8)           |     -/            +--------------------+
 *      |--------------------------|  --/
 *      |    map[0]                |-/
 *      |--------------------------|                   +---------------------+
 *      |    map[1]                |---                |       mask          |
 *      |--------------------------|   \----           |---------------------|
 *      |           *              |        \--        | sde[0] -> eng 1+n   |
 *      |           *              |           \----   |---------------------|
 *      |           *              |                \->| sde[1] -> eng 2+n   |
 *      |--------------------------|                   |---------------------|
 *      |   map[vls - 1]           |-                  |         *           |
 *      +--------------------------+ \-                |---------------------|
 *                                     \-              | sde[m-1] -> eng m+n |
 *                                       \             +---------------------+
 *                                        \-
 *                                          \
 *                                           \-        +----------------------+
 *                                             \-      |       mask           |
 *                                               \     |----------------------|
 *                                                \-   | sde[0] -> eng 1+m+n  |
 *                                                  \- |----------------------|
 *                                                    >| sde[1] -> eng 2+m+n  |
 *                                                     |----------------------|
 *                                                     |         *            |
 *                                                     |----------------------|
 *                                                     | sde[o-1] -> eng o+m+n|
 *                                                     +----------------------+
< ASCII >
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_395.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/infiniband/hw/hfi1/tid_rdma.c#L91-L108

```c
/*
 * OPFN TID layout
 *
< ASCII >
 * 63               47               31               15
 * NNNNNNNNKKKKKKKK MMMMMMMMMMMTTTTT DDDDDDUVVVJJJJJJ RRRRRRWWWWWWCCCC
 * 3210987654321098 7654321098765432 1098765432109876 5432109876543210
< ASCII >
 * N - the context Number
 * K - the Kdeth_qp
 * M - Max_len
 * T - Timeout
 * D - reserveD
 * V - version
 * U - Urg capable
 * J - Jkey
 * R - max_Read
 * W - max_Write
 * C - Capcode
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_396.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/keyboard/lkkbd.c#L10-L47

```c
/*
 * DEC LK201 and LK401 keyboard driver for Linux (primary for DECstations
 * and VAXstations, but can also be used on any standard RS232 with an
 * adaptor).
 *
 * DISCLAIMER: This works for _me_. If you break anything by using the
 * information given below, I will _not_ be liable!
 *
< ASCII >
 * RJ10 pinout:		To DE9:		Or DB25:
 *	1 - RxD <---->	Pin 3 (TxD) <->	Pin 2 (TxD)
 *	2 - GND <---->	Pin 5 (GND) <->	Pin 7 (GND)
 *	4 - TxD <---->	Pin 2 (RxD) <->	Pin 3 (RxD)
 *	3 - +12V (from HDD drive connector), DON'T connect to DE9 or DB25!!!
< ASCII >
 *
 * Pin numbers for DE9 and DB25 are noted on the plug (quite small:). For
 * RJ10, it's like this:
 *
< ASCII >
 *      __=__	Hold the plug in front of you, cable downwards,
 *     /___/|	nose is hidden behind the plug. Now, pin 1 is at
 *    |1234||	the left side, pin 4 at the right and 2 and 3 are
 *    |IIII||	in between, of course:)
 *    |    ||
 *    |____|/
 *      ||	So the adaptor consists of three connected cables
 *      ||	for data transmission (RxD and TxD) and signal ground.
 *		Additionally, you have to get +12V from somewhere.
 * Most easily, you'll get that from a floppy or HDD power connector.
 * It's the yellow cable there (black is ground and red is +5V).
< ASCII >
 *
 * The keyboard and all the commands it understands are documented in
 * "VCB02 Video Subsystem - Technical Manual", EK-104AA-TM-001. This
 * document is LK201 specific, but LK401 is mostly compatible. It comes
 * up in LK201 mode and doesn't report any of the additional keys it
 * has. These need to be switched on with the LK_CMD_ENABLE_LK401
 * command. You'll find this document (scanned .pdf file) on MANX,
 * a search engine specific to DEC documentation. Try
 * http://www.vt100.net/manx/details?pn=EK-104AA-TM-001;id=21;cp=1
 */
```
## Visual type:
- #custom


== ./linux/linux_397.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/misc/cm109.c#L148-L171

```c
/* Map device buttons to internal key events.
 *
 * The "up" and "down" keys, are symbolised by arrows on the button.
 * The "pickup" and "hangup" keys are symbolised by a green and red phone
 * on the button.

< ASCII >
 Komunikate KIP1000 Keyboard Matrix

     -> -- 1 -- 2 -- 3  --> GPI pin 4 (0x10)
      |    |    |    |
     <- -- 4 -- 5 -- 6  --> GPI pin 5 (0x20)
      |    |    |    |
     END - 7 -- 8 -- 9  --> GPI pin 6 (0x40)
      |    |    |    |
     OK -- * -- 0 -- #  --> GPI pin 7 (0x80)
      |    |    |    |

     /|\  /|\  /|\  /|\
      |    |    |    |
GPO
pin:  3    2    1    0
     0x8  0x4  0x2  0x1
< ASCII >

 */
```
## Visual type:
- #custom


== ./linux/linux_398.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/misc/yealink.c#L172-L189

```c
/* Map device buttons to internal key events.
 *
< ASCII >
 * USB-P1K button layout:
 *
 *             up
 *       IN           OUT
 *            down
 *
 *     pickup   C    hangup
 *       1      2      3
 *       4      5      6
 *       7      8      9
 *       *      0      #
< ASCII >
 *
 * The "up" and "down" keys, are symbolised by arrows on the button.
 * The "pickup" and "hangup" keys are symbolised by a green and red phone
 * on the button.
 */
```
## Visual type:
- #custom


== ./linux/linux_399.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/misc/yealink.c#L396-L409

```c
/* Decide on how to handle responses
 *
 * The state transition diagram is somethhing like:
 *
< ASCII >
 *          syncState<--+
 *               |      |
 *               |    idle
 *              \|/     |
 * init --ok--> waitForKey --ok--> getKey
 *  ^               ^                |
 *  |               +-------ok-------+
 * error,start
< ASCII >
 *
 */
```
## Visual type:
- #state-machine


== ./linux/linux_4.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/include/asm/core_mcpcia.h#L217-L247

```c
/*
 * Memory functions.  64-bit and 32-bit accesses are done through
 * dense memory space, everything else through sparse space.
 *
 * For reading and writing 8 and 16 bit quantities we need to
 * go through one of the three sparse address mapping regions
 * and use the HAE_MEM CSR to provide some bits of the address.
 * The following few routines use only sparse address region 1
 * which gives 1Gbyte of accessible space which relates exactly
 * to the amount of PCI memory mapping *into* system address space.
 * See p 6-17 of the specification but it looks something like this:
 *
< ASCII >
 * 21164 Address:
 *
 *          3         2         1
 * 9876543210987654321098765432109876543210
 * 1ZZZZ0.PCI.QW.Address............BBLL
< ASCII >
 *
 * ZZ = SBZ
 * BB = Byte offset
 * LL = Transfer length
 *
< ASCII >
 * PCI Address:
 *
 * 3         2         1
 * 10987654321098765432109876543210
 * HHH....PCI.QW.Address........ 00
< ASCII >
 *
 * HHH = 31:29 HAE_MEM CSR
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_40.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/kernel/perf_event_v7.c#L1673-L1707

```c
/*
< ASCII >
 * Scorpion Local Performance Monitor Register (LPMn)
 *
 *            31   30     24     16     8      0
 *            +--------------------------------+
 *  LPM0      | EN |  CC  |  CC  |  CC  |  CC  |   N = 1, R = 0
 *            +--------------------------------+
 *  LPM1      | EN |  CC  |  CC  |  CC  |  CC  |   N = 1, R = 1
 *            +--------------------------------+
 *  LPM2      | EN |  CC  |  CC  |  CC  |  CC  |   N = 1, R = 2
 *            +--------------------------------+
 *  L2LPM     | EN |  CC  |  CC  |  CC  |  CC  |   N = 1, R = 3
 *            +--------------------------------+
 *  VLPM      | EN |  CC  |  CC  |  CC  |  CC  |   N = 2, R = ?
 *            +--------------------------------+
 *              EN | G=3  | G=2  | G=1  | G=0
< ASCII >
 *
 *
 *  Event Encoding:
 *
 *      hwc->config_base = 0xNRCCG
 *
 *      N  = prefix, 1 for Scorpion CPU (LPMn/L2LPM), 2 for Venum VFP (VLPM)
 *      R  = region register
 *      CC = class of events the group G is choosing from
 *      G  = group or particular event
 *
 *  Example: 0x12021 is a Scorpion CPU event in LPM2's group 1 with code 2
 *
 *  A region (R) corresponds to a piece of the CPU (execution unit, instruction
 *  unit, etc.) while the event code (CC) corresponds to a particular class of
 *  events (interrupts for example). An event code is broken down into
 *  groups (G) that can be mapped into the PMU (irq, fiqs, and irq+fiqs for
 *  example).
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_400.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/misc/yealink.h#L116-L128

```c
/* LCD, each segment must be driven separately.
 *
< ASCII >
 * Layout:
 *
 *   |[]   [][]   [][]   [][]   in   |[][]
 *   |[] M [][] D [][] : [][]   out  |[][]
 *                             store
 *
 *    NEW REP         SU MO TU WE TH FR SA
 *
 *    [] [] [] [] [] [] [] [] [] [] [] []
 *    [] [] [] [] [] [] [] [] [] [] [] []
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_401.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/misc/yealink.h#L130-L133

```c
/* Line 1
< ASCII >
 *	Format		: 18.e8.M8.88...188
 *	Icon names	: M D : IN OUT STORE
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_402.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/misc/yealink.h#L157-L160

```c
/* Line 2
< ASCII >
 *	Format		: .........
 *	Pict. name	: NEW REP SU MO TU WE TH FR SA
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_403.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/mouse/elantech.c#L270-L310

```c
/*
 * Advertise INPUT_PROP_BUTTONPAD for clickpads. The testing of bit 12 in
 * fw_version for this is based on the following fw_version & caps table:
 *
< ASCII >
 * Laptop-model:           fw_version:     caps:           buttons:
 * Acer S3                 0x461f00        10, 13, 0e      clickpad
 * Acer S7-392             0x581f01        50, 17, 0d      clickpad
 * Acer V5-131             0x461f02        01, 16, 0c      clickpad
 * Acer V5-551             0x461f00        ?               clickpad
 * Asus K53SV              0x450f01        78, 15, 0c      2 hw buttons
 * Asus G46VW              0x460f02        00, 18, 0c      2 hw buttons
 * Asus G750JX             0x360f00        00, 16, 0c      2 hw buttons
 * Asus TP500LN            0x381f17        10, 14, 0e      clickpad
 * Asus X750JN             0x381f17        10, 14, 0e      clickpad
 * Asus UX31               0x361f00        20, 15, 0e      clickpad
 * Asus UX32VD             0x361f02        00, 15, 0e      clickpad
 * Avatar AVIU-145A2       0x361f00        ?               clickpad
 * Fujitsu CELSIUS H760    0x570f02        40, 14, 0c      3 hw buttons (**)
 * Fujitsu CELSIUS H780    0x5d0f02        41, 16, 0d      3 hw buttons (**)
 * Fujitsu LIFEBOOK E544   0x470f00        d0, 12, 09      2 hw buttons
 * Fujitsu LIFEBOOK E546   0x470f00        50, 12, 09      2 hw buttons
 * Fujitsu LIFEBOOK E547   0x470f00        50, 12, 09      2 hw buttons
 * Fujitsu LIFEBOOK E554   0x570f01        40, 14, 0c      2 hw buttons
 * Fujitsu LIFEBOOK E557   0x570f01        40, 14, 0c      2 hw buttons
 * Fujitsu T725            0x470f01        05, 12, 09      2 hw buttons
 * Fujitsu H730            0x570f00        c0, 14, 0c      3 hw buttons (**)
 * Gigabyte U2442          0x450f01        58, 17, 0c      2 hw buttons
 * Lenovo L430             0x350f02        b9, 15, 0c      2 hw buttons (*)
 * Lenovo L530             0x350f02        b9, 15, 0c      2 hw buttons (*)
 * Samsung NF210           0x150b00        78, 14, 0a      2 hw buttons
 * Samsung NP770Z5E        0x575f01        10, 15, 0f      clickpad
 * Samsung NP700Z5B        0x361f06        21, 15, 0f      clickpad
 * Samsung NP900X3E-A02    0x575f03        ?               clickpad
 * Samsung NP-QX410        0x851b00        19, 14, 0c      clickpad
 * Samsung RC512           0x450f00        08, 15, 0c      2 hw buttons
 * Samsung RF710           0x450f00        ?               2 hw buttons
 * System76 Pangolin       0x250f01        ?               2 hw buttons
 * (*) + 3 trackpoint buttons
 * (**) + 0 trackpoint buttons
< ASCII >
 * Note: Lenovo L430 and Lenovo L530 have the same fw_version/caps
 */
```
## Visual type:
- #table


== ./linux/linux_404.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/mouse/elantech.h#L116-L126

```c
/*
 * New ICs are either using SMBus Host Notify or just plain PS2.
 *
< ASCII >
 * ETP_FW_VERSION_QUERY is:
 * Byte 1:
 *  - bit 0..3: IC BODY
 * Byte 2:
 *  - bit 4: HiddenButton
 *  - bit 5: PS2_SMBUS_NOTIFY
 *  - bit 6: PS2CRCCheck
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_405.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/mouse/hgpk.c#L275-L305

```c
/*
 * HGPK Mouse Mode format (standard mouse format, sans middle button)
 *
< ASCII >
 * byte 0:	y-over	x-over	y-neg	x-neg	1	0	swr	swl
 * byte 1:	x7	x6	x5	x4	x3	x2	x1	x0
 * byte 2:	y7	y6	y5	y4	y3	y2	y1	y0
< ASCII >
 *
 * swr/swl are the left/right buttons.
 * x-neg/y-neg are the x and y delta negative bits
 * x-over/y-over are the x and y overflow bits
 *
 * ---
 *
< ASCII >
 * HGPK Advanced Mode - single-mode format
 *
 * byte 0(PT):  1    1    0    0    1    1     1     1
 * byte 0(GS):  1    1    1    1    1    1     1     1
 * byte 1:      0   x6   x5   x4   x3   x2    x1    x0
 * byte 2(PT):  0    0   x9   x8   x7    ? pt-dsw    0
 * byte 2(GS):  0  x10   x9   x8   x7    ? gs-dsw pt-dsw
 * byte 3:      0   y9   y8   y7    1    0   swr   swl
 * byte 4:      0   y6   y5   y4   y3   y2    y1    y0
 * byte 5:      0   z6   z5   z4   z3   z2    z1    z0
< ASCII >
 *
 * ?'s are not defined in the protocol spec, may vary between models.
 *
 * swr/swl are the left/right buttons.
 *
 * pt-dsw/gs-dsw indicate that the pt/gs sensor is detecting a
 * pen/finger
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_406.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/mouse/vsxxxaa.c#L15-L62

```c
/*
 * Building an adaptor to DE9 / DB25 RS232
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * DISCLAIMER: Use this description AT YOUR OWN RISK! I'll not pay for
 * anything if you break your mouse, your computer or whatever!
 *
 * In theory, this mouse is a simple RS232 device. In practice, it has got
 * a quite uncommon plug and the requirement to additionally get a power
 * supply at +5V and -12V.
 *
 * If you look at the socket/jack (_not_ at the plug), we use this pin
 * numbering:
< ASCII >
 *    _______
 *   / 7 6 5 \
 *  | 4 --- 3 |
 *   \  2 1  /
 *    -------
< ASCII >
 *
 *	DEC socket	DE9	DB25	Note
 *	1 (GND)		5	7	-
 *	2 (RxD)		2	3	-
 *	3 (TxD)		3	2	-
 *	4 (-12V)	-	-	Somewhere from the PSU. At ATX, it's
 *					the thin blue wire at pin 12 of the
 *					ATX power connector. Only required for
 *					VSXXX-AA/-GA mice.
 *	5 (+5V)		-	-	PSU (red wires of ATX power connector
 *					on pin 4, 6, 19 or 20) or HDD power
 *					connector (also red wire).
 *	6 (+12V)	-	-	HDD power connector, yellow wire. Only
 *					required for VSXXX-AB digitizer.
 *	7 (dev. avail.)	-	-	The mouse shorts this one to pin 1.
 *					This way, the host computer can detect
 *					the mouse. To use it with the adaptor,
 *					simply don't connect this pin.
 *
 * So to get a working adaptor, you need to connect the mouse with three
 * wires to a RS232 port and two or three additional wires for +5V, +12V and
 * -12V to the PSU.
 *
 * Flow specification for the link is 4800, 8o1.
 *
 * The mice and tablet are described in "VCB02 Video Subsystem - Technical
 * Manual", DEC EK-104AA-TM-001. You'll find it at MANX, a search engine
 * specific for DEC documentation. Try
 * http://www.vt100.net/manx/details?pn=EK-104AA-TM-001;id=21;cp=1
 */
```
## Visual type:
- #custom


== ./linux/linux_407.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/serio/parkbd.c#L9-L41

```c
/*
 * To connect an AT or XT keyboard to the parallel port, a fairly simple adapter
 * can be made:
 * 
< ASCII >
 *  Parallel port            Keyboard port
 *
 *     +5V --------------------- +5V (4)
 *  
 *                 ______
 *     +5V -------|______|--.
 *                          |
 *     ACK (10) ------------|
 *                          |--- KBD CLOCK (5)
 *     STROBE (1) ---|<|----'
 *     
 *                 ______
 *     +5V -------|______|--.
 *                          |
 *     BUSY (11) -----------|
 *                          |--- KBD DATA (1)
 *     AUTOFD (14) --|<|----'
 *
 *     GND (18-25) ------------- GND (3)
< ASCII >
 *     
 * The diodes can be fairly any type, and the resistors should be somewhere
 * around 5 kOhm, but the adapter will likely work without the resistors,
 * too.
 *
 * The +5V source can be taken either from USB, from mouse or keyboard ports,
 * or from a joystick port. Unfortunately, the parallel port of a PC doesn't
 * have a +5V pin, and feeding the keyboard from signal pins is out of question
 * with 300 mA power reqirement of a typical AT keyboard.
 */
```
## Visual type:
- #schematic


== ./linux/linux_408.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/serio/ps2-gpio.c#L47-L63

```c
/*
 * The PS2 protocol specifies a clock frequency between 10kHz and 16.7kHz,
 * therefore the maximal interrupt interval should be 100us and the minimum
 * interrupt interval should be ~60us. Let's allow +/- 20us for frequency
 * deviations and interrupt latency.
 *
 * The data line must be samples after ~30us to 50us after the falling edge,
 * since the device updates the data line at the rising edge.
< ASCII >
 *
 * ___            ______            ______            ______            ___
 *    \          /      \          /      \          /      \          /
 *     \        /        \        /        \        /        \        /
 *      \______/          \______/          \______/          \______/
 *
 *     |-----------------|                 |--------|
 *          60us/100us                      30us/50us
< ASCII >
 */
```
## Visual type:
- #plot


== ./linux/linux_409.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/tablet/aiptek.c#L68-L163

```c
/*
 * Aiptek status packet:
 *
 * (returned as Report 1 - relative coordinates from mouse and stylus)
 *
< ASCII >
 *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
 * byte0   0     0     0     0     0     0     0     1
 * byte1   0     0     0     0     0    BS2   BS    Tip
 * byte2  X7    X6    X5    X4    X3    X2    X1    X0
 * byte3  Y7    Y6    Y5    Y4    Y3    Y2    Y1    Y0
 *
 * (returned as Report 2 - absolute coordinates from the stylus)
 *
 *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
 * byte0   0     0     0     0     0     0     1     0
 * byte1  X7    X6    X5    X4    X3    X2    X1    X0
 * byte2  X15   X14   X13   X12   X11   X10   X9    X8
 * byte3  Y7    Y6    Y5    Y4    Y3    Y2    Y1    Y0
 * byte4  Y15   Y14   Y13   Y12   Y11   Y10   Y9    Y8
 * byte5   *     *     *    BS2   BS1   Tip   IR    DV
 * byte6  P7    P6    P5    P4    P3    P2    P1    P0
 * byte7  P15   P14   P13   P12   P11   P10   P9    P8
 *
 * (returned as Report 3 - absolute coordinates from the mouse)
 *
 *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
 * byte0   0     0     0     0     0     0     1     1
 * byte1  X7    X6    X5    X4    X3    X2    X1    X0
 * byte2  X15   X14   X13   X12   X11   X10   X9    X8
 * byte3  Y7    Y6    Y5    Y4    Y3    Y2    Y1    Y0
 * byte4  Y15   Y14   Y13   Y12   Y11   Y10   Y9    Y8
 * byte5   *     *     *    BS2   BS1   Tip   IR    DV
 * byte6  P7    P6    P5    P4    P3    P2    P1    P0
 * byte7  P15   P14   P13   P12   P11   P10   P9    P8
 *
 * (returned as Report 4 - macrokeys from the stylus)
 *
 *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
 * byte0   0     0     0     0     0     1     0     0
 * byte1   0     0     0    BS2   BS    Tip   IR    DV
 * byte2   0     0     0     0     0     0     1     0
 * byte3   0     0     0    K4    K3    K2    K1    K0
 * byte4  P7    P6    P5    P4    P3    P2    P1    P0
 * byte5  P15   P14   P13   P12   P11   P10   P9    P8
 *
 * (returned as Report 5 - macrokeys from the mouse)
 *
 *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
 * byte0   0     0     0     0     0     1     0     1
 * byte1   0     0     0    BS2   BS    Tip   IR    DV
 * byte2   0     0     0     0     0     0     1     0
 * byte3   0     0     0    K4    K3    K2    K1    K0
 * byte4  P7    P6    P5    P4    P3    P2    P1    P0
 * byte5  P15   P14   P13   P12   P11   P10   P9    P8
< ASCII >
 *
 * IR: In Range = Proximity on
 * DV = Data Valid
 * BS = Barrel Switch (as in, macro keys)
 * BS2 also referred to as Tablet Pick
 *
 * Command Summary:
 *
 * Use report_type CONTROL (3)
 * Use report_id   2
 *
< ASCII >
 * Command/Data    Description     Return Bytes    Return Value
 * 0x10/0x00       SwitchToMouse       0
 * 0x10/0x01       SwitchToTablet      0
 * 0x18/0x04       SetResolution       0
 * 0x12/0xFF       AutoGainOn          0
 * 0x17/0x00       FilterOn            0
 * 0x01/0x00       GetXExtension       2           MaxX
 * 0x01/0x01       GetYExtension       2           MaxY
 * 0x02/0x00       GetModelCode        2           ModelCode = LOBYTE
 * 0x03/0x00       GetODMCode          2           ODMCode
 * 0x08/0x00       GetPressureLevels   2           =512
 * 0x04/0x00       GetFirmwareVersion  2           Firmware Version
 * 0x11/0x02       EnableMacroKeys     0
< ASCII >
 *
 * To initialize the tablet:
 *
 * (1) Send Resolution500LPI (Command)
 * (2) Query for Model code (Option Report)
 * (3) Query for ODM code (Option Report)
 * (4) Query for firmware (Option Report)
 * (5) Query for GetXExtension (Option Report)
 * (6) Query for GetYExtension (Option Report)
 * (7) Query for GetPressureLevels (Option Report)
 * (8) SwitchToTablet for Absolute coordinates, or
 *     SwitchToMouse for Relative coordinates (Command)
 * (9) EnableMacroKeys (Command)
 * (10) FilterOn (Command)
 * (11) AutoGainOn (Command)
 *
 * (Step 9 can be omitted, but you'll then have no function keys.)
 */
```
## Visual type:
- #tree


== ./linux/linux_41.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/kernel/tcm.c#L182-L232

```c
/*
 * When we are running in the non-secure world and the secure world
 * has not explicitly given us access to the TCM we will get an
 * undefined error when reading the TCM region register in the
 * setup_tcm_bank function (above).
 *
 * There are two variants of this register read that we need to trap,
 * the read for the data TCM and the read for the instruction TCM:
 *  c0370628:       ee196f11        mrc     15, 0, r6, cr9, cr1, {0}
 *  c0370674:       ee196f31        mrc     15, 0, r6, cr9, cr1, {1}
 *
 * Our undef hook mask explicitly matches all fields of the encoded
 * instruction other than the destination register.  The mask also
 * only allows operand 2 to have the values 0 or 1.
 *
 * The undefined hook is defined as __init and __initdata, and therefore
 * must be removed before tcm_init returns.
 *
 * In this particular case (MRC with ARM condition code ALways) the
 * Thumb-2 and ARM instruction encoding are identical, so this hook
 * will work on a Thumb-2 kernel.
 *
 * See A8.8.107, DDI0406C_C ARM Architecture Reference Manual, Encoding
 * T1/A1 for the bit-by-bit details.
 *
< ASCII >
 *  mrc   p15, 0, XX, c9, c1, 0
 *  mrc   p15, 0, XX, c9, c1, 1
 *   |  |  |   |   |   |   |  +---- opc2           0|1 = 000|001
 *   |  |  |   |   |   |   +------- CRm              0 = 0001
 *   |  |  |   |   |   +----------- CRn              0 = 1001
 *   |  |  |   |   +--------------- Rt               ? = ????
 *   |  |  |   +------------------- opc1             0 =  000
 *   |  |  +----------------------- coproc          15 = 1111
 *   |  +-------------------------- condition   ALways = 1110
 *   +----------------------------- instruction    MRC = 1110
 *
 * Encoding this as per A8.8.107 of DDI0406C, Encoding T1/A1, yields:
 *  1111 1111 1111 1111 0000 1111 1101 1111 Required Mask
 *  1110 1110 0001 1001 ???? 1111 0001 0001 mrc p15, 0, XX, c9, c1, 0
 *  1110 1110 0001 1001 ???? 1111 0011 0001 mrc p15, 0, XX, c9, c1, 1
 *  [  ] [  ] [ ]| [  ] [  ] [  ] [ ]| +--- CRm
 *    |    |   | |   |    |    |   | +----- SBO
 *    |    |   | |   |    |    |   +------- opc2
 *    |    |   | |   |    |    +----------- coproc
 *    |    |   | |   |    +---------------- Rt
 *    |    |   | |   +--------------------- CRn
 *    |    |   | +------------------------- SBO
 *    |    |   +--------------------------- opc1
 *    |    +------------------------------- instruction
 *    +------------------------------------ condition
< ASCII >
 */
```
## Visual type:
- #sequence


== ./linux/linux_410.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/tablet/pegasus_notetaker.c#L8-L37

```c
/*
< ASCII >
 * request packet (control endpoint):
 * |-------------------------------------|
 * | Report ID | Nr of bytes | command   |
 * | (1 byte)  | (1 byte)    | (n bytes) |
 * |-------------------------------------|
 * | 0x02      | n           |           |
 * |-------------------------------------|
< ASCII >
 *
 * data packet after set xy mode command, 0x80 0xb5 0x02 0x01
 * and pen is in range:
 *
< ASCII >
 * byte	byte name		value (bits)
 * --------------------------------------------
 * 0	status			0 1 0 0 0 0 X X
 * 1	color			0 0 0 0 H 0 S T
 * 2	X low
 * 3	X high
 * 4	Y low
 * 5	Y high
< ASCII >
 *
 * X X	battery state:
 *	no state reported	0x00
 *	battery low		0x01
 *	battery good		0x02
 *
 * H	Hovering
 * S	Switch 1 (pen button)
 * T	Tip
 */
```
## Visual type:
- #table


== ./linux/linux_411.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/touchscreen/bu21029_ts.c#L23-L38

```c
/*
< ASCII >
 * HW_ID1 Register (PAGE=0, ADDR=0x0E, Reset value=0x02, Read only)
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |   D7   |   D6   |   D5   |   D4   |   D3   |   D2   |   D1   |   D0   |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |                                 HW_IDH                                |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * HW_ID2 Register (PAGE=0, ADDR=0x0F, Reset value=0x29, Read only)
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |   D7   |   D6   |   D5   |   D4   |   D3   |   D2   |   D1   |   D0   |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |                                 HW_IDL                                |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
< ASCII >
 * HW_IDH: high 8bits of IC's ID
 * HW_IDL: low  8bits of IC's ID
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_412.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/touchscreen/bu21029_ts.c#L42-L53

```c
/*
< ASCII >
 * CFR0 Register (PAGE=0, ADDR=0x00, Reset value=0x20)
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |   D7   |   D6   |   D5   |   D4   |   D3   |   D2   |   D1   |   D0   |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |   0    |   0    |  CALIB |  INTRM |   0    |   0    |   0    |   0    |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
< ASCII >
 * CALIB: 0 = not to use calibration result (*)
 *        1 = use calibration result
 * INTRM: 0 = INT output depend on "pen down" (*)
 *        1 = INT output always "0"
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_413.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/touchscreen/bu21029_ts.c#L57-L69

```c
/*
< ASCII >
 * CFR1 Register (PAGE=0, ADDR=0x01, Reset value=0xA6)
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |   D7   |   D6   |   D5   |   D4   |   D3   |   D2   |   D1   |   D0   |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |  MAV   |         AVE[2:0]         |   0    |         SMPL[2:0]        |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
< ASCII >
 * MAV:  0 = median average filter off
 *       1 = median average filter on (*)
 * AVE:  AVE+1 = number of average samples for MAV,
 *               if AVE>SMPL, then AVE=SMPL (=3)
 * SMPL: SMPL+1 = number of conversion samples for MAV (=7)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_414.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/touchscreen/bu21029_ts.c#L73-L85

```c
/*
< ASCII >
 * CFR2 Register (PAGE=0, ADDR=0x02, Reset value=0x04)
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |   D7   |   D6   |   D5   |   D4   |   D3   |   D2   |   D1   |   D0   |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |          INTVL_TIME[3:0]          |          TIME_ST_ADC[3:0]         |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
< ASCII >
 * INTVL_TIME: waiting time between completion of conversion
 *             and start of next conversion, only usable in
 *             autoscan mode (=20.480ms)
 * TIME_ST_ADC: waiting time between application of voltage
 *              to panel and start of A/D conversion (=100us)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_415.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/touchscreen/bu21029_ts.c#L89-L106

```c
/*
< ASCII >
 * CFR3 Register (PAGE=0, ADDR=0x0B, Reset value=0x72)
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |   D7   |   D6   |   D5   |   D4   |   D3   |   D2   |   D1   |   D0   |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |  RM8   | STRETCH|  PU90K |  DUAL  |           PIDAC_OFS[3:0]          |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
< ASCII >
 * RM8: 0 = coordinate resolution is 12bit (*)
 *      1 = coordinate resolution is 8bit
 * STRETCH: 0 = SCL_STRETCH function off
 *          1 = SCL_STRETCH function on (*)
 * PU90K: 0 = internal pull-up resistance for touch detection is ~50kohms (*)
 *        1 = internal pull-up resistance for touch detection is ~90kohms
 * DUAL: 0 = dual touch detection off (*)
 *       1 = dual touch detection on
 * PIDAC_OFS: dual touch detection circuit adjustment, it is not necessary
 *            to change this from initial value
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_416.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/touchscreen/bu21029_ts.c#L110-L119

```c
/*
< ASCII >
 * LDO Register (PAGE=0, ADDR=0x0C, Reset value=0x00)
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |   D7   |   D6   |   D5   |   D4   |   D3   |   D2   |   D1   |   D0   |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |   0    |         PVDD[2:0]        |   0    |         AVDD[2:0]        |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
< ASCII >
 * PVDD: output voltage of panel output regulator (=2.000V)
 * AVDD: output voltage of analog circuit regulator (=2.000V)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_417.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/touchscreen/bu21029_ts.c#L123-L136

```c
/*
< ASCII >
 * Serial Interface Command Byte 1 (CID=1)
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |   D7   |   D6   |   D5   |   D4   |   D3   |   D2   |   D1   |   D0   |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * |   1    |                 CF                |  CMSK  |  PDM   |  STP   |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
< ASCII >
 * CF: conversion function, see table 3 in datasheet p6 (=0000, automatic scan)
 * CMSK: 0 = executes convert function (*)
 *       1 = reads the convert result
 * PDM: 0 = power down after convert function stops (*)
 *      1 = keep power on after convert function stops
 * STP: 1 = abort current conversion and power down, set to "0" automatically
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_418.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/touchscreen/max11801_ts.c#L12-L29

```c
/*
 * This driver aims to support the series of MAXI touch chips max11801
 * through max11803. The main difference between these 4 chips can be
 * found in the table below:
< ASCII >
 * -----------------------------------------------------
 * | CHIP     |  AUTO MODE SUPPORT(FIFO) | INTERFACE    |
 * |----------------------------------------------------|
 * | max11800 |  YES                     |   SPI        |
 * | max11801 |  YES                     |   I2C        |
 * | max11802 |  NO                      |   SPI        |
 * | max11803 |  NO                      |   I2C        |
 * ------------------------------------------------------
< ASCII >
 *
 * Currently, this driver only supports max11801.
 *
 * Data Sheet:
 * http://www.maxim-ic.com/datasheet/index.mvp/id/5943
 */
```
## Visual type:
- #table


== ./linux/linux_419.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/touchscreen/mxs-lradc-ts.c#L260-L271

```c
/*
< ASCII >
 * YP(open)--+-------------+
 *	     |		   |--+
 *	     |		   |  |
 *    YM(-)--+-------------+  |
 *	       +--------------+
 *	       |	      |
 *	   XP(weak+)	    XM(open)
< ASCII >
 *
 * "weak+" means 200k Ohm VDDIO
 * (-) means GND
 */
```
## Visual type:
- #schematic


== ./linux/linux_42.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/lib/backtrace-clang.S#L30-L97

```c
/*
 * Clang does not store pc or sp in function prologues so we don't know exactly
 * where the function starts.
 *
 * We can treat the current frame's lr as the saved pc and the preceding
 * frame's lr as the current frame's lr, but we can't trace the most recent
 * call.  Inserting a false stack frame allows us to reference the function
 * called last in the stacktrace.
 *
 * If the call instruction was a bl we can look at the callers branch
 * instruction to calculate the saved pc.  We can recover the pc in most cases,
 * but in cases such as calling function pointers we cannot. In this case,
 * default to using the lr. This will be some address in the function, but will
 * not be the function start.
 *
 * Unfortunately due to the stack frame layout we can't dump r0 - r3, but these
 * are less frequently saved.
 *
< ASCII >
 * Stack frame layout:
 * 		<larger addresses>
 * 		saved lr
 * 	frame=> saved fp
 * 		optionally saved caller registers (r4 - r10)
 * 		optionally saved arguments (r0 - r3)
 * 		<top of stack frame>
 * 		<smaller addresses>
< ASCII >
 *
 * Functions start with the following code sequence:
 * corrected pc =>  stmfd sp!, {..., fp, lr}
 *		add fp, sp, #x
 *		stmfd sp!, {r0 - r3} (optional)
 *
 *
 *
 *
 *
 *
 * The diagram below shows an example stack setup for dump_stack.
 *
 * The frame for c_backtrace has pointers to the code of dump_stack. This is
 * why the frame of c_backtrace is used to for the pc calculation of
 * dump_stack. This is why we must move back a frame to print dump_stack.
 *
 * The stored locals for dump_stack are in dump_stack's frame. This means that
 * to fully print dump_stack's frame we need both the frame for dump_stack (for
 * locals) and the frame that was called by dump_stack (for pc).
 *
 * To print locals we must know where the function start is. If we read the
 * function prologue opcodes we can determine which variables are stored in the
 * stack frame.
 *
 * To find the function start of dump_stack we can look at the stored LR of
 * show_stack. It points at the instruction directly after the bl dump_stack.
 * We can then read the offset from the bl opcode to determine where the branch
 * takes us.  The address calculated must be the start of dump_stack.
 *
< ASCII >
 * c_backtrace frame           dump_stack:
 * {[LR]    }  ============|   ...
 * {[FP]    }  =======|    |   bl c_backtrace
 *                    |    |=> ...
 * {[R4-R10]}         |
 * {[R0-R3] }         |        show_stack:
 * dump_stack frame   |        ...
 * {[LR]    } =============|   bl dump_stack
 * {[FP]    } <=======|    |=> ...
 * {[R4-R10]}
 * {[R0-R3] }
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_420.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/touchscreen/mxs-lradc-ts.c#L288-L299

```c
/*
< ASCII >
 * YP(meas)--+-------------+
 *	     |		   |--+
 *	     |		   |  |
 * YM(open)--+-------------+  |
 *	       +--------------+
 *	       |	      |
 *	     XP(+)	    XM(-)
< ASCII >
 *
 * (+) means here 1.85 V
 * (-) means here GND
 */
```
## Visual type:
- #schematic


== ./linux/linux_421.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/touchscreen/mxs-lradc-ts.c#L314-L325

```c
/*
< ASCII >
 *   YP(+)--+-------------+
 *	    |		  |--+
 *	    |		  |  |
 *   YM(-)--+-------------+  |
 *	      +--------------+
 *	      |		     |
 *	   XP(open)	   XM(meas)
< ASCII >
 *
 * (+) means here 1.85 V
 * (-) means here GND
 */
```
## Visual type:
- #schematic


== ./linux/linux_422.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/touchscreen/mxs-lradc-ts.c#L340-L351

```c
/*
< ASCII >
 *    YP(+)--+-------------+
 *	     |		   |--+
 *	     |		   |  |
 * YM(meas)--+-------------+  |
 *	       +--------------+
 *	       |	      |
 *	    XP(meas)	    XM(-)
< ASCII >
 *
 * (+) means here 1.85 V
 * (-) means here GND
 */
```
## Visual type:
- #schematic


== ./linux/linux_423.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/input/touchscreen/touchit213.c#L31-L53

```c
/*
 * Data is received through COM1 at 9600bit/s,8bit,no parity in packets
 * of 5 byte each.
 *
< ASCII >
 *   +--------+   +--------+   +--------+   +--------+   +--------+
 *   |1000000p|   |0xxxxxxx|   |0xxxxxxx|   |0yyyyyyy|   |0yyyyyyy|
 *   +--------+   +--------+   +--------+   +--------+   +--------+
 *                    MSB          LSB          MSB          LSB
< ASCII >
 *
 * The value of p is 1 as long as the screen is touched and 0 when
 * reporting the location where touching stopped, e.g. where the pen was
 * lifted from the screen.
 *
 * When holding the screen in landscape mode as the BIOS text output is
 * presented, x is the horizontal axis with values growing from left to
 * right and y is the vertical axis with values growing from top to
 * bottom.
 *
 * When holding the screen in portrait mode with the Sahara logo in its
 * correct position, x ist the vertical axis with values growing from
 * top to bottom and y is the horizontal axis with values growing from
 * right to left.
 */
```
## Visual type:
- #sequence


== ./linux/linux_424.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/iommu/mtk_iommu.c#L278-L299

```c
/*
 * In M4U 4GB mode, the physical address is remapped as below:
 *
< ASCII >
 * CPU Physical address:
 * ====================
 *
 * 0      1G       2G     3G       4G     5G
 * |---A---|---B---|---C---|---D---|---E---|
 * +--I/O--+------------Memory-------------+
< ASCII >
< ASCII >
 *
 * IOMMU output physical address:
 *  =============================
 *
 *                                 4G      5G     6G      7G      8G
 *                                 |---E---|---B---|---C---|---D---|
 *                                 +------------Memory-------------+
< ASCII >
 *
 * The Region 'A'(I/O) can NOT be mapped by M4U; For Region 'B'/'C'/'D', the
 * bit32 of the CPU physical address always is needed to set, and for Region
 * 'E', the CPU physical address keep as is.
 * Additionally, The iommu consumers always use the CPU phyiscal address.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_425.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/iommu/rockchip-iommu.c#L141-L171

```c
/*
 * The Rockchip rk3288 iommu uses a 2-level page table.
 * The first level is the "Directory Table" (DT).
 * The DT consists of 1024 4-byte Directory Table Entries (DTEs), each pointing
 * to a "Page Table".
 * The second level is the 1024 Page Tables (PT).
 * Each PT consists of 1024 4-byte Page Table Entries (PTEs), each pointing to
 * a 4 KB page of physical memory.
 *
 * The DT and each PT fits in a single 4 KB page (4-bytes * 1024 entries).
 * Each iommu device has a MMU_DTE_ADDR register that contains the physical
 * address of the start of the DT page.
 *
 * The structure of the page table is as follows:
 *
< ASCII >
 *                   DT
 * MMU_DTE_ADDR -> +-----+
 *                 |     |
 *                 +-----+     PT
 *                 | DTE | -> +-----+
 *                 +-----+    |     |     Memory
 *                 |     |    +-----+     Page
 *                 |     |    | PTE | -> +-----+
 *                 +-----+    +-----+    |     |
 *                            |     |    |     |
 *                            |     |    |     |
 *                            +-----+    |     |
 *                                       |     |
 *                                       |     |
 *                                       +-----+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_426.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/iommu/rockchip-iommu.c#L236-L255

```c
/*
 * Each PTE has a Page address, some flags and a valid bit:
< ASCII >
 * +---------------------+---+-------+-+
 * | Page address        |Rsv| Flags |V|
 * +---------------------+---+-------+-+
< ASCII >
 *  31:12 - Page address (Pages always start on a 4 KB boundary)
 *  11: 9 - Reserved
 *   8: 1 - Flags
 *      8 - Read allocate - allocate cache space on read misses
 *      7 - Read cache - enable cache & prefetch of data
 *      6 - Write buffer - enable delaying writes on their way to memory
 *      5 - Write allocate - allocate cache space on write misses
 *      4 - Write cache - different writes can be merged together
 *      3 - Override cache attributes
 *          if 1, bits 4-8 control cache attributes
 *          if 0, the system bus defaults are used
 *      2 - Writable
 *      1 - Readable
 *      0 - 1 if Page @ Page address is valid
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_427.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/iommu/rockchip-iommu.c#L303-L312

```c
/*
< ASCII >
 * rk3288 iova (IOMMU Virtual Address) format
 *  31       22.21       12.11          0
 * +-----------+-----------+-------------+
 * | DTE index | PTE index | Page offset |
 * +-----------+-----------+-------------+
< ASCII >
 *  31:22 - DTE index   - index of DTE in DT
 *  21:12 - PTE index   - index of PTE in PT @ DTE.pt_address
 *  11: 0 - Page offset - offset into page @ PTE.page_address
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_428.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/iommu/sun50i-iommu.c#L180-L190

```c
/*
 * Each Directory Table Entry has a Page Table address and a valid
 * bit:

< ASCII >
 * +---------------------+-----------+-+
 * | PT address          | Reserved  |V|
 * +---------------------+-----------+-+
< ASCII >
 *  31:10 - Page Table address
 *   9:2  - Reserved
 *   1:0  - 1 if the entry is valid
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_429.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/iommu/sun50i-iommu.c#L211-L242

```c
/*
 * Each PTE has a Page address, an authority index and a valid bit:
 *
< ASCII >
 * +----------------+-----+-----+-----+---+-----+
 * | Page address   | Rsv | ACI | Rsv | V | Rsv |
 * +----------------+-----+-----+-----+---+-----+
< ASCII >
 *  31:12 - Page address
 *  11:8  - Reserved
 *   7:4  - Authority Control Index
 *   3:2  - Reserved
 *     1  - 1 if the entry is valid
 *     0  - Reserved
 *
 * The way permissions work is that the IOMMU has 16 "domains" that
 * can be configured to give each masters either read or write
 * permissions through the IOMMU_DM_AUT_CTRL_REG registers. The domain
 * 0 seems like the default domain, and its permissions in the
 * IOMMU_DM_AUT_CTRL_REG are only read-only, so it's not really
 * useful to enforce any particular permission.
 *
 * Each page entry will then have a reference to the domain they are
 * affected to, so that we can actually enforce them on a per-page
 * basis.
 *
 * In order to make it work with the IOMMU framework, we will be using
 * 4 different domains, starting at 1: RD_WR, RD, WR and NONE
 * depending on the permission we want to enforce. Each domain will
 * have each master setup in the same way, since the IOMMU framework
 * doesn't seem to restrict page access on a per-device basis. And
 * then we will use the relevant domain index when generating the page
 * table entry depending on the permissions we want to be enforced.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_43.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-imx/mx3x.h#L10-L31

```c
/*
 * MX31 memory map:
 *
< ASCII >
 * Virt		Phys		Size	What
 * ---------------------------------------------------------------------------
 * FC000000	43F00000	1M	AIPS 1
 * FC100000	50000000	1M	SPBA
 * FC200000	53F00000	1M	AIPS 2
 * FC500000	60000000	128M	ROMPATCH
 * FC400000	68000000	128M	AVIC
 *         	70000000	256M	IPU (MAX M2)
 *         	80000000	256M	CSD0 SDRAM/DDR
 *         	90000000	256M	CSD1 SDRAM/DDR
 *         	A0000000	128M	CS0 Flash
 *         	A8000000	128M	CS1 Flash
 *         	B0000000	32M	CS2
 *         	B2000000	32M	CS3
 * F4000000	B4000000	32M	CS4
 *         	B6000000	32M	CS5
 * FC320000	B8000000	64K	NAND, SDRAM, WEIM, M3IF, EMI controllers
 *         	C0000000	64M	PCMCIA/CF
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_430.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/irqchip/irq-armada-370-xp.c#L37-L115

```c
/*
< ASCII >
 * Overall diagram of the Armada XP interrupt controller:
 *
 *    To CPU 0                 To CPU 1
 *
 *       /\                       /\
 *       ||                       ||
 * +---------------+     +---------------+
 * |               |	 |               |
 * |    per-CPU    |	 |    per-CPU    |
 * |  mask/unmask  |	 |  mask/unmask  |
 * |     CPU0      |	 |     CPU1      |
 * |               |	 |               |
 * +---------------+	 +---------------+
 *        /\                       /\
 *        ||                       ||
 *        \\_______________________//
 *                     ||
 *            +-------------------+
 *            |                   |
 *            | Global interrupt  |
 *            |    mask/unmask    |
 *            |                   |
 *            +-------------------+
 *                     /\
 *                     ||
 *               interrupt from
 *                   device
< ASCII >
 *
 * The "global interrupt mask/unmask" is modified using the
 * ARMADA_370_XP_INT_SET_ENABLE_OFFS and
 * ARMADA_370_XP_INT_CLEAR_ENABLE_OFFS registers, which are relative
 * to "main_int_base".
 *
 * The "per-CPU mask/unmask" is modified using the
 * ARMADA_370_XP_INT_SET_MASK_OFFS and
 * ARMADA_370_XP_INT_CLEAR_MASK_OFFS registers, which are relative to
 * "per_cpu_int_base". This base address points to a special address,
 * which automatically accesses the registers of the current CPU.
 *
 * The per-CPU mask/unmask can also be adjusted using the global
 * per-interrupt ARMADA_370_XP_INT_SOURCE_CTL register, which we use
 * to configure interrupt affinity.
 *
 * Due to this model, all interrupts need to be mask/unmasked at two
 * different levels: at the global level and at the per-CPU level.
 *
 * This driver takes the following approach to deal with this:
 *
 *  - For global interrupts:
 *
 *    At ->map() time, a global interrupt is unmasked at the per-CPU
 *    mask/unmask level. It is therefore unmasked at this level for
 *    the current CPU, running the ->map() code. This allows to have
 *    the interrupt unmasked at this level in non-SMP
 *    configurations. In SMP configurations, the ->set_affinity()
 *    callback is called, which using the
 *    ARMADA_370_XP_INT_SOURCE_CTL() readjusts the per-CPU mask/unmask
 *    for the interrupt.
 *
 *    The ->mask() and ->unmask() operations only mask/unmask the
 *    interrupt at the "global" level.
 *
 *    So, a global interrupt is enabled at the per-CPU level as soon
 *    as it is mapped. At run time, the masking/unmasking takes place
 *    at the global level.
 *
 *  - For per-CPU interrupts
 *
 *    At ->map() time, a per-CPU interrupt is unmasked at the global
 *    mask/unmask level.
 *
 *    The ->mask() and ->unmask() operations mask/unmask the interrupt
 *    at the per-CPU level.
 *
 *    So, a per-CPU interrupt is enabled at the global level as soon
 *    as it is mapped. At run time, the masking/unmasking takes place
 *    at the per-CPU level.
 */
```
## Visual type:
- #flowchart


== ./linux/linux_431.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/irqchip/irq-imx-intmux.c#L4-L45

```c
/*                     INTMUX Block Diagram
 *
 *    
< ASCII >                           ________________
 * interrupt source #  0  +---->|                |
 *                        |     |                |
 * interrupt source #  1  +++-->|                |
 *            ...         | |   |   channel # 0  |--------->interrupt out # 0
 *            ...         | |   |                |
 *            ...         | |   |                |
 * interrupt source # X-1 +++-->|________________|
 *                        | | |
 *                        | | |
 *                        | | |  ________________
 *                        +---->|                |
 *                        | | | |                |
 *                        | +-->|                |
 *                        | | | |   channel # 1  |--------->interrupt out # 1
 *                        | | +>|                |
 *                        | | | |                |
 *                        | | | |________________|
 *                        | | |
 *                        | | |
 *                        | | |       ...
 *                        | | |       ...
 *                        | | |
 *                        | | |  ________________
 *                        +---->|                |
 *                          | | |                |
 *                          +-->|                |
 *                            | |   channel # N  |--------->interrupt out # N
 *                            +>|                |
 *                              |                |
 *                              |________________|
< ASCII >
 *
 *
 * N: Interrupt Channel Instance Number (N=7)
 * X: Interrupt Source Number for each channel (X=32)
 *
 * The INTMUX interrupt multiplexer has 8 channels, each channel receives 32
 * interrupt sources and generates 1 interrupt output.
 *
 */
```
## Visual type:
- #schematic


== ./linux/linux_432.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/irqchip/irq-qcom-mpm.c#L24-L63

```c
/*
 * This is the driver for Qualcomm MPM (MSM Power Manager) interrupt controller,
 * which is commonly found on Qualcomm SoCs built on the RPM architecture.
 * Sitting in always-on domain, MPM monitors the wakeup interrupts when SoC is
 * asleep, and wakes up the AP when one of those interrupts occurs.  This driver
 * doesn't directly access physical MPM registers though.  Instead, the access
 * is bridged via a piece of internal memory (SRAM) that is accessible to both
 * AP and RPM.  This piece of memory is called 'vMPM' in the driver.
 *
 * When SoC is awake, the vMPM is owned by AP and the register setup by this
 * driver all happens on vMPM.  When AP is about to get power collapsed, the
 * driver sends a mailbox notification to RPM, which will take over the vMPM
 * ownership and dump vMPM into physical MPM registers.  On wakeup, AP is woken
 * up by a MPM pin/interrupt, and RPM will copy STATUS registers into vMPM.
 * Then AP start owning vMPM again.
 *
< ASCII >
 * vMPM register map:
 *
 *    31                              0
 *    +--------------------------------+
 *    |            TIMER0              | 0x00
 *    +--------------------------------+
 *    |            TIMER1              | 0x04
 *    +--------------------------------+
 *    |            ENABLE0             | 0x08
 *    +--------------------------------+
 *    |              ...               | ...
 *    +--------------------------------+
 *    |            ENABLEn             |
 *    +--------------------------------+
 *    |          FALLING_EDGE0         |
 *    +--------------------------------+
 *    |              ...               |
 *    +--------------------------------+
 *    |            STATUSn             |
 *    +--------------------------------+
< ASCII >
 *
 *    n = DIV_ROUND_UP(pin_cnt, 32)
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_433.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/isdn/mISDN/dsp_core.c#L21-L152

```c
/* STRUCTURE:
 *
 * The dsp module provides layer 2 for b-channels (64kbit). It provides
 * transparent audio forwarding with special digital signal processing:
 *
 * - (1) generation of tones
 * - (2) detection of dtmf tones
 * - (3) crossconnecting and conferences (clocking)
 * - (4) echo generation for delay test
 * - (5) volume control
 * - (6) disable receive data
 * - (7) pipeline
 * - (8) encryption/decryption
 *
< ASCII >
 * Look:
 *             TX            RX
 *         ------upper layer------
 *             |             ^
 *             |             |(6)
 *             v             |
 *       +-----+-------------+-----+
 *       |(3)(4)                   |
 *       |           CMX           |
 *       |                         |
 *       |           +-------------+
 *       |           |       ^
 *       |           |       |
 *       |+---------+|  +----+----+
 *       ||(1)      ||  |(2)      |
 *       ||         ||  |         |
 *       ||  Tones  ||  |  DTMF   |
 *       ||         ||  |         |
 *       ||         ||  |         |
 *       |+----+----+|  +----+----+
 *       +-----+-----+       ^
 *             |             |
 *             v             |
 *        +----+----+   +----+----+
 *        |(5)      |   |(5)      |
 *        |         |   |         |
 *        |TX Volume|   |RX Volume|
 *        |         |   |         |
 *        |         |   |         |
 *        +----+----+   +----+----+
 *             |             ^
 *             |             |
 *             v             |
 *        +----+-------------+----+
 *        |(7)                    |
 *        |                       |
 *        |  Pipeline Processing  |
 *        |                       |
 *        |                       |
 *        +----+-------------+----+
 *             |             ^
 *             |             |
 *             v             |
 *        +----+----+   +----+----+
 *        |(8)      |   |(8)      |
 *        |         |   |         |
 *        | Encrypt |   | Decrypt |
 *        |         |   |         |
 *        |         |   |         |
 *        +----+----+   +----+----+
 *             |             ^
 *             |             |
 *             v             |
 *         ------card  layer------
 *             TX            RX
< ASCII >
 *
 * Above you can see the logical data flow. If software is used to do the
 * process, it is actually the real data flow. If hardware is used, data
 * may not flow, but hardware commands to the card, to provide the data flow
 * as shown.
 *
 * NOTE: The channel must be activated in order to make dsp work, even if
 * no data flow to the upper layer is intended. Activation can be done
 * after and before controlling the setting using PH_CONTROL requests.
 *
 * DTMF: Will be detected by hardware if possible. It is done before CMX
 * processing.
 *
 * Tones: Will be generated via software if endless looped audio fifos are
 * not supported by hardware. Tones will override all data from CMX.
 * It is not required to join a conference to use tones at any time.
 *
 * CMX: Is transparent when not used. When it is used, it will do
 * crossconnections and conferences via software if not possible through
 * hardware. If hardware capability is available, hardware is used.
 *
 * Echo: Is generated by CMX and is used to check performance of hard and
 * software CMX.
 *
 * The CMX has special functions for conferences with one, two and more
 * members. It will allow different types of data flow. Receive and transmit
 * data to/form upper layer may be switched on/off individually without losing
 * features of CMX, Tones and DTMF.
 *
 * Echo Cancellation: Sometimes we like to cancel echo from the interface.
 * Note that a VoIP call may not have echo caused by the IP phone. The echo
 * is generated by the telephone line connected to it. Because the delay
 * is high, it becomes an echo. RESULT: Echo Cachelation is required if
 * both echo AND delay is applied to an interface.
 * Remember that software CMX always generates a more or less delay.
 *
 * If all used features can be realized in hardware, and if transmit and/or
 * receive data ist disabled, the card may not send/receive any data at all.
 * Not receiving is useful if only announcements are played. Not sending is
 * useful if an answering machine records audio. Not sending and receiving is
 * useful during most states of the call. If supported by hardware, tones
 * will be played without cpu load. Small PBXs and NT-Mode applications will
 * not need expensive hardware when processing calls.
 *
 *
 * LOCKING:
 *
 * When data is received from upper or lower layer (card), the complete dsp
 * module is locked by a global lock.  This lock MUST lock irq, because it
 * must lock timer events by DSP poll timer.
 * When data is ready to be transmitted down, the data is queued and sent
 * outside lock and timer event.
 * PH_CONTROL must not change any settings, join or split conference members
 * during process of data.
 *
 * HDLC:
 *
 * It works quite the same as transparent, except that HDLC data is forwarded
 * to all other conference members if no hardware bridging is possible.
 * Send data will be writte to sendq. Sendq will be sent if confirm is received.
 * Conference cannot join, if one member is not hdlc.
 *
 */
```
## Visual type:
- #flowchart


== ./linux/linux_434.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/leds/leds-cr0014114.c#L12-L30

```c
/*
< ASCII >
 *  CR0014114 SPI protocol descrtiption:
 *  +----+-----------------------------------+----+
 *  | CMD|             BRIGHTNESS            |CRC |
 *  +----+-----------------------------------+----+
 *  |    | LED0| LED1| LED2| LED3| LED4| LED5|    |
 *  |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |
 *  |    |R|G|B|R|G|B|R|G|B|R|G|B|R|G|B|R|G|B|    |
 *  | 1  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 1  |
 *  |    |1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|    |
 *  |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |
 *  |    |               18                  |    |
 *  +----+-----------------------------------+----+
 *  |                    20                       |
 *  +---------------------------------------------+
< ASCII >
 *
 *  PS: Boards can be connected to the chain:
 *      SPI -> board0 -> board1 -> board2 ..
 */
```
## Visual type:
- #custom


== ./linux/linux_435.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/leds/leds-el15203000.c#L12-L48

```c
/*
< ASCII >
 * EL15203000 SPI protocol description:
 * +-----+---------+
 * | LED | COMMAND |
 * +-----+---------+
 * |  1  |    1    |
 * +-----+---------+
< ASCII >
 * (*) LEDs MCU board expects 20 msec delay per byte.
 *
< ASCII >
 * LEDs:
 * +----------+--------------+-------------------------------------------+
 * |    ID    |     NAME     |         DESCRIPTION                       |
 * +----------+--------------+-------------------------------------------+
 * | 'P' 0x50 |     Pipe     | Consists from 5 LEDs, controlled by board |
 * +----------+--------------+-------------------------------------------+
 * | 'S' 0x53 | Screen frame | Light tube around the screen              |
 * +----------+--------------+-------------------------------------------+
 * | 'V' 0x56 | Vending area | Highlights a cup of coffee                |
 * +----------+--------------+-------------------------------------------+
 *
< ASCII >
< ASCII >
 * COMMAND:
 * +----------+-----------------+--------------+--------------+
 * |  VALUES  |       PIPE      | SCREEN FRAME | VENDING AREA |
 * +----------+-----------------+--------------+--------------+
 * | '0' 0x30 |                      Off                      |
 * +----------+-----------------------------------------------+
 * | '1' 0x31 |                      On                       |
 * +----------+-----------------+--------------+--------------+
 * | '2' 0x32 |     Cascade     |   Breathing  |
 * +----------+-----------------+--------------+
 * | '3' 0x33 | Inverse cascade |
 * +----------+-----------------+
 * | '4' 0x34 |     Bounce      |
 * +----------+-----------------+
 * | '5' 0x35 | Inverse bounce  |
 * +----------+-----------------+
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_436.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/macintosh/via-cuda.c#L57-L72

```c
/*
 * When the Cuda design replaced the Egret, some signal names and
 * logic sense changed. They all serve the same purposes, however.
 *
< ASCII >
 *   VIA pin       |  Egret pin
 * ----------------+------------------------------------------
 *   PB3 (input)   |  Transceiver session   (active low)
 *   PB4 (output)  |  VIA full              (active high)
 *   PB5 (output)  |  System session        (active high)
 *
 *   VIA pin       |  Cuda pin
 * ----------------+------------------------------------------
 *   PB3 (input)   |  Transfer request      (active low)
 *   PB4 (output)  |  Byte acknowledge      (active low)
 *   PB5 (output)  |  Transfer in progress  (active low)
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_437.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/mailbox/arm_mhuv2.c#L418-L444

```c
/*
 * Message will be transmitted from most significant to least significant word.
 * This is to allow for messages shorter than channel windows to still trigger
 * the receiver interrupt which gets activated when the last stat register is
 * written. As an example, a 6-word message is to be written on a 4-channel MHU
 * connection: Registers marked with '*' are masked, and will not generate an
 * interrupt on the receiver side once written.
 *
 * u32 *data =	[0x00000001], [0x00000002], [0x00000003], [0x00000004],
 *		[0x00000005], [0x00000006]
 *
< ASCII >
 * ROUND 1:
 * stat reg		To write	Write sequence
 * [ stat 3 ]	<-	[0x00000001]	4 <- triggers interrupt on receiver
 * [ stat 2 ]	<-	[0x00000002]	3
 * [ stat 1 ]	<-	[0x00000003]	2
 * [ stat 0 ]	<-	[0x00000004]	1
 *
 * data += 4 // Increment data pointer by number of stat regs
 *
 * ROUND 2:
 * stat reg		To write	Write sequence
 * [ stat 3 ]	<-	[0x00000005]	2 <- triggers interrupt on receiver
 * [ stat 2 ]	<-	[0x00000006]	1
 * [ stat 1 ]	<-	[0x00000000]
 * [ stat 0 ]	<-	[0x00000000]
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_438.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/md/dm.c#L1287-L1316

```c
/*
 * A target may call dm_accept_partial_bio only from the map routine.  It is
 * allowed for all bio types except REQ_PREFLUSH, REQ_OP_ZONE_* zone management
 * operations, REQ_OP_ZONE_APPEND (zone append writes) and any bio serviced by
 * __send_duplicate_bios().
 *
 * dm_accept_partial_bio informs the dm that the target only wants to process
 * additional n_sectors sectors of the bio and the rest of the data should be
 * sent in a next bio.
 *
< ASCII >
 * A diagram that explains the arithmetics:
 * +--------------------+---------------+-------+
 * |         1          |       2       |   3   |
 * +--------------------+---------------+-------+
 *
 * <-------------- *tio->len_ptr --------------->
 *                      <----- bio_sectors ----->
 *                      <-- n_sectors -->
< ASCII >
 *
 * Region 1 was already iterated over with bio_advance or similar function.
 *	(it may be empty if the target doesn't use bio_advance)
 * Region 2 is the remaining bio size that the target wants to process.
 *	(it may be empty if region 1 is non-empty, although there is no reason
 *	 to make it empty)
 * The target requires that region 3 is to be sent in the next bio.
 *
 * If the target wants to receive multiple copies of the bio (via num_*bios, etc),
 * the partially processed part (the sum of regions 1+2) must be the same for all
 * copies of the bio.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_439.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/md/md-bitmap.h#L19-L79

```c
/*
 * in-memory bitmap:
 *
 * Use 16 bit block counters to track pending writes to each "chunk".
 * The 2 high order bits are special-purpose, the first is a flag indicating
 * whether a resync is needed.  The second is a flag indicating whether a
 * resync is active.
 * This means that the counter is actually 14 bits:
 *
< ASCII >
 * +--------+--------+------------------------------------------------+
 * | resync | resync |               counter                          |
 * | needed | active |                                                |
 * |  (0-1) |  (0-1) |              (0-16383)                         |
 * +--------+--------+------------------------------------------------+
< ASCII >
 *
 * The "resync needed" bit is set when:
 *    a '1' bit is read from storage at startup.
 *    a write request fails on some drives
 *    a resync is aborted on a chunk with 'resync active' set
 * It is cleared (and resync-active set) when a resync starts across all drives
 * of the chunk.
 *
 *
 * The "resync active" bit is set when:
 *    a resync is started on all drives, and resync_needed is set.
 *       resync_needed will be cleared (as long as resync_active wasn't already set).
 * It is cleared when a resync completes.
 *
 * The counter counts pending write requests, plus the on-disk bit.
 * When the counter is '1' and the resync bits are clear, the on-disk
 * bit can be cleared as well, thus setting the counter to 0.
 * When we set a bit, or in the counter (to start a write), if the fields is
 * 0, we first set the disk bit and set the counter to 1.
 *
 * If the counter is 0, the on-disk bit is clear and the stripe is clean
 * Anything that dirties the stripe pushes the counter to 2 (at least)
 * and sets the on-disk bit (lazily).
 * If a periodic sweep find the counter at 2, it is decremented to 1.
 * If the sweep find the counter at 1, the on-disk bit is cleared and the
 * counter goes to zero.
 *
 * Also, we'll hijack the "map" pointer itself and use it as two 16 bit block
 * counters as a fallback when "page" memory cannot be allocated:
 *
< ASCII >
 * Normal case (page memory allocated):
 *
 *     page pointer (32-bit)
 *
 *     [ ] ------+
 *               |
 *               +-------> [   ][   ]..[   ] (4096 byte page == 2048 counters)
 *                          c1   c2    c2048
< ASCII >
 *
< ASCII >
 * Hijacked case (page memory allocation failed):
 *
 *     hijacked page pointer (32-bit)
 *
 *     [		  ][		  ] (no page memory allocated)
 *      counter #1 (16-bit) counter #2 (16-bit)
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_44.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-imx/pm-imx6.c#L67-L79

```c
/*
< ASCII >
 * suspend ocram space layout:
 * ======================== high address ======================
 *                              .
 *                              .
 *                              .
 *                              ^
 *                              ^
 *                              ^
 *                      imx6_suspend code
 *              PM_INFO structure(imx6_cpu_pm_info)
 * ======================== low address =======================
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_440.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/md/raid10.c#L26-L65

```c
/*
 * RAID10 provides a combination of RAID0 and RAID1 functionality.
 * The layout of data is defined by
 *    chunk_size
 *    raid_disks
 *    near_copies (stored in low byte of layout)
 *    far_copies (stored in second byte of layout)
 *    far_offset (stored in bit 16 of layout )
 *    use_far_sets (stored in bit 17 of layout )
 *    use_far_sets_bugfixed (stored in bit 18 of layout )
 *
 * The data to be stored is divided into chunks using chunksize.  Each device
 * is divided into far_copies sections.   In each section, chunks are laid out
 * in a style similar to raid0, but near_copies copies of each chunk is stored
 * (each on a different drive).  The starting device for each section is offset
 * near_copies from the starting device of the previous section.  Thus there
 * are (near_copies * far_copies) of each chunk, and each is on a different
 * drive.  near_copies and far_copies must be at least one, and their product
 * is at most raid_disks.
 *
 * If far_offset is true, then the far_copies are handled a bit differently.
 * The copies are still in different stripes, but instead of being very far
 * apart on disk, there are adjacent stripes.
 *
 * The far and offset algorithms are handled slightly differently if
 * 'use_far_sets' is true.  In this case, the array's devices are grouped into
 * sets that are (near_copies * far_copies) in size.  The far copied stripes
 * are still shifted by 'near_copies' devices, but this shifting stays confined
 * to the set rather than the entire array.  This is done to improve the number
 * of device combinations that can fail without causing the array to fail.
< ASCII >
 * Example 'far' algorithm w/o 'use_far_sets' (each letter represents a chunk
 * on a device):
 *    A B C D    A B C D E
 *      ...         ...
 *    D A B C    E A B C D
< ASCII >
< ASCII >
 * Example 'far' algorithm w/ 'use_far_sets' enabled (sets illustrated w/ []'s):
 *    [A B] [C D]    [A B] [C D E]
 *    |...| |...|    |...| | ... |
 *    [B A] [D C]    [B A] [E C D]
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_441.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/md/raid5-cache.c#L2290-L2344

```c
/*
 * Before recovery, the log looks like the following
 *
< ASCII >
 *   ---------------------------------------------
 *   |           valid log        | invalid log  |
 *   ---------------------------------------------
 *   ^
 *   |- log->last_checkpoint
 *   |- log->last_cp_seq
< ASCII >
 * Now we scan through the log until we see invalid entry
 *
< ASCII >
 *   ---------------------------------------------
 *   |           valid log        | invalid log  |
 *   ---------------------------------------------
 *   ^                            ^
 *   |- log->last_checkpoint      |- ctx->pos
 *   |- log->last_cp_seq          |- ctx->seq
< ASCII >
 *
 * From this point, we need to increase seq number by 10 to avoid
 * confusing next recovery.
 *
< ASCII >
 *   ---------------------------------------------
 *   |           valid log        | invalid log  |
 *   ---------------------------------------------
 *   ^                              ^
 *   |- log->last_checkpoint        |- ctx->pos+1
 *   |- log->last_cp_seq            |- ctx->seq+10001
< ASCII >
 *
 * However, it is not safe to start the state machine yet, because data only
 * parities are not yet secured in RAID. To save these data only parities, we
 * rewrite them from seq+11.
 *
< ASCII >
 *   -----------------------------------------------------------------
 *   |           valid log        | data only stripes | invalid log  |
 *   -----------------------------------------------------------------
 *   ^                                                ^
 *   |- log->last_checkpoint                          |- ctx->pos+n
 *   |- log->last_cp_seq                              |- ctx->seq+10000+n
< ASCII >
 *
 * If failure happens again during this process, the recovery can safe start
 * again from log->last_checkpoint.
 *
 * Once data only stripes are rewritten to journal, we move log_tail
 *
< ASCII >
 *   -----------------------------------------------------------------
 *   |     old log        |    data only stripes    | invalid log  |
 *   -----------------------------------------------------------------
 *                        ^                         ^
 *                        |- log->last_checkpoint   |- ctx->pos+n
 *                        |- log->last_cp_seq       |- ctx->seq+10000+n
< ASCII >
 *
 * Then we can safely start the state machine. If failure happens from this
 * point on, the recovery will start from new log->last_checkpoint.
 */
```
## Visual type:
- #sequence


== ./linux/linux_442.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/md/raid5-ppl.c#L17-L83

```c
/*
 * PPL consists of a 4KB header (struct ppl_header) and at least 128KB for
 * partial parity data. The header contains an array of entries
 * (struct ppl_header_entry) which describe the logged write requests.
 * Partial parity for the entries comes after the header, written in the same
 * sequence as the entries:
 *
< ASCII >
 * Header
 *   entry0
 *   ...
 *   entryN
 * PP data
 *   PP for entry0
 *   ...
 *   PP for entryN
< ASCII >
 *
 * An entry describes one or more consecutive stripe_heads, up to a full
 * stripe. The modifed raid data chunks form an m-by-n matrix, where m is the
 * number of stripe_heads in the entry and n is the number of modified data
 * disks. Every stripe_head in the entry must write to the same data disks.
 * An example of a valid case described by a single entry (writes to the first
 * stripe of a 4 disk array, 16k chunk size):
 *
< ASCII >
 * sh->sector   dd0   dd1   dd2    ppl
 *            +-----+-----+-----+
 * 0          | --- | --- | --- | +----+
 * 8          | -W- | -W- | --- | | pp |   data_sector = 8
 * 16         | -W- | -W- | --- | | pp |   data_size = 3 * 2 * 4k
 * 24         | -W- | -W- | --- | | pp |   pp_size = 3 * 4k
 *            +-----+-----+-----+ +----+
< ASCII >
 *
 * data_sector is the first raid sector of the modified data, data_size is the
 * total size of modified data and pp_size is the size of partial parity for
 * this entry. Entries for full stripe writes contain no partial parity
 * (pp_size = 0), they only mark the stripes for which parity should be
 * recalculated after an unclean shutdown. Every entry holds a checksum of its
 * partial parity, the header also has a checksum of the header itself.
 *
 * A write request is always logged to the PPL instance stored on the parity
 * disk of the corresponding stripe. For each member disk there is one ppl_log
 * used to handle logging for this disk, independently from others. They are
 * grouped in child_logs array in struct ppl_conf, which is assigned to
 * r5conf->log_private.
 *
 * ppl_io_unit represents a full PPL write, header_page contains the ppl_header.
 * PPL entries for logged stripes are added in ppl_log_stripe(). A stripe_head
 * can be appended to the last entry if it meets the conditions for a valid
 * entry described above, otherwise a new entry is added. Checksums of entries
 * are calculated incrementally as stripes containing partial parity are being
 * added. ppl_submit_iounit() calculates the checksum of the header and submits
 * a bio containing the header page and partial parity pages (sh->ppl_page) for
 * all stripes of the io_unit. When the PPL write completes, the stripes
 * associated with the io_unit are released and raid5d starts writing their data
 * and parity. When all stripes are written, the io_unit is freed and the next
 * can be submitted.
 *
 * An io_unit is used to gather stripes until it is submitted or becomes full
 * (if the maximum number of entries or size of PPL is reached). Another io_unit
 * can't be submitted until the previous has completed (PPL and stripe
 * data+parity is written). The log->io_list tracks all io_units of a log
 * (for a single member disk). New io_units are added to the end of the list
 * and the first io_unit is submitted, if it is not submitted already.
 * The current io_unit accepting new stripes is always at the end of the list.
 *
 * If write-back cache is enabled for any of the disks in the array, its data
 * must be flushed before next io_unit is submitted.
 */
```
## Visual type:
- #custom


== ./linux/linux_443.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/md/raid5-ppl.c#L720-L785

```c
/*
 * PPL recovery strategy: xor partial parity and data from all modified data
 * disks within a stripe and write the result as the new stripe parity. If all
 * stripe data disks are modified (full stripe write), no partial parity is
 * available, so just xor the data disks.
 *
 * Recovery of a PPL entry shall occur only if all modified data disks are
 * available and read from all of them succeeds.
 *
 * A PPL entry applies to a stripe, partial parity size for an entry is at most
 * the size of the chunk. Examples of possible cases for a single entry:
 *
< ASCII >
 * case 0: single data disk write:
 *   data0    data1    data2     ppl        parity
 * +--------+--------+--------+           +--------------------+
 * | ------ | ------ | ------ | +----+    | (no change)        |
 * | ------ | -data- | ------ | | pp | -> | data1 ^ pp         |
 * | ------ | -data- | ------ | | pp | -> | data1 ^ pp         |
 * | ------ | ------ | ------ | +----+    | (no change)        |
 * +--------+--------+--------+           +--------------------+
< ASCII >
 * pp_size = data_size
 *
< ASCII >
 * case 1: more than one data disk write:
 *   data0    data1    data2     ppl        parity
 * +--------+--------+--------+           +--------------------+
 * | ------ | ------ | ------ | +----+    | (no change)        |
 * | -data- | -data- | ------ | | pp | -> | data0 ^ data1 ^ pp |
 * | -data- | -data- | ------ | | pp | -> | data0 ^ data1 ^ pp |
 * | ------ | ------ | ------ | +----+    | (no change)        |
 * +--------+--------+--------+           +--------------------+
< ASCII >
 * pp_size = data_size / modified_data_disks
 *
< ASCII >
 * case 2: write to all data disks (also full stripe write):
 *   data0    data1    data2                parity
 * +--------+--------+--------+           +--------------------+
 * | ------ | ------ | ------ |           | (no change)        |
 * | -data- | -data- | -data- | --------> | xor all data       |
 * | ------ | ------ | ------ | --------> | (no change)        |
 * | ------ | ------ | ------ |           | (no change)        |
 * +--------+--------+--------+           +--------------------+
< ASCII >
 * pp_size = 0
 *
 * The following cases are possible only in other implementations. The recovery
 * code can handle them, but they are not generated at runtime because they can
 * be reduced to cases 0, 1 and 2:
 *
< ASCII >
 * case 3:
 *   data0    data1    data2     ppl        parity
 * +--------+--------+--------+ +----+    +--------------------+
 * | ------ | -data- | -data- | | pp |    | data1 ^ data2 ^ pp |
 * | ------ | -data- | -data- | | pp | -> | data1 ^ data2 ^ pp |
 * | -data- | -data- | -data- | | -- | -> | xor all data       |
 * | -data- | -data- | ------ | | pp |    | data0 ^ data1 ^ pp |
 * +--------+--------+--------+ +----+    +--------------------+
< ASCII >
 * pp_size = chunk_size
 *
< ASCII >
 * case 4:
 *   data0    data1    data2     ppl        parity
 * +--------+--------+--------+ +----+    +--------------------+
 * | ------ | -data- | ------ | | pp |    | data1 ^ pp         |
 * | ------ | ------ | ------ | | -- | -> | (no change)        |
 * | ------ | ------ | ------ | | -- | -> | (no change)        |
 * | -data- | ------ | ------ | | pp |    | data0 ^ pp         |
 * +--------+--------+--------+ +----+    +--------------------+
< ASCII >
 * pp_size = chunk_size
 */
```
## Visual type:
- #custom


== ./linux/linux_444.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/md/bcache/super.c#L1754-L1769

```c
/*
 * This function is only called when CACHE_SET_IO_DISABLE is set, which means
 * cache set is unregistering due to too many I/O errors. In this condition,
 * the bcache device might be stopped, it depends on stop_when_cache_set_failed
 * value and whether the broken cache has dirty data:
 *
< ASCII >
 * dc->stop_when_cache_set_failed    dc->has_dirty   stop bcache device
 *  BCH_CACHED_STOP_AUTO               0               NO
 *  BCH_CACHED_STOP_AUTO               1               YES
 *  BCH_CACHED_DEV_STOP_ALWAYS         0               YES
 *  BCH_CACHED_DEV_STOP_ALWAYS         1               YES
< ASCII >
 *
 * The expected behavior is, if stop_when_cache_set_failed is configured to
 * "auto" via sysfs interface, the bcache device will not be stopped if the
 * backing device is clean on the broken cache device.
 */
```
## Visual type:
- #table


== ./linux/linux_445.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/md/persistent-data/dm-btree.c#L615-L644

```c
/*
 * Splits a node by creating a sibling node and shifting half the nodes
 * contents across.  Assumes there is a parent node, and it has room for
 * another child.
 *
< ASCII >
 * Before:
 *	  +--------+
 *	  | Parent |
 *	  +--------+
 *	     |
 *	     v
 *	+----------+
 *	| A ++++++ |
 *	+----------+
 *
 *
 * After:
 *		+--------+
 *		| Parent |
 *		+--------+
 *		  |	|
 *		  v	+------+
 *	    +---------+	       |
 *	    | A* +++  |	       v
 *	    +---------+	  +-------+
 *			  | B +++ |
 *			  +-------+
< ASCII >
 *
 * Where A* is a shadow of A.
 */
```
## Visual type:
- #tree


== ./linux/linux_446.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/md/persistent-data/dm-btree.c#L808-L828

```c
/*
 * Splits a node by creating two new children beneath the given node.
 *
< ASCII >
 * Before:
 *	  +----------+
 *	  | A ++++++ |
 *	  +----------+
 *
 *
 * After:
 *	+------------+
 *	| A (shadow) |
 *	+------------+
 *	    |	|
 *   +------+	+----+
 *   |		     |
 *   v		     v
 * +-------+	 +-------+
 * | B +++ |	 | C +++ |
 * +-------+	 +-------+
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_447.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/cec/platform/meson/ao-cec-g12a.c#L196-L212

```c
/*
 * The AO-CECB embeds a dual/divider to generate a more precise
 * 32,768KHz clock for CEC core clock.
< ASCII >
 *                      ______   ______
 *                     |      | |      |
 *         ______      | Div1 |-| Cnt1 |       ______
 *        |      |    /|______| |______|\     |      |
 * Xtal-->| Gate |---|  ______   ______  X-X--| Gate |-->
 *        |______| |  \|      | |      |/  |  |______|
 *                 |   | Div2 |-| Cnt2 |   |
 *                 |   |______| |______|   |
 *                 |_______________________|
< ASCII >
 *
 * The dividing can be switched to single or dual, with a counter
 * for each divider to set when the switching is done.
 * The entire dividing mechanism can be also bypassed.
 */
```
## Visual type:
- #schematic


== ./linux/linux_448.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/dvb-frontends/cx24116.c#L295-L353

```c
/*
< ASCII >
 * modfec (modulation and FEC)
 * ===========================
 *
 * MOD          FEC             mask/val    standard
 * ----         --------        ----------- --------
 * QPSK         FEC_1_2         0x02 0x02+X DVB-S
 * QPSK         FEC_2_3         0x04 0x02+X DVB-S
 * QPSK         FEC_3_4         0x08 0x02+X DVB-S
 * QPSK         FEC_4_5         0x10 0x02+X DVB-S (?)
 * QPSK         FEC_5_6         0x20 0x02+X DVB-S
 * QPSK         FEC_6_7         0x40 0x02+X DVB-S
 * QPSK         FEC_7_8         0x80 0x02+X DVB-S
 * QPSK         FEC_8_9         0x01 0x02+X DVB-S (?) (NOT SUPPORTED?)
 * QPSK         AUTO            0xff 0x02+X DVB-S
< ASCII >
 *
 * For DVB-S high byte probably represents FEC
 * and low byte selects the modulator. The high
 * byte is search range mask. Bit 5 may turn
 * on DVB-S and remaining bits represent some
 * kind of calibration (how/what i do not know).
 *
 * Eg.(2/3) szap "Zone Horror"
 *
 * mask/val = 0x04, 0x20
 * status 1f | signal c3c0 | snr a333 | ber 00000098 | unc 0 | FE_HAS_LOCK
 *
 * mask/val = 0x04, 0x30
 * status 1f | signal c3c0 | snr a333 | ber 00000000 | unc 0 | FE_HAS_LOCK
 *
 * After tuning FECSTATUS contains actual FEC
 * in use numbered 1 through to 8 for 1/2 .. 2/3 etc
 *
< ASCII >
 * NBC=NOT/NON BACKWARD COMPATIBLE WITH DVB-S (DVB-S2 only)
 *
 * NBC-QPSK     FEC_1_2         0x00, 0x04      DVB-S2
 * NBC-QPSK     FEC_3_5         0x00, 0x05      DVB-S2
 * NBC-QPSK     FEC_2_3         0x00, 0x06      DVB-S2
 * NBC-QPSK     FEC_3_4         0x00, 0x07      DVB-S2
 * NBC-QPSK     FEC_4_5         0x00, 0x08      DVB-S2
 * NBC-QPSK     FEC_5_6         0x00, 0x09      DVB-S2
 * NBC-QPSK     FEC_8_9         0x00, 0x0a      DVB-S2
 * NBC-QPSK     FEC_9_10        0x00, 0x0b      DVB-S2
 *
 * NBC-8PSK     FEC_3_5         0x00, 0x0c      DVB-S2
 * NBC-8PSK     FEC_2_3         0x00, 0x0d      DVB-S2
 * NBC-8PSK     FEC_3_4         0x00, 0x0e      DVB-S2
 * NBC-8PSK     FEC_5_6         0x00, 0x0f      DVB-S2
 * NBC-8PSK     FEC_8_9         0x00, 0x10      DVB-S2
 * NBC-8PSK     FEC_9_10        0x00, 0x11      DVB-S2
< ASCII >
 *
 * For DVB-S2 low bytes selects both modulator
 * and FEC. High byte is meaningless here. To
 * set pilot, bit 6 (0x40) is set. When inspecting
 * FECSTATUS bit 7 (0x80) represents the pilot
 * selection whilst not tuned. When tuned, actual FEC
 * in use is found in FECSTATUS as per above. Pilot
 * value is reset.
 */
```
## Visual type:
- #table


== ./linux/linux_449.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/dvb-frontends/ix2505v.c#L30-L47

```c
/*
< ASCII >
 *  Data read format of the Sharp IX2505V B0017
 *
 *  byte1:   1   |   1   |   0   |   0   |   0   |  MA1  |  MA0  |  1
 *  byte2:  POR  |   FL  |  RD2  |  RD1  |  RD0  |   X   |   X   |  X
< ASCII >
 *
 *  byte1 = address
 *  byte2;
 *	POR = Power on Reset (VCC H=<2.2v L=>2.2v)
 *	FL  = Phase Lock (H=lock L=unlock)
 *	RD0-2 = Reserved internal operations
 *
 * Only POR can be used to check the tuner is present
 *
 * Caution: after byte2 the I2C reverts to write mode continuing to read
 *          may corrupt tuning data.
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_45.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-imx/suspend-imx53.S#L16-L33

```c
/*
 * ==================== low level suspend ====================
 *
 * On entry
 * r0: pm_info structure address;
 *
< ASCII >
 * suspend ocram space layout:
 * ======================== high address ======================
 *                              .
 *                              .
 *                              .
 *                              ^
 *                              ^
 *                              ^
 *                      imx53_suspend code
 *              PM_INFO structure(imx5_cpu_suspend_info)
 * ======================== low address =======================
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_450.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/dvb-frontends/ix2505v.c#L93-L116

```c
/*
< ASCII >
 *  Data write format of the Sharp IX2505V B0017
 *
 *  byte1:   1   |   1   |   0   |   0   |   0   | 0(MA1)| 0(MA0)|  0
 *  byte2:   0   |  BG1  |  BG2  |   N8  |   N7  |   N6  |  N5   |  N4
 *  byte3:   N3  |   N2  |   N1  |   A5  |   A4  |   A3  |   A2  |  A1
 *  byte4:   1   | 1(C1) | 1(C0) |  PD5  |  PD4  |   TM  | 0(RTS)| 1(REF)
 *  byte5:   BA2 |   BA1 |  BA0  |  PSC  |  PD3  |PD2/TS2|DIV/TS1|PD0/TS0
< ASCII >
 *
 *  byte1 = address
 *
< ASCII >
 *  Write order
 *  1) byte1 -> byte2 -> byte3 -> byte4 -> byte5
 *  2) byte1 -> byte4 -> byte5 -> byte2 -> byte3
 *  3) byte1 -> byte2 -> byte3 -> byte4
 *  4) byte1 -> byte4 -> byte5 -> byte2
 *  5) byte1 -> byte2 -> byte3
 *  6) byte1 -> byte4 -> byte5
 *  7) byte1 -> byte2
 *  8) byte1 -> byte4
< ASCII >
 *
 *  Recommended Setup
 *  1 -> 8 -> 6
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_451.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/dvb-frontends/zl10036.c#L152-L168

```c
/*
 * register map of the ZL10036/ZL10038
 *
< ASCII >
 * reg[default] content
 *  2[0x00]:   0 | N14 | N13 | N12 | N11 | N10 |  N9 |  N8
 *  3[0x00]:  N7 |  N6 |  N5 |  N4 |  N3 |  N2 |  N1 |  N0
 *  4[0x80]:   1 |   0 | RFG | BA1 | BA0 | BG1 | BG0 | LEN
 *  5[0x00]:  P0 |  C1 |  C0 |  R4 |  R3 |  R2 |  R1 |  R0
 *  6[0xc0]:   1 |   1 |   0 |   0 | RSD |   0 |   0 |   0
 *  7[0x20]:  P1 | BF6 | BF5 | BF4 | BF3 | BF2 | BF1 |   0
 *  8[0xdb]:   1 |   1 |   0 |   1 |   0 |  CC |   1 |   1
 *  9[0x30]: VSD |  V2 |  V1 |  V0 |  S3 |  S2 |  S1 |  S0
 * 10[0xe1]:   1 |   1 |   1 |   0 |   0 | LS2 | LS1 | LS0
 * 11[0xf5]:  WS | WH2 | WH1 | WH0 | WL2 | WL1 | WL0 | WRE
 * 12[0xf0]:   1 |   1 |   1 |   1 |   0 |   0 |   0 |   0
 * 13[0x28]:  PD | BR4 | BR3 | BR2 | BR1 | BR0 | CLR |  TL
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_452.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/i2c/imx290.c#L109-L144

```c
/*
 * The IMX290 pixel array is organized as follows:
 *
< ASCII >
 *     +------------------------------------+
 *     |           Optical Black            |     }  Vertical effective optical black (10)
 * +---+------------------------------------+---+
 * |   |                                    |   | }  Effective top margin (8)
 * |   |   +----------------------------+   |   | \
 * |   |   |                            |   |   |  |
 * |   |   |                            |   |   |  |
 * |   |   |                            |   |   |  |
 * |   |   |    Recording Pixel Area    |   |   |  | Recommended height (1080)
 * |   |   |                            |   |   |  |
 * |   |   |                            |   |   |  |
 * |   |   |                            |   |   |  |
 * |   |   +----------------------------+   |   | /
 * |   |                                    |   | }  Effective bottom margin (9)
 * +---+------------------------------------+---+
 *  <-> <-> <--------------------------> <-> <->
 *                                            \----  Ignored right margin (4)
 *                                        \--------  Effective right margin (9)
 *                       \-------------------------  Recommended width (1920)
 *       \-----------------------------------------  Effective left margin (8)
 *   \---------------------------------------------  Ignored left margin (4)
< ASCII >
 *
 * The optical black lines are output over CSI-2 with a separate data type.
 *
 * The pixel array is meant to have 1920x1080 usable pixels after image
 * processing in an ISP. It has 8 (9) extra active pixels usable for color
 * processing in the ISP on the top and left (bottom and right) sides of the
 * image. In addition, 4 additional pixels are present on the left and right
 * sides of the image, documented as "ignored area".
 *
 * As far as is understood, all pixels of the pixel array (ignored area, color
 * processing margins and recording area) can be output by the sensor.
 */
```
## Visual type:
- #custom


== ./linux/linux_453.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/i2c/imx319.c#L32-L45

```c
/*
< ASCII >
 *  the digital control register for all color control looks like:
 *  +-----------------+------------------+
 *  |      [7:0]      |       [15:8]     |
 *  +-----------------+------------------+
 *  |	  0x020f      |       0x020e     |
 *  --------------------------------------
< ASCII >
 *  it is used to calculate the digital gain times value(integral + fractional)
 *  the [15:8] bits is the fractional part and [7:0] bits is the integral
 *  calculation equation is:
 *      gain value (unit: times) = REG[15:8] + REG[7:0]/0x100
 *  Only value in 0x0100 ~ 0x0FFF range is allowed.
 *  Analog gain use 10 bits in the registers and allowed range is 0 ~ 960
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_454.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/i2c/ov5640.c#L1268-L1315

```c
/*
 * After trying the various combinations, reading various
 * documentations spread around the net, and from the various
 * feedback, the clock tree is probably as follows:
 *
< ASCII >
 *   +--------------+
 *   |  Ext. Clock  |
 *   +-+------------+
 *     |  +----------+
 *     +->|   PLL1   | - reg 0x3036, for the multiplier
 *        +-+--------+ - reg 0x3037, bits 0-3 for the pre-divider
 *          |  +--------------+
 *          +->| System Clock |  - reg 0x3035, bits 4-7
 *             +-+------------+
 *               |  +--------------+
 *               +->| MIPI Divider | - reg 0x3035, bits 0-3
 *               |  +-+------------+
 *               |    +----------------> MIPI SCLK
 *               |    +  +-----+
 *               |    +->| / 2 |-------> MIPI BIT CLK
 *               |       +-----+
 *               |  +--------------+
 *               +->| PLL Root Div | - reg 0x3037, bit 4
 *                  +-+------------+
 *                    |  +---------+
 *                    +->| Bit Div | - reg 0x3034, bits 0-3
 *                       +-+-------+
 *                         |  +-------------+
 *                         +->| SCLK Div    | - reg 0x3108, bits 0-1
 *                         |  +-+-----------+
 *                         |    +---------------> SCLK
 *                         |  +-------------+
 *                         +->| SCLK 2X Div | - reg 0x3108, bits 2-3
 *                         |  +-+-----------+
 *                         |    +---------------> SCLK 2X
 *                         |  +-------------+
 *                         +->| PCLK Div    | - reg 0x3108, bits 4-5
 *                            ++------------+
 *                             +  +-----------+
 *                             +->|   P_DIV   | - reg 0x3035, bits 0-3
 *                                +-----+-----+
 *                                       +------------> PCLK
< ASCII >
 *
 * There seems to be also constraints:
 *  - the PLL pre-divider output rate should be in the 4-27MHz range
 *  - the PLL multiplier output rate should be in the 500-1000MHz range
 *  - PCLK >= SCLK * 2 in YUV, >= SCLK in Raw or JPEG
 */
```
## Visual type:
- #tree


== ./linux/linux_455.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/i2c/ov5648.c#L510-L540

```c
/*
 * PLL1 Clock Tree:
 *
< ASCII >
 * +-< XVCLK
 * |
 * +-+ pll_pre_div (0x3037 [3:0], special values: 5: 1.5, 7: 2.5)
 *   |
 *   +-+ pll_mul (0x3036 [7:0])
 *     |
 *     +-+ sys_div (0x3035 [7:4])
 *       |
 *       +-+ mipi_div (0x3035 [3:0])
 *       | |
 *       | +-> MIPI_SCLK
 *       | |
 *       | +-+ mipi_phy_div (2)
 *       |   |
 *       |   +-> MIPI_CLK
 *       |
 *       +-+ root_div (0x3037 [4])
 *         |
 *         +-+ bit_div (0x3034 [3:0], 8 bits: 2, 10 bits: 2.5, other: 1)
 *           |
 *           +-+ sclk_div (0x3106 [3:2])
 *             |
 *             +-> SCLK
 *             |
 *             +-+ mipi_div (0x3035, 1: PCLK = SCLK)
 *               |
 *               +-> PCLK
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_456.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/i2c/ov5648.c#L551-L567

```c
/*
 * PLL2 Clock Tree:
 *
< ASCII >
 * +-< XVCLK
 * |
 * +-+ plls_pre_div (0x303d [5:4], special values: 0: 1, 1: 1.5)
 *   |
 *   +-+ plls_div_r (0x303d [2])
 *     |
 *     +-+ plls_mul (0x303b [4:0])
 *       |
 *       +-+ sys_div (0x303c [3:0])
 *         |
 *         +-+ sel_div (0x303d [1:0], special values: 0: 1, 3: 2.5)
 *           |
 *           +-> ADCLK
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_457.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/i2c/ov8865.c#L482-L517

```c
/*
 * PLL1 Clock Tree:
 *
< ASCII >
 * +-< EXTCLK
 * |
 * +-+ pll_pre_div_half (0x30a [0])
 *   |
 *   +-+ pll_pre_div (0x300 [2:0], special values:
 *     |              0: 1, 1: 1.5, 3: 2.5, 4: 3, 5: 4, 7: 8)
 *     +-+ pll_mul (0x301 [1:0], 0x302 [7:0])
 *       |
 *       +-+ m_div (0x303 [3:0])
 *       | |
 *       | +-> PHY_SCLK
 *       | |
 *       | +-+ mipi_div (0x304 [1:0], special values: 0: 4, 1: 5, 2: 6, 3: 8)
 *       |   |
 *       |   +-+ pclk_div (0x3020 [3])
 *       |     |
 *       |     +-> PCLK
 *       |
 *       +-+ sys_pre_div (0x305 [1:0], special values: 0: 3, 1: 4, 2: 5, 3: 6)
 *         |
 *         +-+ sys_div (0x306 [0])
 *           |
 *           +-+ sys_sel (0x3032 [7], 0: PLL1, 1: PLL2)
 *             |
 *             +-+ sclk_sel (0x3033 [1], 0: sys_sel, 1: PLL2 DAC_CLK)
 *               |
 *               +-+ sclk_pre_div (0x3106 [3:2], special values:
 *                 |               0: 1, 1: 2, 2: 4, 3: 1)
 *                 |
 *                 +-+ sclk_div (0x3106 [7:4], special values: 0: 1)
 *                   |
 *                   +-> SCLK
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_458.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/i2c/ov8865.c#L530-L560

```c
/*
 * PLL2 Clock Tree:
 *
< ASCII >
 * +-< EXTCLK
 * |
 * +-+ pll_pre_div_half (0x312 [4])
 *   |
 *   +-+ pll_pre_div (0x30b [2:0], special values:
 *     |              0: 1, 1: 1.5, 3: 2.5, 4: 3, 5: 4, 7: 8)
 *     +-+ pll_mul (0x30c [1:0], 0x30d [7:0])
 *       |
 *       +-+ dac_div (0x312 [3:0])
 *       | |
 *       | +-> DAC_CLK
 *       |
 *       +-+ sys_pre_div (0x30f [3:0])
 *         |
 *         +-+ sys_div (0x30e [2:0], special values:
 *           |          0: 1, 1: 1.5, 3: 2.5, 4: 3, 5: 3.5, 6: 4, 7:5)
 *           |
 *           +-+ sys_sel (0x3032 [7], 0: PLL1, 1: PLL2)
 *             |
 *             +-+ sclk_sel (0x3033 [1], 0: sys_sel, 1: PLL2 DAC_CLK)
 *               |
 *               +-+ sclk_pre_div (0x3106 [3:2], special values:
 *                 |               0: 1, 1: 2, 2: 4, 3: 1)
 *                 |
 *                 +-+ sclk_div (0x3106 [7:4], special values: 0: 1)
 *                   |
 *                   +-> SCLK
< ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_459.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/i2c/sony-btf-mpx.c#L65-L114

```c
/*
 * MPX register values for the BTF-PG472Z:
 *
< ASCII >
 *                                 FM_     NICAM_  SCART_
 *          MODUS  SOURCE    ACB   PRESCAL PRESCAL PRESCAL SYSTEM  VOLUME
 *         10/0030 12/0008 12/0013 12/000E 12/0010 12/0000 10/0020 12/0000
 *         ---------------------------------------------------------------
 * Auto     1003    0020    0100    2603    5000    XXXX    0001    7500
 *
 * B/G
 *  Mono    1003    0020    0100    2603    5000    XXXX    0003    7500
 *  A2      1003    0020    0100    2601    5000    XXXX    0003    7500
 *  NICAM   1003    0120    0100    2603    5000    XXXX    0008    7500
 *
 * I
 *  Mono    1003    0020    0100    2603    7900    XXXX    000A    7500
 *  NICAM   1003    0120    0100    2603    7900    XXXX    000A    7500
 *
 * D/K
 *  Mono    1003    0020    0100    2603    5000    XXXX    0004    7500
 *  A2-1    1003    0020    0100    2601    5000    XXXX    0004    7500
 *  A2-2    1003    0020    0100    2601    5000    XXXX    0005    7500
 *  A2-3    1003    0020    0100    2601    5000    XXXX    0007    7500
 *  NICAM   1003    0120    0100    2603    5000    XXXX    000B    7500
 *
 * L/L'
 *  Mono    0003    0200    0100    7C03    5000    2200    0009    7500
 *  NICAM   0003    0120    0100    7C03    5000    XXXX    0009    7500
 *
 * M
 *  Mono    1003    0200    0100    2B03    5000    2B00    0002    7500
< ASCII >
 *
 * For Asia, replace the 0x26XX in FM_PRESCALE with 0x14XX.
 *
< ASCII >
 * Bilingual selection in A2/NICAM:
 *
 *         High byte of SOURCE     Left chan   Right chan
 *                 0x01              MAIN         SUB
 *                 0x03              MAIN         MAIN
 *                 0x04              SUB          SUB
< ASCII >
 *
< ASCII >
 * Force mono in NICAM by setting the high byte of SOURCE to 0x02 (L/L') or
 * 0x00 (all other bands).  Force mono in A2 with FMONO_A2:
 *
 *                      FMONO_A2
 *                      10/0022
 *                      --------
 *     Forced mono ON     07F0
 *     Forced mono OFF    0190
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_46.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-imx/suspend-imx6.S#L14-L34

```c
/*
 * ==================== low level suspend ====================
 *
 * Better to follow below rules to use ARM registers:
 * r0: pm_info structure address;
 * r1 ~ r4: for saving pm_info members;
 * r5 ~ r10: free registers;
 * r11: io base address.
 *
< ASCII >
 * suspend ocram space layout:
 * ======================== high address ======================
 *                              .
 *                              .
 *                              .
 *                              ^
 *                              ^
 *                              ^
 *                      imx6_suspend code
 *              PM_INFO structure(imx6_cpu_pm_info)
 * ======================== low address =======================
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_460.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/i2c/m5mols/m5mols.h#L252-L276

```c
/*
 * I2C operation of the M-5MOLS
 *
 * The I2C read operation of the M-5MOLS requires 2 messages. The first
 * message sends the information about the command, command category, and total
 * message size. The second message is used to retrieve the data specified in
 * the first message
 *
< ASCII >
 *   1st message                                2nd message
 *   +-------+---+----------+-----+-------+     +------+------+------+------+
 *   | size1 | R | category | cmd | size2 |     | d[0] | d[1] | d[2] | d[3] |
 *   +-------+---+----------+-----+-------+     +------+------+------+------+
 *   - size1: message data size(5 in this case)
 *   - size2: desired buffer size of the 2nd message
 *   - d[0..3]: according to size2
< ASCII >
 *
 * The I2C write operation needs just one message. The message includes
 * category, command, total size, and desired data.
 *
< ASCII >
 *   1st message
 *   +-------+---+----------+-----+------+------+------+------+
 *   | size1 | W | category | cmd | d[0] | d[1] | d[2] | d[3] |
 *   +-------+---+----------+-----+------+------+------+------+
< ASCII >
 *   - d[0..3]: according to size1
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_461.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/pci/cx23885/altera-ci.c#L26-L40

```c
/*
 *  Bit definitions for MC417_RWD and MC417_OEN registers
 * bits 31-16
< ASCII >
 * +-----------+
 * | Reserved  |
 * +-----------+
 *   bit 15  bit 14  bit 13 bit 12  bit 11  bit 10  bit 9   bit 8
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |  TDI  |  TDO  |  TCK  |  RDY# |  #RD  |  #WR  | AD_RG |  #CS  |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 *  bit 7   bit 6   bit 5   bit 4   bit 3   bit 2   bit 1   bit 0
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |  DATA7|  DATA6|  DATA5|  DATA4|  DATA3|  DATA2|  DATA1|  DATA0|
 * +-------+-------+-------+-------+-------+-------+-------+-------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_462.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/pci/ivtv/ivtv-gpio.c#L17-L85

```c
/*
 * GPIO assignment of Yuan MPG600/MPG160
 *
< ASCII >
 *    bit 15  14  13  12 |  11  10   9   8 |   7   6   5   4 |   3   2   1   0
 * OUTPUT         IN1 IN0                                       AM3 AM2 AM1 AM0
 *  INPUT                   DM1         DM0
< ASCII >
 *
< ASCII >
 *   IN* : Input selection
 *          IN1 IN0
 *           1   1  N/A
 *           1   0  Line
 *           0   1  N/A
 *           0   0  Tuner
 *
 *   AM* : Audio Mode
 *          AM3  0: Normal        1: Mixed(Sub+Main channel)
 *          AM2  0: Subchannel    1: Main channel
 *          AM1  0: Stereo        1: Mono
 *          AM0  0: Normal        1: Mute
 *
 *   DM* : Detected tuner audio Mode
 *          DM1  0: Stereo        1: Mono
 *          DM0  0: Multiplex     1: Normal
 *
 * GPIO Initial Settings
 *           MPG600   MPG160
 *     DIR   0x3080   0x7080
 *  OUTPUT   0x000C   0x400C
< ASCII >
 *
 *  Special thanks to Makoto Iguchi <iguchi@tahoo.org> and Mr. Anonymous
 *  for analyzing GPIO of MPG160.
 *
 *****************************************************************************
 *
 * GPIO assignment of Avermedia M179 (per information direct from AVerMedia)
 *
< ASCII >
 *    bit 15  14  13  12 |  11  10   9   8 |   7   6   5   4 |   3   2   1   0
 * OUTPUT IN0 AM0 IN1               AM1 AM2       IN2     BR0   BR1
 *  INPUT
 *
 *   IN* : Input selection
 *          IN0 IN1 IN2
 *           *   1   *  Mute
 *           0   0   0  Line-In
 *           1   0   0  TV Tuner Audio
 *           0   0   1  FM Audio
 *           1   0   1  Mute
 *
 *   AM* : Audio Mode
 *          AM0 AM1 AM2
 *           0   0   0  TV Tuner Audio: L_OUT=(L+R)/2, R_OUT=SAP
 *           0   0   1  TV Tuner Audio: L_OUT=R_OUT=SAP   (SAP)
 *           0   1   0  TV Tuner Audio: L_OUT=L, R_OUT=R   (stereo)
 *           0   1   1  TV Tuner Audio: mute
 *           1   *   *  TV Tuner Audio: L_OUT=R_OUT=(L+R)/2   (mono)
 *
 *   BR* : Audio Sample Rate (BR stands for bitrate for some reason)
 *          BR0 BR1
 *           0   0   32 kHz
 *           0   1   44.1 kHz
 *           1   0   48 kHz
 *
 *   DM* : Detected tuner audio Mode
 *         Unknown currently
< ASCII >
 *
 * Special thanks to AVerMedia Technologies, Inc. and Jiun-Kuei Jung at
 * AVerMedia for providing the GPIO information used to add support
 * for the M179 cards.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_463.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/pci/saa7164/saa7164-buffer.c#L12-L53

```c
/* The PCI address space for buffer handling looks like this:
 *
< ASCII >
 * +-u32 wide-------------+
 * |                      +
 * +-u64 wide------------------------------------+
 * +                                             +
 * +----------------------+
 * | CurrentBufferPtr     + Pointer to current PCI buffer >-+
 * +----------------------+                                 |
 * | Unused               +                                 |
 * +----------------------+                                 |
 * | Pitch                + = 188 (bytes)                   |
 * +----------------------+                                 |
 * | PCI buffer size      + = pitch * number of lines (312) |
 * +----------------------+                                 |
 * |0| Buf0 Write Offset  +                                 |
 * +----------------------+                                 v
 * |1| Buf1 Write Offset  +                                 |
 * +----------------------+                                 |
 * |2| Buf2 Write Offset  +                                 |
 * +----------------------+                                 |
 * |3| Buf3 Write Offset  +                                 |
 * +----------------------+                                 |
 * ... More write offsets                                   |
 * +---------------------------------------------+          |
 * +0| set of ptrs to PCI pagetables             +          |
 * +---------------------------------------------+          |
 * +1| set of ptrs to PCI pagetables             + <--------+
 * +---------------------------------------------+
 * +2| set of ptrs to PCI pagetables             +
 * +---------------------------------------------+
 * +3| set of ptrs to PCI pagetables             + >--+
 * +---------------------------------------------+    |
 * ... More buffer pointers                           |  +----------------+
 *						    +->| pt[0] TS data  |
 *						    |  +----------------+
 *						    |
 *						    |  +----------------+
 *						    +->| pt[1] TS data  |
 *						    |  +----------------+
 *						    | etc
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_464.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/pci/zoran/videocodec.h#L104-L117

```c
/*
 * Currently there is only a information display planned, as the layer
 * is not visible for the user space at all.
 *
 * Information is available via procfs. The current entry is "/proc/videocodecs"
 * but it makes sense to "hide" it in the /proc/video tree of v4l(2) --TODO--.
 *
 * A example for such an output is:
 *
< ASCII >
 * <S>lave or attached <M>aster name  type flags    magic    (connected as)
 * S                          zr36050 0002 0000d001 00000000 (TEMPLATE)
 * M                       zr36055[0] 0001 0000c001 00000000 (zr36050[0])
 * M                       zr36055[1] 0001 0000c001 00000000 (zr36050[1])
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_465.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/platform/aspeed/aspeed-video.c#L937-L982

```c
/*
 * Update v4l2_bt_timings per current status.
 * frame_top/frame_bottom/frame_left/frame_right need to be ready.
 *
 * The following registers start counting from sync's rising edge:
 * 1. VR090: frame edge's left and right
 * 2. VR094: frame edge's top and bottom
 * 3. VR09C: counting from sync's rising edge to falling edge
 *
< ASCII >
 * [Vertical timing]
 *             +--+     +-------------------+     +--+
 *             |  |     |     v i d e o     |     |  |
 *          +--+  +-----+                   +-----+  +---+
 *        vsync+--+
 *    frame_top+--------+
 * frame_bottom+----------------------------+
 *
 *                   +-------------------+
 *                   |     v i d e o     |
 *       +--+  +-----+                   +-----+  +---+
 *          |  |                               |  |
 *          +--+                               +--+
 *        vsync+-------------------------------+
 *    frame_top+-----+
 * frame_bottom+-------------------------+
 *
 * [Horizontal timing]
 *             +--+     +-------------------+     +--+
 *             |  |     |     v i d e o     |     |  |
 *          +--+  +-----+                   +-----+  +---+
 *        hsync+--+
 *   frame_left+--------+
 *  frame_right+----------------------------+
 *
 *                   +-------------------+
 *                   |     v i d e o     |
 *       +--+  +-----+                   +-----+  +---+
 *          |  |                               |  |
 *          +--+                               +--+
 *        hsync+-------------------------------+
 *   frame_left+-----+
 *  frame_right+-------------------------+
< ASCII >
 *
 * @v: the struct of aspeed_video
 * @det: v4l2_bt_timings to be updated.
 */
```
## Visual type:
- #plot


== ./linux/linux_466.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/platform/rockchip/rkisp1/rkisp1-dev.c#L25-L112

```c
/*
 * ISP Details
 * -----------
 *
 * ISP Comprises with:
 *	MIPI serial camera interface
 *	Image Signal Processing
 *	Many Image Enhancement Blocks
 *	Crop
 *	Resizer
 *	RBG display ready image
 *	Image Rotation
 *
< ASCII >
 * ISP Block Diagram
 * -----------------
 *                                                             rkisp1-resizer.c          rkisp1-capture.c
 *                                                          |====================|  |=======================|
 *                                rkisp1-isp.c                              Main Picture Path
 *                        |==========================|      |===============================================|
 *                        +-----------+  +--+--+--+--+      +--------+  +--------+              +-----------+
 *                        |           |  |  |  |  |  |      |        |  |        |              |           |
 * +--------+    |\       |           |  |  |  |  |  |   -->|  Crop  |->|  RSZ   |------------->|           |
 * |  MIPI  |--->|  \     |           |  |  |  |  |  |   |  |        |  |        |              |           |
 * +--------+    |   |    |           |  |IE|IE|IE|IE|   |  +--------+  +--------+              |  Memory   |
 *               |MUX|--->|    ISP    |->|0 |1 |2 |3 |---+                                      | Interface |
 * +--------+    |   |    |           |  |  |  |  |  |   |  +--------+  +--------+  +--------+  |           |
 * |Parallel|--->|  /     |           |  |  |  |  |  |   |  |        |  |        |  |        |  |           |
 * +--------+    |/       |           |  |  |  |  |  |   -->|  Crop  |->|  RSZ   |->|  RGB   |->|           |
 *                        |           |  |  |  |  |  |      |        |  |        |  | Rotate |  |           |
 *                        +-----------+  +--+--+--+--+      +--------+  +--------+  +--------+  +-----------+
 *                                               ^
 * +--------+                                    |          |===============================================|
 * |  DMA   |------------------------------------+                          Self Picture Path
 * +--------+
 *
 *         rkisp1-stats.c        rkisp1-params.c
 *       |===============|      |===============|
 *       +---------------+      +---------------+
 *       |               |      |               |
 *       |      ISP      |      |      ISP      |
 *       |               |      |               |
 *       +---------------+      +---------------+
 *
< ASCII >
< ASCII >
 *
 * Media Topology
 * --------------
 *
 *          +----------+       +----------+
 *          | Sensor 1 |       | Sensor X |
 *          ------------  ...  ------------
 *          |    0     |       |    0     |
 *          +----------+       +----------+
 *               |                  |
 *                \----\       /----/
 *                     |       |
 *                     v       v
 *                  +-------------+
 *                  |      0      |
 *                  ---------------
 *                  |  CSI-2 RX   |
 *                  ---------------         +-----------+
 *                  |      1      |         |  params   |
 *                  +-------------+         | (output)  |
 *                         |               +-----------+
 *                         v                     |
 *                      +------+------+          |
 *                      |  0   |  1   |<---------+
 *                      |------+------|
 *                      |     ISP     |
 *                      |------+------|
 *        +-------------|  2   |  3   |----------+
 *        |             +------+------+          |
 *        |                |                     |
 *        v                v                     v
 *  +- ---------+    +-----------+         +-----------+
 *  |     0     |    |     0     |         |   stats   |
 *  -------------    -------------         | (capture) |
 *  |  Resizer  |    |  Resizer  |         +-----------+
 *  ------------|    ------------|
 *  |     1     |    |     1     |
 *  +-----------+    +-----------+
 *        |                |
 *        v                v
 *  +-----------+    +-----------+
 *  | selfpath  |    | mainpath  |
 *  | (capture) |    | (capture) |
 *  +-----------+    +-----------+
< ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_467.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/platform/verisilicon/hantro_g1_vp8_dec.c#L206-L230

```c
/*
 * set control partition and DCT partition regs
 *
 * VP8 frame stream data layout:
 *
< ASCII >
 *	                     first_part_size          parttion_sizes[0]
 *                              ^                     ^
 * src_dma                      |                     |
 * ^                   +--------+------+        +-----+-----+
 * |                   | control part  |        |           |
 * +--------+----------------+------------------+-----------+-----+-----------+
 * | tag 3B | extra 7B | hdr | mb_data | DCT sz | DCT part0 | ... | DCT partn |
 * +--------+-----------------------------------+-----------+-----+-----------+
 *                           |         |        |                             |
 *                           v         +----+---+                             v
 *                           mb_start       |                       src_dma_end
 *                                          v
 *                                       DCT size part
 *                                      (num_dct-1)*3B
< ASCII >
 * Note:
 *   1. only key-frames have extra 7-bytes
 *   2. all offsets are base on src_dma
 *   3. number of DCT parts is 1, 2, 4 or 8
 *   4. the addresses set to the VPU must be 64-bits aligned
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_468.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/rc/redrat3.c#L315-L325

```c
/*
 * convert us back into redrat3 lengths
 *
< ASCII >
 * length * 1000   length * 1000000
 * ------------- = ---------------- = micro
 * rr3clk / 1000       rr3clk

 * 6 * 2       4 * 3        micro * rr3clk          micro * rr3clk / 1000
 * ----- = 4   ----- = 6    -------------- = len    ---------------------
 *   3           2             1000000                    1000
< ASCII >
 */
```
## Visual type:
- #formula


== ./linux/linux_469.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/rc/st_rc.c#L70-L90

```c
/*
 * RX graphical example to better understand the difference between ST IR block
 * output and standard definition used by LIRC (and most of the world!)
 *
< ASCII >
 *           mark                                     mark
 *      |-IRB_RX_ON-|                            |-IRB_RX_ON-|
 *      ___  ___  ___                            ___  ___  ___             _
 *      | |  | |  | |                            | |  | |  | |             |
 *      | |  | |  | |         space 0            | |  | |  | |   space 1   |
 * _____| |__| |__| |____________________________| |__| |__| |_____________|
 *
 *      |--------------- IRB_RX_SYS -------------|------ IRB_RX_SYS -------|
 *
 *      |------------- encoding bit 0 -----------|---- encoding bit 1 -----|
 *
< ASCII >
 * ST hardware returns mark (IRB_RX_ON) and total symbol time (IRB_RX_SYS), so
 * convert to standard mark/space we have to calculate space=(IRB_RX_SYS-mark)
 * The mark time represents the amount of time the carrier (usually 36-40kHz)
 * is detected.The above examples shows Pulse Width Modulation encoding where
 * bit 0 is represented by space>mark.
 */
```
## Visual type:
- #custom


== ./linux/linux_47.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-omap1/board-htcherald.c#L56-L110

```c
/*
 * CPLD Logic
 *
< ASCII >
 * Chip 3 - 0x03
 *
 * Function            7 6 5 4  3 2 1 0
 * ------------------------------------
 * DPAD light          x x x x  x x x 1
 * SoundDev            x x x x  1 x x x
 * Screen white        1 x x x  x x x x
 * MMC power on        x x x x  x 1 x x
 * Happy times (n)     0 x x x  x 1 x x
 *
 * Chip 4 - 0x04
 *
 * Function            7 6 5 4  3 2 1 0
 * ------------------------------------
 * Keyboard light      x x x x  x x x 1
 * LCD Bright (4)      x x x x  x 1 1 x
 * LCD Bright (3)      x x x x  x 0 1 x
 * LCD Bright (2)      x x x x  x 1 0 x
 * LCD Bright (1)      x x x x  x 0 0 x
 * LCD Off             x x x x  0 x x x
 * LCD image (fb)      1 x x x  x x x x
 * LCD image (white)   0 x x x  x x x x
 * Caps lock LED       x x 1 x  x x x x
 *
 * Chip 5 - 0x05
 *
 * Function            7 6 5 4  3 2 1 0
 * ------------------------------------
 * Red (solid)         x x x x  x 1 x x
 * Red (flash)         x x x x  x x 1 x
 * Green (GSM flash)   x x x x  1 x x x
 * Green (GSM solid)   x x x 1  x x x x
 * Green (wifi flash)  x x 1 x  x x x x
 * Blue (bt flash)     x 1 x x  x x x x
 * DPAD Int Enable     1 x x x  x x x 0
< ASCII >
 *
 * (Combinations of the above can be made for different colors.)
 * The direction pad interrupt enable must be set each time the
 * interrupt is handled.
 *
< ASCII >
 * Chip 6 - 0x06
 *
 * Function            7 6 5 4  3 2 1 0
 * ------------------------------------
 * Vibrator            x x x x  1 x x x
 * Alt LED             x x x 1  x x x x
 * Screen white        1 x x x  x x x x
 * Screen white        x x 1 x  x x x x
 * Screen white        x 0 x x  x x x x
 * Enable kbd dpad     x x x x  x x 0 x
 * Happy Times         0 1 0 x  x x 0 x
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_470.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/rc/keymaps/rc-msi-tvanywhere-plus.c#L27-L45

```c
/*  ---- Remote Button Layout ----
< ASCII >

    POWER   SOURCE  SCAN    MUTE
    TV/FM   1       2       3
    |>      4       5       6
    <|      7       8       9
    ^^UP    0       +       RECALL
    vvDN    RECORD  STOP    PLAY

	MINIMIZE          ZOOM

		  CH+
      VOL-                   VOL+
		  CH-

	SNAPSHOT           MTS

     <<      FUNC    >>     RESET
< ASCII >
*/
```
## Visual type:
- #custom


== ./linux/linux_471.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/tuners/mt2060_priv.h#L14-L59

```c
/* This driver is based on the information available in the datasheet of the
   "Comtech SDVBT-3K6M" tuner ( K1000737843.pdf ) which features the MT2060 register map :

   I2C Address : 0x60

< ASCII >
   Reg.No |   B7   |   B6   |   B5   |   B4   |   B3   |   B2   |   B1   |   B0   | ( defaults )
   --------------------------------------------------------------------------------
       00 | [              PART             ] | [              REV              ] | R  = 0x63
       01 | [             LNABAND           ] | [              NUM1(5:2)        ] | RW = 0x3F
       02 | [                               DIV1                                ] | RW = 0x74
       03 | FM1CA  | FM1SS  | [  NUM1(1:0)  ] | [              NUM2(3:0)        ] | RW = 0x00
       04 |                                 NUM2(11:4)                          ] | RW = 0x08
       05 | [                               DIV2                       ] |NUM2(12)| RW = 0x93
       06 | L1LK   | [        TAD1          ] | L2LK   | [         TAD2         ] | R
       07 | [                               FMF                                 ] | R
       08 |   ?    | FMCAL  |   ?    |   ?    |   ?    |   ?    |   ?    | TEMP   | R
       09 |   0    |   0    | [    FMGC     ] |   0    | GP02   | GP01   |   0    | RW = 0x20
       0A | ??
       0B |   0    |   0    |   1    |   1    |   0    |   0    | [   VGAG      ] | RW = 0x30
       0C | V1CSE  |   1    |   1    |   1    |   1    |   1    |   1    |   1    | RW = 0xFF
       0D |   1    |   0    | [                      V1CS                       ] | RW = 0xB0
       0E | ??
       0F | ??
       10 | ??
       11 | [             LOTO              ] |   0    |   0    |   1    |   0    | RW = 0x42
< ASCII >

       PART    : Part code      : 6 for MT2060
       REV     : Revision code  : 3 for current revision
       LNABAND : Input frequency range : ( See code for details )
       NUM1 / DIV1 / NUM2 / DIV2 : Frequencies programming ( See code for details )
       FM1CA  : Calibration Start Bit
       FM1SS  : Calibration Single Step bit
       L1LK   : LO1 Lock Detect
       TAD1   : Tune Line ADC ( ? )
       L2LK   : LO2 Lock Detect
       TAD2   : Tune Line ADC ( ? )
       FMF    : Estimated first IF Center frequency Offset ( ? )
       FM1CAL : Calibration done bit
       TEMP   : On chip temperature sensor
       FMCG   : Mixer 1 Cap Gain ( ? )
       GP01 / GP02 : Programmable digital outputs. Unconnected pins ?
       V1CSE  : LO1 VCO Automatic Capacitor Select Enable ( ? )
       V1CS   : LO1 Capacitor Selection Value ( ? )
       LOTO   : LO Timeout ( ? )
       VGAG   : Tuner Output gain
*/
```
## Visual type:
- #memory-layout


== ./linux/linux_472.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/tuners/mt2063.c#L659-L677

```c
/**
< ASCII >
 * IsSpurInBand() - Checks to see if a spur will be present within the IF's
 *                  bandwidth. (fIFOut +/- fIFBW, -fIFOut +/- fIFBW)
 *
 *                    ma   mb                                     mc   md
 *                  <--+-+-+-------------------+-------------------+-+-+-->
 *                     |   ^                   0                   ^   |
 *                     ^   b=-fIFOut+fIFBW/2      -b=+fIFOut-fIFBW/2   ^
 *                     a=-fIFOut-fIFBW/2              -a=+fIFOut+fIFBW/2
 *
 *                  Note that some equations are doubled to prevent round-off
 *                  problems when calculating fIFBW/2
< ASCII >
 *
 * @pAS_Info:	Avoid Spurs information block
 * @fm:		If spur, amount f_IF1 has to move negative
 * @fp:		If spur, amount f_IF1 has to move positive
 *
 *  Returns 1 if an LO spur would be present, otherwise 0.
 */
```
## Visual type:
- #custom


== ./linux/linux_473.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/tuners/mt2063.c#L944-L978

```c
/*
 *  Constants for setting receiver modes.
 *  (6 modes defined at this time, enumerated by mt2063_delivery_sys)
 *  (DNC1GC & DNC2GC are the values, which are used, when the specific
 *   DNC Output is selected, the other is always off)
 *
< ASCII >
 *                enum mt2063_delivery_sys
 * -------------+----------------------------------------------
 * Mode 0 :     | MT2063_CABLE_QAM
 * Mode 1 :     | MT2063_CABLE_ANALOG
 * Mode 2 :     | MT2063_OFFAIR_COFDM
 * Mode 3 :     | MT2063_OFFAIR_COFDM_SAWLESS
 * Mode 4 :     | MT2063_OFFAIR_ANALOG
 * Mode 5 :     | MT2063_OFFAIR_8VSB
 * --------------+----------------------------------------------
 *
 *                |<----------   Mode  -------------->|
 *    Reg Field   |  0  |  1  |  2  |  3  |  4  |  5  |
 *    ------------+-----+-----+-----+-----+-----+-----+
 *    RFAGCen     | OFF | OFF | OFF | OFF | OFF | OFF
 *    LNARin      |   0 |   0 |   3 |   3 |  3  |  3
 *    FIFFQen     |   1 |   1 |   1 |   1 |  1  |  1
 *    FIFFq       |   0 |   0 |   0 |   0 |  0  |  0
 *    DNC1gc      |   0 |   0 |   0 |   0 |  0  |  0
 *    DNC2gc      |   0 |   0 |   0 |   0 |  0  |  0
 *    GCU Auto    |   1 |   1 |   1 |   1 |  1  |  1
 *    LNA max Atn |  31 |  31 |  31 |  31 | 31  | 31
 *    LNA Target  |  44 |  43 |  43 |  43 | 43  | 43
 *    ign  RF Ovl |   0 |   0 |   0 |   0 |  0  |  0
 *    RF  max Atn |  31 |  31 |  31 |  31 | 31  | 31
 *    PD1 Target  |  36 |  36 |  38 |  38 | 36  | 38
 *    ign FIF Ovl |   0 |   0 |   0 |   0 |  0  |  0
 *    FIF max Atn |   5 |   5 |   5 |   5 |  5  |  5
 *    PD2 Target  |  40 |  33 |  42 |  42 | 33  | 42
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_474.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/tuners/tda18271-common.c#L515-L529

```c
/*
 *  Standby modes, EP3 [7:5]
< ASCII >
 *
 *  | SM  || SM_LT || SM_XT || mode description
 *  |=====\\=======\\=======\\====================================
 *  |  0  ||   0   ||   0   || normal mode
 *  |-----||-------||-------||------------------------------------
 *  |     ||       ||       || standby mode w/ slave tuner output
 *  |  1  ||   0   ||   0   || & loop through & xtal oscillator on
 *  |-----||-------||-------||------------------------------------
 *  |  1  ||   1   ||   0   || standby mode w/ xtal oscillator on
 *  |-----||-------||-------||------------------------------------
 *  |  1  ||   1   ||   1   || power off
< ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_475.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/usb/dvb-usb/vp702x.h#L26-L28

```c
/* additional in buffer:
< ASCII >
 * 0   1   2    3              4   5   6               7       8
 * N/A N/A 0x05 signal-quality N/A N/A signal-strength lock==0 N/A 
< ASCII >*/
```
## Visual type:
- #memory-layout


== ./linux/linux_476.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/usb/dvb-usb/vp702x.h#L31-L33

```c
/* additional in buffer:
< ASCII >
 * 0   1   2   3   4   5   6   7   8
 * N/A 'U' 'S' 'B' '7' '0' '2' 'X' N/A 
< ASCII >*/
```
## Visual type:
- #memory-layout


== ./linux/linux_477.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/usb/dvb-usb/vp702x.h#L36-L41

```c
/* additional out buffer:
< ASCII >
 * 0    1  2  3  4
 * len  X1 X2 X3 X4
 * additional in buffer:
 * 0   1 2
 * N/A 0 0   b[1] == b[2] == 0 -> success, failure otherwise 
< ASCII >*/
```
## Visual type:
- #memory-layout


== ./linux/linux_478.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/usb/dvb-usb/vp702x.h#L44-L49

```c
/* additional out buffer:
< ASCII >
 * 0    1    2
 * 0x00 0xff 1 = on, 0 = off
 * additional in buffer:
 * 0   1 2
 * N/A 0 0   b[1] == b[2] == 0 -> success failure otherwise 
< ASCII >*/
```
## Visual type:
- #memory-layout


== ./linux/linux_479.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/usb/dvb-usb/vp702x.h#L53-L55

```c
/* additional in buffer:
< ASCII >
 * 0   1   2            3    4    5    6    7    8
 * N/A N/A 0x0A or 0x0B MAC0 MAC1 MAC2 MAC3 MAC4 MAC5 
< ASCII >*/
```
## Visual type:
- #memory-layout


== ./linux/linux_48.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-orion5x/board-d2net.c#L32-L48

```c
/*
 * The blue front LED is wired to the CPLD and can blink in relation with the
 * SATA activity.
 *
 * The following array detail the different LED registers and the combination
 * of their possible values:
 *
< ASCII >
 * led_off   | blink_ctrl | SATA active | LED state
 *           |            |             |
 *    1      |     x      |      x      |  off
 *    0      |     0      |      0      |  off
 *    0      |     1      |      0      |  blink (rate 300ms)
 *    0      |     x      |      1      |  on
< ASCII >
 *
 * Notes: The blue and the red front LED's can't be on at the same time.
 *        Red LED have priority.
 */
```
## Visual type:
- #table


== ./linux/linux_480.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/usb/dvb-usb/vp702x.h#L58-L60

```c
/* additional in buffer:
< ASCII >
 * 0        1        ... 14       15       16
 * PID0_MSB PID0_LSB ... PID7_MSB PID7_LSB PID_active (bits) 
< ASCII >*/
```
## Visual type:
- #memory-layout


== ./linux/linux_481.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/usb/dvb-usb/vp702x.h#L62-L66

```c
/* request: 0xB2; i: 0; v: 0;
< ASCII >
 * b[0] != 0 -> tune and lock a channel
 * 0     1     2       3      4      5      6    7
 * freq0 freq1 divstep srate0 srate1 srate2 flag chksum
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_482.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/usb/dvb-usb-v2/dvb_usb.h#L23-L43

```c
/*
 * device file: /dev/dvb/adapter[0-1]/frontend[0-2]
 *
< ASCII >
 * |-- device
 * |   |-- adapter0
 * |   |   |-- frontend0
 * |   |   |-- frontend1
 * |   |   `-- frontend2
 * |   `-- adapter1
 * |       |-- frontend0
 * |       |-- frontend1
 * |       `-- frontend2
< ASCII >
 *
 *
 * Commonly used variable names:
 * d = pointer to device (struct dvb_usb_device *)
 * adap = pointer to adapter (struct dvb_usb_adapter *)
 * fe = pointer to frontend (struct dvb_frontend *)
 *
 * Use macros defined in that file to resolve needed pointers.
 */
```
## Visual type:
- #tree


== ./linux/linux_483.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/usb/dvb-usb-v2/mxl111sf-gpio.c#L708-L714

```c
/*	GPO:
< ASCII >
 *	3 - ATSC/MH#   | 1 = ATSC transport, 0 = MH transport      | default 0
 *	4 - ATSC_RST## | 1 = ATSC enable, 0 = ATSC Reset           | default 0
 *	5 - ATSC_EN    | 1 = ATSC power enable, 0 = ATSC power off | default 0
 *	6 - MH_RESET#  | 1 = MH enable, 0 = MH Reset               | default 0
 *	7 - MH_EN      | 1 = MH power enable, 0 = MH power off     | default 0
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_484.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/usb/gspca/pac7302.c#L13-L78

```c
/*
 * Some documentation about various registers as determined by trial and error.
 *
< ASCII >
 * Register page 0:
 *
 * Address	Description
 * 0x01		Red balance control
 * 0x02		Green balance control
 * 0x03		Blue balance control
 *		     The Windows driver uses a quadratic approach to map
 *		     the settable values (0-200) on register values:
 *		     min=0x20, default=0x40, max=0x80
 * 0x0f-0x20	Color and saturation control
 * 0xa2-0xab	Brightness, contrast and gamma control
 * 0xb6		Sharpness control (bits 0-4)
 *
 * Register page 1:
 *
 * Address	Description
 * 0x78		Global control, bit 6 controls the LED (inverted)
 * 0x80		Compression balance, 2 interesting settings:
 *		0x0f Default
 *		0x50 Values >= this switch the camera to a lower compression,
 *		     using the same table for both luminance and chrominance.
 *		     This gives a sharper picture. Only usable when running
 *		     at < 15 fps! Note currently the driver does not use this
 *		     as the quality gain is small and the generated JPG-s are
 *		     only understood by v4l-utils >= 0.8.9
 *
 * Register page 3:
 *
 * Address	Description
 * 0x02		Clock divider 3-63, fps = 90 / val. Must be a multiple of 3 on
 *		the 7302, so one of 3, 6, 9, ..., except when between 6 and 12?
 * 0x03		Variable framerate ctrl reg2==3: 0 -> ~30 fps, 255 -> ~22fps
 * 0x04		Another var framerate ctrl reg2==3, reg3==0: 0 -> ~30 fps,
 *		63 -> ~27 fps, the 2 msb's must always be 1 !!
 * 0x05		Another var framerate ctrl reg2==3, reg3==0, reg4==0xc0:
 *		1 -> ~30 fps, 2 -> ~20 fps
 * 0x0e		Exposure bits 0-7, 0-448, 0 = use full frame time
 * 0x0f		Exposure bit 8, 0-448, 448 = no exposure at all
 * 0x10		Gain 0-31
 * 0x12		Another gain 0-31, unlike 0x10 this one seems to start with an
 *		amplification value of 1 rather then 0 at its lowest setting
 * 0x21		Bitfield: 0-1 unused, 2-3 vflip/hflip, 4-5 unknown, 6-7 unused
 * 0x80		Another framerate control, best left at 1, moving it from 1 to
 *		2 causes the framerate to become 3/4th of what it was, and
 *		also seems to cause pixel averaging, resulting in an effective
 *		resolution of 320x240 and thus a much blockier image
< ASCII >
 *
 * The registers are accessed in the following functions:
 *
< ASCII >
 * Page | Register   | Function
 * -----+------------+---------------------------------------------------
 *  0   | 0x01       | setredbalance()
 *  0   | 0x03       | setbluebalance()
 *  0   | 0x0f..0x20 | setcolors()
 *  0   | 0xa2..0xab | setbrightcont()
 *  0   | 0xb6       | setsharpness()
 *  0   | 0xc6       | setwhitebalance()
 *  0   | 0xdc       | setbrightcont(), setcolors()
 *  3   | 0x02       | setexposure()
 *  3   | 0x10, 0x12 | setgain()
 *  3   | 0x11       | setcolors(), setgain(), setexposure(), sethvflip()
 *  3   | 0x21       | sethvflip()
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_485.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/usb/gspca/pac_common.h#L21-L58

```c
/*
   The following state machine finds the SOF marker sequence
   0xff, 0xff, 0x00, 0xff, 0x96 in a byte stream.

< ASCII >
	   +----------+
	   | 0: START |<---------------\
	   +----------+<-\             |
	     |       \---/otherwise    |
	     v 0xff                    |
	   +----------+ otherwise      |
	   |     1    |--------------->*
	   |          |                ^
	   +----------+                |
	     |                         |
	     v 0xff                    |
	   +----------+<-\0xff         |
	/->|          |--/             |
	|  |     2    |--------------->*
	|  |          | otherwise      ^
	|  +----------+                |
	|    |                         |
	|    v 0x00                    |
	|  +----------+                |
	|  |     3    |                |
	|  |          |--------------->*
	|  +----------+ otherwise      ^
	|    |                         |
   0xff |    v 0xff                    |
	|  +----------+                |
	\--|     4    |                |
	   |          |----------------/
	   +----------+ otherwise
	     |
	     v 0x96
	   +----------+
	   |  FOUND   |
	   +----------+
< ASCII >
*/
```
## Visual type:
- #state-machine


== ./linux/linux_486.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/usb/s2255/s2255drv.c#L299-L322

```c
/*
< ASCII >
 * The following chart displays how COLORFILTER should be set
 *  =========================================================
 *  =     fourcc              =     COLORFILTER             =
 *  =                         ===============================
 *  =                         =   0             =    1      =
 *  =========================================================
 *  =  V4L2_PIX_FMT_GREY(Y8)  = monochrome from = monochrome=
 *  =                         = s-video or      = composite =
 *  =                         = B/W camera      = input     =
 *  =========================================================
 *  =    other                = color, svideo   = color,    =
 *  =                         =                 = composite =
 *  =========================================================
< ASCII >
 *
 * Notes:
 *   channels 0-3 on 2255 are composite
 *   channels 0-1 on 2257 are composite, 2-3 are s-video
 * If COLORFILTER is 0 with a composite color camera connected,
 * the output will appear monochrome but hatching
 * will occur.
 * COLORFILTER is different from "color killer" and "color effects"
 * for reasons above.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_487.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/media/usb/uvc/uvc_driver.c#L1311-L1336

```c
/*
 * Scan the UVC descriptors to locate a chain starting at an Output Terminal
 * and containing the following units:
 *
 * - one or more Output Terminals (USB Streaming or Display)
 * - zero or one Processing Unit
 * - zero, one or more single-input Selector Units
 * - zero or one multiple-input Selector Units, provided all inputs are
 *   connected to input terminals
 * - zero, one or mode single-input Extension Units
 * - one or more Input Terminals (Camera, External or USB Streaming)
 *
 * The terminal and units must match on of the following structures:
 *
< ASCII >
 * ITT_*(0) -> +---------+    +---------+    +---------+ -> TT_STREAMING(0)
 * ...         | SU{0,1} | -> | PU{0,1} | -> | XU{0,n} |    ...
 * ITT_*(n) -> +---------+    +---------+    +---------+ -> TT_STREAMING(n)
 *
 *                 +---------+    +---------+ -> OTT_*(0)
 * TT_STREAMING -> | PU{0,1} | -> | XU{0,n} |    ...
 *                 +---------+    +---------+ -> OTT_*(n)
< ASCII >
 *
 * The Processing Unit and Extension Units can be in any order. Additional
 * Extension Units connected to the main chain as single-unit branches are
 * also supported. Single-input Selector Units are ignored.
 */
```
## Visual type:
- #custom


== ./linux/linux_488.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/memory/tegra/mc.c#L757-L779

```c
/*
 * Memory Controller (MC) has few Memory Clients that are issuing memory
 * bandwidth allocation requests to the MC interconnect provider. The MC
 * provider aggregates the requests and then sends the aggregated request
 * up to the External Memory Controller (EMC) interconnect provider which
 * re-configures hardware interface to External Memory (EMEM) in accordance
 * to the required bandwidth. Each MC interconnect node represents an
 * individual Memory Client.
 *
< ASCII >
 * Memory interconnect topology:
 *
 *               +----+
 * +--------+    |    |
 * | TEXSRD +--->+    |
 * +--------+    |    |
 *               |    |    +-----+    +------+
 *    ...        | MC +--->+ EMC +--->+ EMEM |
 *               |    |    +-----+    +------+
 * +--------+    |    |
 * | DISP.. +--->+    |
 * +--------+    |    |
 *               +----+
< ASCII >
 */
```
## Visual type:
- #topology


== ./linux/linux_489.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/misc/fastrpc.c#L827-L852

```c
/*
 * Fastrpc payload buffer with metadata looks like:
 *
< ASCII >
 * >>>>>>  START of METADATA <<<<<<<<<
 * +---------------------------------+
 * |           Arguments             |
 * | type:(union fastrpc_remote_arg)|
 * |             (0 - N)             |
 * +---------------------------------+
 * |         Invoke Buffer list      |
 * | type:(struct fastrpc_invoke_buf)|
 * |           (0 - N)               |
 * +---------------------------------+
 * |         Page info list          |
 * | type:(struct fastrpc_phy_page)  |
 * |             (0 - N)             |
 * +---------------------------------+
 * |         Optional info           |
 * |(can be specific to SoC/Firmware)|
 * +---------------------------------+
 * >>>>>>>>  END of METADATA <<<<<<<<<
 * +---------------------------------+
 * |         Inline ARGS             |
 * |            (0-N)                |
 * +---------------------------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_49.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-orion5x/dns323-setup.c#L437-L453

```c
/* Rev C1 Fan speed notes:
 *
 * The fan is controlled by 2 GPIOs on this board. The settings
 * of the bits is as follow:
 *
< ASCII >
 *  GPIO 18    GPIO 19    Fan
 *
 *    0          0        stopped
 *    0          1        low speed
 *    1          0        high speed
 *    1          1        don't do that (*)
< ASCII >
 *
 * (*) I think the two bits control two feed-in resistors into a fixed
 *     PWN circuit, setting both bits will basically go a 'bit' faster
 *     than high speed, but d-link doesn't do it and you may get out of
 *     HW spec so don't do it.
 */
```
## Visual type:
- #table


== ./linux/linux_490.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/misc/genwqe/card_ddcb.c#L35-L80

```c
/*
 * N: next DDCB, this is where the next DDCB will be put.
 * A: active DDCB, this is where the code will look for the next completion.
 * x: DDCB is enqueued, we are waiting for its completion.

< ASCII >
 * Situation (1): Empty queue
 *  +---+---+---+---+---+---+---+---+
 *  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
 *  |   |   |   |   |   |   |   |   |
 *  +---+---+---+---+---+---+---+---+
 *           A/N
 *  enqueued_ddcbs = A - N = 2 - 2 = 0
 *
 * Situation (2): Wrapped, N > A
 *  +---+---+---+---+---+---+---+---+
 *  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
 *  |   |   | x | x |   |   |   |   |
 *  +---+---+---+---+---+---+---+---+
 *            A       N
 *  enqueued_ddcbs = N - A = 4 - 2 = 2
 *
 * Situation (3): Queue wrapped, A > N
 *  +---+---+---+---+---+---+---+---+
 *  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
 *  | x | x |   |   | x | x | x | x |
 *  +---+---+---+---+---+---+---+---+
 *            N       A
 *  enqueued_ddcbs = queue_max  - (A - N) = 8 - (4 - 2) = 6
 *
 * Situation (4a): Queue full N > A
 *  +---+---+---+---+---+---+---+---+
 *  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
 *  | x | x | x | x | x | x | x |   |
 *  +---+---+---+---+---+---+---+---+
 *    A                           N
 *
 *  enqueued_ddcbs = N - A = 7 - 0 = 7
 *
 * Situation (4a): Queue full A > N
 *  +---+---+---+---+---+---+---+---+
 *  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
 *  | x | x | x |   | x | x | x | x |
 *  +---+---+---+---+---+---+---+---+
 *                N   A
 *  enqueued_ddcbs = queue_max - (A - N) = 8 - (4 - 3) = 7
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_491.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/misc/habanalabs/gaudi/gaudi.c#L6775-L6792

```c
/*
< ASCII >
 *  +-------------------+------------------------------------------------------+
 *  | Configuration Reg |                     Description                      |
 *  |      Address      |                                                      |
 *  +-------------------+------------------------------------------------------+
 *  |  0xF30 - 0xF3F    |ECC single error indication (1 bit per memory wrapper)|
 *  |                   |0xF30 memory wrappers 31:0 (MSB to LSB)               |
 *  |                   |0xF34 memory wrappers 63:32                           |
 *  |                   |0xF38 memory wrappers 95:64                           |
 *  |                   |0xF3C memory wrappers 127:96                          |
 *  +-------------------+------------------------------------------------------+
 *  |  0xF40 - 0xF4F    |ECC double error indication (1 bit per memory wrapper)|
 *  |                   |0xF40 memory wrappers 31:0 (MSB to LSB)               |
 *  |                   |0xF44 memory wrappers 63:32                           |
 *  |                   |0xF48 memory wrappers 95:64                           |
 *  |                   |0xF4C memory wrappers 127:96                          |
 *  +-------------------+------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_492.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/misc/habanalabs/gaudi2/gaudi2.c#L9994-L10011

```c
/*
 * hl_mmu_scramble - converts a dram (non power of 2) page-size aligned address
 *                   to DMMU page-size address (64MB) before mapping it in
 *                   the MMU.
 * The operation is performed on both the virtual and physical addresses.
 * for device with 6 HBMs the scramble is:
 * (addr[47:0] / 48M) * 64M + addr % 48M + addr[63:48]
 *
< ASCII >
 * Example:
 * =============================================================================
 * Allocated DRAM  Reserved VA      scrambled VA for MMU mapping    Scrambled PA
 * Phys address                                                     in MMU last
 *                                                                    HOP
 * =============================================================================
 * PA1 0x3000000  VA1 0x9C000000  SVA1= (VA1/48M)*64M 0xD0000000  <- PA1/48M 0x1
 * PA2 0x9000000  VA2 0x9F000000  SVA2= (VA2/48M)*64M 0xD4000000  <- PA2/48M 0x3
 * =============================================================================
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_493.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/misc/ibmasm/ibmasmfs.c#L16-L60

```c
/*
 * The IBMASM file virtual filesystem. It creates the following hierarchy
 * dynamically when mounted from user space:
 *
< ASCII >
 *    /ibmasm
 *    |-- 0
 *    |   |-- command
 *    |   |-- event
 *    |   |-- reverse_heartbeat
 *    |   `-- remote_video
 *    |       |-- depth
 *    |       |-- height
 *    |       `-- width
 *    .
 *    .
 *    .
 *    `-- n
 *        |-- command
 *        |-- event
 *        |-- reverse_heartbeat
 *        `-- remote_video
 *            |-- depth
 *            |-- height
 *            `-- width
< ASCII >
 *
 * For each service processor the following files are created:
 *
 * command: execute dot commands
 *	write: execute a dot command on the service processor
 *	read: return the result of a previously executed dot command
 *
 * events: listen for service processor events
 *	read: sleep (interruptible) until an event occurs
 *      write: wakeup sleeping event listener
 *
 * reverse_heartbeat: send a heartbeat to the service processor
 *	read: sleep (interruptible) until the reverse heartbeat fails
 *      write: wakeup sleeping heartbeat listener
 *
 * remote_video/width
 * remote_video/height
 * remote_video/width: control remote display settings
 *	write: set value
 *	read: read value
 */
```
## Visual type:
- #tree


== ./linux/linux_494.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/misc/sgi-gru/gruhandles.h#L481-L495

```c
/*
 * Convert a processor pagesize into the strange encoded pagesize used by the
 * GRU. Processor pagesize is encoded as log of bytes per page. (or PAGE_SHIFT)
< ASCII >
 * 	pagesize	log pagesize	grupagesize
 * 	  4k			12	0
 * 	 16k 			14	1
 * 	 64k			16	2
 * 	256k			18	3
 * 	  1m			20	4
 * 	  2m			21	5
 * 	  4m			22	6
 * 	 16m			24	7
 * 	 64m			26	8
 * 	...
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_495.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/misc/sgi-gru/grutables.h#L13-L130

```c
/*
 * GRU Chiplet:
 *   The GRU is a user addressible memory accelerator. It provides
 *   several forms of load, store, memset, bcopy instructions. In addition, it
 *   contains special instructions for AMOs, sending messages to message
 *   queues, etc.
 *
 *   The GRU is an integral part of the node controller. It connects
 *   directly to the cpu socket. In its current implementation, there are 2
 *   GRU chiplets in the node controller on each blade (~node).
 *
 *   The entire GRU memory space is fully coherent and cacheable by the cpus.
 *
< ASCII >
 *   Each GRU chiplet has a physical memory map that looks like the following:
 *
 *   	+-----------------+
 *   	|/////////////////|
 *   	|/////////////////|
 *   	|/////////////////|
 *   	|/////////////////|
 *   	|/////////////////|
 *   	|/////////////////|
 *   	|/////////////////|
 *   	|/////////////////|
 *   	+-----------------+
 *   	|  system control |
 *   	+-----------------+        _______ +-------------+
 *   	|/////////////////|       /        |             |
 *   	|/////////////////|      /         |             |
 *   	|/////////////////|     /          | instructions|
 *   	|/////////////////|    /           |             |
 *   	|/////////////////|   /            |             |
 *   	|/////////////////|  /             |-------------|
 *   	|/////////////////| /              |             |
 *   	+-----------------+                |             |
 *   	|   context 15    |                |  data       |
 *   	+-----------------+                |             |
 *   	|    ......       | \              |             |
 *   	+-----------------+  \____________ +-------------+
 *   	|   context 1     |
 *   	+-----------------+
 *   	|   context 0     |
 *   	+-----------------+
< ASCII >
 *
 *   Each of the "contexts" is a chunk of memory that can be mmaped into user
 *   space. The context consists of 2 parts:
 *
 *  	- an instruction space that can be directly accessed by the user
 *  	  to issue GRU instructions and to check instruction status.
 *
 *  	- a data area that acts as normal RAM.
 *
 *   User instructions contain virtual addresses of data to be accessed by the
 *   GRU. The GRU contains a TLB that is used to convert these user virtual
 *   addresses to physical addresses.
 *
 *   The "system control" area of the GRU chiplet is used by the kernel driver
 *   to manage user contexts and to perform functions such as TLB dropin and
 *   purging.
 *
 *   One context may be reserved for the kernel and used for cross-partition
 *   communication. The GRU will also be used to asynchronously zero out
 *   large blocks of memory (not currently implemented).
 *
 *
< ASCII >
 * Tables:
 *
 * 	VDATA-VMA Data		- Holds a few parameters. Head of linked list of
 * 				  GTS tables for threads using the GSEG
 * 	GTS - Gru Thread State  - contains info for managing a GSEG context. A
 * 				  GTS is allocated for each thread accessing a
 * 				  GSEG.
 *     	GTD - GRU Thread Data   - contains shadow copy of GRU data when GSEG is
 *     				  not loaded into a GRU
 *	GMS - GRU Memory Struct - Used to manage TLB shootdowns. Tracks GRUs
 *				  where a GSEG has been loaded. Similar to
 *				  an mm_struct but for GRU.
 *
 *	GS  - GRU State 	- Used to manage the state of a GRU chiplet
 *	BS  - Blade State	- Used to manage state of all GRU chiplets
 *				  on a blade
< ASCII >
 *
 *
 *  Normal task tables for task using GRU.
 *  		- 2 threads in process
 *  		- 2 GSEGs open in process
 *  		- GSEG1 is being used by both threads
 *  		- GSEG2 is used only by thread 2
 *
< ASCII >
 *       task -->|
 *       task ---+---> mm ->------ (notifier) -------+-> gms
 *                     |                             |
 *                     |--> vma -> vdata ---> gts--->|		GSEG1 (thread1)
 *                     |                  |          |
 *                     |                  +-> gts--->|		GSEG1 (thread2)
 *                     |                             |
 *                     |--> vma -> vdata ---> gts--->|		GSEG2 (thread2)
 *                     .
 *                     .
< ASCII >
 *
 *  GSEGs are marked DONTCOPY on fork
 *
 * At open
 * 	file.private_data -> NULL
 *
 * At mmap,
 * 	vma -> vdata
 *
 * After gseg reference
 * 	vma -> vdata ->gts
 *
 * After fork
 *   parent
 * 	vma -> vdata -> gts
 *   child
 * 	(vma is not copied)
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_496.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/misc/vmw_vmci/vmci_queue_pair.c#L33-L122

```c
/*
 * In the following, we will distinguish between two kinds of VMX processes -
 * the ones with versions lower than VMCI_VERSION_NOVMVM that use specialized
 * VMCI page files in the VMX and supporting VM to VM communication and the
 * newer ones that use the guest memory directly. We will in the following
 * refer to the older VMX versions as old-style VMX'en, and the newer ones as
 * new-style VMX'en.
 *
 * The state transition datagram is as follows (the VMCIQPB_ prefix has been
 * removed for readability) - see below for more details on the transtions:
 *
< ASCII >
 *            --------------  NEW  -------------
 *            |                                |
 *           \_/                              \_/
 *     CREATED_NO_MEM <-----------------> CREATED_MEM
 *            |    |                           |
 *            |    o-----------------------o   |
 *            |                            |   |
 *           \_/                          \_/ \_/
 *     ATTACHED_NO_MEM <----------------> ATTACHED_MEM
 *            |                            |   |
 *            |     o----------------------o   |
 *            |     |                          |
 *           \_/   \_/                        \_/
 *     SHUTDOWN_NO_MEM <----------------> SHUTDOWN_MEM
 *            |                                |
 *            |                                |
 *            -------------> gone <-------------
< ASCII >
 *
 * In more detail. When a VMCI queue pair is first created, it will be in the
 * VMCIQPB_NEW state. It will then move into one of the following states:
 *
 * - VMCIQPB_CREATED_NO_MEM: this state indicates that either:
 *
 *     - the created was performed by a host endpoint, in which case there is
 *       no backing memory yet.
 *
 *     - the create was initiated by an old-style VMX, that uses
 *       vmci_qp_broker_set_page_store to specify the UVAs of the queue pair at
 *       a later point in time. This state can be distinguished from the one
 *       above by the context ID of the creator. A host side is not allowed to
 *       attach until the page store has been set.
 *
 * - VMCIQPB_CREATED_MEM: this state is the result when the queue pair
 *     is created by a VMX using the queue pair device backend that
 *     sets the UVAs of the queue pair immediately and stores the
 *     information for later attachers. At this point, it is ready for
 *     the host side to attach to it.
 *
 * Once the queue pair is in one of the created states (with the exception of
 * the case mentioned for older VMX'en above), it is possible to attach to the
 * queue pair. Again we have two new states possible:
 *
 * - VMCIQPB_ATTACHED_MEM: this state can be reached through the following
 *   paths:
 *
 *     - from VMCIQPB_CREATED_NO_MEM when a new-style VMX allocates a queue
 *       pair, and attaches to a queue pair previously created by the host side.
 *
 *     - from VMCIQPB_CREATED_MEM when the host side attaches to a queue pair
 *       already created by a guest.
 *
 *     - from VMCIQPB_ATTACHED_NO_MEM, when an old-style VMX calls
 *       vmci_qp_broker_set_page_store (see below).
 *
 * - VMCIQPB_ATTACHED_NO_MEM: If the queue pair already was in the
 *     VMCIQPB_CREATED_NO_MEM due to a host side create, an old-style VMX will
 *     bring the queue pair into this state. Once vmci_qp_broker_set_page_store
 *     is called to register the user memory, the VMCIQPB_ATTACH_MEM state
 *     will be entered.
 *
 * From the attached queue pair, the queue pair can enter the shutdown states
 * when either side of the queue pair detaches. If the guest side detaches
 * first, the queue pair will enter the VMCIQPB_SHUTDOWN_NO_MEM state, where
 * the content of the queue pair will no longer be available. If the host
 * side detaches first, the queue pair will either enter the
 * VMCIQPB_SHUTDOWN_MEM, if the guest memory is currently mapped, or
 * VMCIQPB_SHUTDOWN_NO_MEM, if the guest memory is not mapped
 * (e.g., the host detaches while a guest is stunned).
 *
 * New-style VMX'en will also unmap guest memory, if the guest is
 * quiesced, e.g., during a snapshot operation. In that case, the guest
 * memory will no longer be available, and the queue pair will transition from
 * *_MEM state to a *_NO_MEM state. The VMX may later map the memory once more,
 * in which case the queue pair will transition from the *_NO_MEM state at that
 * point back to the *_MEM state. Note that the *_NO_MEM state may have changed,
 * since the peer may have either attached or detached in the meantime. The
 * values are laid out such that ++ on a state will move from a *_NO_MEM to a
 * *_MEM state, and vice versa.
 */
```
## Visual type:
- #state-machine


== ./linux/linux_497.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/mmc/host/cqhci-core.c#L154-L168

```c
/*
 * The allocated descriptor table for task, link & transfer descriptors
 * looks like:
< ASCII >
 * |----------|
 * |task desc |  |->|----------|
 * |----------|  |  |trans desc|
 * |link desc-|->|  |----------|
 * |----------|          .
 *      .                .
 *  no. of slots      max-segs
 *      .           |----------|
 * |----------|
< ASCII >
 * The idea here is to create the [task+trans] table and mark & point the
 * link desc to the transfer desc table on a per slot basis.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_498.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/mmc/host/sdhci-of-aspeed.c#L80-L90

```c
/*
 * The function sets the mirror register for updating
 * capbilities of the current slot.
 *
< ASCII >
 *   slot | capability  | caps_reg | mirror_reg
 *   -----|-------------|----------|------------
 *     0  | CAP1_1_8V   | SDIO140  |   SDIO10
 *     0  | CAP2_SDR104 | SDIO144  |   SDIO14
 *     1  | CAP1_1_8V   | SDIO240  |   SDIO20
 *     1  | CAP2_SDR104 | SDIO244  |   SDIO24
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_499.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/mtd/devices/mtd_dataflash.c#L840-L853

```c
/*
 * Detect and initialize DataFlash device, using JEDEC IDs on newer chips
 * or else the ID code embedded in the status bits:
 *
< ASCII >
 *   Device      Density         ID code          #Pages PageSize  Offset
 *   AT45DB011B  1Mbit   (128K)  xx0011xx (0x0c)    512    264      9
 *   AT45DB021B  2Mbit   (256K)  xx0101xx (0x14)   1024    264      9
 *   AT45DB041B  4Mbit   (512K)  xx0111xx (0x1c)   2048    264      9
 *   AT45DB081B  8Mbit   (1M)    xx1001xx (0x24)   4096    264      9
 *   AT45DB0161B 16Mbit  (2M)    xx1011xx (0x2c)   4096    528     10
 *   AT45DB0321B 32Mbit  (4M)    xx1101xx (0x34)   8192    528     10
 *   AT45DB0642  64Mbit  (8M)    xx111xxx (0x3c)   8192   1056     11
 *   AT45DB1282  128Mbit (16M)   xx0100xx (0x10)  16384   1056     11
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_5.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/include/asm/core_t2.h#L95-L127

```c
/*  T2 CSRs are in the non-cachable primary IO space from 3.8000.0000 to
 3.8fff.ffff
 *
< ASCII >
 *  +--------------+ 3 8000 0000
 *  | CPU 0 CSRs   |
 *  +--------------+ 3 8100 0000
 *  | CPU 1 CSRs   |
 *  +--------------+ 3 8200 0000
 *  | CPU 2 CSRs   |
 *  +--------------+ 3 8300 0000
 *  | CPU 3 CSRs   |
 *  +--------------+ 3 8400 0000
 *  | CPU Reserved |
 *  +--------------+ 3 8700 0000
 *  | Mem Reserved |
 *  +--------------+ 3 8800 0000
 *  | Mem 0 CSRs   |
 *  +--------------+ 3 8900 0000
 *  | Mem 1 CSRs   |
 *  +--------------+ 3 8a00 0000
 *  | Mem 2 CSRs   |
 *  +--------------+ 3 8b00 0000
 *  | Mem 3 CSRs   |
 *  +--------------+ 3 8c00 0000
 *  | Mem Reserved |
 *  +--------------+ 3 8e00 0000
 *  | PCI Bridge   |
 *  +--------------+ 3 8f00 0000
 *  | Expansion IO |
 *  +--------------+ 3 9000 0000
< ASCII >
 *
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_50.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-orion5x/dns323-setup.c#L455-L462

```c
/*
 * On the DNS-323 A1 and B1 the following devices are attached via I2C:
 *
< ASCII >
 *  i2c addr | chip        | description
 *  0x3e     | GMT G760Af  | fan speed PWM controller
 *  0x48     | GMT G751-2f | temp. sensor and therm. watchdog (LM75 compatible)
 *  0x68     | ST M41T80   | RTC w/ alarm
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_500.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/mtd/nand/raw/nand_micron.c#L19-L32

```c
/*
 * On chips with 8-bit ECC and additional bit can be used to distinguish
 * cases where a errors were corrected without needing a rewrite
 *
< ASCII >
 * Bit 4 Bit 3 Bit 0 Description
 * ----- ----- ----- -----------
 * 0     0     0     No Errors
 * 0     0     1     Multiple uncorrected errors
 * 0     1     0     4 - 6 errors corrected, recommend rewrite
 * 0     1     1     Reserved
 * 1     0     0     1 - 3 errors corrected
 * 1     0     1     Reserved
 * 1     1     0     7 - 8 errors corrected, recommend rewrite
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_501.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/mtd/nand/raw/qcom_nandc.c#L2555-L2639

```c
/*
 * NAND controller page layout info
 *
< ASCII >
 * Layout with ECC enabled:
 *
 * |----------------------|  |---------------------------------|
 * |           xx.......yy|  |             *********xx.......yy|
 * |    DATA   xx..ECC..yy|  |    DATA     **SPARE**xx..ECC..yy|
 * |   (516)   xx.......yy|  |  (516-n*4)  **(n*4)**xx.......yy|
 * |           xx.......yy|  |             *********xx.......yy|
 * |----------------------|  |---------------------------------|
 *     codeword 1,2..n-1                  codeword n
 *  <---(528/532 Bytes)-->    <-------(528/532 Bytes)--------->
< ASCII >
 *
 * n = Number of codewords in the page
 * . = ECC bytes
 * * = Spare/free bytes
 * x = Unused byte(s)
 * y = Reserved byte(s)
 *
 * 2K page: n = 4, spare = 16 bytes
 * 4K page: n = 8, spare = 32 bytes
 * 8K page: n = 16, spare = 64 bytes
 *
 * the qcom nand controller operates at a sub page/codeword level. each
 * codeword is 528 and 532 bytes for 4 bit and 8 bit ECC modes respectively.
 * the number of ECC bytes vary based on the ECC strength and the bus width.
 *
 * the first n - 1 codewords contains 516 bytes of user data, the remaining
 * 12/16 bytes consist of ECC and reserved data. The nth codeword contains
 * both user data and spare(oobavail) bytes that sum up to 516 bytes.
 *
 * When we access a page with ECC enabled, the reserved bytes(s) are not
 * accessible at all. When reading, we fill up these unreadable positions
 * with 0xffs. When writing, the controller skips writing the inaccessible
 * bytes.
 *
< ASCII >
 * Layout with ECC disabled:
 *
 * |------------------------------|  |---------------------------------------|
 * |         yy          xx.......|  |         bb          *********xx.......|
 * |  DATA1  yy  DATA2   xx..ECC..|  |  DATA1  bb  DATA2   **SPARE**xx..ECC..|
 * | (size1) yy (size2)  xx.......|  | (size1) bb (size2)  **(n*4)**xx.......|
 * |         yy          xx.......|  |         bb          *********xx.......|
 * |------------------------------|  |---------------------------------------|
 *         codeword 1,2..n-1                        codeword n
 *  <-------(528/532 Bytes)------>    <-----------(528/532 Bytes)----------->
< ASCII >
 *
 * n = Number of codewords in the page
 * . = ECC bytes
 * * = Spare/free bytes
 * x = Unused byte(s)
 * y = Dummy Bad Bock byte(s)
 * b = Real Bad Block byte(s)
 * size1/size2 = function of codeword size and 'n'
 *
 * when the ECC block is disabled, one reserved byte (or two for 16 bit bus
 * width) is now accessible. For the first n - 1 codewords, these are dummy Bad
 * Block Markers. In the last codeword, this position contains the real BBM
 *
 * In order to have a consistent layout between RAW and ECC modes, we assume
 * the following OOB layout arrangement:
< ASCII >
 *
 * |-----------|  |--------------------|
 * |yyxx.......|  |bb*********xx.......|
 * |yyxx..ECC..|  |bb*FREEOOB*xx..ECC..|
 * |yyxx.......|  |bb*********xx.......|
 * |yyxx.......|  |bb*********xx.......|
 * |-----------|  |--------------------|
 *  first n - 1       nth OOB region
 *  OOB regions
< ASCII >
 *
 * n = Number of codewords in the page
 * . = ECC bytes
 * * = FREE OOB bytes
 * y = Dummy bad block byte(s) (inaccessible when ECC enabled)
 * x = Unused byte(s)
 * b = Real bad block byte(s) (inaccessible when ECC enabled)
 *
 * This layout is read as is when ECC is disabled. When ECC is enabled, the
 * inaccessible Bad Block byte(s) are ignored when we write to a page/oob,
 * and assumed as 0xffs when we read a page/oob. The ECC, unused and
 * dummy/real bad block bytes are grouped as ecc bytes (i.e, ecc->bytes is
 * the sum of the three).
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_502.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/mtd/nand/raw/gpmi-nand/gpmi-nand.c#L766-L839

```c
/*
 * <1> Firstly, we should know what's the GPMI-clock means.
 *     The GPMI-clock is the internal clock in the gpmi nand controller.
 *     If you set 100MHz to gpmi nand controller, the GPMI-clock's period
 *     is 10ns. Mark the GPMI-clock's period as GPMI-clock-period.
 *
 * <2> Secondly, we should know what's the frequency on the nand chip pins.
 *     The frequency on the nand chip pins is derived from the GPMI-clock.
 *     We can get it from the following equation:
 *
 *         F = G / (DS + DH)
 *
 *         F  : the frequency on the nand chip pins.
 *         G  : the GPMI clock, such as 100MHz.
 *         DS : GPMI_HW_GPMI_TIMING0:DATA_SETUP
 *         DH : GPMI_HW_GPMI_TIMING0:DATA_HOLD
 *
 * <3> Thirdly, when the frequency on the nand chip pins is above 33MHz,
 *     the nand EDO(extended Data Out) timing could be applied.
 *     The GPMI implements a feedback read strobe to sample the read data.
 *     The feedback read strobe can be delayed to support the nand EDO timing
 *     where the read strobe may deasserts before the read data is valid, and
 *     read data is valid for some time after read strobe.
 *
 *     The following figure illustrates some aspects of a NAND Flash read:
< ASCII >
 *
 *                   |<---tREA---->|
 *                   |             |
 *                   |         |   |
 *                   |<--tRP-->|   |
 *                   |         |   |
 *                  __          ___|__________________________________
 *     RDN            \________/   |
 *                                 |
 *                                 /---------\
 *     Read Data    --------------<           >---------
 *                                 \---------/
 *                                |     |
 *                                |<-D->|
 *     FeedbackRDN  ________             ____________
 *                          \___________/
 *
 *          D stands for delay, set in the HW_GPMI_CTRL1:RDN_DELAY.
< ASCII >
 *
 *
 * <4> Now, we begin to describe how to compute the right RDN_DELAY.
 *
 *  4.1) From the aspect of the nand chip pins:
 *        Delay = (tREA + C - tRP)               {1}
 *
 *        tREA : the maximum read access time.
 *        C    : a constant to adjust the delay. default is 4000ps.
 *        tRP  : the read pulse width, which is exactly:
 *                   tRP = (GPMI-clock-period) * DATA_SETUP
 *
 *  4.2) From the aspect of the GPMI nand controller:
 *         Delay = RDN_DELAY * 0.125 * RP        {2}
 *
 *         RP   : the DLL reference period.
 *            if (GPMI-clock-period > DLL_THRETHOLD)
 *                   RP = GPMI-clock-period / 2;
 *            else
 *                   RP = GPMI-clock-period;
 *
 *            Set the HW_GPMI_CTRL1:HALF_PERIOD if GPMI-clock-period
 *            is greater DLL_THRETHOLD. In other SOCs, the DLL_THRETHOLD
 *            is 16000ps, but in mx6q, we use 12000ps.
 *
< ASCII >
 *  4.3) since {1} equals {2}, we get:
 *
 *                     (tREA + 4000 - tRP) * 8
 *         RDN_DELAY = -----------------------     {3}
 *                           RP
< ASCII >
 */
```
## Visual type:
- #plot


== ./linux/linux_503.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/mtd/nand/raw/gpmi-nand/gpmi-nand.c#L1691-L1750

```c
/*
 * There are several places in this driver where we have to handle the OOB and
 * block marks. This is the function where things are the most complicated, so
 * this is where we try to explain it all. All the other places refer back to
 * here.
 *
 * These are the rules, in order of decreasing importance:
 *
 * 1) Nothing the caller does can be allowed to imperil the block mark.
 *
 * 2) In read operations, the first byte of the OOB we return must reflect the
 *    true state of the block mark, no matter where that block mark appears in
 *    the physical page.
 *
 * 3) ECC-based read operations return an OOB full of set bits (since we never
 *    allow ECC-based writes to the OOB, it doesn't matter what ECC-based reads
 *    return).
 *
 * 4) "Raw" read operations return a direct view of the physical bytes in the
 *    page, using the conventional definition of which bytes are data and which
 *    are OOB. This gives the caller a way to see the actual, physical bytes
 *    in the page, without the distortions applied by our ECC engine.
 *
 *
 * What we do for this specific read operation depends on two questions:
 *
 * 1) Are we doing a "raw" read, or an ECC-based read?
 *
 * 2) Are we using block mark swapping or transcription?
 *
< ASCII >
 * There are four cases, illustrated by the following Karnaugh map:
 *
 *                    |           Raw           |         ECC-based       |
 *       -------------+-------------------------+-------------------------+
 *                    | Read the conventional   |                         |
 *                    | OOB at the end of the   |                         |
 *       Swapping     | page and return it. It  |                         |
 *                    | contains exactly what   |                         |
 *                    | we want.                | Read the block mark and |
 *       -------------+-------------------------+ return it in a buffer   |
 *                    | Read the conventional   | full of set bits.       |
 *                    | OOB at the end of the   |                         |
 *                    | page and also the block |                         |
 *       Transcribing | mark in the metadata.   |                         |
 *                    | Copy the block mark     |                         |
 *                    | into the first byte of  |                         |
 *                    | the OOB.                |                         |
 *       -------------+-------------------------+-------------------------+
< ASCII >
 *
 * Note that we break rule #4 in the Transcribing/Raw case because we're not
 * giving an accurate view of the actual, physical bytes in the page (we're
 * overwriting the block mark). That's OK because it's more important to follow
 * rule #2.
 *
 * It turns out that knowing whether we want an "ECC-based" or "raw" read is not
 * easy. When reading a page, for example, the NAND Flash MTD code calls our
 * ecc.read_page or ecc.read_page_raw function. Thus, the fact that MTD wants an
 * ECC-based or raw view of the page is implicit in which function it calls
 * (there is a similar pair of ECC-based/raw functions for writing).
 */
```
## Visual type:
- #table


== ./linux/linux_504.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/mtd/parsers/sharpslpart.c#L265-L281

```c
/*
 * MTD Partition Parser
 *
 * Sample values read from SL-C860
 *
< ASCII >
 * # cat /proc/mtd
 * dev:    size   erasesize  name
 * mtd0: 006d0000 00020000 "Filesystem"
 * mtd1: 00700000 00004000 "smf"
 * mtd2: 03500000 00004000 "root"
 * mtd3: 04400000 00004000 "home"
 *
 * PARTITIONINFO1
 * 0x00060000: 00 00 00 00 00 00 70 00 42 4f 4f 54 00 00 00 00  ......p.BOOT....
 * 0x00060010: 00 00 70 00 00 00 c0 03 46 53 52 4f 00 00 00 00  ..p.....FSRO....
 * 0x00060020: 00 00 c0 03 00 00 00 04 46 53 52 57 00 00 00 00  ........FSRW....
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_505.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/mtd/spi-nor/swp.c#L121-L153

```c
/*
 * Lock a region of the flash. Compatible with ST Micro and similar flash.
 * Supports the block protection bits BP{0,1,2}/BP{0,1,2,3} in the status
 * register
 * (SR). Does not support these features found in newer SR bitfields:
 *   - SEC: sector/block protect - only handle SEC=0 (block protect)
 *   - CMP: complement protect - only support CMP=0 (range is not complemented)
 *
 * Support for the following is provided conditionally for some flash:
 *   - TB: top/bottom protect
 *
 * Sample table portion for 8MB flash (Winbond w25q64fw):
< ASCII >
 *
 *   SEC  |  TB   |  BP2  |  BP1  |  BP0  |  Prot Length  | Protected Portion
 *  --------------------------------------------------------------------------
 *    X   |   X   |   0   |   0   |   0   |  NONE         | NONE
 *    0   |   0   |   0   |   0   |   1   |  128 KB       | Upper 1/64
 *    0   |   0   |   0   |   1   |   0   |  256 KB       | Upper 1/32
 *    0   |   0   |   0   |   1   |   1   |  512 KB       | Upper 1/16
 *    0   |   0   |   1   |   0   |   0   |  1 MB         | Upper 1/8
 *    0   |   0   |   1   |   0   |   1   |  2 MB         | Upper 1/4
 *    0   |   0   |   1   |   1   |   0   |  4 MB         | Upper 1/2
 *    X   |   X   |   1   |   1   |   1   |  8 MB         | ALL
 *  ------|-------|-------|-------|-------|---------------|-------------------
 *    0   |   1   |   0   |   0   |   1   |  128 KB       | Lower 1/64
 *    0   |   1   |   0   |   1   |   0   |  256 KB       | Lower 1/32
 *    0   |   1   |   0   |   1   |   1   |  512 KB       | Lower 1/16
 *    0   |   1   |   1   |   0   |   0   |  1 MB         | Lower 1/8
 *    0   |   1   |   1   |   0   |   1   |  2 MB         | Lower 1/4
 *    0   |   1   |   1   |   1   |   0   |  4 MB         | Lower 1/2
< ASCII >
 *
 * Returns negative on errors, 0 on success.
 */
```
## Visual type:
- #table


== ./linux/linux_506.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/amt.c#L383-L407

```c
/* RFC 3810 - 7.2.2.  Definition of Filter Timers
 *
< ASCII >
 *  Router Mode          Filter Timer         Actions/Comments
 *  -----------       -----------------       ----------------
 *
 *    INCLUDE             Not Used            All listeners in
 *                                            INCLUDE mode.
 *
 *    EXCLUDE             Timer > 0           At least one listener
 *                                            in EXCLUDE mode.
 *
 *    EXCLUDE             Timer == 0          No more listeners in
 *                                            EXCLUDE mode for the
 *                                            multicast address.
 *                                            If the Requested List
 *                                            is empty, delete
 *                                            Multicast Address
 *                                            Record.  If not, switch
 *                                            to INCLUDE filter mode;
 *                                            the sources in the
 *                                            Requested List are
 *                                            moved to the Include
 *                                            List, and the Exclude
 *                                            List is deleted.
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_507.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/amt.c#L1449-L1467

```c
/* < ASCII >
 * Router State   Report Rec'd New Router State
 * ------------   ------------ ----------------
 * EXCLUDE (X,Y)  IS_IN (A)    EXCLUDE (X+A,Y-A)
 *
 * -----------+-----------+-----------+
 *            |    OLD    |    NEW    |
 * -----------+-----------+-----------+
 *    FWD     |     X     |    X+A    |
 * -----------+-----------+-----------+
 *    D_FWD   |     Y     |    Y-A    |
 * -----------+-----------+-----------+
 *    NONE    |           |     A     |
 * -----------+-----------+-----------+
< ASCII >
 *
 * a) Received sources are NONE/NEW
 * b) All NONE will be deleted by amt_cleanup_srcs().
 * c) All OLD will be deleted by amt_cleanup_srcs().
 * d) After delete, NEW source will be switched to OLD.
 */
```
## Visual type:
- #table


== ./linux/linux_508.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/can/flexcan/flexcan.h#L19-L37

```c
/* FLEXCAN hardware feature flags
 *
< ASCII >
 * Below is some version info we got:
 *    SOC   Version   IP-Version  Glitch- [TR]WRN_INT IRQ Err Memory err RTR rece-   FD Mode     MB
 *                                Filter? connected?  Passive detection  ption in MB Supported?
 * MCF5441X FlexCAN2  ?               no       yes        no       no        no           no     16
 *    MX25  FlexCAN2  03.00.00.00     no        no        no       no        no           no     64
 *    MX28  FlexCAN2  03.00.04.00    yes       yes        no       no        no           no     64
 *    MX35  FlexCAN2  03.00.00.00     no        no        no       no        no           no     64
 *    MX53  FlexCAN2  03.00.00.00    yes        no        no       no        no           no     64
 *    MX6s  FlexCAN3  10.00.12.00    yes       yes        no       no       yes           no     64
 *    MX8QM FlexCAN3  03.00.23.00    yes       yes        no       no       yes          yes     64
 *    MX8MP FlexCAN3  03.00.17.01    yes       yes        no      yes       yes          yes     64
 *    VF610 FlexCAN3  ?               no       yes        no      yes       yes?          no     64
 *  LS1021A FlexCAN2  03.00.04.00     no       yes        no       no       yes           no     64
 *  LX2160A FlexCAN3  03.00.23.00     no       yes        no      yes       yes          yes     64
< ASCII >
 *
 * Some SOCs do not have the RX_WARN & TX_WARN interrupt line connected.
 */
```
## Visual type:
- #table


== ./linux/linux_509.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/dsa/microchip/ksz8863_smi.c#L11-L18

```c
/* Serial Management Interface (SMI) uses the following frame format:
 *
< ASCII >
 *       preamble|start|Read/Write|  PHY   |  REG  |TA|   Data bits      | Idle
 *               |frame| OP code  |address |address|  |                  |
 * read | 32x1´s | 01  |    00    | 1xRRR  | RRRRR |Z0| 00000000DDDDDDDD |  Z
 * write| 32x1´s | 01  |    00    | 0xRRR  | RRRRR |10| xxxxxxxxDDDDDDDD |  Z
< ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_51.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-orion5x/net2big-setup.c#L92-L96

```c
/*
< ASCII >
 * i2c addr | chip         | description
 * 0x32     | Ricoh 5C372b | RTC
 * 0x50     | HT24LC08     | eeprom (1kB)
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_510.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/dsa/qca/ar9331.c#L124-L146

```c
/* Phy bypass mode
< ASCII >
 * ------------------------------------------------------------------------
 * Bit:   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 |12 |13 |14 |15 |
 *
 * real   | start |   OP  | PhyAddr           |  Reg Addr         |  TA   |
 * atheros| start |   OP  | 2'b00 |PhyAdd[2:0]|  Reg Addr[4:0]    |  TA   |
 *
 *
 * Bit:   |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |26 |27 |28 |29 |30 |31 |
 * real   |  Data                                                         |
 * atheros|  Data                                                         |
 *
 * ------------------------------------------------------------------------
 * Page address mode
 * ------------------------------------------------------------------------
 * Bit:   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 |12 |13 |14 |15 |
 * real   | start |   OP  | PhyAddr           |  Reg Addr         |  TA   |
 * atheros| start |   OP  | 2'b11 |                          8'b0 |  TA   |
 *
 * Bit:   |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |26 |27 |28 |29 |30 |31 |
 * real   |  Data                                                         |
 * atheros|                       | Page [9:0]                            |
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_511.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/dsa/qca/ar9331.c#L152-L163

```c
/* < ASCII >
 * ------------------------------------------------------------------------
 * Normal register access mode
 * ------------------------------------------------------------------------
 * Bit:   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 |12 |13 |14 |15 |
 * real   | start |   OP  | PhyAddr           |  Reg Addr         |  TA   |
 * atheros| start |   OP  | 2'b10 |  low_addr[7:0]                |  TA   |
 *
 * Bit:   |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |26 |27 |28 |29 |30 |31 |
 * real   |  Data                                                         |
 * atheros|  Data                                                         |
 * ------------------------------------------------------------------------
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_512.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/dsa/sja1105/sja1105_main.c#L737-L749

```c
/* SJA1110 TDMACONFIGIDX values:
< ASCII >
 *
 *      | 100 Mbps ports |  1Gbps ports  | 2.5Gbps ports | Disabled ports
 * -----+----------------+---------------+---------------+---------------
 *   0  |   0, [5:10]    |     [1:2]     |     [3:4]     |     retag
 *   1  |0, [5:10], retag|     [1:2]     |     [3:4]     |       -
 *   2  |   0, [5:10]    |  [1:3], retag |       4       |       -
 *   3  |   0, [5:10]    |[1:2], 4, retag|       3       |       -
 *   4  |  0, 2, [5:10]  |    1, retag   |     [3:4]     |       -
 *   5  |  0, 1, [5:10]  |    2, retag   |     [3:4]     |       -
 *  14  |   0, [5:10]    | [1:4], retag  |       -       |       -
 *  15  |     [5:10]     | [0:4], retag  |       -       |       -
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_513.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/dsa/sja1105/sja1105_main.c#L962-L1004

```c
/* The L2 policing table is 2-stage. The table is looked up for each frame
 * according to the ingress port, whether it was broadcast or not, and the
 * classified traffic class (given by VLAN PCP). This portion of the lookup is
 * fixed, and gives access to the SHARINDX, an indirection register pointing
 * within the policing table itself, which is used to resolve the policer that
 * will be used for this frame.
 *
< ASCII >
 *  Stage 1                              Stage 2
 * +------------+--------+              +---------------------------------+
 * |Port 0 TC 0 |SHARINDX|              | Policer 0: Rate, Burst, MTU     |
 * +------------+--------+              +---------------------------------+
 * |Port 0 TC 1 |SHARINDX|              | Policer 1: Rate, Burst, MTU     |
 * +------------+--------+              +---------------------------------+
 *    ...                               | Policer 2: Rate, Burst, MTU     |
 * +------------+--------+              +---------------------------------+
 * |Port 0 TC 7 |SHARINDX|              | Policer 3: Rate, Burst, MTU     |
 * +------------+--------+              +---------------------------------+
 * |Port 1 TC 0 |SHARINDX|              | Policer 4: Rate, Burst, MTU     |
 * +------------+--------+              +---------------------------------+
 *    ...                               | Policer 5: Rate, Burst, MTU     |
 * +------------+--------+              +---------------------------------+
 * |Port 1 TC 7 |SHARINDX|              | Policer 6: Rate, Burst, MTU     |
 * +------------+--------+              +---------------------------------+
 *    ...                               | Policer 7: Rate, Burst, MTU     |
 * +------------+--------+              +---------------------------------+
 * |Port 4 TC 7 |SHARINDX|                 ...
 * +------------+--------+
 * |Port 0 BCAST|SHARINDX|                 ...
 * +------------+--------+
 * |Port 1 BCAST|SHARINDX|                 ...
 * +------------+--------+
 *    ...                                  ...
 * +------------+--------+              +---------------------------------+
 * |Port 4 BCAST|SHARINDX|              | Policer 44: Rate, Burst, MTU    |
 * +------------+--------+              +---------------------------------+
< ASCII >
 *
 * In this driver, we shall use policers 0-4 as statically alocated port
 * (matchall) policers. So we need to make the SHARINDX for all lookups
 * corresponding to this ingress port (8 VLAN PCP lookups and 1 broadcast
 * lookup) equal.
 * The remaining policers (40) shall be dynamically allocated for flower
 * policers, where the key is either vlan_prio or dst_mac ff:ff:ff:ff:ff:ff.
 */
```
## Visual type:
- #custom


== ./linux/linux_514.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/dsa/sja1105/sja1105_ptp.c#L260-L285

```c
/* Reads the SPI interface for an egress timestamp generated by the switch
 * for frames sent using management routes.
 *
< ASCII >
 * SJA1105 E/T layout of the 4-byte SPI payload:
 *
 * 31    23    15    7     0
 * |     |     |     |     |
 * +-----+-----+-----+     ^
 *          ^              |
 *          |              |
 *  24-bit timestamp   Update bit
 *
 *
 * SJA1105 P/Q/R/S layout of the 8-byte SPI payload:
 *
 * 31    23    15    7     0     63    55    47    39    32
 * |     |     |     |     |     |     |     |     |     |
 *                         ^     +-----+-----+-----+-----+
 *                         |                 ^
 *                         |                 |
 *                    Update bit    32-bit timestamp
< ASCII >
 *
 * Notice that the update bit is in the same place.
 * To have common code for E/T and P/Q/R/S for reading the timestamp,
 * we need to juggle with the offset and the bit indices.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_515.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/dsa/sja1105/sja1105_ptp.c#L750-L756

```c
/* The PTP_CLK pin may be configured to toggle with a 50% duty cycle and a
 * frequency f:
 *
< ASCII >
 *           NSEC_PER_SEC
 * f = ----------------------
 *     (PTPPINDUR * 8 ns) * 2
< ASCII >
 */
```
## Visual type:
- #formula


== ./linux/linux_516.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/dsa/sja1105/sja1105_ptp.h#L26-L38

```c
/* Calculate the first base_time in the future that satisfies this
 * relationship:
 *
< ASCII >
 * future_base_time = base_time + N x cycle_time >= now, or
 *
 *      now - base_time
 * N >= ---------------
 *         cycle_time
< ASCII >
 *
 * Because N is an integer, the ceiling value of the above "a / b" ratio
 * is in fact precisely the floor value of "(a + b - 1) / b", which is
 * easier to calculate only having integer division tools.
 */
```
## Visual type:
- #formula


== ./linux/linux_517.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/dsa/sja1105/sja1105_tas.c#L93-L157

```c
/* Lo and behold: the egress scheduler from hell.
 *
 * At the hardware level, the Time-Aware Shaper holds a global linear arrray of
 * all schedule entries for all ports. These are the Gate Control List (GCL)
 * entries, let's call them "timeslots" for short. This linear array of
 * timeslots is held in BLK_IDX_SCHEDULE.
 *
 * Then there are a maximum of 8 "execution threads" inside the switch, which
 * iterate cyclically through the "schedule". Each "cycle" has an entry point
 * and an exit point, both being timeslot indices in the schedule table. The
 * hardware calls each cycle a "subschedule".
 *
 * Subschedule (cycle) i starts when
 *   ptpclkval >= ptpschtm + BLK_IDX_SCHEDULE_ENTRY_POINTS[i].delta.
 *
 * The hardware scheduler iterates BLK_IDX_SCHEDULE with a k ranging from
 *   k = BLK_IDX_SCHEDULE_ENTRY_POINTS[i].address to
 *   k = BLK_IDX_SCHEDULE_PARAMS.subscheind[i]
 *
 * For each schedule entry (timeslot) k, the engine executes the gate control
 * list entry for the duration of BLK_IDX_SCHEDULE[k].delta.
 *
< ASCII >
 *         +---------+
 *         |         | BLK_IDX_SCHEDULE_ENTRY_POINTS_PARAMS
 *         +---------+
 *              |
 *              +-----------------+
 *                                | .actsubsch
 *  BLK_IDX_SCHEDULE_ENTRY_POINTS v
 *                 +-------+-------+
 *                 |cycle 0|cycle 1|
 *                 +-------+-------+
 *                   |  |      |  |
 *  +----------------+  |      |  +-------------------------------------+
 *  |   .subschindx     |      |             .subschindx                |
 *  |                   |      +---------------+                        |
 *  |          .address |        .address      |                        |
 *  |                   |                      |                        |
 *  |                   |                      |                        |
 *  |  BLK_IDX_SCHEDULE v                      v                        |
 *  |              +-------+-------+-------+-------+-------+------+     |
 *  |              |entry 0|entry 1|entry 2|entry 3|entry 4|entry5|     |
 *  |              +-------+-------+-------+-------+-------+------+     |
 *  |                                  ^                    ^  ^  ^     |
 *  |                                  |                    |  |  |     |
 *  |        +-------------------------+                    |  |  |     |
 *  |        |              +-------------------------------+  |  |     |
 *  |        |              |              +-------------------+  |     |
 *  |        |              |              |                      |     |
 *  | +---------------------------------------------------------------+ |
 *  | |subscheind[0]<=subscheind[1]<=subscheind[2]<=...<=subscheind[7]| |
 *  | +---------------------------------------------------------------+ |
 *  |        ^              ^                BLK_IDX_SCHEDULE_PARAMS    |
 *  |        |              |                                           |
 *  +--------+              +-------------------------------------------+
< ASCII >
 *
 *  In the above picture there are two subschedules (cycles):
 *
 *  - cycle 0: iterates the schedule table from 0 to 2 (and back)
 *  - cycle 1: iterates the schedule table from 3 to 5 (and back)
 *
 *  All other possible execution threads must be marked as unused by making
 *  their "subschedule end index" (subscheind) equal to the last valid
 *  subschedule's end index (in this case 5).
 */
```
## Visual type:
- #custom


== ./linux/linux_518.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/dsa/sja1105/sja1105_vl.c#L169-L274

```c
/* The switch flow classification core implements TTEthernet, which 'thinks' in
 * terms of Virtual Links (VL), a concept borrowed from ARINC 664 part 7.
 * However it also has one other operating mode (VLLUPFORMAT=0) where it acts
 * somewhat closer to a pre-standard implementation of IEEE 802.1Qci
 * (Per-Stream Filtering and Policing), which is what the driver is going to be
 * implementing.
 *
< ASCII >
 *                                 VL Lookup
 *        Key = {DMAC && VLANID   +---------+  Key = { (DMAC[47:16] & VLMASK ==
 *               && VLAN PCP      |         |                         VLMARKER)
 *               && INGRESS PORT} +---------+                      (both fixed)
 *            (exact match,            |             && DMAC[15:0] == VLID
 *         all specified in rule)      |                    (specified in rule)
 *                                     v             && INGRESS PORT }
 *                               ------------
 *                    0 (PSFP)  /            \  1 (ARINC664)
 *                 +-----------/  VLLUPFORMAT \----------+
 *                 |           \    (fixed)   /          |
 *                 |            \            /           |
 *  0 (forwarding) v             ------------            |
 *           ------------                                |
 *          /            \  1 (QoS classification)       |
 *     +---/  ISCRITICAL  \-----------+                  |
 *     |   \  (per rule)  /           |                  |
 *     |    \            /   VLID taken from      VLID taken from
 *     v     ------------     index of rule       contents of rule
 *  select                     that matched         that matched
 * DESTPORTS                          |                  |
 *  |                                 +---------+--------+
 *  |                                           |
 *  |                                           v
 *  |                                     VL Forwarding
 *  |                                   (indexed by VLID)
 *  |                                      +---------+
 *  |                       +--------------|         |
 *  |                       |  select TYPE +---------+
 *  |                       v
 *  |   0 (rate      ------------    1 (time
 *  |  constrained) /            \   triggered)
 *  |       +------/     TYPE     \------------+
 *  |       |      \  (per VLID)  /            |
 *  |       v       \            /             v
 *  |  VL Policing   ------------         VL Policing
 *  | (indexed by VLID)                (indexed by VLID)
 *  |  +---------+                        +---------+
 *  |  | TYPE=0  |                        | TYPE=1  |
 *  |  +---------+                        +---------+
 *  |  select SHARINDX                 select SHARINDX to
 *  |  to rate-limit                 re-enter VL Forwarding
 *  |  groups of VL's               with new VLID for egress
 *  |  to same quota                           |
 *  |       |                                  |
 *  |  select MAXLEN -> exceed => drop    select MAXLEN -> exceed => drop
 *  |       |                                  |
 *  |       v                                  v
 *  |  VL Forwarding                      VL Forwarding
 *  | (indexed by SHARINDX)             (indexed by SHARINDX)
 *  |  +---------+                        +---------+
 *  |  | TYPE=0  |                        | TYPE=1  |
 *  |  +---------+                        +---------+
 *  |  select PRIORITY,                 select PRIORITY,
 *  | PARTITION, DESTPORTS            PARTITION, DESTPORTS
 *  |       |                                  |
 *  |       v                                  v
 *  |  VL Policing                        VL Policing
 *  | (indexed by SHARINDX)           (indexed by SHARINDX)
 *  |  +---------+                        +---------+
 *  |  | TYPE=0  |                        | TYPE=1  |
 *  |  +---------+                        +---------+
 *  |       |                                  |
 *  |       v                                  |
 *  |  select BAG, -> exceed => drop           |
 *  |    JITTER                                v
 *  |       |             ----------------------------------------------
 *  |       |            /    Reception Window is open for this VL      \
 *  |       |           /    (the Schedule Table executes an entry i     \
 *  |       |          /   M <= i < N, for which these conditions hold):  \ no
 *  |       |    +----/                                                    \-+
 *  |       |    |yes \       WINST[M] == 1 && WINSTINDEX[M] == VLID       / |
 *  |       |    |     \     WINEND[N] == 1 && WINSTINDEX[N] == VLID      /  |
 *  |       |    |      \                                                /   |
 *  |       |    |       \ (the VL window has opened and not yet closed)/    |
 *  |       |    |        ----------------------------------------------     |
 *  |       |    v                                                           v
 *  |       |  dispatch to DESTPORTS when the Schedule Table               drop
 *  |       |  executes an entry i with TXEN == 1 && VLINDEX == i
 *  v       v
 * dispatch immediately to DESTPORTS
< ASCII >
 *
 * The per-port classification key is always composed of {DMAC, VID, PCP} and
 * is non-maskable. This 'looks like' the NULL stream identification function
 * from IEEE 802.1CB clause 6, except for the extra VLAN PCP. When the switch
 * ports operate as VLAN-unaware, we do allow the user to not specify the VLAN
 * ID and PCP, and then the port-based defaults will be used.
 *
 * In TTEthernet, routing is something that needs to be done manually for each
 * Virtual Link. So the flow action must always include one of:
 * a. 'redirect', 'trap' or 'drop': select the egress port list
 * Additionally, the following actions may be applied on a Virtual Link,
 * turning it into 'critical' traffic:
 * b. 'police': turn it into a rate-constrained VL, with bandwidth limitation
 *    given by the maximum frame length, bandwidth allocation gap (BAG) and
 *    maximum jitter.
 * c. 'gate': turn it into a time-triggered VL, which can be only be received
 *    and forwarded according to a given schedule.
 */
```
## Visual type:
- #custom


== ./linux/linux_519.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/atheros/alx/hw.h#L43-L100

```c
/* Transmit Packet Descriptor, contains 4 32-bit words.
 *
< ASCII >
 *   31               16               0
 *   +----------------+----------------+
 *   |    vlan-tag    |   buf length   |
 *   +----------------+----------------+
 *   |              Word 1             |
 *   +----------------+----------------+
 *   |      Word 2: buf addr lo        |
 *   +----------------+----------------+
 *   |      Word 3: buf addr hi        |
 *   +----------------+----------------+
< ASCII >
 *
 * Word 2 and 3 combine to form a 64-bit buffer address
 *
 * Word 1 has three forms, depending on the state of bit 8/12/13:
 * if bit8 =='1', the definition is just for custom checksum offload.
 * if bit8 == '0' && bit12 == '1' && bit13 == '1', the *FIRST* descriptor
 *     for the skb is special for LSO V2, Word 2 become total skb length ,
 *     Word 3 is meaningless.
 * other condition, the definition is for general skb or ip/tcp/udp
 *     checksum or LSO(TSO) offload.
 *
< ASCII >
 * Here is the depiction:
 *
 *   0-+                                  0-+
 *   1 |                                  1 |
 *   2 |                                  2 |
 *   3 |    Payload offset                3 |    L4 header offset
 *   4 |        (7:0)                     4 |        (7:0)
 *   5 |                                  5 |
 *   6 |                                  6 |
 *   7-+                                  7-+
 *   8      Custom csum enable = 1        8      Custom csum enable = 0
 *   9      General IPv4 checksum         9      General IPv4 checksum
 *   10     General TCP checksum          10     General TCP checksum
 *   11     General UDP checksum          11     General UDP checksum
 *   12     Large Send Segment enable     12     Large Send Segment enable
 *   13     Large Send Segment type       13     Large Send Segment type
 *   14     VLAN tagged                   14     VLAN tagged
 *   15     Insert VLAN tag               15     Insert VLAN tag
 *   16     IPv4 packet                   16     IPv4 packet
 *   17     Ethernet frame type           17     Ethernet frame type
 *   18-+                                 18-+
 *   19 |                                 19 |
 *   20 |                                 20 |
 *   21 |   Custom csum offset            21 |
 *   22 |       (25:18)                   22 |
 *   23 |                                 23 |   MSS (30:18)
 *   24 |                                 24 |
 *   25-+                                 25 |
 *   26-+                                 26 |
 *   27 |                                 27 |
 *   28 |   Reserved                      28 |
 *   29 |                                 29 |
 *   30-+                                 30-+
 *   31     End of packet                 31     End of packet
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_52.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-orion5x/net2big-setup.c#L187-L202

```c
/*
 * The power front LEDs (blue and red) and SATA red LEDs are controlled via a
 * single GPIO line and are compatible with the leds-gpio driver.
 *
 * The SATA blue LEDs have some hardware blink capabilities which are detailed
 * in the following array:
 *
< ASCII >
 * SATAx blue LED | SATAx activity | LED state
 *                |                |
 *       0        |       0        |  blink (rate 300ms)
 *       1        |       0        |  off
 *       ?        |       1        |  on
< ASCII >
 *
 * Notes: The blue and the red front LED's can't be on at the same time.
 *        Blue LED have priority.
 */
```
## Visual type:
- #table


== ./linux/linux_520.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/atheros/alx/hw.h#L156-L238

```c
/* Receive Return Descriptor, contains 4 32-bit words.
 *
< ASCII >
 *   31               16               0
 *   +----------------+----------------+
 *   |              Word 0             |
 *   +----------------+----------------+
 *   |     Word 1: RSS Hash value      |
 *   +----------------+----------------+
 *   |              Word 2             |
 *   +----------------+----------------+
 *   |              Word 3             |
 *   +----------------+----------------+
 *
 * Word 0 depiction         &            Word 2 depiction:
 *
 *   0--+                                 0--+
 *   1  |                                 1  |
 *   2  |                                 2  |
 *   3  |                                 3  |
 *   4  |                                 4  |
 *   5  |                                 5  |
 *   6  |                                 6  |
 *   7  |    IP payload checksum          7  |     VLAN tag
 *   8  |         (15:0)                  8  |      (15:0)
 *   9  |                                 9  |
 *   10 |                                 10 |
 *   11 |                                 11 |
 *   12 |                                 12 |
 *   13 |                                 13 |
 *   14 |                                 14 |
 *   15-+                                 15-+
 *   16-+                                 16-+
 *   17 |     Number of RFDs              17 |
 *   18 |        (19:16)                  18 |
 *   19-+                                 19 |     Protocol ID
 *   20-+                                 20 |      (23:16)
 *   21 |                                 21 |
 *   22 |                                 22 |
 *   23 |                                 23-+
 *   24 |                                 24 |     Reserved
 *   25 |     Start index of RFD-ring     25-+
 *   26 |         (31:20)                 26 |     RSS Q-num (27:25)
 *   27 |                                 27-+
 *   28 |                                 28-+
 *   29 |                                 29 |     RSS Hash algorithm
 *   30 |                                 30 |      (31:28)
 *   31-+                                 31-+
 *
 * Word 3 depiction:
 *
 *   0--+
 *   1  |
 *   2  |
 *   3  |
 *   4  |
 *   5  |
 *   6  |
 *   7  |    Packet length (include FCS)
 *   8  |         (13:0)
 *   9  |
 *   10 |
 *   11 |
 *   12 |
 *   13-+
 *   14      L4 Header checksum error
 *   15      IPv4 checksum error
 *   16      VLAN tagged
 *   17-+
 *   18 |    Protocol ID (19:17)
 *   19-+
 *   20      Receive error summary
 *   21      FCS(CRC) error
 *   22      Frame alignment error
 *   23      Truncated packet
 *   24      Runt packet
 *   25      Incomplete packet due to insufficient rx-desc
 *   26      Broadcast packet
 *   27      Multicast packet
 *   28      Ethernet type (EII or 802.3)
 *   29      FIFO overflow
 *   30      Length error (for 802.3, length field mismatch with actual len)
 *   31      Updated, indicate to driver that this RRD is refreshed.
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_521.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/broadcom/bnx2x/bnx2x_hsi.h#L1722-L1745

```c
/* the bit-position macro allows the used to flip the order of the arrays
 * elements on a per byte or word boundary.
 *
 * example: an array with 8 entries each 4 bit wide. This array will fit into
 * a single dword. The diagrmas below show the array order of the nibbles.
 *
< ASCII >
 * SHMEM_ARRAY_BITPOS(i, 4, 4) defines the stadard ordering:
 *
 *                |                |                |               |
 *   0    |   1   |   2    |   3   |   4    |   5   |   6   |   7   |
 *                |                |                |               |
 *
 * SHMEM_ARRAY_BITPOS(i, 4, 8) defines a flip ordering per byte:
 *
 *                |                |                |               |
 *   1   |   0    |   3    |   2   |   5    |   4   |   7   |   6   |
 *                |                |                |               |
 *
 * SHMEM_ARRAY_BITPOS(i, 4, 16) defines a flip ordering per word:
 *
 *                |                |                |               |
 *   3   |   2    |   1   |   0    |   7   |   6    |   5   |   4   |
 *                |                |                |               |
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_522.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/broadcom/bnxt/bnxt.h#L595-L601

```c
/* First RX buffer page in XDP multi-buf mode
 *
< ASCII >
 * +-------------------------------------------------------------------------+
 * | XDP_PACKET_HEADROOM | bp->rx_buf_use_size              | skb_shared_info|
 * | (bp->rx_dma_offset) |                                  |                |
 * +-------------------------------------------------------------------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_523.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/cavium/liquidio/liquidio_common.h#L289-L304

```c
/* < ASCII >
 *   wqe
 *  ---------------  0
 * |  wqe  word0-3 |
 *  ---------------  32
 * |    PCI IH     |
 *  ---------------  40
 * |     RPTR      |
 *  ---------------  48
 * |    PCI IRH    |
 *  ---------------  56
 * |  OCT_NET_CMD  |
 *  ---------------  64
 * | Addtl 8-BData |
 * |               |
 *  ---------------
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_524.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/cavium/liquidio/octeon_droq.h#L159-L173

```c
/** The first parameter of a dispatch function.
 *  For a raw mode opcode, the driver dispatches with the device
 *  pointer in this structure.
 *  For non-raw mode opcode, the driver dispatches the recv_pkt
 *  created to contain the buffers with data received from Octeon.
< ASCII >
 *  ---------------------
 *  |     *recv_pkt ----|---
 *  |-------------------|   |
 *  | 0 or more bytes   |   |
 *  | reserved by driver|   |
 *  |-------------------|<-/
 *  | octeon_recv_pkt   |
 *  |                   |
 *  |___________________|
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_525.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/cavium/liquidio/response_manager.h#L68-L79

```c
/** Error codes  used in Octeon Host-Core communication.
 *
< ASCII >
 *   31            16 15            0
 *   ---------------------------------
 *   |               |               |
 *   ---------------------------------
< ASCII >
 *   Error codes are 32-bit wide. The upper 16-bits, called Major Error Number,
 *   are reserved to identify the group to which the error code belongs. The
 *   lower 16-bits, called Minor Error Number, carry the actual code.
 *
 *   So error codes are (MAJOR NUMBER << 16)| MINOR_NUMBER.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_526.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/chelsio/libcxgb/libcxgb_ppm.h#L65-L78

```c
/* ddp tag format
 * for a 32-bit tag:
 * bit #
< ASCII >
 * 31 .....   .....  0
 *     X   Y...Y Z...Z, where
 *     ^   ^^^^^ ^^^^
 *     |   |      |____ when ddp bit = 0: color bits
 *     |   |
 *     |   |____ when ddp bit = 0: idx into the ddp memory region
 *     |
 *     |____ ddp bit: 0 - ddp tag, 1 - non-ddp tag
 *
 *  [page selector:2] [sw/free bits] [0] [idx] [color:6]
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_527.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/cortina/gemini.h#L873-L924

```c
/* Queue Header
 *	(1) TOE Queue Header
 *	(2) Non-TOE Queue Header
 *	(3) Interrupt Queue Header
 *
< ASCII >
 * memory Layout
 *	TOE Queue Header
 *		     0x60003000 +---------------------------+ 0x0000
 *				|     TOE Queue 0 Header    |
 *				|         8 * 4 Bytes	    |
 *				+---------------------------+ 0x0020
 *				|     TOE Queue 1 Header    |
 *				|         8 * 4 Bytes	    |
 *				+---------------------------+ 0x0040
 *				|          ......           |
 *				|                           |
 *				+---------------------------+
 *
 *	Non TOE Queue Header
 *		     0x60002000 +---------------------------+ 0x0000
 *				|   Default Queue 0 Header  |
 *				|         2 * 4 Bytes       |
 *				+---------------------------+ 0x0008
 *				|   Default Queue 1 Header  |
 *				|         2 * 4 Bytes       |
 *				+---------------------------+ 0x0010
 *				|   Classification Queue 0  |
 *				|	  2 * 4 Bytes       |
 *				+---------------------------+
 *				|   Classification Queue 1  |
 *				|	  2 * 4 Bytes       |
 *				+---------------------------+ (n * 8 + 0x10)
 *				|		...	    |
 *				|	  2 * 4 Bytes	    |
 *				+---------------------------+ (13 * 8 + 0x10)
 *				|   Classification Queue 13 |
 *				|	  2 * 4 Bytes	    |
 *				+---------------------------+ 0x80
 *				|      Interrupt Queue 0    |
 *				|	  2 * 4 Bytes	    |
 *				+---------------------------+
 *				|      Interrupt Queue 1    |
 *				|	  2 * 4 Bytes	    |
 *				+---------------------------+
 *				|      Interrupt Queue 2    |
 *				|	  2 * 4 Bytes	    |
 *				+---------------------------+
 *				|      Interrupt Queue 3    |
 *				|	  2 * 4 Bytes	    |
 *				+---------------------------+
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_528.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/dec/tulip/pnic2.c#L15-L71

```c
/* Understanding the PNIC_II - everything is this file is based
 * on the PNIC_II_PDF datasheet which is sorely lacking in detail
 *
 * As I understand things, here are the registers and bits that
 * explain the masks and constants used in this file that are
 * either different from the 21142/3 or important for basic operation.
 *
 *
< ASCII >
 * CSR 6  (mask = 0xfe3bd1fd of bits not to change)
 * -----
 * Bit 24    - SCR
 * Bit 23    - PCS
 * Bit 22    - TTM (Trasmit Threshold Mode)
 * Bit 18    - Port Select
 * Bit 13    - Start - 1, Stop - 0 Transmissions
 * Bit 11:10 - Loop Back Operation Mode
 * Bit 9     - Full Duplex mode (Advertise 10BaseT-FD is CSR14<7> is set)
 * Bit 1     - Start - 1, Stop - 0 Receive
 *
 *
 * CSR 14  (mask = 0xfff0ee39 of bits not to change)
 * ------
 * Bit 19    - PAUSE-Pause
 * Bit 18    - Advertise T4
 * Bit 17    - Advertise 100baseTx-FD
 * Bit 16    - Advertise 100baseTx-HD
 * Bit 12    - LTE - Link Test Enable
 * Bit 7     - ANE - Auto Negotiate Enable
 * Bit 6     - HDE - Advertise 10baseT-HD
 * Bit 2     - Reset to Power down - kept as 1 for normal operation
 * Bit 1     -  Loop Back enable for 10baseT MCC
 *
 *
 * CSR 12
 * ------
 * Bit 25    - Partner can do T4
 * Bit 24    - Partner can do 100baseTx-FD
 * Bit 23    - Partner can do 100baseTx-HD
 * Bit 22    - Partner can do 10baseT-FD
 * Bit 21    - Partner can do 10baseT-HD
 * Bit 15    - LPN is 1 if all above bits are valid other wise 0
 * Bit 14:12 - autonegotiation state (write 001 to start autonegotiate)
 * Bit 3     - Autopolarity state
 * Bit 2     - LS10B - link state of 10baseT 0 - good, 1 - failed
 * Bit 1     - LS100B - link state of 100baseT 0 - good, 1 - failed
 *
 *
 * Data Port Selection Info
 *-------------------------
 *
 * CSR14<7>   CSR6<18>    CSR6<22>    CSR6<23>    CSR6<24>   MODE/PORT
 *   1           0           0 (X)       0 (X)       1        NWAY
 *   0           0           1           0 (X)       0        10baseT
 *   0           1           0           1           1 (X)    100baseT
< ASCII >
 *
 *
 */
```
## Visual type:
- #table


== ./linux/linux_529.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.h#L814-L831

```c
/* For each bit of TCAM entry, it uses a pair of 'x' and
 * 'y' to indicate which value to match, like below:
< ASCII >
 * ----------------------------------
 * | bit x | bit y |  search value  |
 * ----------------------------------
 * |   0   |   0   |   always hit   |
 * ----------------------------------
 * |   1   |   0   |   match '0'    |
 * ----------------------------------
 * |   0   |   1   |   match '1'    |
 * ----------------------------------
 * |   1   |   1   |   invalid      |
 * ----------------------------------
< ASCII >
 * Then for input key(k) and mask(v), we can calculate the value by
 * the formulae:
 *	x = (~k) & v
 *	y = (k ^ ~v) & k
 */
```
## Visual type:
- #table


== ./linux/linux_53.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-s3c/gpio-samsung-s3c24xx.h#L19-L37

```c
/*
 * GPIO sizes for various SoCs:
 *
< ASCII >
 *   2410 2412 2440 2443 2416
 *             2442
 *   ---- ---- ---- ---- ----
 * A  23   22   25   16   27
 * B  11   11   11   11   11
 * C  16   16   16   16   16
 * D  16   16   16   16   16
 * E  16   16   16   16   16
 * F  8    8    8    8    8
 * G  16   16   16   16   8
 * H  11   11   11   15   15
 * J  --   --   13   16   --
 * K  --   --   --   --   16
 * L  --   --   --   15   14
 * M  --   --   --   2    2
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_530.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/e1000/e1000_param.c#L69-L82

```c
/* Auto-negotiation Advertisement Override
 *
 * Valid Range: 0x01-0x0F, 0x20-0x2F (copper); 0x20 (fiber)
 *
 * The AutoNeg value is a bit mask describing which speed and duplex
 * combinations should be advertised during auto-negotiation.
 * The supported speed and duplex modes are listed below
 *
< ASCII >
 * Bit           7     6     5      4      3     2     1      0
 * Speed (Mbps)  N/A   N/A   1000   N/A    100   100   10     10
 * Duplex                    Full          Full  Half  Full   Half
< ASCII >
 *
 * Default Value: 0x2F (copper); 0x20 (fiber)
 */
```
## Visual type:
- #table


== ./linux/linux_531.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/e1000e/hw.h#L520-L533

```c
/* When to use various PHY register access functions:
 *
< ASCII >
 *                 Func   Caller
 *   Function      Does   Does    When to use
 *   ~~~~~~~~~~~~  ~~~~~  ~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *   X_reg         L,P,A  n/a     for simple PHY reg accesses
 *   X_reg_locked  P,A    L       for multiple accesses of different regs
 *                                on different pages
 *   X_reg_page    A      L,P     for multiple accesses of different regs
 *                                on the same page
< ASCII >
 *
 * Where X=[read|write], L=locking, P=sets page, A=register access
 *
 */
```
## Visual type:
- #table


== ./linux/linux_532.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/fm10k/fm10k_mbx.h#L87-L118

```c
/* PF/VF Mailbox header format
< ASCII >
 *    3			  2		      1			  0
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |        Size/Err_no/CRC        | Rsvd0 | Head  | Tail  | Type  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 * The layout above describes the format for the header used in the PF/VF
 * mailbox.  The header is broken out into the following fields:
 * Type: There are 4 supported message types
 *		0x8: Data header - used to transport message data
 *		0xC: Connect header - used to establish connection
 *		0xD: Disconnect header - used to tear down a connection
 *		0xE: Error header - used to address message exceptions
 * Tail: Tail index for local FIFO
 *		Tail index actually consists of two parts.  The MSB of
 *		the head is a loop tracker, it is 0 on an even numbered
 *		loop through the FIFO, and 1 on the odd numbered loops.
 *		To get the actual mailbox offset based on the tail it
 *		is necessary to add bit 3 to bit 0 and clear bit 3.  This
 *		gives us a valid range of 0x1 - 0xE.
 * Head: Head index for remote FIFO
 *		Head index follows the same format as the tail index.
 * Rsvd0: Reserved 0 portion of the mailbox header
 * CRC: Running CRC for all data since connect plus current message header
 * Size: Maximum message size - Applies only to connect headers
 *		The maximum message size is provided during connect to avoid
 *		jamming the mailbox with messages that do not fit.
 * Err_no: Error number - Applies only to error headers
 *		The error number provides an indication of the type of error
 *		experienced.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_533.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/fm10k/fm10k_mbx.h#L157-L180

```c
/* HNI/SM Mailbox FIFO format
< ASCII >
 *    3                   2                   1                   0
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-------+-----------------------+-------+-----------------------+
 * | Error |      Remote Head      |Version|      Local Tail       |
 * +-------+-----------------------+-------+-----------------------+
 * |                                                               |
 * .                        Local FIFO Data                        .
 * .                                                               .
 * +-------+-----------------------+-------+-----------------------+
< ASCII >
 *
 * The layout above describes the format for the FIFOs used by the host
 * network interface and the switch manager to communicate messages back
 * and forth.  Both the HNI and the switch maintain one such FIFO.  The
 * layout in memory has the switch manager FIFO followed immediately by
 * the HNI FIFO.  For this reason I am using just the pointer to the
 * HNI FIFO in the mailbox ops as the offset between the two is fixed.
 *
 * The header for the FIFO is broken out into the following fields:
 * Local Tail:  Offset into FIFO region for next DWORD to write.
 * Version:  Version info for mailbox, only values of 0/1 are supported.
 * Remote Head:  Offset into remote FIFO to indicate how much we have read.
 * Error: Error indication, values TBD.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_534.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/fm10k/fm10k_tlv.h#L12-L27

```c
/* Message / Argument header format
< ASCII >
 *    3			  2		      1			  0
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |	     Length	   | Flags |	      Type / ID		   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 *
 * The message header format described here is used for messages that are
 * passed between the PF and the VF.  To allow for messages larger then
 * mailbox size we will provide a message with the above header and it
 * will be segmented and transported to the mailbox to the other side where
 * it is reassembled.  It contains the following fields:
 * Length: Length of the message in bytes excluding the message header
 * Flags: TBD
 * Type/ID: These will be the message/argument types we pass
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_535.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h#L54-L57

```c
/* Flags sub-structure
< ASCII >
 * |0  |1  |2  |3  |4  |5  |6  |7  |8  |9  |10 |11 |12 |13 |14 |15 |
 * |DD |CMP|ERR|VFE| * *  RESERVED * * |LB |RD |VFC|BUF|SI |EI |FE |
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_536.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/iavf/iavf_adminq_cmd.h#L48-L51

```c
/* Flags sub-structure
< ASCII >
 * |0  |1  |2  |3  |4  |5  |6  |7  |8  |9  |10 |11 |12 |13 |14 |15 |
 * |DD |CMP|ERR|VFE| * *  RESERVED * * |LB |RD |VFC|BUF|SI |EI |FE |
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_537.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/ice/ice_flex_pipe.c#L653-L677

```c
/**
 * ice_gen_key_word - generate 16-bits of a key/mask word
 * @val: the value
 * @valid: valid bits mask (change only the valid bits)
 * @dont_care: don't care mask
 * @nvr_mtch: never match mask
 * @key: pointer to an array of where the resulting key portion
 * @key_inv: pointer to an array of where the resulting key invert portion
 *
 * This function generates 16-bits from a 8-bit value, an 8-bit don't care mask
 * and an 8-bit never match mask. The 16-bits of output are divided into 8 bits
 * of key and 8 bits of key invert.
 *
 *     '0' =    b01, always match a 0 bit
 *     '1' =    b10, always match a 1 bit
 *     '?' =    b11, don't care bit (always matches)
 *     '~' =    b00, never match bit
 *
< ASCII >
 * Input:
 *          val:         b0  1  0  1  0  1
 *          dont_care:   b0  0  1  1  0  0
 *          never_mtch:  b0  0  0  0  1  1
 *          ------------------------------
 * Result:  key:        b01 10 11 11 00 00
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_538.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/ice/ice_ptp.h#L36-L83

```c
/* The ice hardware captures Tx hardware timestamps in the PHY. The timestamp
 * is stored in a buffer of registers. Depending on the specific hardware,
 * this buffer might be shared across multiple PHY ports.
 *
 * On transmit of a packet to be timestamped, software is responsible for
 * selecting an open index. Hardware makes no attempt to lock or prevent
 * re-use of an index for multiple packets.
 *
 * To handle this, timestamp indexes must be tracked by software to ensure
 * that an index is not re-used for multiple transmitted packets. The
 * structures and functions declared in this file track the available Tx
 * register indexes, as well as provide storage for the SKB pointers.
 *
 * To allow multiple ports to access the shared register block independently,
 * the blocks are split up so that indexes are assigned to each port based on
 * hardware logical port number.
 *
 * The timestamp blocks are handled differently for E810- and E822-based
 * devices. In E810 devices, each port has its own block of timestamps, while in
 * E822 there is a need to logically break the block of registers into smaller
 * chunks based on the port number to avoid collisions.
 *
< ASCII >
 * Example for port 5 in E810:
 *  +--------+--------+--------+--------+--------+--------+--------+--------+
 *  |register|register|register|register|register|register|register|register|
 *  | block  | block  | block  | block  | block  | block  | block  | block  |
 *  |  for   |  for   |  for   |  for   |  for   |  for   |  for   |  for   |
 *  | port 0 | port 1 | port 2 | port 3 | port 4 | port 5 | port 6 | port 7 |
 *  +--------+--------+--------+--------+--------+--------+--------+--------+
 *                                               ^^
 *                                               ||
 *                                               |---  quad offset is always 0
 *                                               ---- quad number
 *
 * Example for port 5 in E822:
 * +-----------------------------+-----------------------------+
 * |  register block for quad 0  |  register block for quad 1  |
 * |+------+------+------+------+|+------+------+------+------+|
 * ||port 0|port 1|port 2|port 3|||port 0|port 1|port 2|port 3||
 * |+------+------+------+------+|+------+------+------+------+|
 * +-----------------------------+-------^---------------------+
 *                                ^      |
 *                                |      --- quad offset*
 *                                ---- quad number
 *
 *   * PHY port 5 is port 1 in quad 1
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_539.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/ice/ice_ptp_hw.c#L10-L70

```c
/* Low level functions for interacting with and managing the device clock used
 * for the Precision Time Protocol.
 *
 * The ice hardware represents the current time using three registers:
 *
< ASCII >
 *    GLTSYN_TIME_H     GLTSYN_TIME_L     GLTSYN_TIME_R
 *  +---------------+ +---------------+ +---------------+
 *  |    32 bits    | |    32 bits    | |    32 bits    |
 *  +---------------+ +---------------+ +---------------+
< ASCII >
 *
 * The registers are incremented every clock tick using a 40bit increment
 * value defined over two registers:
 *
< ASCII >
 *                     GLTSYN_INCVAL_H   GLTSYN_INCVAL_L
 *                    +---------------+ +---------------+
 *                    |    8 bit s    | |    32 bits    |
 *                    +---------------+ +---------------+
< ASCII >
 *
 * The increment value is added to the GLSTYN_TIME_R and GLSTYN_TIME_L
 * registers every clock source tick. Depending on the specific device
 * configuration, the clock source frequency could be one of a number of
 * values.
 *
 * For E810 devices, the increment frequency is 812.5 MHz
 *
 * For E822 devices the clock can be derived from different sources, and the
 * increment has an effective frequency of one of the following:
 * - 823.4375 MHz
 * - 783.36 MHz
 * - 796.875 MHz
 * - 816 MHz
 * - 830.078125 MHz
 * - 783.36 MHz
 *
 * The hardware captures timestamps in the PHY for incoming packets, and for
 * outgoing packets on request. To support this, the PHY maintains a timer
 * that matches the lower 64 bits of the global source timer.
 *
 * In order to ensure that the PHY timers and the source timer are equivalent,
 * shadow registers are used to prepare the desired initial values. A special
 * sync command is issued to trigger copying from the shadow registers into
 * the appropriate source and PHY registers simultaneously.
 *
 * The driver supports devices which have different PHYs with subtly different
 * mechanisms to program and control the timers. We divide the devices into
 * families named after the first major device, E810 and similar devices, and
 * E822 and similar devices.
 *
 * - E822 based devices have additional support for fine grained Vernier
 *   calibration which requires significant setup
 * - The layout of timestamp data in the PHY register blocks is different
 * - The way timer synchronization commands are issued is different.
 *
 * To support this, very low level functions have an e810 or e822 suffix
 * indicating what type of device they work on. Higher level abstractions for
 * tasks that can be done on both devices do not have the suffix and will
 * correctly look up the appropriate low level function when running.
 *
 * Functions which only make sense on a single device family may not have
 * a suitable generic implementation
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_54.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-s3c/mach-mini2440.c#L345-L361

```c
/* < ASCII >
 *  CON5
 *	+--+	 /-----\
 *	|  |    |	|
 *	|  |	|  BAT	|
 *	|  |	 \_____/
 *	|  |
 *	|  |  +----+  +----+
 *	|  |  | K5 |  | K1 |
 *	|  |  +----+  +----+
 *	|  |  +----+  +----+
 *	|  |  | K4 |  | K2 |
 *	|  |  +----+  +----+
 *	|  |  +----+  +----+
 *	|  |  | K6 |  | K3 |
 *	|  |  +----+  +----+
 *	  .....
< ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_540.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/ice/ice_ptp_hw.c#L1457-L1502

```c
/**
 * ice_phy_cfg_uix_e822 - Configure Serdes UI to TU conversion for E822
 * @hw: pointer to the HW structure
 * @port: the port to configure
 *
 * Program the conversion ration of Serdes clock "unit intervals" (UIs) to PHC
 * hardware clock time units (TUs). That is, determine the number of TUs per
 * serdes unit interval, and program the UIX registers with this conversion.
 *
 * This conversion is used as part of the calibration process when determining
 * the additional error of a timestamp vs the real time of transmission or
 * receipt of the packet.
 *
 * Hardware uses the number of TUs per 66 UIs, written to the UIX registers
 * for the two main serdes clock rates, 10G/40G and 25G/100G serdes clocks.
 *
 * To calculate the conversion ratio, we use the following facts:
 *
 * a) the clock frequency in Hz (cycles per second)
 * b) the number of TUs per cycle (the increment value of the clock)
 * c) 1 second per 1 billion nanoseconds
 * d) the duration of 66 UIs in nanoseconds
 *
 * Given these facts, we can use the following table to work out what ratios
 * to multiply in order to get the number of TUs per 66 UIs:
 *
< ASCII >
 * cycles |   1 second   | incval (TUs) | nanoseconds
 * -------+--------------+--------------+-------------
 * second | 1 billion ns |    cycle     |   66 UIs
< ASCII >
 *
 * To perform the multiplication using integers without too much loss of
 * precision, we can take use the following equation:
 *
 * (freq * incval * 6600 LINE_UI ) / ( 100 * 1 billion)
 *
 * We scale up to using 6600 UI instead of 66 in order to avoid fractional
 * nanosecond UIs (66 UI at 10G/40G is 6.4 ns)
 *
 * The increment value has a maximum expected range of about 34 bits, while
 * the frequency value is about 29 bits. Multiplying these values shouldn't
 * overflow the 64 bits. However, we must then further multiply them again by
 * the Serdes unit interval duration. To avoid overflow here, we split the
 * overall divide by 1e11 into a divide by 256 (shift down by 8 bits) and
 * a divide by 390,625,000. This does lose some precision, but avoids
 * miscalculation due to arithmetic overflow.
 */
```
## Visual type:
- #table


== ./linux/linux_541.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/ice/ice_ptp_hw.c#L1542-L1584

```c
/**
 * ice_phy_cfg_parpcs_e822 - Configure TUs per PAR/PCS clock cycle
 * @hw: pointer to the HW struct
 * @port: port to configure
 *
 * Configure the number of TUs for the PAR and PCS clocks used as part of the
 * timestamp calibration process. This depends on the link speed, as the PHY
 * uses different markers depending on the speed.
 *
 * 1Gb/10Gb/25Gb:
 * - Tx/Rx PAR/PCS markers
 *
 * 25Gb RS:
 * - Tx/Rx Reed Solomon gearbox PAR/PCS markers
 *
 * 40Gb/50Gb:
 * - Tx/Rx PAR/PCS markers
 * - Rx Deskew PAR/PCS markers
 *
 * 50G RS and 100GB RS:
 * - Tx/Rx Reed Solomon gearbox PAR/PCS markers
 * - Rx Deskew PAR/PCS markers
 * - Tx PAR/PCS markers
 *
 * To calculate the conversion, we use the PHC clock frequency (cycles per
 * second), the increment value (TUs per cycle), and the related PHY clock
 * frequency to calculate the TUs per unit of the PHY link clock. The
 * following table shows how the units convert:
 *
< ASCII >
 * cycles |  TUs  | second
 * -------+-------+--------
 * second | cycle | cycles
< ASCII >
 *
 * For each conversion register, look up the appropriate frequency from the
 * e822 PAR/PCS table and calculate the TUs per unit of that clock. Program
 * this to the appropriate register, preparing hardware to perform timestamp
 * calibration to calculate the total Tx or Rx offset to adjust the timestamp
 * in order to calibrate for the internal PHY delays.
 *
 * Note that the increment value ranges up to ~34 bits, and the clock
 * frequency is ~29 bits, so multiplying them together should fit within the
 * 64 bit arithmetic.
 */
```
## Visual type:
- #table


== ./linux/linux_542.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/igb/igb_ptp.c#L14-L62

```c
/* The 82580 timesync updates the system timer every 8ns by 8ns,
 * and this update value cannot be reprogrammed.
 *
 * Neither the 82576 nor the 82580 offer registers wide enough to hold
 * nanoseconds time values for very long. For the 82580, SYSTIM always
 * counts nanoseconds, but the upper 24 bits are not available. The
 * frequency is adjusted by changing the 32 bit fractional nanoseconds
 * register, TIMINCA.
 *
 * For the 82576, the SYSTIM register time unit is affect by the
 * choice of the 24 bit TININCA:IV (incvalue) field. Five bits of this
 * field are needed to provide the nominal 16 nanosecond period,
 * leaving 19 bits for fractional nanoseconds.
 *
 * We scale the NIC clock cycle by a large factor so that relatively
 * small clock corrections can be added or subtracted at each clock
 * tick. The drawbacks of a large factor are a) that the clock
 * register overflows more quickly (not such a big deal) and b) that
 * the increment per tick has to fit into 24 bits.  As a result we
 * need to use a shift of 19 so we can fit a value of 16 into the
 * TIMINCA register.
 *
 *
< ASCII >
 *             SYSTIMH            SYSTIML
 *        +--------------+   +---+---+------+
 *  82576 |      32      |   | 8 | 5 |  19  |
 *        +--------------+   +---+---+------+
 *         \________ 45 bits _______/  fract
 *
 *        +----------+---+   +--------------+
 *  82580 |    24    | 8 |   |      32      |
 *        +----------+---+   +--------------+
 *          reserved  \______ 40 bits _____/
< ASCII >
 *
 *
 * The 45 bit 82576 SYSTIM overflows every
 *   2^45 * 10^-9 / 3600 = 9.77 hours.
 *
 * The 40 bit 82580 SYSTIM overflows every
 *   2^40 * 10^-9 /  60  = 18.3 minutes.
 *
 * SYSTIM is converted to real time using a timecounter. As
 * timecounter_cyc2time() allows old timestamps, the timecounter needs
 * to be updated at least once per half of the SYSTIM interval.
 * Scheduling of delayed work is not very accurate, and also the NIC
 * clock can be adjusted to run up to 6% faster and the system clock
 * up to 10% slower, so we aim for 6 minutes to be sure the actual
 * interval in the NIC time is shorter than 9.16 minutes.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_543.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c#L8-L62

```c
/*
 * The 82599 and the X540 do not have true 64bit nanosecond scale
 * counter registers. Instead, SYSTIME is defined by a fixed point
 * system which allows the user to define the scale counter increment
 * value at every level change of the oscillator driving the SYSTIME
 * value. For both devices the TIMINCA:IV field defines this
 * increment. On the X540 device, 31 bits are provided. However on the
 * 82599 only provides 24 bits. The time unit is determined by the
 * clock frequency of the oscillator in combination with the TIMINCA
 * register. When these devices link at 10Gb the oscillator has a
 * period of 6.4ns. In order to convert the scale counter into
 * nanoseconds the cyclecounter and timecounter structures are
 * used. The SYSTIME registers need to be converted to ns values by use
 * of only a right shift (division by power of 2). The following math
 * determines the largest incvalue that will fit into the available
 * bits in the TIMINCA register.
 *
 * PeriodWidth: Number of bits to store the clock period
 * MaxWidth: The maximum width value of the TIMINCA register
 * Period: The clock period for the oscillator
 * round(): discard the fractional portion of the calculation
 *
 * Period * [ 2 ^ ( MaxWidth - PeriodWidth ) ]
 *
 * For the X540, MaxWidth is 31 bits, and the base period is 6.4 ns
 * For the 82599, MaxWidth is 24 bits, and the base period is 6.4 ns
 *
 * The period also changes based on the link speed:
 * At 10Gb link or no link, the period remains the same.
 * At 1Gb link, the period is multiplied by 10. (64ns)
 * At 100Mb link, the period is multiplied by 100. (640ns)
 *
 * The calculated value allows us to right shift the SYSTIME register
 * value in order to quickly convert it into a nanosecond clock,
 * while allowing for the maximum possible adjustment value.
 *
 * These diagrams are only for the 10Gb link period
 *
< ASCII >
 *           SYSTIMEH            SYSTIMEL
 *       +--------------+  +--------------+
 * X540  |      32      |  | 1 | 3 |  28  |
 *       *--------------+  +--------------+
 *        \________ 36 bits ______/  fract
 *
 *       +--------------+  +--------------+
 * 82599 |      32      |  | 8 | 3 |  21  |
 *       *--------------+  +--------------+
 *        \________ 43 bits ______/  fract
< ASCII >
 *
 * The 36 bit X540 SYSTIME overflows every
 *   2^36 * 10^-9 / 60 = 1.14 minutes or 69 seconds
 *
 * The 43 bit 82599 SYSTIME overflows every
 *   2^43 * 10^-9 / 3600 = 2.4 hours
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_544.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c#L83-L141

```c
/* In contrast, the X550 controller has two registers, SYSTIMEH and SYSTIMEL
 * which contain measurements of seconds and nanoseconds respectively. This
 * matches the standard linux representation of time in the kernel. In addition,
 * the X550 also has a SYSTIMER register which represents residue, or
 * subnanosecond overflow adjustments. To control clock adjustment, the TIMINCA
 * register is used, but it is unlike the X540 and 82599 devices. TIMINCA
 * represents units of 2^-32 nanoseconds, and uses 31 bits for this, with the
 * high bit representing whether the adjustent is positive or negative. Every
 * clock cycle, the X550 will add 12.5 ns + TIMINCA which can result in a range
 * of 12 to 13 nanoseconds adjustment. Unlike the 82599 and X540 devices, the
 * X550's clock for purposes of SYSTIME generation is constant and not dependent
 * on the link speed.
 *
< ASCII >
 *           SYSTIMEH           SYSTIMEL        SYSTIMER
 *       +--------------+  +--------------+  +-------------+
 * X550  |      32      |  |      32      |  |     32      |
 *       *--------------+  +--------------+  +-------------+
 *       \____seconds___/   \_nanoseconds_/  \__2^-32 ns__/
< ASCII >
 *
 * This results in a full 96 bits to represent the clock, with 32 bits for
 * seconds, 32 bits for nanoseconds (largest value is 0d999999999 or just under
 * 1 second) and an additional 32 bits to measure sub nanosecond adjustments for
 * underflow of adjustments.
 *
 * The 32 bits of seconds for the X550 overflows every
 *   2^32 / ( 365.25 * 24 * 60 * 60 ) = ~136 years.
 *
 * In order to adjust the clock frequency for the X550, the TIMINCA register is
 * provided. This register represents a + or minus nearly 0.5 ns adjustment to
 * the base frequency. It is measured in 2^-32 ns units, with the high bit being
 * the sign bit. This register enables software to calculate frequency
 * adjustments and apply them directly to the clock rate.
 *
 * The math for converting scaled_ppm into TIMINCA values is fairly
 * straightforward.
 *
 *   TIMINCA value = ( Base_Frequency * scaled_ppm ) / 1000000ULL << 16
 *
 * To avoid overflow, we simply use mul_u64_u64_div_u64.
 *
 * This assumes that scaled_ppm is never high enough to create a value bigger
 * than TIMINCA's 31 bits can store. This is ensured by the stack, and is
 * measured in parts per billion. Calculating this value is also simple.
 *   Max ppb = ( Max Adjustment / Base Frequency ) / 1000000000ULL
 *
 * For the X550, the Max adjustment is +/- 0.5 ns, and the base frequency is
 * 12.5 nanoseconds. This means that the Max ppb is 39999999
 *   Note: We subtract one in order to ensure no overflow, because the TIMINCA
 *         register can only hold slightly under 0.5 nanoseconds.
 *
 * Because TIMINCA is measured in 2^-32 ns units, we have to convert 12.5 ns
 * into 2^-32 units, which is
 *
 *  12.5 * 2^32 = C80000000
 *
 * Some revisions of hardware have a faster base frequency than the registers
 * were defined for. To fix this, we use a timecounter structure with the
 * proper mult and shift to convert the cycles into nanoseconds of time.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_545.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/marvell/octeon_ep/octep_ctrl_mbox.h#L10-L49

```c
/* < ASCII >
 *             barmem structure
 * |===========================================|
 * |Info (16 + 120 + 120 = 256 bytes)          |
 * |-------------------------------------------|
 * |magic number (8 bytes)                     |
 * |bar memory size (4 bytes)                  |
 * |reserved (4 bytes)                         |
 * |-------------------------------------------|
 * |host version (8 bytes)                     |
 * |host status (8 bytes)                      |
 * |host reserved (104 bytes)                  |
 * |-------------------------------------------|
 * |fw version (8 bytes)                       |
 * |fw status (8 bytes)                        |
 * |fw reserved (104 bytes)                    |
 * |===========================================|
 * |Host to Fw Queue info (16 bytes)           |
 * |-------------------------------------------|
 * |producer index (4 bytes)                   |
 * |consumer index (4 bytes)                   |
 * |element size (4 bytes)                     |
 * |element count (4 bytes)                    |
 * |===========================================|
 * |Fw to Host Queue info (16 bytes)           |
 * |-------------------------------------------|
 * |producer index (4 bytes)                   |
 * |consumer index (4 bytes)                   |
 * |element size (4 bytes)                     |
 * |element count (4 bytes)                    |
 * |===========================================|
 * |Host to Fw Queue                           |
 * |-------------------------------------------|
 * |((elem_sz + hdr(8 bytes)) * elem_cnt) bytes|
 * |===========================================|
 * |===========================================|
 * |Fw to Host Queue                           |
 * |-------------------------------------------|
 * |((elem_sz + hdr(8 bytes)) * elem_cnt) bytes|
 * |===========================================|
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_546.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/marvell/prestera/prestera_router_hw.c#L11-L28

```c
/*
< ASCII >
 *                                Nexthop is pointed
 *                                to port (not rif)
 *                                +-------+
 *                              +>|nexthop|
 *                              | +-------+
 *                              |
 *            +--+        +-----++
 *   +------->|vr|<-+   +>|nh_grp|
 *   |        +--+  |   | +------+
 *   |              |   |
 * +-+-------+   +--+---+-+
 * |rif_entry|   |fib_node|
 * +---------+   +--------+
 *  Rif is        Fib - is exit point
 *  used as
 *  entry point
 *  for vr in hw
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_547.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c#L2339-L2361

```c
/* Tunnel device follows RFC 6040, see include/net/inet_ecn.h.
 * And changes inner ip_ecn depending on inner and outer ip_ecn as follows:
< ASCII >
 *      +---------+----------------------------------------+
 *      |Arriving |         Arriving Outer Header          |
 *      |   Inner +---------+---------+---------+----------+
 *      |  Header | Not-ECT | ECT(0)  | ECT(1)  |   CE     |
 *      +---------+---------+---------+---------+----------+
 *      | Not-ECT | Not-ECT | Not-ECT | Not-ECT | <drop>   |
 *      |  ECT(0) |  ECT(0) | ECT(0)  | ECT(1)  |   CE*    |
 *      |  ECT(1) |  ECT(1) | ECT(1)  | ECT(1)* |   CE*    |
 *      |    CE   |   CE    |  CE     | CE      |   CE     |
 *      +---------+---------+---------+---------+----------+
< ASCII >
 *
 * Tc matches on inner after decapsulation on tunnel device, but hw offload matches
 * the inner ip_ecn value before hardware decap action.
 *
 * Cells marked are changed from original inner packet ip_ecn value during decap, and
 * so matching those values on inner ip_ecn before decap will fail.
 *
 * The following helper allows offload when inner ip_ecn won't be changed by outer ip_ecn,
 * except for the outer ip_ecn = CE, where in all cases inner ip_ecn will be changed to CE,
 * and such we can drop the inner ip_ecn=CE match.
 */
```
## Visual type:
- #table


== ./linux/linux_548.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c#L3781-L3800

```c
/* TC filter rule HW translation:
 *
< ASCII >
 * +---------------------+
 * + ft prio (tc chain)  +
 * + original match      +
 * +---------------------+
 *           |
 *           | if multi table action
 *           |
 *           v
 * +---------------------+
 * + post act ft         |<----.
 * + match fte id        |     | split on multi table action
 * + do actions          |-----'
 * +---------------------+
 *           |
 *           |
 *           v
 * Do rest of the actions after last multi table action.
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_549.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c#L1775-L1813

```c
/* We translate the tc filter with CT action to the following HW model:
 *
< ASCII >
 *	+---------------------+
 *	+ ft prio (tc chain)  +
 *	+ original match      +
 *	+---------------------+
 *		 | set chain miss mapping
 *		 | set fte_id
 *		 | set tunnel_id
 *		 | do decap
 *		 |
 * +-------------+
 * | Chain 0	 |
 * | optimization|
 * |		 v
 * |	+---------------------+
 * |	+ pre_ct/pre_ct_nat   +  if matches     +----------------------+
 * |	+ zone+nat match      +---------------->+ post_act (see below) +
 * |	+---------------------+  set zone       +----------------------+
 * |		 |
 * +-------------+ set zone
 *		 |
 *		 v
 *	+--------------------+
 *	+ CT (nat or no nat) +
 *	+ tuple + zone match +
 *	+--------------------+
 *		 | set mark
 *		 | set labels_id
 *		 | set established
 *		 | set zone_restore
 *		 | do nat (if needed)
 *		 v
 *	+--------------+
 *	+ post_act     + original filter actions
 *	+ fte_id match +------------------------>
 *	+--------------+
< ASCII >
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_55.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-sa1100/include/mach/hardware.h#L20-L29

```c
/*
 * SA1100 internal I/O mappings
 *
< ASCII >
 * We have the following mapping:
 *      phys            virt
 *      80000000        f8000000
 *      90000000        fa000000
 *      a0000000        fc000000
 *      b0000000        fe000000
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_550.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h#L48-L64

```c
/* Helper struct for accessing a struct containing list_head array.
< ASCII >
 * Containing struct
 *   |- Helper array
 *      [0] Helper item 0
 *          |- list_head item 0
 *          |- index (0)
 *      [1] Helper item 1
 *          |- list_head item 1
 *          |- index (1)
< ASCII >
 * To access the containing struct from one of the list_head items:
 * 1. Get the helper item from the list_head item using
 *    helper item =
 *        container_of(list_head item, helper struct type, list_head field)
 * 2. Get the contining struct from the helper item and its index in the array:
 *    containing struct =
 *        container_of(helper item, containing struct type, helper field[index])
 */
```
## Visual type:
- #tree


== ./linux/linux_551.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlx5/core/en/tc/sample.c#L422-L467

```c
/* For the following typical flow table:
 *
< ASCII >
 * +-------------------------------+
 * +       original flow table     +
 * +-------------------------------+
 * +         original match        +
 * +-------------------------------+
 * + sample action + other actions +
 * +-------------------------------+
< ASCII >
 *
 * We translate the tc filter with sample action to the following HW model:
 *
< ASCII >
 *         +---------------------+
 *         + original flow table +
 *         +---------------------+
 *         +   original match    +
 *         +---------------------+
 *               | set fte_id (if reg_c preserve cap)
 *               | do decap (if required)
 *               v
 * +------------------------------------------------+
 * +                Flow Sampler Object             +
 * +------------------------------------------------+
 * +                    sample ratio                +
 * +------------------------------------------------+
 * +    sample table id    |    default table id    +
 * +------------------------------------------------+
 *            |                            |
 *            v                            v
 * +-----------------------------+  +-------------------+
 * +        sample table         +  +   default table   +
 * +-----------------------------+  +-------------------+
 * + forward to management vport +             |
 * +-----------------------------+             |
 *                                     +-------+------+
 *                                     |              |reg_c preserve cap
 *                                     |              |or decap action
 *                                     v              v
 *                        +-----------------+   +-------------+
 *                        + per vport table +   + post action +
 *                        +-----------------+   +-------------+
 *                        + original match  +
 *                        +-----------------+
 *                        + other actions   +
 *                        +-----------------+
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_552.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_ste.c#L172-L183

```c
/* Replace relevant fields, except of:
 * htbl - keep the origin htbl
 * miss_list + list - already took the src from the list.
 * icm_addr/mr_addr - depends on the hosting table.
 *
< ASCII >
 * Before:
 * | a | -> | b | -> | c | ->
 *
 * After:
 * | a | -> | c | ->
< ASCII >
 * While the data that was in b copied to a.
 */
```
## Visual type:
- #sequence


== ./linux/linux_553.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_ste.c#L229-L231

```c
/* Free ste which is the head but NOT the only one in miss_list:
< ASCII >
 * |_ste_| --> |_next_ste_| -->|__| -->|__| -->/0
< ASCII >
 */
```
## Visual type:
- #sequence


== ./linux/linux_554.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_ste.c#L277-L279

```c
/* Free ste that is located in the middle of the miss list:
< ASCII >
 * |__| -->|_prev_ste_|->|_ste_|-->|_next_ste_|
< ASCII >
 */
```
## Visual type:
- #sequence


== ./linux/linux_555.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlxfw/mlxfw_mfa2.c#L17-L76

```c
/*
< ASCII >
 *               MFA2 FILE
 *  +----------------------------------+
 *  |        MFA2 finger print         |
 *  +----------------------------------+
 *  |   package descriptor multi_tlv   |
 *  | +------------------------------+ |     +-----------------+
 *  | |    package descriptor tlv    +-----> |num_devices=n    |
 *  | +------------------------------+ |     |num_components=m |
 *  +----------------------------------+     |CB offset        |
 *  |    device descriptor multi_tlv   |     |...              |
 *  | +------------------------------+ |     |                 |
 *  | |           PSID tlv           | |     +-----------------+
 *  | +------------------------------+ |
 *  | |     component index tlv      | |
 *  | +------------------------------+ |
 *  +----------------------------------+
 *  |  component descriptor multi_tlv  |
 *  | +------------------------------+ |     +-----------------+
 *  | |  component descriptor tlv    +-----> |Among others:    |
 *  | +------------------------------+ |     |CB offset=o      |
 *  +----------------------------------+     |comp index=i     |
 *  |                                  |     |...              |
 *  |                                  |     |                 |
 *  |                                  |     +-----------------+
 *  |        COMPONENT BLOCK (CB)      |
 *  |                                  |
 *  |                                  |
 *  |                                  |
 *  +----------------------------------+
< ASCII >
 *
 * On the top level, an MFA2 file contains:
 *  - Fingerprint
 *  - Several multi_tlvs (TLVs of type MLXFW_MFA2_TLV_MULTI, as defined in
 *    mlxfw_mfa2_format.h)
 *  - Compresses content block
 *
 * The first multi_tlv
 * -------------------
 * The first multi TLV is treated as package descriptor, and expected to have a
 * first TLV child of type MLXFW_MFA2_TLV_PACKAGE_DESCRIPTOR which contains all
 * the global information needed to parse the file. Among others, it contains
 * the number of device descriptors and component descriptor following this
 * multi TLV.
 *
 * The device descriptor multi_tlv
 * -------------------------------
 * The multi TLVs following the package descriptor are treated as device
 * descriptor, and are expected to have the following children:
 *  - PSID TLV child of type MLXFW_MFA2_TLV_PSID containing that device PSID.
 *  - Component index of type MLXFW_MFA2_TLV_COMPONENT_PTR that contains that
 *    device component index.
 *
 * The component descriptor multi_tlv
 * ----------------------------------
 * The multi TLVs following the device descriptor multi TLVs are treated as
 * component descriptor, and are expected to have a first child of type
 * MLXFW_MFA2_TLV_COMPONENT_DESCRIPTOR that contains mostly the component index,
 * needed for the flash process and the offset to the binary within the
 * component block.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_556.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlxsw/core_linecards.c#L1328-L1340

```c
/*
< ASCII >
 *        LINECARDS INI BUNDLE FILE
 *  +----------------------------------+
 *  |        MAGIC ("NVLCINI+")        |
 *  +----------------------------------+     +--------------------+
 *  |  INI 0                           +---> | __le16 size        |
 *  +----------------------------------+     | __be16 hw_revision |
 *  |  INI 1                           |     | __be16 ini_version |
 *  +----------------------------------+     | u8 __dontcare[3]   |
 *  |  ...                             |     | u8 type            |
 *  +----------------------------------+     | u8 name[20]        |
 *  |  INI N                           |     | ...                |
 *  +----------------------------------+     +--------------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_557.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_bloom_filter.c#L19-L28

```c
/* Bloom filter uses a crc-16 hash over chunks of data which contain 4 key
 * blocks, eRP ID and region ID. In Spectrum-2 and above, region key is combined
 * of up to 12 key blocks, so there can be up to 3 chunks in the Bloom filter
 * key, depending on the actual number of key blocks used in the region.
 * The layout of the Bloom filter key is as follows:
 *
< ASCII >
 * +-------------------------+------------------------+------------------------+
 * | Chunk 2 Key blocks 11-8 | Chunk 1 Key blocks 7-4 | Chunk 0 Key blocks 3-0 |
 * +-------------------------+------------------------+------------------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_558.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_bloom_filter.c#L34-L46

```c
/* Each chunk size is 23 bytes. 18 bytes of it contain 4 key blocks, each is
 * 36 bits, 2 bytes which hold eRP ID and region ID, and 3 bytes of zero
 * padding.
 * The layout of each chunk is as follows:
 *
< ASCII >
 * +---------+----------------------+-----------------------------------+
 * | 3 bytes |        2 bytes       |              18 bytes             |
 * +---------+-----------+----------+-----------------------------------+
 * | 183:158 |  157:148  | 147:144  |               143:0               |
 * +---------+-----------+----------+-----------------------------------+
 * |    0    | region ID |  eRP ID  |      4 Key blocks (18 Bytes)      |
 * +---------+-----------+----------+-----------------------------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_559.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_bloom_filter.c#L99-L111

```c
/* In Spectrum-4, there is no padding. Each chunk size is 20 bytes.
 * 18 bytes of it contain 4 key blocks, each is 36 bits, and 2 bytes which hold
 * eRP ID and region ID.
 * The layout of each chunk is as follows:
 *
< ASCII >
 * +----------------------+-----------------------------------+
 * |        2 bytes       |              18 bytes             |
 * +-----------+----------+-----------------------------------+
 * |  157:148  | 147:144  |               143:0               |
 * +---------+-----------+----------+-------------------------+
 * | region ID |  eRP ID  |      4 Key blocks (18 Bytes)      |
 * +-----------+----------+-----------------------------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_56.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-sa1100/include/mach/memory.h#L13-L26

```c
/*
 * Because of the wide memory address space between physical RAM banks on the
 * SA1100, it's much convenient to use Linux's SparseMEM support to implement
 * our memory map representation.  Assuming all memory nodes have equal access
 * characteristics, we then have generic discontiguous memory support.
 *
 * The sparsemem banks are matched with the physical memory bank addresses
 * which are incidentally the same as virtual addresses.
 * 
< ASCII >
 * 	node 0:  0xc0000000 - 0xc7ffffff
 * 	node 1:  0xc8000000 - 0xcfffffff
 * 	node 2:  0xd0000000 - 0xd7ffffff
 * 	node 3:  0xd8000000 - 0xdfffffff
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_560.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_flex_keys.c#L231-L238

```c
/* A block in Spectrum-2 is of the following form:
 *
< ASCII >
 * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 * |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |35|34|33|32|
 * +-----------------------------------------------------------------------------------------------+
 * |31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
 * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_561.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_flex_keys.c#L241-L249

```c
/* The key / mask block layout in Spectrum-2 is of the following form:
 *
< ASCII >
 * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 * |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |                block11_high                   |
 * +-----------------------------------------------------------------------------------------------+
 * |                    block11_low                               |         block10_high           |
 * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
< ASCII >
 * ...
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_562.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/microchip/sparx5/sparx5_fdma.c#L40-L69

```c
/* Frame DMA DCB format
 *
< ASCII >
 * +---------------------------+
 * |         Next Ptr          |
 * +---------------------------+
 * |   Reserved  |    Info     |
 * +---------------------------+
 * |         Data0 Ptr         |
 * +---------------------------+
 * |   Reserved  |    Status0  |
 * +---------------------------+
 * |         Data1 Ptr         |
 * +---------------------------+
 * |   Reserved  |    Status1  |
 * +---------------------------+
 * |         Data2 Ptr         |
 * +---------------------------+
 * |   Reserved  |    Status2  |
 * |-------------|-------------|
 * |                           |
 * |                           |
 * |                           |
 * |                           |
 * |                           |
 * |---------------------------|
 * |         Data14 Ptr        |
 * +-------------|-------------+
 * |   Reserved  |    Status14 |
 * +-------------|-------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_563.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L39-L46

```c
/*
< ASCII >
 *  Amount of packet buffer
 *  |  per QoS class
 *  |  |  reserved
 *  |  |  |   per egress port
 *  |  |  |   |
 *  V  V  v   v
 * BUF_Q_RSRV_E
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_564.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L50-L57

```c
/*
< ASCII >
 *  Amount of packet buffer
 *  |  for all port's traffic classes
 *  |  |  reserved
 *  |  |  |   per egress port
 *  |  |  |   |
 *  V  V  v   v
 * BUF_P_RSRV_E
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_565.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L61-L68

```c
/*
< ASCII >
 *  Amount of packet buffer
 *  |  per QoS class
 *  |  |  reserved
 *  |  |  |   per ingress port
 *  |  |  |   |
 *  V  V  v   v
 * BUF_Q_RSRV_I
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_566.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L72-L79

```c
/*
< ASCII >
 *  Amount of packet buffer
 *  |  for all port's traffic classes
 *  |  |  reserved
 *  |  |  |   per ingress port
 *  |  |  |   |
 *  V  V  v   v
 * BUF_P_RSRV_I
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_567.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L83-L90

```c
/*
< ASCII >
 *  Amount of frame references
 *  |  per QoS class
 *  |  |  reserved
 *  |  |  |   per egress port
 *  |  |  |   |
 *  V  V  v   v
 * REF_Q_RSRV_E
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_568.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L94-L101

```c
/*
< ASCII >
 *  Amount of frame references
 *  |  for all port's traffic classes
 *  |  |  reserved
 *  |  |  |   per egress port
 *  |  |  |   |
 *  V  V  v   v
 * REF_P_RSRV_E
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_569.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L105-L112

```c
/*
< ASCII >
 *  Amount of frame references
 *  |  per QoS class
 *  |  |  reserved
 *  |  |  |   per ingress port
 *  |  |  |   |
 *  V  V  v   v
 * REF_Q_RSRV_I
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_57.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mach-sa1100/include/mach/nanoengine.h#L28-L38

```c
/*
 * nanoEngine Memory Map:
 *
< ASCII >
 * 0000.0000 - 003F.0000 -   4 MB Flash
 * C000.0000 - C1FF.FFFF -  32 MB SDRAM
 * 1860.0000 - 186F.FFFF -   1 MB Internal PCI Memory Read/Write
 * 18A1.0000 - 18A1.FFFF -  64 KB Internal PCI Config Space
 * 4000.0000 - 47FF.FFFF - 128 MB External Bus I/O - Multiplexed Mode
 * 4800.0000 - 4FFF.FFFF - 128 MB External Bus I/O - Non-Multiplexed Mode
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_570.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L116-L123

```c
/*
< ASCII >
 *  Amount of frame references
 *  |  for all port's traffic classes
 *  |  |  reserved
 *  |  |  |   per ingress port
 *  |  |  |   |
 *  V  V  v   v
 * REF_P_RSRV_I
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_571.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L133-L140

```c
/*
< ASCII >
 * Amount of buffer
 *  |   per QoS class
 *  |   |    from the shared memory area
 *  |   |    |  for egress traffic
 *  |   |    |  |
 *  V   V    v  v
 * BUF_PRIO_SHR_E
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_572.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L144-L151

```c
/*
< ASCII >
 * Amount of buffer
 *  |   per color (drop precedence level)
 *  |   |   from the shared memory area
 *  |   |   |  for egress traffic
 *  |   |   |  |
 *  V   V   v  v
 * BUF_COL_SHR_E
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_573.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L155-L162

```c
/*
< ASCII >
 * Amount of buffer
 *  |   per QoS class
 *  |   |    from the shared memory area
 *  |   |    |  for ingress traffic
 *  |   |    |  |
 *  V   V    v  v
 * BUF_PRIO_SHR_I
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_574.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L166-L173

```c
/*
< ASCII >
 * Amount of buffer
 *  |   per color (drop precedence level)
 *  |   |   from the shared memory area
 *  |   |   |  for ingress traffic
 *  |   |   |  |
 *  V   V   v  v
 * BUF_COL_SHR_I
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_575.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L177-L184

```c
/*
< ASCII >
 * Amount of frame references
 *  |   per QoS class
 *  |   |    from the shared area
 *  |   |    |  for egress traffic
 *  |   |    |  |
 *  V   V    v  v
 * REF_PRIO_SHR_E
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_576.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L188-L195

```c
/*
< ASCII >
 * Amount of frame references
 *  |   per color (drop precedence level)
 *  |   |   from the shared area
 *  |   |   |  for egress traffic
 *  |   |   |  |
 *  V   V   v  v
 * REF_COL_SHR_E
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_577.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L199-L206

```c
/*
< ASCII >
 * Amount of frame references
 *  |   per QoS class
 *  |   |    from the shared area
 *  |   |    |  for ingress traffic
 *  |   |    |  |
 *  V   V    v  v
 * REF_PRIO_SHR_I
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_578.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L210-L217

```c
/*
< ASCII >
 * Amount of frame references
 *  |   per color (drop precedence level)
 *  |   |   from the shared area
 *  |   |   |  for ingress traffic
 *  |   |   |  |
 *  V   V   v  v
 * REF_COL_SHR_I
< ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_579.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/mscc/ocelot_devlink.c#L415-L475

```c
/* The hardware works like this:
 *
< ASCII >
 *                         Frame forwarding decision taken
 *                                       |
 *                                       v
 *       +--------------------+--------------------+--------------------+
 *       |                    |                    |                    |
 *       v                    v                    v                    v
 * Ingress memory       Egress memory        Ingress frame        Egress frame
 *     check                check           reference check      reference check
 *       |                    |                    |                    |
 *       v                    v                    v                    v
 *  BUF_Q_RSRV_I   ok    BUF_Q_RSRV_E   ok    REF_Q_RSRV_I   ok     REF_Q_RSRV_E   ok
 *(src port, prio) -+  (dst port, prio) -+  (src port, prio) -+   (dst port, prio) -+
 *       |          |         |          |         |          |         |           |
 *       |exceeded  |         |exceeded  |         |exceeded  |         |exceeded   |
 *       v          |         v          |         v          |         v           |
 *  BUF_P_RSRV_I  ok|    BUF_P_RSRV_E  ok|    REF_P_RSRV_I  ok|    REF_P_RSRV_E   ok|
 *   (src port) ----+     (dst port) ----+     (src port) ----+     (dst port) -----+
 *       |          |         |          |         |          |         |           |
 *       |exceeded  |         |exceeded  |         |exceeded  |         |exceeded   |
 *       v          |         v          |         v          |         v           |
 * BUF_PRIO_SHR_I ok|   BUF_PRIO_SHR_E ok|   REF_PRIO_SHR_I ok|   REF_PRIO_SHR_E  ok|
 *     (prio) ------+       (prio) ------+       (prio) ------+       (prio) -------+
 *       |          |         |          |         |          |         |           |
 *       |exceeded  |         |exceeded  |         |exceeded  |         |exceeded   |
 *       v          |         v          |         v          |         v           |
 * BUF_COL_SHR_I  ok|   BUF_COL_SHR_E  ok|   REF_COL_SHR_I  ok|   REF_COL_SHR_E   ok|
 *      (dp) -------+        (dp) -------+        (dp) -------+        (dp) --------+
 *       |          |         |          |         |          |         |           |
 *       |exceeded  |         |exceeded  |         |exceeded  |         |exceeded   |
 *       v          v         v          v         v          v         v           v
 *      fail     success     fail     success     fail     success     fail      success
 *       |          |         |          |         |          |         |           |
 *       v          v         v          v         v          v         v           v
 *       +-----+----+         +-----+----+         +-----+----+         +-----+-----+
 *             |                    |                    |                    |
 *             +-------> OR <-------+                    +-------> OR <-------+
 *                        |                                        |
 *                        v                                        v
 *                        +----------------> AND <-----------------+
 *                                            |
 *                                            v
 *                                    FIFO drop / accept
< ASCII >
 *
 * We are modeling each of the 4 parallel lookups as a devlink-sb pool.
 * At least one (ingress or egress) memory pool and one (ingress or egress)
 * frame reference pool need to have resources for frame acceptance to succeed.
 *
 * The following watermarks are controlled explicitly through devlink-sb:
 * BUF_Q_RSRV_I, BUF_Q_RSRV_E, REF_Q_RSRV_I, REF_Q_RSRV_E
 * BUF_P_RSRV_I, BUF_P_RSRV_E, REF_P_RSRV_I, REF_P_RSRV_E
 * The following watermarks are controlled implicitly through devlink-sb:
 * BUF_COL_SHR_I, BUF_COL_SHR_E, REF_COL_SHR_I, REF_COL_SHR_E
 * The following watermarks are unused and disabled:
 * BUF_PRIO_SHR_I, BUF_PRIO_SHR_E, REF_PRIO_SHR_I, REF_PRIO_SHR_E
 *
 * This function overrides the hardware defaults with more sane ones (no
 * reservations by default, let sharing use all resources) and disables the
 * unused watermarks.
 */
```
## Visual type:
- #custom


== ./linux/linux_58.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mm/alignment.c#L486-L498

```c
/*
 * LDM/STM alignment handler.
 *
 * There are 4 variants of this instruction:
 *
< ASCII >
 * B = rn pointer before instruction, A = rn pointer after instruction
 *              ------ increasing address ----->
 *	        |    | r0 | r1 | ... | rx |    |
 * PU = 01             B                    A
 * PU = 11        B                    A
 * PU = 00        A                    B
 * PU = 10             A                    B
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_580.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/netronome/nfp/flower/cmsg.h#L268-L278

```c
/* Metadata with L2 (1W/4B)
< ASCII >
 * ----------------------------------------------------------------
 *    3                   2                   1
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |    key_type   |    mask_id    | PCP |p|   vlan outermost VID  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *                                 ^                               ^
 *                           NOTE: |             TCI               |
 *                                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_581.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/netronome/nfp/flower/cmsg.h#L285-L292

```c
/* Extended metadata for additional key_layers (1W/4B)
< ASCII >
 * ----------------------------------------------------------------
 *    3                   2                   1
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      nfp_flow_key_layer2                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_582.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/netronome/nfp/flower/cmsg.h#L297-L304

```c
/* Port details (1W/4B)
< ASCII >
 * ----------------------------------------------------------------
 *    3                   2                   1
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                         port_ingress                          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_583.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/netronome/nfp/flower/cmsg.h#L309-L321

```c
/* L2 details (4W/16B)
< ASCII >
 *    3                   2                   1
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     mac_addr_dst, 31 - 0                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |      mac_addr_dst, 47 - 32    |     mac_addr_src, 15 - 0      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     mac_addr_src, 47 - 16                     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |       mpls outermost label            |  TC |B|   reserved  |q|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_584.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/netronome/nfp/flower/cmsg.h#L328-L336

```c
/* VLAN details (2W/8B)
< ASCII >
 *    3                   2                   1
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |           outer_tpid          |           outer_tci           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |           inner_tpid          |           inner_tci           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_585.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/netronome/nfp/flower/cmsg.h#L344-L350

```c
/* L4 ports (for UDP, TCP, SCTP) (1W/4B)
< ASCII >
 *    3                   2                   1
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |            port_src           |           port_dst            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_586.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/netronome/nfp/flower/cmsg.h#L363-L373

```c
/* L3 IPv4 details (3W/12B)
< ASCII >
 *    3                   2                   1
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |    DSCP   |ECN|   protocol    |      ttl      |     flags     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                        ipv4_addr_src                          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                        ipv4_addr_dst                          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_587.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/netronome/nfp/flower/cmsg.h#L380-L404

```c
/* L3 IPv6 details (10W/40B)
< ASCII >
 *    3                   2                   1
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |    DSCP   |ECN|   protocol    |      ttl      |     flags     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |   ipv6_exthdr   | res |            ipv6_flow_label            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_src,   31 - 0                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_src,  63 - 32                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_src,  95 - 64                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_src, 127 - 96                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_dst,   31 - 0                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_dst,  63 - 32                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_dst,  95 - 64                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_dst, 127 - 96                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_588.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/netronome/nfp/flower/cmsg.h#L427-L442

```c
/* Flow Frame IPv4 UDP TUNNEL --> Tunnel details (4W/16B)
< ASCII >
 * -----------------------------------------------------------------
 *    3                   2                   1
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                         ipv4_addr_src                         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                         ipv4_addr_dst                         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |           Reserved            |      tos      |      ttl      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                            Reserved                           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     VNI                       |   Reserved    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_589.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/netronome/nfp/flower/cmsg.h#L451-L478

```c
/* Flow Frame IPv6 UDP TUNNEL --> Tunnel details (11W/44B)
< ASCII >
 * -----------------------------------------------------------------
 *    3                   2                   1
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_src,   31 - 0                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_src,  63 - 32                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_src,  95 - 64                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_src, 127 - 96                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_dst,   31 - 0                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_dst,  63 - 32                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_dst,  95 - 64                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_dst, 127 - 96                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |           Reserved            |      tos      |      ttl      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                            Reserved                           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     VNI                       |   Reserved    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_59.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mm/cache-v4wb.S#L30-L43

```c
/*
 * This is the size at which it becomes more efficient to
 * clean the whole cache, rather than using the individual
 * cache line maintenance instructions.
 *
< ASCII >
 *  Size  Clean (ticks) Dirty (ticks)
 *   4096   21  20  21    53  55  54
 *   8192   40  41  40   106 100 102
 *  16384   77  77  76   140 140 138
 *  32768  150 149 150   214 216 212 <---
 *  65536  296 297 296   351 358 361
 * 131072  591 591 591   656 657 651
 *  Whole  132 136 132   221 217 207 <---
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_590.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/netronome/nfp/flower/cmsg.h#L487-L504

```c
/* Flow Frame GRE TUNNEL --> Tunnel details (6W/24B)
< ASCII >
 * -----------------------------------------------------------------
 *    3                   2                   1
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                         ipv4_addr_src                         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                         ipv4_addr_dst                         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |           tun_flags           |       tos     |       ttl     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |            Reserved           |           Ethertype           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                              Key                              |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                           Reserved                            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_591.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/netronome/nfp/flower/cmsg.h#L516-L545

```c
/* Flow Frame GRE TUNNEL V6 --> Tunnel details (12W/48B)
< ASCII >
 * -----------------------------------------------------------------
 *    3                   2                   1
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_src,   31 - 0                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_src,  63 - 32                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_src,  95 - 64                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_src, 127 - 96                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_dst,   31 - 0                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_dst,  63 - 32                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_dst,  95 - 64                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  ipv6_addr_dst, 127 - 96                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |           tun_flags           |       tos     |       ttl     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |            Reserved           |           Ethertype           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                              Key                              |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                           Reserved                            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_592.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/netronome/nfp/flower/qos_conf.c#L34-L67

```c
/* Police cmsg for configuring a trTCM traffic conditioner (8W/32B)
 * See RFC 2698 for more details.
< ASCII >
 * ----------------------------------------------------------------
 *    3                   2                   1
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |             Reserved          |p|         Reserved            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                          Port Ingress                         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                        Token Bucket Peak                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     Token Bucket Committed                    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                         Peak Burst Size                       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Committed Burst Size                     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Peak Information Rate                    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                    Committed Information Rate                 |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
< ASCII >
 * Word[0](FLag options):
 * [15] p(pps) 1 for pps, 0 for bps
 *
< ASCII >
 * Meter control message
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-------------------------------+-+---+-----+-+---------+-+---+-+
 * |            Reserved           |p| Y |TYPE |E|TSHFV    |P| PC|R|
 * +-------------------------------+-+---+-----+-+---------+-+---+-+
 * |                            meter ID                           |
 * +-------------------------------+-------------------------------+
< ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_593.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/netronome/nfp/nfpcore/nfp6000_pcie.c#L519-L534

```c
/* Map all PCI bars and fetch the actual BAR configurations from the
 * board.  We assume that the BAR with the PCIe config block is
 * already mapped.
 *
< ASCII >
 * BAR0.0: Reserved for General Mapping (for MSI-X access to PCIe SRAM)
 * BAR0.1: Reserved for XPB access (for MSI-X access to PCIe PBA)
 * BAR0.2: --
 * BAR0.3: --
 * BAR0.4: Reserved for Explicit 0.0-0.3 access
 * BAR0.5: Reserved for Explicit 1.0-1.3 access
 * BAR0.6: Reserved for Explicit 2.0-2.3 access
 * BAR0.7: Reserved for Explicit 3.0-3.3 access
 *
 * BAR1.0-BAR1.7: --
 * BAR2.0-BAR2.7: --
< ASCII >
 */
```
## Visual type:
- #ignore


== ./linux/linux_594.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_param.c#L62-L75

```c
/*
 * AutoNeg - Auto-negotiation Advertisement Override
 * @Valid Range: 0x01-0x0F, 0x20-0x2F
 *
 *       The AutoNeg value is a bit mask describing which speed and duplex
 *       combinations should be advertised during auto-negotiation.
 *       The supported speed and duplex modes are listed below
< ASCII >
 *
 *       Bit           7     6     5      4      3     2     1      0
 *       Speed (Mbps)  N/A   N/A   1000   N/A    100   100   10     10
 *       Duplex                    Full          Full  Half  Full   Half
< ASCII >
 *
 * @Default Value: 0x2F (copper)
 */
```
## Visual type:
- #table


== ./linux/linux_595.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/packetengines/hamachi.c#L88-L102

```c
/* The Hamachi chipset supports 3 parameters each for Rx and Tx
 * interruput management.  Parameters will be loaded as specified into
 * the TxIntControl and RxIntControl registers.
 *
< ASCII >
 * The registers are arranged as follows:
 *     23 - 16   15 -  8   7    -    0
 *    _________________________________
 *   | min_pkt | max_gap | max_latency |
 *    ---------------------------------
< ASCII >
 *   min_pkt      : The minimum number of packets processed between
 *                  interrupts.
 *   max_gap      : The maximum inter-packet gap in units of 8.192 us
 *   max_latency  : The absolute time between interrupts in units of 8.192 us
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_596.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/qlogic/qed/qed_main.c#L2299-L2309

```c
/* Binary file format -
< ASCII >
 *     /----------------------------------------------------------------------\
 * 0B  |                       0x4 [command index]                            |
 * 4B  | image_type     | Options        |  Number of register settings       |
 * 8B  |                       Value                                          |
 * 12B |                       Mask                                           |
 * 16B |                       Offset                                         |
 *     \----------------------------------------------------------------------/
< ASCII >
 * There can be several Value-Mask-Offset sets as specified by 'Number of...'.
 * Options - 0'b - Calculate & Update CRC for image
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_597.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/qlogic/qed/qed_main.c#L2403-L2411

```c
/* Binary file format -
< ASCII >
 *     /----------------------------------------------------------------------\
 * 0B  |                       0x3 [command index]                            |
 * 4B  | b'0: check_response?   | b'1-31  reserved                            |
 * 8B  | File-type |                   reserved                               |
 * 12B |                    Image length in bytes                             |
 *     \----------------------------------------------------------------------/
< ASCII >
 *     Start a new file of the provided type
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_598.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/qlogic/qed/qed_main.c#L2437-L2447

```c
/* Binary file format -
< ASCII >
 *     /----------------------------------------------------------------------\
 * 0B  |                       0x2 [command index]                            |
 * 4B  |                       Length in bytes                                |
 * 8B  | b'0: check_response?   | b'1-31  reserved                            |
 * 12B |                       Offset in bytes                                |
 * 16B |                       Data ...                                       |
 *     \----------------------------------------------------------------------/
< ASCII >
 *     Write data as part of a file that was previously started. Data should be
 *     of length equal to that provided in the message
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_599.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/qlogic/qed/qed_main.c#L2473-L2479

```c
/* Binary file format [General header] -
< ASCII >
 *     /----------------------------------------------------------------------\
 * 0B  |                       QED_NVM_SIGNATURE                              |
 * 4B  |                       Length in bytes                                |
 * 8B  | Highest command in this batchfile |          Reserved                |
 *     \----------------------------------------------------------------------/
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_6.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/include/asm/core_t2.h#L418-L447

```c
/*
 * Memory functions.
 *
 * For reading and writing 8 and 16 bit quantities we need to
 * go through one of the three sparse address mapping regions
 * and use the HAE_MEM CSR to provide some bits of the address.
 * The following few routines use only sparse address region 1
 * which gives 1Gbyte of accessible space which relates exactly
 * to the amount of PCI memory mapping *into* system address space.
 * See p 6-17 of the specification but it looks something like this:
 *
< ASCII >
 * 21164 Address:
 *
 *          3         2         1
 * 9876543210987654321098765432109876543210
 * 1ZZZZ0.PCI.QW.Address............BBLL
< ASCII >
 *
 * ZZ = SBZ
 * BB = Byte offset
 * LL = Transfer length
 *
< ASCII >
 * PCI Address:
 *
 * 3         2         1
 * 10987654321098765432109876543210
 * HHH....PCI.QW.Address........ 00
< ASCII >
 *
 * HHH = 31:29 HAE_MEM CSR
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_60.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mm/context.c#L22-L38

```c
/*
 * On ARMv6, we have the following structure in the Context ID:
 *
< ASCII >
 * 31                         7          0
 * +-------------------------+-----------+
 * |      process ID         |   ASID    |
 * +-------------------------+-----------+
 * |              context ID             |
 * +-------------------------------------+
< ASCII >
 *
 * The ASID is used to tag entries in the CPU caches and TLBs.
 * The context ID is used by debuggers and trace logic, and
 * should be unique within all running processes.
 *
 * In big endian operation, the two 32 bit words are swapped if accessed
 * by non-64-bit operations.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_600.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/qlogic/qed/qed_main.c#L2521-L2534

```c
/* Binary file format -
< ASCII >
 *     /----------------------------------------------------------------------\
 * 0B  |                       0x5 [command index]                            |
 * 4B  | Number of config attributes     |          Reserved                  |
 * 4B  | Config ID                       | Entity ID      | Length            |
 * 4B  | Value                                                                |
 *     |                                                                      |
 *     \----------------------------------------------------------------------/
< ASCII >
 * There can be several cfg_id-entity_id-Length-Value sets as specified by
 * 'Number of config attributes'.
 *
 * The API parses config attributes from the user provided buffer and flashes
 * them to the respective NVM path using Management FW inerface.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_601.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/realtek/atp.c#L390-L400

```c
/*
  An EEPROM read command starts by shifting out 0x60+address, and then
  shifting in the serial data. See the NatSemi databook for details.
< ASCII >
 *		   ________________
 * CS : __|
 *			   ___	   ___
 * CLK: ______|	  |___|	  |
 *		 __ _______ _______
 * DI :	 __X_______X_______X
 * DO :	 _________X_______X
< ASCII >
 */
```
## Visual type:
- #plot


== ./linux/linux_602.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/realtek/r8169_main.c#L1633-L1659

```c
/*
 * Interrupt coalescing
 *
 * > 1 - the availability of the IntrMitigate (0xe2) register through the
 * >     8169, 8168 and 810x line of chipsets
 *
 * 8169, 8168, and 8136(810x) serial chipsets support it.
 *
 * > 2 - the Tx timer unit at gigabit speed
 *
 * The unit of the timer depends on both the speed and the setting of CPlusCmd
 * (0xe0) bit 1 and bit 0.
 *
< ASCII >
 * For 8169
 * bit[1:0] \ speed        1000M           100M            10M
 * 0 0                     320ns           2.56us          40.96us
 * 0 1                     2.56us          20.48us         327.7us
 * 1 0                     5.12us          40.96us         655.4us
 * 1 1                     10.24us         81.92us         1.31ms
 *
 * For the other
 * bit[1:0] \ speed        1000M           100M            10M
 * 0 0                     5us             2.56us          40.96us
 * 0 1                     40us            20.48us         327.7us
 * 1 0                     80us            40.96us         655.4us
 * 1 1                     160us           81.92us         1.31ms
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_603.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/rocker/rocker_tlv.h#L21-L27

```c
/*  < ASCII >
 * <------- ROCKER_TLV_HDRLEN -------> <--- ROCKER_TLV_ALIGN(payload) --->
 * +-----------------------------+- - -+- - - - - - - - - - - - - - -+- - -+
 * |             Header          | Pad |           Payload           | Pad |
 * |      (struct rocker_tlv)    | ing |                             | ing |
 * +-----------------------------+- - -+- - - - - - - - - - - - - - -+- - -+
 *  <--------------------------- tlv->len -------------------------->
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_604.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/sfc/ef100_regs.h#L15-L35

```c
/* EF100 hardware architecture definitions have a name prefix following
 * the format:
 *
 *     E<type>_<min-rev><max-rev>_
 *
 * The following <type> strings are used:
 *
< ASCII >
 *             MMIO register  Host memory structure
 * -------------------------------------------------------------
 * Address     R
 * Bitfield    RF             SF
 * Enumerator  FE             SE
< ASCII >
 *
 * <min-rev> is the first revision to which the definition applies:
 *
 *     G: Riverhead
 *
 * If the definition has been changed or removed in later revisions
 * then <max-rev> is the last revision to which the definition applies;
 * otherwise it is "Z".
 */
```
## Visual type:
- #table


== ./linux/linux_605.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/sfc/ef10_regs.h#L10-L30

```c
/* EF10 hardware architecture definitions have a name prefix following
 * the format:
 *
 *     E<type>_<min-rev><max-rev>_
 *
< ASCII >
 * The following <type> strings are used:
 *
 *             MMIO register  Host memory structure
 * -------------------------------------------------------------
 * Address     R
 * Bitfield    RF             SF
 * Enumerator  FE             SE
< ASCII >
 *
 * <min-rev> is the first revision to which the definition applies:
 *
 *     D: Huntington A0
 *
 * If the definition has been changed or removed in later revisions
 * then <max-rev> is the last revision to which the definition applies;
 * otherwise it is "Z".
 */
```
## Visual type:
- #table


== ./linux/linux_606.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/sfc/ef10_regs.h#L402-L407

```c
/* The workaround for bug 35388 requires multiplexing writes through
 * the TX_DESC_UPD_DWORD address.
< ASCII >
 * TX_DESC_UPD: 0ppppppppppp               (bit 11 lost)
 * EVQ_RPTR:    1000hhhhhhhh, 1001llllllll (split into high and low bits)
 * EVQ_TMR:     11mmvvvvvvvv               (bits 8:13 of value lost)
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_607.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/sfc/farch_regs.h#L11-L34

```c
/*
 * Falcon hardware architecture definitions have a name prefix following
 * the format:
 *
 *     F<type>_<min-rev><max-rev>_
 *
< ASCII >
 * The following <type> strings are used:
 *
 *             MMIO register  MC register  Host memory structure
 * -------------------------------------------------------------
 * Address     R              MCR
 * Bitfield    RF             MCRF         SF
 * Enumerator  FE             MCFE         SE
< ASCII >
 *
 * <min-rev> is the first revision to which the definition applies:
 *
 *     A: Falcon A1 (SFC4000AB)
 *     B: Falcon B0 (SFC4000BA)
 *     C: Siena A0 (SFL9021AA)
 *
 * If the definition has been changed or removed in later revisions
 * then <max-rev> is the last revision to which the definition applies;
 * otherwise it is "Z".
 */
```
## Visual type:
- #table


== ./linux/linux_608.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/sfc/mae.c#L282-L287

```c
/* Bit twiddling:
< ASCII >
 * Prefix: 1...110...0
 *      ~: 0...001...1
 *    + 1: 0...010...0 is power of two
 * so (~x) & ((~x) + 1) == 0.  Converse holds also.
< ASCII >
 */
```
## Visual type:
- #formula


== ./linux/linux_609.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/sfc/mcdi_pcol.h#L63-L91

```c
/* MCDI version 1
 *
 * Each MCDI request starts with an MCDI_HEADER, which is a 32bit
 * structure, filled in by the client.
< ASCII >
 *
 *       0       7  8     16    20     22  23  24    31
 *      | CODE | R | LEN | SEQ | Rsvd | E | R | XFLAGS |
 *               |                      |   |
 *               |                      |   \--- Response
 *               |                      \------- Error
 *               \------------------------------ Resync (always set)
< ASCII >
 *
 * The client writes it's request into MC shared memory, and rings the
 * doorbell. Each request is completed by either by the MC writing
 * back into shared memory, or by writing out an event.
 *
 * All MCDI commands support completion by shared memory response. Each
 * request may also contain additional data (accounted for by HEADER.LEN),
 * and some response's may also contain additional data (again, accounted
 * for by HEADER.LEN).
 *
 * Some MCDI commands support completion by event, in which any associated
 * response data is included in the event.
 *
 * The protocol requires one response to be delivered for every request, a
 * request should not be sent unless the response for the previous request
 * has been received (either by polling shared memory, or by receiving
 * an event).
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_61.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mm/proc-macros.S#L120-L132

```c
/*
 * The ARMv6 and ARMv7 set_pte_ext translation function.
 *
< ASCII >
 * Permission translation:
 *  YUWD  APX AP1 AP0	SVC	User
 *  0xxx   0   0   0	no acc	no acc
 *  100x   1   0   1	r/o	no acc
 *  10x0   1   0   1	r/o	no acc
 *  1011   0   0   1	r/w	no acc
 *  110x   1   1   1	r/o	r/o
 *  11x0   1   1   1	r/o	r/o
 *  1111   0   1   1	r/w	r/w
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_610.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/sfc/mcdi_pcol.h#L125-L164

```c
/* The MC can generate events for two reasons:
 *   - To advance a shared memory request if XFLAGS_EVREQ was set
 *   - As a notification (link state, i2c event), controlled
 *     via MC_CMD_LOG_CTRL
 *
 * Both events share a common structure:
 *
< ASCII >
 *  0      32     33      36    44     52     60
 * | Data | Cont | Level | Src | Code | Rsvd |
 *           |
 *           \ There is another event pending in this notification
< ASCII >
 *
 * If Code==CMDDONE, then the fields are further interpreted as:
 *
 *   - LEVEL==INFO    Command succeeded
 *   - LEVEL==ERR     Command failed
 *
< ASCII >
 *    0     8         16      24     32
 *   | Seq | Datalen | Errno | Rsvd |
< ASCII >
 *
 *   These fields are taken directly out of the standard MCDI header, i.e.,
 *   LEVEL==ERR, Datalen == 0 => Reboot
 *
 * Events can be squirted out of the UART (using LOG_CTRL) without a
 * MCDI header.  An event can be distinguished from a MCDI response by
 * examining the first byte which is 0xc0.  This corresponds to the
 * non-existent MCDI command MC_CMD_DEBUG_LOG.
 *
< ASCII >
 *      0         7        8
 *     | command | Resync |     = 0xc0
< ASCII >
 *
 * Since the event is written in big-endian byte order, this works
 * providing bits 56-63 of the event are 0xc0.
 *
< ASCII >
 *      56     60  63
 *     | Rsvd | Code |    = 0xc0
< ASCII >
 *
 * Which means for convenience the event code is 0xc for all MC
 * generated events.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_611.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/sfc/vfdi.h#L9-L71

```c
/**
 * DOC: Virtual Function Driver Interface
 *
 * This file contains software structures used to form a two way
 * communication channel between the VF driver and the PF driver,
 * named Virtual Function Driver Interface (VFDI).
 *
 * For the purposes of VFDI, a page is a memory region with size and
 * alignment of 4K.  All addresses are DMA addresses to be used within
 * the domain of the relevant VF.
 *
 * The only hardware-defined channels for a VF driver to communicate
 * with the PF driver are the event mailboxes (%FR_CZ_USR_EV
 * registers).  Writing to these registers generates an event with
 * EV_CODE = EV_CODE_USR_EV, USER_QID set to the index of the mailbox
 * and USER_EV_REG_VALUE set to the value written.  The PF driver may
 * direct or disable delivery of these events by setting
 * %FR_CZ_USR_EV_CFG.
 *
 * The PF driver can send arbitrary events to arbitrary event queues.
 * However, for consistency, VFDI events from the PF are defined to
 * follow the same form and be sent to the first event queue assigned
 * to the VF while that queue is enabled by the VF driver.
 *
< ASCII >
 * The general form of the variable bits of VFDI events is:
 *
 *       0             16                       24   31
 *      | DATA        | TYPE                   | SEQ   |
< ASCII >
 *
 * SEQ is a sequence number which should be incremented by 1 (modulo
 * 256) for each event.  The sequence numbers used in each direction
 * are independent.
 *
 * The VF submits requests of type &struct vfdi_req by sending the
 * address of the request (ADDR) in a series of 4 events:
< ASCII >
 *
 *       0             16                       24   31
 *      | ADDR[0:15]  | VFDI_EV_TYPE_REQ_WORD0 | SEQ   |
 *      | ADDR[16:31] | VFDI_EV_TYPE_REQ_WORD1 | SEQ+1 |
 *      | ADDR[32:47] | VFDI_EV_TYPE_REQ_WORD2 | SEQ+2 |
 *      | ADDR[48:63] | VFDI_EV_TYPE_REQ_WORD3 | SEQ+3 |
< ASCII >
 *
 * The address must be page-aligned.  After receiving such a valid
 * series of events, the PF driver will attempt to read the request
 * and write a response to the same address.  In case of an invalid
 * sequence of events or a DMA error, there will be no response.
 *
 * The VF driver may request that the PF driver writes status
 * information into its domain asynchronously.  After writing the
 * status, the PF driver will send an event of the form:
< ASCII >
 *
 *       0             16                       24   31
 *      | reserved    | VFDI_EV_TYPE_STATUS    | SEQ   |
< ASCII >
 *
 * In case the VF must be reset for any reason, the PF driver will
 * send an event of the form:
< ASCII >
 *
 *       0             16                       24   31
 *      | reserved    | VFDI_EV_TYPE_RESET     | SEQ   |
< ASCII >
 *
 * It is then the responsibility of the VF driver to request
 * reinitialisation of its queues.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_612.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/sfc/siena/farch_regs.h#L11-L34

```c
/*
 * Falcon hardware architecture definitions have a name prefix following
 * the format:
 *
 *     F<type>_<min-rev><max-rev>_
 *
< ASCII >
 * The following <type> strings are used:
 *
 *             MMIO register  MC register  Host memory structure
 * -------------------------------------------------------------
 * Address     R              MCR
 * Bitfield    RF             MCRF         SF
 * Enumerator  FE             MCFE         SE
 *
 * <min-rev> is the first revision to which the definition applies:
 *
 *     A: Falcon A1 (SFC4000AB)
 *     B: Falcon B0 (SFC4000BA)
 *     C: Siena A0 (SFL9021AA)
< ASCII >
 *
 * If the definition has been changed or removed in later revisions
 * then <max-rev> is the last revision to which the definition applies;
 * otherwise it is "Z".
 */
```
## Visual type:
- #table


== ./linux/linux_613.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/sfc/siena/mcdi_pcol.h#L63-L91

```c
/* MCDI version 1
 *
 * Each MCDI request starts with an MCDI_HEADER, which is a 32bit
 * structure, filled in by the client.
 *
< ASCII >
 *       0       7  8     16    20     22  23  24    31
 *      | CODE | R | LEN | SEQ | Rsvd | E | R | XFLAGS |
 *               |                      |   |
 *               |                      |   \--- Response
 *               |                      \------- Error
 *               \------------------------------ Resync (always set)
< ASCII >
 *
 * The client writes it's request into MC shared memory, and rings the
 * doorbell. Each request is completed by either by the MC writing
 * back into shared memory, or by writing out an event.
 *
 * All MCDI commands support completion by shared memory response. Each
 * request may also contain additional data (accounted for by HEADER.LEN),
 * and some response's may also contain additional data (again, accounted
 * for by HEADER.LEN).
 *
 * Some MCDI commands support completion by event, in which any associated
 * response data is included in the event.
 *
 * The protocol requires one response to be delivered for every request, a
 * request should not be sent unless the response for the previous request
 * has been received (either by polling shared memory, or by receiving
 * an event).
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_614.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/sfc/siena/mcdi_pcol.h#L125-L164

```c
/* The MC can generate events for two reasons:
 *   - To advance a shared memory request if XFLAGS_EVREQ was set
 *   - As a notification (link state, i2c event), controlled
 *     via MC_CMD_LOG_CTRL
 *
 * Both events share a common structure:
 * 
< ASCII >
 *  0      32     33      36    44     52     60
 * | Data | Cont | Level | Src | Code | Rsvd |
 *           |
 *           \ There is another event pending in this notification
< ASCII >
 *
 * If Code==CMDDONE, then the fields are further interpreted as:
 *
 *   - LEVEL==INFO    Command succeeded
 *   - LEVEL==ERR     Command failed
 *
< ASCII >
 *    0     8         16      24     32
 *   | Seq | Datalen | Errno | Rsvd |
< ASCII >
 *
 *   These fields are taken directly out of the standard MCDI header, i.e.,
 *   LEVEL==ERR, Datalen == 0 => Reboot
 *
 * Events can be squirted out of the UART (using LOG_CTRL) without a
 * MCDI header.  An event can be distinguished from a MCDI response by
 * examining the first byte which is 0xc0.  This corresponds to the
 * non-existent MCDI command MC_CMD_DEBUG_LOG.
 *
< ASCII >
 *      0         7        8
 *     | command | Resync |     = 0xc0
< ASCII >
 *
 * Since the event is written in big-endian byte order, this works
 * providing bits 56-63 of the event are 0xc0.
 *
< ASCII >
 *      56     60  63
 *     | Rsvd | Code |    = 0xc0
< ASCII >
 *
 * Which means for convenience the event code is 0xc for all MC
 * generated events.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_615.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/sfc/siena/vfdi.h#L9-L71

```c
/**
 * DOC: Virtual Function Driver Interface
 *
 * This file contains software structures used to form a two way
 * communication channel between the VF driver and the PF driver,
 * named Virtual Function Driver Interface (VFDI).
 *
 * For the purposes of VFDI, a page is a memory region with size and
 * alignment of 4K.  All addresses are DMA addresses to be used within
 * the domain of the relevant VF.
 *
 * The only hardware-defined channels for a VF driver to communicate
 * with the PF driver are the event mailboxes (%FR_CZ_USR_EV
 * registers).  Writing to these registers generates an event with
 * EV_CODE = EV_CODE_USR_EV, USER_QID set to the index of the mailbox
 * and USER_EV_REG_VALUE set to the value written.  The PF driver may
 * direct or disable delivery of these events by setting
 * %FR_CZ_USR_EV_CFG.
 *
 * The PF driver can send arbitrary events to arbitrary event queues.
 * However, for consistency, VFDI events from the PF are defined to
 * follow the same form and be sent to the first event queue assigned
 * to the VF while that queue is enabled by the VF driver.
 *
 * The general form of the variable bits of VFDI events is:
 *
< ASCII >
 *       0             16                       24   31
 *      | DATA        | TYPE                   | SEQ   |
< ASCII >
 *
 * SEQ is a sequence number which should be incremented by 1 (modulo
 * 256) for each event.  The sequence numbers used in each direction
 * are independent.
 *
 * The VF submits requests of type &struct vfdi_req by sending the
 * address of the request (ADDR) in a series of 4 events:
 *
< ASCII >
 *       0             16                       24   31
 *      | ADDR[0:15]  | VFDI_EV_TYPE_REQ_WORD0 | SEQ   |
 *      | ADDR[16:31] | VFDI_EV_TYPE_REQ_WORD1 | SEQ+1 |
 *      | ADDR[32:47] | VFDI_EV_TYPE_REQ_WORD2 | SEQ+2 |
 *      | ADDR[48:63] | VFDI_EV_TYPE_REQ_WORD3 | SEQ+3 |
< ASCII >
 *
 * The address must be page-aligned.  After receiving such a valid
 * series of events, the PF driver will attempt to read the request
 * and write a response to the same address.  In case of an invalid
 * sequence of events or a DMA error, there will be no response.
 *
 * The VF driver may request that the PF driver writes status
 * information into its domain asynchronously.  After writing the
 * status, the PF driver will send an event of the form:
 *
< ASCII >
 *       0             16                       24   31
 *      | reserved    | VFDI_EV_TYPE_STATUS    | SEQ   |
< ASCII >
 *
 * In case the VF must be reset for any reason, the PF driver will
 * send an event of the form:
 *
< ASCII >
 *       0             16                       24   31
 *      | reserved    | VFDI_EV_TYPE_RESET     | SEQ   |
< ASCII >
 *
 * It is then the responsibility of the VF driver to request
 * reinitialisation of its queues.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_616.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c#L37-L49

```c
/*  Ethernet PHY interface selection in register SYSCFG Configuration
< ASCII >
 *------------------------------------------
 * src	 |BIT(23)| BIT(22)| BIT(21)|BIT(20)|
 *------------------------------------------
 * MII   |   0	 |   0	  |   0    |   1   |
 *------------------------------------------
 * GMII  |   0	 |   0	  |   0    |   0   |
 *------------------------------------------
 * RGMII |   0	 |   0	  |   1	   |  n/a  |
 *------------------------------------------
 * RMII  |   1	 |   0	  |   0	   |  n/a  |
 *------------------------------------------
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_617.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c#L57-L80

```c
/* STM32MP1 register definitions
 *
 * Below table summarizes the clock requirement and clock sources for
 * supported phy interface modes.
< ASCII >
 * __________________________________________________________________________
 *|PHY_MODE | Normal | PHY wo crystal|   PHY wo crystal   |No 125Mhz from PHY|
 *|         |        |      25MHz    |        50MHz       |                  |
 * ---------------------------------------------------------------------------
 *|  MII    |	 -   |     eth-ck    |	      n/a	  |	  n/a        |
 *|         |        | st,ext-phyclk |                    |		     |
 * ---------------------------------------------------------------------------
 *|  GMII   |	 -   |     eth-ck    |	      n/a	  |	  n/a        |
 *|         |        | st,ext-phyclk |                    |		     |
 * ---------------------------------------------------------------------------
 *| RGMII   |	 -   |     eth-ck    |	      n/a	  |      eth-ck      |
 *|         |        | st,ext-phyclk |                    | st,eth-clk-sel or|
 *|         |        |               |                    | st,ext-phyclk    |
 * ---------------------------------------------------------------------------
 *| RMII    |	 -   |     eth-ck    |	    eth-ck        |	  n/a        |
 *|         |        | st,ext-phyclk | st,eth-ref-clk-sel |		     |
 *|         |        |               | or st,ext-phyclk   |		     |
 * ---------------------------------------------------------------------------
< ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_618.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c#L4053-L4079

```c
/**
 *  stmmac_tso_xmit - Tx entry point of the driver for oversized frames (TSO)
 *  @skb : the socket buffer
 *  @dev : device pointer
 *  Description: this is the transmit function that is called on TSO frames
 *  (support available on GMAC4 and newer chips).
 *  Diagram below show the ring programming in case of TSO frames:
 *
< ASCII >
 *  First Descriptor
 *   --------
 *   | DES0 |---> buffer1 = L2/L3/L4 header
 *   | DES1 |---> TCP Payload (can continue on next descr...)
 *   | DES2 |---> buffer 1 and 2 len
 *   | DES3 |---> must set TSE, TCP hdr len-> [22:19]. TCP payload len [17:0]
 *   --------
 *	|
 *     ...
 *	|
 *   --------
 *   | DES0 | --| Split TCP Payload on Buffers 1 and 2
 *   | DES1 | --|
 *   | DES2 | --> buffer 1 and 2 len
 *   | DES3 |
 *   --------
< ASCII >
 *
 * mss is fixed when enable tso, so w/o programming the TDES3 ctx field.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_619.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/toshiba/spider_net.h#L184-L200

```c
/* DMAC control register GDMACCNTR
 *
< ASCII >
 * 1(0)				enable r/tx dma
 *  0000000				fixed to 0
 *
 *         000000			fixed to 0
 *               0(1)			en/disable descr writeback on force end
 *                0(1)			force end
 *
 *                 000000		fixed to 0
 *                       00		burst alignment: 128 bytes
 *                       11		burst alignment: 1024 bytes
 *
 *                         00000	fixed to 0
 *                              0	descr writeback size 32 bytes
 *                               0(1)	descr chain end interrupt enable
 *                                0(1)	descr status writeback enable
< ASCII > */
```
## Visual type:
- #custom


== ./linux/linux_62.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mm/proc-macros.S#L192-L205

```c
/*
 * The ARMv3, ARMv4 and ARMv5 set_pte_ext translation function,
 * covering most CPUs except Xscale and Xscale 3.
 *
< ASCII >
 * Permission translation:
 *  YUWD   AP	SVC	User
 *  0xxx  0x00	no acc	no acc
 *  100x  0x00	r/o	no acc
 *  10x0  0x00	r/o	no acc
 *  1011  0x55	r/w	no acc
 *  110x  0xaa	r/w	r/o
 *  11x0  0xaa	r/w	r/o
 *  1111  0xff	r/w	r/w
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_620.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ethernet/xircom/xirc2ps_cs.c#L516-L533

```c
/****************
 * Detect the type of the card. s is the buffer with the data of tuple 0x20
 * Returns: 0 := not supported
 *		       mediaid=11 and prodid=47
< ASCII >
 * Media-Id bits:
 *  Ethernet	    0x01
 *  Tokenring	    0x02
 *  Arcnet	    0x04
 *  Wireless	    0x08
 *  Modem	    0x10
 *  GSM only	    0x20
 * Prod-Id bits:
 *  Pocket	    0x10
 *  External	    0x20
 *  Creditcard	    0x40
 *  Cardbus	    0x80
< ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_621.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/hamradio/scc.c#L750-L793

```c
/*
 * Initialization according to the Z8530 manual (SGS-Thomson's version):
 *
< ASCII >
 * 1. Modes and constants
 *
 * WR9	11000000	chip reset
 * WR4	XXXXXXXX	Tx/Rx control, async or sync mode
 * WR1	0XX00X00	select W/REQ (optional)
 * WR2	XXXXXXXX	program interrupt vector
 * WR3	XXXXXXX0	select Rx control
 * WR5	XXXX0XXX	select Tx control
 * WR6	XXXXXXXX	sync character
 * WR7	XXXXXXXX	sync character
 * WR9	000X0XXX	select interrupt control
 * WR10	XXXXXXXX	miscellaneous control (optional)
 * WR11	XXXXXXXX	clock control
 * WR12	XXXXXXXX	time constant lower byte (optional)
 * WR13	XXXXXXXX	time constant upper byte (optional)
 * WR14	XXXXXXX0	miscellaneous control
 * WR14	XXXSSSSS	commands (optional)
 *
< ASCII >
< ASCII >
 * 2. Enables
 *
 * WR14	000SSSS1	baud rate enable
 * WR3	SSSSSSS1	Rx enable
 * WR5	SSSS1SSS	Tx enable
 * WR0	10000000	reset Tx CRG (optional)
 * WR1	XSS00S00	DMA enable (optional)
 *
< ASCII >
< ASCII >
 * 3. Interrupt status
 *
 * WR15	XXXXXXXX	enable external/status
 * WR0	00010000	reset external status
 * WR0	00010000	reset external status twice
 * WR1	SSSXXSXX	enable Rx, Tx and Ext/status
 * WR9	000SXSSS	enable master interrupt enable
 *
< ASCII >
 * 1 = set to one, 0 = reset to zero
 * X = user defined, S = same as previous init
 *
 *
 * Note that the implementation differs in some points from above scheme.
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_622.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ipa/gsi.c#L26-L87

```c
/**
 * DOC: The IPA Generic Software Interface
 *
 * The generic software interface (GSI) is an integral component of the IPA,
 * providing a well-defined communication layer between the AP subsystem
 * and the IPA core.  The modem uses the GSI layer as well.
 *
< ASCII >
 *	--------	     ---------
 *	|      |	     |	     |
 *	|  AP  +<---.	.----+ Modem |
 *	|      +--. |	| .->+	     |
 *	|      |  | |	| |  |	     |
 *	--------  | |	| |  ---------
 *		  v |	v |
 *		--+-+---+-+--
 *		|    GSI    |
 *		|-----------|
 *		|	    |
 *		|    IPA    |
 *		|	    |
 *		-------------
< ASCII >
 *
 * In the above diagram, the AP and Modem represent "execution environments"
 * (EEs), which are independent operating environments that use the IPA for
 * data transfer.
 *
 * Each EE uses a set of unidirectional GSI "channels," which allow transfer
 * of data to or from the IPA.  A channel is implemented as a ring buffer,
 * with a DRAM-resident array of "transfer elements" (TREs) available to
 * describe transfers to or from other EEs through the IPA.  A transfer
 * element can also contain an immediate command, requesting the IPA perform
 * actions other than data transfer.
 *
 * Each TRE refers to a block of data--also located in DRAM.  After writing
 * one or more TREs to a channel, the writer (either the IPA or an EE) writes
 * a doorbell register to inform the receiving side how many elements have
 * been written.
 *
 * Each channel has a GSI "event ring" associated with it.  An event ring
 * is implemented very much like a channel ring, but is always directed from
 * the IPA to an EE.  The IPA notifies an EE (such as the AP) about channel
 * events by adding an entry to the event ring associated with the channel.
 * The GSI then writes its doorbell for the event ring, causing the target
 * EE to be interrupted.  Each entry in an event ring contains a pointer
 * to the channel TRE whose completion the event represents.
 *
 * Each TRE in a channel ring has a set of flags.  One flag indicates whether
 * the completion of the transfer operation generates an entry (and possibly
 * an interrupt) in the channel's event ring.  Other flags allow transfer
 * elements to be chained together, forming a single logical transaction.
 * TRE flags are used to control whether and when interrupts are generated
 * to signal completion of channel transfers.
 *
 * Elements in channel and event rings are completed (or consumed) strictly
 * in order.  Completion of one entry implies the completion of all preceding
 * entries.  A single completion interrupt can therefore communicate the
 * completion of many transfers.
 *
 * Note that all GSI registers are little-endian, which is the assumed
 * endianness of I/O space accesses.  The accessor functions perform byte
 * swapping if needed (i.e., for a big endian CPU).
 */
```
## Visual type:
- #custom


== ./linux/linux_623.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ipa/ipa_table.c#L27-L120

```c
/**
 * DOC: IPA Filter and Route Tables
 *
 * The IPA has tables defined in its local (IPA-resident) memory that define
 * filter and routing rules.  An entry in either of these tables is a little
 * endian 64-bit "slot" that holds the address of a rule definition.  (The
 * size of these slots is 64 bits regardless of the host DMA address size.)
 *
 * Separate tables (both filter and route) are used for IPv4 and IPv6.  There
 * is normally another set of "hashed" filter and route tables, which are
 * used with a hash of message metadata.  Hashed operation is not supported
 * by all IPA hardware (IPA v4.2 doesn't support hashed tables).
 *
 * Rules can be in local memory or in DRAM (system memory).  The offset of
 * an object (such as a route or filter table) in IPA-resident memory must
 * 128-byte aligned.  An object in system memory (such as a route or filter
 * rule) must be at an 8-byte aligned address.  We currently only place
 * route or filter rules in system memory.
 *
 * A rule consists of a contiguous block of 32-bit values terminated with
 * 32 zero bits.  A special "zero entry" rule consisting of 64 zero bits
 * represents "no filtering" or "no routing," and is the reset value for
 * filter or route table rules.
 *
 * Each filter rule is associated with an AP or modem TX endpoint, though
 * not all TX endpoints support filtering.  The first 64-bit slot in a
 * filter table is a bitmap indicating which endpoints have entries in
 * the table.  Each set bit in this bitmap indicates the presence of the
 * address of a filter rule in the memory following the bitmap.  Until IPA
 * v5.0,  the low-order bit (bit 0) in this bitmap represents a special
 * global filter, which applies to all traffic.  Otherwise the position of
 * each set bit represents an endpoint for which a filter rule is defined.
 *
 * The global rule is not used in current code, and support for it is
 * removed starting at IPA v5.0.  For IPA v5.0+, the endpoint bitmap
 * position defines the endpoint ID--i.e. if bit 1 is set in the endpoint
 * bitmap, endpoint 1 has a filter rule.  Older versions of IPA represent
 * the presence of a filter rule for endpoint X by bit (X + 1) being set.
 * I.e., bit 1 set indicates the presence of a filter rule for endpoint 0,
 * and bit 3 set means there is a filter rule present for endpoint 2.
 *
 * Each filter table entry has the address of a set of equations that
 * implement a filter rule.  So following the endpoint bitmap there
 * will be such an address/entry for each endpoint with a set bit in
 * the bitmap.
 *
 * The AP initializes all entries in a filter table to refer to a "zero"
 * rule.  Once initialized, the modem and AP update the entries for
 * endpoints they "own" directly.  Currently the AP does not use the IPA
 * filtering functionality.
 *
 * This diagram shows an example of a filter table with an endpoint
 * bitmap as defined prior to IPA v5.0.
 *
< ASCII >
 *                    IPA Filter Table
 *                 ----------------------
 * endpoint bitmap | 0x0000000000000048 | Bits 3 and 6 set (endpoints 2 and 5)
 *                 |--------------------|
 * 1st endpoint    | 0x000123456789abc0 | DMA address for modem endpoint 2 rule
 *                 |--------------------|
 * 2nd endpoint    | 0x000123456789abf0 | DMA address for AP endpoint 5 rule
 *                 |--------------------|
 * (unused)        |                    | (Unused space in filter table)
 *                 |--------------------|
 *                          . . .
 *                 |--------------------|
 * (unused)        |                    | (Unused space in filter table)
 *                 ----------------------
< ASCII >
 *
 * The set of available route rules is divided about equally between the AP
 * and modem.  The AP initializes all entries in a route table to refer to
 * a "zero entry".  Once initialized, the modem and AP are responsible for
 * updating their own entries.  All entries in a route table are usable,
 * though the AP currently does not use the IPA routing functionality.
 *
< ASCII >
 *                    IPA Route Table
 *                 ----------------------
 * 1st modem route | 0x0001234500001100 | DMA address for first route rule
 *                 |--------------------|
 * 2nd modem route | 0x0001234500001140 | DMA address for second route rule
 *                 |--------------------|
 *                          . . .
 *                 |--------------------|
 * Last modem route| 0x0001234500002280 | DMA address for Nth route rule
 *                 |--------------------|
 * 1st AP route    | 0x0001234500001100 | DMA address for route rule (N+1)
 *                 |--------------------|
 * 2nd AP route    | 0x0001234500001140 | DMA address for next route rule
 *                 |--------------------|
 *                          . . .
 *                 |--------------------|
 * Last AP route   | 0x0001234500002280 | DMA address for last route rule
 *                 ----------------------
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_624.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/ipa/ipa_table.c#L657-L687

```c
/* Initialize a coherent DMA allocation containing initialized filter and
 * route table data.  This is used when initializing or resetting the IPA
 * filter or route table.
 *
 * The first entry in a filter table contains a bitmap indicating which
 * endpoints contain entries in the table.  In addition to that first entry,
 * there is a fixed maximum number of entries that follow.  Filter table
 * entries are 64 bits wide, and (other than the bitmap) contain the DMA
 * address of a filter rule.  A "zero rule" indicates no filtering, and
 * consists of 64 bits of zeroes.  When a filter table is initialized (or
 * reset) its entries are made to refer to the zero rule.
 *
 * Each entry in a route table is the DMA address of a routing rule.  For
 * routing there is also a 64-bit "zero rule" that means no routing, and
 * when a route table is initialized or reset, its entries are made to refer
 * to the zero rule.  The zero rule is shared for route and filter tables.
 *
< ASCII >
 *	     +-------------------+
 *	 --> |     zero rule     |
 *	/    |-------------------|
 *	|    |     filter mask   |
 *	|\   |-------------------|
 *	| ---- zero rule address | \
 *	|\   |-------------------|  |
 *	| ---- zero rule address |  |	Max IPA filter count
 *	|    |-------------------|   >	or IPA route count,
 *	|	      ...	    |	whichever is greater
 *	 \   |-------------------|  |
 *	  ---- zero rule address | /
 *	     +-------------------+
< ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_625.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/mdio/mdio-i2c.c#L97-L107

```c
/* RollBall SFPs do not access internal PHY via I2C address 0x56, but
 * instead via address 0x51, when SFP page is set to 0x03 and password to
 * 0xffffffff.
 *
< ASCII >
 * address  size  contents  description
 * -------  ----  --------  -----------
 * 0x80     1     CMD       0x01/0x02/0x04 for write/read/done
 * 0x81     1     DEV       Clause 45 device
 * 0x82     2     REG       Clause 45 register
 * 0x84     2     VAL       Register value
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_626.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/phy/linkmode.c#L46-L88

```c
/**
 * linkmode_set_pause - set the pause mode advertisement
 * @advertisement: advertisement in ethtool format
 * @tx: boolean from ethtool struct ethtool_pauseparam tx_pause member
 * @rx: boolean from ethtool struct ethtool_pauseparam rx_pause member
 *
 * Configure the advertised Pause and Asym_Pause bits according to the
 * capabilities of provided in @tx and @rx.
 *
< ASCII >
 * We convert as follows:
 *  tx rx  Pause AsymDir
 *  0  0   0     0
 *  0  1   1     1
 *  1  0   0     1
 *  1  1   1     0
< ASCII >
 *
 * Note: this translation from ethtool tx/rx notation to the advertisement
 * is actually very problematical. Here are some examples:
 *
 * For tx=0 rx=1, meaning transmit is unsupported, receive is supported:
 *
< ASCII >
 *  Local device  Link partner
 *  Pause AsymDir Pause AsymDir Result
 *    1     1       1     0     TX + RX - but we have no TX support.
 *    1     1       0     1	Only this gives RX only
< ASCII >
 *
 * For tx=1 rx=1, meaning we have the capability to transmit and receive
 * pause frames:
 *
 *  Local device  Link partner
 *  Pause AsymDir Pause AsymDir Result
 *    1     0       0     1     Disabled - but since we do support tx and rx,
 *				this should resolve to RX only.
 *
 * Hence, asking for:
 *  rx=1 tx=0 gives Pause+AsymDir advertisement, but we may end up
 *            resolving to tx+rx pause or only rx pause depending on
 *            the partners advertisement.
 *  rx=0 tx=1 gives AsymDir only, which will only give tx pause if
 *            the partners advertisement allows it.
 *  rx=1 tx=1 gives Pause only, which will only allow tx+rx pause
 *            if the other end also advertises Pause.
 */
```
## Visual type:
- #table


== ./linux/linux_627.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/phy/nxp-tja11xx.c#L737-L748

```c
/*
< ASCII >
 * | BI_DA+           | BI_DA-                 | Result
 * | open             | open                   | open
 * | + short to -     | - short to +           | short
 * | short to Vdd     | open                   | open
 * | open             | shot to Vdd            | open
 * | short to Vdd     | short to Vdd           | short
 * | shot to GND      | open                   | open
 * | open             | shot to GND            | open
 * | short to GND     | shot to GND            | short
 * | connected to active link partner (master) | shot and open
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_628.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/wl3501.h#L554-L572

```c
/*
< ASCII >
   Reserve the beginning Tx space for descriptor use.

   TxBlockOffset -->	*----*----*----*----* \
	(TxFreeDesc)	|  0 |  1 |  2 |  3 |  \
			|  4 |  5 |  6 |  7 |   |
			|  8 |  9 | 10 | 11 |   TX_DESC * 20
			| 12 | 13 | 14 | 15 |   |
			| 16 | 17 | 18 | 19 |  /
   TxBufferBegin -->	*----*----*----*----* /
   (TxBufferHead)	| 		    |
   (TxBufferTail)	| 		    |
			|    Send Buffer    |
			| 		    |
			|		    |
			*-------------------*
   TxBufferEnd    -------------------------/
< ASCII >

*/
```
## Visual type:
- #memory-layout


== ./linux/linux_629.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/wl3501_cs.c#L284-L295

```c
/*
< ASCII >
 * Get/Allocate a free Tx Data Buffer
 *
 *  *--------------*-----------------*----------------------------------*
 *  |    PLCP      |    MAC Header   |  DST  SRC         Data ...       |
 *  |  (24 bytes)  |    (30 bytes)   |  (6)  (6)  (Ethernet Row Data)   |
 *  *--------------*-----------------*----------------------------------*
 *  \               \- IEEE 802.11 -/ \-------------- len --------------/
 *   \-struct wl3501_80211_tx_hdr--/   \-------- Ethernet Frame -------/
 *
< ASCII >
 * Return = Position in Card
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_63.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/mm/proc-macros.S#L234-L248

```c
/*
 * Xscale set_pte_ext translation, split into two halves to cope
 * with work-arounds.  r3 must be preserved by code between these
 * two macros.
 *
< ASCII >
 * Permission translation:
 *  YUWD  AP	SVC	User
 *  0xxx  00	no acc	no acc
 *  100x  00	r/o	no acc
 *  10x0  00	r/o	no acc
 *  1011  01	r/w	no acc
 *  110x  10	r/w	r/o
 *  11x0  10	r/w	r/o
 *  1111  11	r/w	r/w
< ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_630.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/hw.c#L26-L117

```c
/**
 * ath_hw_setbssidmask - filter out bssids we listen
 *
 * @common: the ath_common struct for the device.
 *
 * BSSID masking is a method used by AR5212 and newer hardware to inform PCU
 * which bits of the interface's MAC address should be looked at when trying
 * to decide which packets to ACK. In station mode and AP mode with a single
 * BSS every bit matters since we lock to only one BSS. In AP mode with
 * multiple BSSes (virtual interfaces) not every bit matters because hw must
 * accept frames for all BSSes and so we tweak some bits of our mac address
 * in order to have multiple BSSes.
 *
 * NOTE: This is a simple filter and does *not* filter out all
 * relevant frames. Some frames that are not for us might get ACKed from us
 * by PCU because they just match the mask.
 *
 * When handling multiple BSSes you can get the BSSID mask by computing the
 * set of  ~ ( MAC XOR BSSID ) for all bssids we handle.
 *
 * When you do this you are essentially computing the common bits of all your
 * BSSes. Later it is assumed the hardware will "and" (&) the BSSID mask with
 * the MAC address to obtain the relevant bits and compare the result with
 * (frame's BSSID & mask) to see if they match.
 *
 * Simple example: on your card you have two BSSes you have created with
 * BSSID-01 and BSSID-02. Lets assume BSSID-01 will not use the MAC address.
 * There is another BSSID-03 but you are not part of it. For simplicity's sake,
 * assuming only 4 bits for a mac address and for BSSIDs you can then have:
 *
 < ASCII >
 *                  \
 * MAC:        0001 |
 * BSSID-01:   0100 | --> Belongs to us
 * BSSID-02:   1001 |
 *                  /
 * -------------------
 * BSSID-03:   0110  | --> External
 * -------------------
 *
 * Our bssid_mask would then be:
 *
 *             On loop iteration for BSSID-01:
 *             ~(0001 ^ 0100)  -> ~(0101)
 *                             ->   1010
 *             bssid_mask      =    1010
 *
 *             On loop iteration for BSSID-02:
 *             bssid_mask &= ~(0001   ^   1001)
 *             bssid_mask =   (1010)  & ~(0001 ^ 1001)
 *             bssid_mask =   (1010)  & ~(1000)
 *             bssid_mask =   (1010)  &  (0111)
 *             bssid_mask =   0010
 < ASCII >
 *
 * A bssid_mask of 0010 means "only pay attention to the second least
 * significant bit". This is because its the only bit common
 * amongst the MAC and all BSSIDs we support. To findout what the real
 * common bit is we can simply "&" the bssid_mask now with any BSSID we have
 * or our MAC address (we assume the hardware uses the MAC address).
 *
 * Now, suppose there's an incoming frame for BSSID-03:
 *
 * IFRAME-01:  0110
 *
 * An easy eye-inspeciton of this already should tell you that this frame
 * will not pass our check. This is because the bssid_mask tells the
 * hardware to only look at the second least significant bit and the
 * common bit amongst the MAC and BSSIDs is 0, this frame has the 2nd LSB
 * as 1, which does not match 0.
 *
 < ASCII >
 * So with IFRAME-01 we *assume* the hardware will do:
 *
 *     allow = (IFRAME-01 & bssid_mask) == (bssid_mask & MAC) ? 1 : 0;
 *  --> allow = (0110 & 0010) == (0010 & 0001) ? 1 : 0;
 *  --> allow = (0010) == 0000 ? 1 : 0;
 *  --> allow = 0
 *
 *  Lets now test a frame that should work:
 *
 * IFRAME-02:  0001 (we should allow)
 *
 *     allow = (IFRAME-02 & bssid_mask) == (bssid_mask & MAC) ? 1 : 0;
 *  --> allow = (0001 & 0010) ==  (0010 & 0001) ? 1 :0;
 *  --> allow = (0000) == (0000)
 *  --> allow = 1
 *
 * Other examples:
 *
 * IFRAME-03:  0100 --> allowed
 * IFRAME-04:  1001 --> allowed
 * IFRAME-05:  1101 --> allowed but its not for us!!!
 < ASCII >
 *
 */
```
## Visual type:



== ./linux/linux_631.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/ath10k/htt.h#L909-L977

```c
/**
 * @brief target -> host TX completion indication message definition
 *
 * @details
 * The following diagram shows the format of the TX completion indication sent
 * from the target to the host
 < ASCII >
 *
 *          |31 28|27|26|25|24|23        16| 15 |14 11|10   8|7          0|
 *          |-------------------------------------------------------------|
 * header:  |rsvd |A2|TP|A1|A0|     num    | t_i| tid |status|  msg_type  |
 *          |-------------------------------------------------------------|
 * payload: |            MSDU1 ID          |         MSDU0 ID             |
 *          |-------------------------------------------------------------|
 *          :            MSDU3 ID          :         MSDU2 ID             :
 *          |-------------------------------------------------------------|
 *          |          struct htt_tx_compl_ind_append_retries             |
 *          |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -|
 *          |          struct htt_tx_compl_ind_append_tx_tstamp           |
 *          |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -|
 *          |           MSDU1 ACK RSSI     |        MSDU0 ACK RSSI        |
 *          |-------------------------------------------------------------|
 *          :           MSDU3 ACK RSSI     :        MSDU2 ACK RSSI        :
 *          |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -|
 < ASCII >
 *    -msg_type
 *     Bits 7:0
 *     Purpose: identifies this as HTT TX completion indication
 *    -status
 *     Bits 10:8
 *     Purpose: the TX completion status of payload fragmentations descriptors
 *     Value: could be HTT_TX_COMPL_IND_STAT_OK or HTT_TX_COMPL_IND_STAT_DISCARD
 *    -tid
 *     Bits 14:11
 *     Purpose: the tid associated with those fragmentation descriptors. It is
 *     valid or not, depending on the tid_invalid bit.
 *     Value: 0 to 15
 *    -tid_invalid
 *     Bits 15:15
 *     Purpose: this bit indicates whether the tid field is valid or not
 *     Value: 0 indicates valid, 1 indicates invalid
 *    -num
 *     Bits 23:16
 *     Purpose: the number of payload in this indication
 *     Value: 1 to 255
 *    -A0 = append
 *     Bits 24:24
 *     Purpose: append the struct htt_tx_compl_ind_append_retries which contains
 *            the number of tx retries for one MSDU at the end of this message
 *     Value: 0 indicates no appending, 1 indicates appending
 *    -A1 = append1
 *     Bits 25:25
 *     Purpose: Append the struct htt_tx_compl_ind_append_tx_tstamp which
 *            contains the timestamp info for each TX msdu id in payload.
 *     Value: 0 indicates no appending, 1 indicates appending
 *    -TP = MSDU tx power presence
 *     Bits 26:26
 *     Purpose: Indicate whether the TX_COMPL_IND includes a tx power report
 *            for each MSDU referenced by the TX_COMPL_IND message.
 *            The order of the per-MSDU tx power reports matches the order
 *            of the MSDU IDs.
 *     Value: 0 indicates not appending, 1 indicates appending
 *    -A2 = append2
 *     Bits 27:27
 *     Purpose: Indicate whether data ACK RSSI is appended for each MSDU in
 *            TX_COMP_IND message.  The order of the per-MSDU ACK RSSI report
 *            matches the order of the MSDU IDs.
 *            The ACK RSSI values are valid when status is COMPLETE_OK (and
 *            this append2 bit is set).
 *     Value: 0 indicates not appending, 1 indicates appending
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_632.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/ath10k/htt.h#L1125-L1158

```c
/*
 * target -> host test message definition
 *
 * The following field definitions describe the format of the test
 * message sent from the target to the host.
 * The message consists of a 4-octet header, followed by a variable
 * number of 32-bit integer values, followed by a variable number
 * of 8-bit character values.
 *
 < ASCII >
 * |31                         16|15           8|7            0|
 * |-----------------------------------------------------------|
 * |          num chars          |   num ints   |   msg type   |
 * |-----------------------------------------------------------|
 * |                           int 0                           |
 * |-----------------------------------------------------------|
 * |                           int 1                           |
 * |-----------------------------------------------------------|
 * |                            ...                            |
 * |-----------------------------------------------------------|
 * |    char 3    |    char 2    |    char 1    |    char 0    |
 * |-----------------------------------------------------------|
 * |              |              |      ...     |    char 4    |
 * |-----------------------------------------------------------|
 < ASCII >
 *   - MSG_TYPE
 *     Bits 7:0
 *     Purpose: identifies this as a test message
 *     Value: HTT_MSG_TYPE_TEST
 *   - NUM_INTS
 *     Bits 15:8
 *     Purpose: indicate how many 32-bit integers follow the message header
 *   - NUM_CHARS
 *     Bits 31:16
 *     Purpose: indicate how many 8-bit characters follow the series of integers
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_633.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/ath10k/htt.h#L1180-L1198

```c
/*
 * target -> host packet log message
 *
 * The following field definitions describe the format of the packet log
 * message sent from the target to the host.
 * The message consists of a 4-octet header,followed by a variable number
 * of 32-bit character values.
 *
 < ASCII >
 * |31          24|23          16|15           8|7            0|
 * |-----------------------------------------------------------|
 * |              |              |              |   msg type   |
 * |-----------------------------------------------------------|
 * |                        payload                            |
 * |-----------------------------------------------------------|
 < ASCII >
 *   - MSG_TYPE
 *     Bits 7:0
 *     Purpose: identifies this as a test message
 *     Value: HTT_MSG_TYPE_PACKETLOG
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_634.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/ath10k/htt.h#L1399-L1447

```c
/*
 * host -> target FRAG DESCRIPTOR/MSDU_EXT DESC bank
 *
 * The following field definitions describe the format of the HTT host
 * to target frag_desc/msdu_ext bank configuration message.
 * The message contains the based address and the min and max id of the
 * MSDU_EXT/FRAG_DESC that will be used by the HTT to map MSDU DESC and
 * MSDU_EXT/FRAG_DESC.
 * HTT will use id in HTT descriptor instead sending the frag_desc_ptr.
 * For QCA988X HW the firmware will use fragment_desc_ptr but in WIFI2.0
 * the hardware does the mapping/translation.
 *
 * Total banks that can be configured is configured to 16.
 *
 * This should be called before any TX has be initiated by the HTT
 *
 < ASCII >
 * |31                         16|15           8|7   5|4       0|
 * |------------------------------------------------------------|
 * | DESC_SIZE    |  NUM_BANKS   | RES |SWP|pdev|    msg type   |
 * |------------------------------------------------------------|
 * |                     BANK0_BASE_ADDRESS                     |
 * |------------------------------------------------------------|
 * |                            ...                             |
 * |------------------------------------------------------------|
 * |                    BANK15_BASE_ADDRESS                     |
 * |------------------------------------------------------------|
 * |       BANK0_MAX_ID          |       BANK0_MIN_ID           |
 * |------------------------------------------------------------|
 * |                            ...                             |
 * |------------------------------------------------------------|
 * |       BANK15_MAX_ID         |       BANK15_MIN_ID          |
 * |------------------------------------------------------------|
 < ASCII >
 * Header fields:
 *  - MSG_TYPE
 *    Bits 7:0
 *    Value: 0x6
 *  - BANKx_BASE_ADDRESS
 *    Bits 31:0
 *    Purpose: Provide a mechanism to specify the base address of the MSDU_EXT
 *         bank physical/bus address.
 *  - BANKx_MIN_ID
 *    Bits 15:0
 *    Purpose: Provide a mechanism to specify the min index that needs to
 *          mapped.
 *  - BANKx_MAX_ID
 *    Bits 31:16
 *    Purpose: Provide a mechanism to specify the max index that needs to
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_635.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/ath10k/targaddrs.h#L277-L284

```c
/*
 * Fw Mode/SubMode Mask
 < ASCII >
 *-----------------------------------------------------------------------------
 *  SUB   |   SUB   |   SUB   |  SUB    |         |         |         |
 *MODE[3] | MODE[2] | MODE[1] | MODE[0] | MODE[3] | MODE[2] | MODE[1] | MODE[0]
 *  (2)   |   (2)   |   (2)   |   (2)   |   (2)   |   (2)   |   (2)   |   (2)
 *-----------------------------------------------------------------------------
 < ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_636.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/ath10k/wow.c#L69-L79

```c
/*
 * Convert a 802.3 format to a 802.11 format.
 < ASCII >
 *         +------------+-----------+--------+----------------+
 * 802.3:  |dest mac(6B)|src mac(6B)|type(2B)|     body...    |
 *         +------------+-----------+--------+----------------+
 *                |__         |_______    |____________  |________
 *                   |                |                |          |
 *         +--+------------+----+-----------+---------------+-----------+
 * 802.11: |4B|dest mac(6B)| 6B |src mac(6B)|  8B  |type(2B)|  body...  |
 *         +--+------------+----+-----------+---------------+-----------+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_637.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/ath11k/dp.h#L352-L477

```c
/* host -> target  HTT_SRING_SETUP message
 *
 * After target is booted up, Host can send SRING setup message for
 * each host facing LMAC SRING. Target setups up HW registers based
 * on setup message and confirms back to Host if response_required is set.
 * Host should wait for confirmation message before sending new SRING
 * setup message
 *
 * The message would appear as follows:
 < ASCII >
 *
 * |31            24|23    20|19|18 16|15|14          8|7                0|
 * |--------------- +-----------------+----------------+------------------|
 * |    ring_type   |      ring_id    |    pdev_id     |     msg_type     |
 * |----------------------------------------------------------------------|
 * |                          ring_base_addr_lo                           |
 * |----------------------------------------------------------------------|
 * |                         ring_base_addr_hi                            |
 * |----------------------------------------------------------------------|
 * |ring_misc_cfg_flag|ring_entry_size|            ring_size              |
 * |----------------------------------------------------------------------|
 * |                         ring_head_offset32_remote_addr_lo            |
 * |----------------------------------------------------------------------|
 * |                         ring_head_offset32_remote_addr_hi            |
 * |----------------------------------------------------------------------|
 * |                         ring_tail_offset32_remote_addr_lo            |
 * |----------------------------------------------------------------------|
 * |                         ring_tail_offset32_remote_addr_hi            |
 * |----------------------------------------------------------------------|
 * |                          ring_msi_addr_lo                            |
 * |----------------------------------------------------------------------|
 * |                          ring_msi_addr_hi                            |
 * |----------------------------------------------------------------------|
 * |                          ring_msi_data                               |
 * |----------------------------------------------------------------------|
 * |         intr_timer_th            |IM|      intr_batch_counter_th     |
 * |----------------------------------------------------------------------|
 * |          reserved        |RR|PTCF|        intr_low_threshold         |
 * |----------------------------------------------------------------------|
 < ASCII >
 * Where
 *     IM = sw_intr_mode
 *     RR = response_required
 *     PTCF = prefetch_timer_cfg
 *
 * The message is interpreted as follows:
 * dword0  - b'0:7   - msg_type: This will be set to
 *                     HTT_H2T_MSG_TYPE_SRING_SETUP
 *           b'8:15  - pdev_id:
 *                     0 (for rings at SOC/UMAC level),
 *                     1/2/3 mac id (for rings at LMAC level)
 *           b'16:23 - ring_id: identify which ring is to setup,
 *                     more details can be got from enum htt_srng_ring_id
 *           b'24:31 - ring_type: identify type of host rings,
 *                     more details can be got from enum htt_srng_ring_type
 * dword1  - b'0:31  - ring_base_addr_lo: Lower 32bits of ring base address
 * dword2  - b'0:31  - ring_base_addr_hi: Upper 32bits of ring base address
 * dword3  - b'0:15  - ring_size: size of the ring in unit of 4-bytes words
 *           b'16:23 - ring_entry_size: Size of each entry in 4-byte word units
 *           b'24:31 - ring_misc_cfg_flag: Valid only for HW_TO_SW_RING and
 *                     SW_TO_HW_RING.
 *                     Refer to HTT_SRING_SETUP_RING_MISC_CFG_RING defs.
 * dword4  - b'0:31  - ring_head_off32_remote_addr_lo:
 *                     Lower 32 bits of memory address of the remote variable
 *                     storing the 4-byte word offset that identifies the head
 *                     element within the ring.
 *                     (The head offset variable has type u32.)
 *                     Valid for HW_TO_SW and SW_TO_SW rings.
 * dword5  - b'0:31  - ring_head_off32_remote_addr_hi:
 *                     Upper 32 bits of memory address of the remote variable
 *                     storing the 4-byte word offset that identifies the head
 *                     element within the ring.
 *                     (The head offset variable has type u32.)
 *                     Valid for HW_TO_SW and SW_TO_SW rings.
 * dword6  - b'0:31  - ring_tail_off32_remote_addr_lo:
 *                     Lower 32 bits of memory address of the remote variable
 *                     storing the 4-byte word offset that identifies the tail
 *                     element within the ring.
 *                     (The tail offset variable has type u32.)
 *                     Valid for HW_TO_SW and SW_TO_SW rings.
 * dword7  - b'0:31  - ring_tail_off32_remote_addr_hi:
 *                     Upper 32 bits of memory address of the remote variable
 *                     storing the 4-byte word offset that identifies the tail
 *                     element within the ring.
 *                     (The tail offset variable has type u32.)
 *                     Valid for HW_TO_SW and SW_TO_SW rings.
 * dword8  - b'0:31  - ring_msi_addr_lo: Lower 32bits of MSI cfg address
 *                     valid only for HW_TO_SW_RING and SW_TO_HW_RING
 * dword9  - b'0:31  - ring_msi_addr_hi: Upper 32bits of MSI cfg address
 *                     valid only for HW_TO_SW_RING and SW_TO_HW_RING
 * dword10 - b'0:31  - ring_msi_data: MSI data
 *                     Refer to HTT_SRING_SETUP_RING_MSC_CFG_xxx defs
 *                     valid only for HW_TO_SW_RING and SW_TO_HW_RING
 * dword11 - b'0:14  - intr_batch_counter_th:
 *                     batch counter threshold is in units of 4-byte words.
 *                     HW internally maintains and increments batch count.
 *                     (see SRING spec for detail description).
 *                     When batch count reaches threshold value, an interrupt
 *                     is generated by HW.
 *           b'15    - sw_intr_mode:
 *                     This configuration shall be static.
 *                     Only programmed at power up.
 *                     0: generate pulse style sw interrupts
 *                     1: generate level style sw interrupts
 *           b'16:31 - intr_timer_th:
 *                     The timer init value when timer is idle or is
 *                     initialized to start downcounting.
 *                     In 8us units (to cover a range of 0 to 524 ms)
 * dword12 - b'0:15  - intr_low_threshold:
 *                     Used only by Consumer ring to generate ring_sw_int_p.
 *                     Ring entries low threshold water mark, that is used
 *                     in combination with the interrupt timer as well as
 *                     the clearing of the level interrupt.
 *           b'16:18 - prefetch_timer_cfg:
 *                     Used only by Consumer ring to set timer mode to
 *                     support Application prefetch handling.
 *                     The external tail offset/pointer will be updated
 *                     at following intervals:
 *                     3'b000: (Prefetch feature disabled; used only for debug)
 *                     3'b001: 1 usec
 *                     3'b010: 4 usec
 *                     3'b011: 8 usec (default)
 *                     3'b100: 16 usec
 *                     Others: Reserved
 *           b'19    - response_required:
 *                     Host needs HTT_T2H_MSG_TYPE_SRING_SETUP_DONE as response
 *           b'20:31 - reserved:  reserved for future use
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_638.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/ath11k/dp.h#L515-L546

```c
/* host -> target FW  PPDU_STATS config message
 *
 * @details
 * The following field definitions describe the format of the HTT host
 * to target FW for PPDU_STATS_CFG msg.
 * The message allows the host to configure the PPDU_STATS_IND messages
 * produced by the target.
 *
 < ASCII >
 * |31          24|23          16|15           8|7            0|
 * |-----------------------------------------------------------|
 * |    REQ bit mask             |   pdev_mask  |   msg type   |
 * |-----------------------------------------------------------|
 < ASCII >
 * Header fields:
 *  - MSG_TYPE
 *    Bits 7:0
 *    Purpose: identifies this is a req to configure ppdu_stats_ind from target
 *    Value: 0x11
 *  - PDEV_MASK
 *    Bits 8:15
 *    Purpose: identifies which pdevs this PPDU stats configuration applies to
 *    Value: This is a overloaded field, refer to usage and interpretation of
 *           PDEV in interface document.
 *           Bit   8    :  Reserved for SOC stats
 *           Bit 9 - 15 :  Indicates PDEV_MASK in DBDC
 *                         Indicates MACID_MASK in DBS
 *  - REQ_TLV_BIT_MASK
 *    Bits 16:31
 *    Purpose: each set bit indicates the corresponding PPDU stats TLV type
 *        needs to be included in the target's PPDU_STATS_IND messages.
 *    Value: refer htt_ppdu_stats_tlv_tag_t <<<???
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_639.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/ath11k/dp.h#L594-L662

```c
/* HTT_H2T_MSG_TYPE_RX_RING_SELECTION_CFG Message
 *
 * details:
 *    HTT_H2T_MSG_TYPE_RX_RING_SELECTION_CFG message is sent by host to
 *    configure RXDMA rings.
 *    The configuration is per ring based and includes both packet subtypes
 *    and PPDU/MPDU TLVs.
 *
 *    The message would appear as follows:
 < ASCII >
 *
 *    |31       26|25|24|23            16|15             8|7             0|
 *    |-----------------+----------------+----------------+---------------|
 *    |   rsvd1   |PS|SS|     ring_id    |     pdev_id    |    msg_type   |
 *    |-------------------------------------------------------------------|
 *    |              rsvd2               |           ring_buffer_size     |
 *    |-------------------------------------------------------------------|
 *    |                        packet_type_enable_flags_0                 |
 *    |-------------------------------------------------------------------|
 *    |                        packet_type_enable_flags_1                 |
 *    |-------------------------------------------------------------------|
 *    |                        packet_type_enable_flags_2                 |
 *    |-------------------------------------------------------------------|
 *    |                        packet_type_enable_flags_3                 |
 *    |-------------------------------------------------------------------|
 *    |                         tlv_filter_in_flags                       |
 *    |-------------------------------------------------------------------|
 < ASCII >
 * Where:
 *     PS = pkt_swap
 *     SS = status_swap
 * The message is interpreted as follows:
 * dword0 - b'0:7   - msg_type: This will be set to
 *                    HTT_H2T_MSG_TYPE_RX_RING_SELECTION_CFG
 *          b'8:15  - pdev_id:
 *                    0 (for rings at SOC/UMAC level),
 *                    1/2/3 mac id (for rings at LMAC level)
 *          b'16:23 - ring_id : Identify the ring to configure.
 *                    More details can be got from enum htt_srng_ring_id
 *          b'24    - status_swap: 1 is to swap status TLV
 *          b'25    - pkt_swap:  1 is to swap packet TLV
 *          b'26:31 - rsvd1:  reserved for future use
 * dword1 - b'0:16  - ring_buffer_size: size of bufferes referenced by rx ring,
 *                    in byte units.
 *                    Valid only for HW_TO_SW_RING and SW_TO_HW_RING
 *        - b'16:31 - rsvd2: Reserved for future use
 * dword2 - b'0:31  - packet_type_enable_flags_0:
 *                    Enable MGMT packet from 0b0000 to 0b1001
 *                    bits from low to high: FP, MD, MO - 3 bits
 *                        FP: Filter_Pass
 *                        MD: Monitor_Direct
 *                        MO: Monitor_Other
 *                    10 mgmt subtypes * 3 bits -> 30 bits
 *                    Refer to PKT_TYPE_ENABLE_FLAG0_xxx_MGMT_xxx defs
 * dword3 - b'0:31  - packet_type_enable_flags_1:
 *                    Enable MGMT packet from 0b1010 to 0b1111
 *                    bits from low to high: FP, MD, MO - 3 bits
 *                    Refer to PKT_TYPE_ENABLE_FLAG1_xxx_MGMT_xxx defs
 * dword4 - b'0:31 -  packet_type_enable_flags_2:
 *                    Enable CTRL packet from 0b0000 to 0b1001
 *                    bits from low to high: FP, MD, MO - 3 bits
 *                    Refer to PKT_TYPE_ENABLE_FLAG2_xxx_CTRL_xxx defs
 * dword5 - b'0:31  - packet_type_enable_flags_3:
 *                    Enable CTRL packet from 0b1010 to 0b1111,
 *                    MCAST_DATA, UCAST_DATA, NULL_DATA
 *                    bits from low to high: FP, MD, MO - 3 bits
 *                    Refer to PKT_TYPE_ENABLE_FLAG3_xxx_CTRL_xxx defs
 * dword6 - b'0:31 -  tlv_filter_in_flags:
 *                    Filter in Attention/MPDU/PPDU/Header/User tlvs
 *                    Refer to CFG_TLV_FILTER_IN_FLAG defs
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_64.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/net/bpf_jit_32.c#L26-L76

```c
/*
 * eBPF prog stack layout:
 < ASCII >
 *
 *                         high
 * original ARM_SP =>     +-----+
 *                        |     | callee saved registers
 *                        +-----+ <= (BPF_FP + SCRATCH_SIZE)
 *                        | ... | eBPF JIT scratch space
 * eBPF fp register =>    +-----+
 *   (BPF_FP)             | ... | eBPF prog stack
 *                        +-----+
 *                        |RSVD | JIT scratchpad
 * current ARM_SP =>      +-----+ <= (BPF_FP - STACK_SIZE + SCRATCH_SIZE)
 *                        | ... | caller-saved registers
 *                        +-----+
 *                        | ... | arguments passed on stack
 * ARM_SP during call =>  +-----|
 *                        |     |
 *                        | ... | Function call stack
 *                        |     |
 *                        +-----+
 *                          low
 < ASCII >
 *
 * The callee saved registers depends on whether frame pointers are enabled.
 < ASCII >
 * With frame pointers (to be compliant with the ABI):
 *
 *                              high
 * original ARM_SP =>     +--------------+ \
 *                        |      pc      | |
 * current ARM_FP =>      +--------------+ } callee saved registers
 *                        |r4-r9,fp,ip,lr| |
 *                        +--------------+ /
 *                              low
 *
 * Without frame pointers:
 *
 *                              high
 * original ARM_SP =>     +--------------+
 *                        |  r4-r9,fp,lr | callee saved registers
 * current ARM_FP =>      +--------------+
 *                              low
 < ASCII >
 *
 * When popping registers off the stack at the end of a BPF function, we
 * reference them via the current ARM_FP register.
 *
 * Some eBPF operations are implemented via a call to a helper function.
 * Such calls are "invisible" in the eBPF code, so it is up to the calling
 * program to preserve any caller-saved ARM registers during the call. The
 * JIT emits code to push and pop those registers onto the stack, immediately
 * above the callee stack frame.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_640.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/ath11k/dp.h#L1129-L1169

```c
/* ppdu stats
 *
 * @details
 * The following field definitions describe the format of the HTT target
 * to host ppdu stats indication message.
 *
 *
 < ASCII >
 * |31                         16|15   12|11   10|9      8|7            0 |
 * |----------------------------------------------------------------------|
 * |    payload_size             | rsvd  |pdev_id|mac_id  |    msg type   |
 * |----------------------------------------------------------------------|
 * |                          ppdu_id                                     |
 * |----------------------------------------------------------------------|
 * |                        Timestamp in us                               |
 * |----------------------------------------------------------------------|
 * |                          reserved                                    |
 * |----------------------------------------------------------------------|
 * |                    type-specific stats info                          |
 * |                     (see htt_ppdu_stats.h)                           |
 * |----------------------------------------------------------------------|
 < ASCII >
 * Header fields:
 *  - MSG_TYPE
 *    Bits 7:0
 *    Purpose: Identifies this is a PPDU STATS indication
 *             message.
 *    Value: 0x1d
 *  - mac_id
 *    Bits 9:8
 *    Purpose: mac_id of this ppdu_id
 *    Value: 0-3
 *  - pdev_id
 *    Bits 11:10
 *    Purpose: pdev_id of this ppdu_id
 *    Value: 0-3
 *     0 (for rings at SOC level),
 *     1/2/3 PDEV -> 0/1/2
 *  - payload_size
 *    Bits 31:16
 *    Purpose: total tlv size
 *    Value: payload_size in bytes
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_641.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/ath11k/dp.h#L1397-L1429

```c
/* @brief target -> host packet log message
 *
 * @details
 * The following field definitions describe the format of the packet log
 * message sent from the target to the host.
 * The message consists of a 4-octet header,followed by a variable number
 * of 32-bit character values.
 *
 < ASCII >
 * |31                         16|15  12|11   10|9    8|7            0|
 * |------------------------------------------------------------------|
 * |        payload_size         | rsvd |pdev_id|mac_id|   msg type   |
 * |------------------------------------------------------------------|
 * |                              payload                             |
 * |------------------------------------------------------------------|
 < ASCII >
 *   - MSG_TYPE
 *     Bits 7:0
 *     Purpose: identifies this as a pktlog message
 *     Value: HTT_T2H_MSG_TYPE_PKTLOG
 *   - mac_id
 *     Bits 9:8
 *     Purpose: identifies which MAC/PHY instance generated this pktlog info
 *     Value: 0-3
 *   - pdev_id
 *     Bits 11:10
 *     Purpose: pdev_id
 *     Value: 0-3
 *     0 (for rings at SOC level),
 *     1/2/3 PDEV -> 0/1/2
 *   - payload_size
 *     Bits 31:16
 *     Purpose: explicitly specify the payload size
 *     Value: payload size in bytes (payload size is a multiple of 4 bytes)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_642.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/ath11k/dp.h#L1435-L1510

```c
/* @brief host -> target FW extended statistics retrieve
 *
 * @details
 * The following field definitions describe the format of the HTT host
 * to target FW extended stats retrieve message.
 * The message specifies the type of stats the host wants to retrieve.
 *
 < ASCII >
 * |31          24|23          16|15           8|7            0|
 * |-----------------------------------------------------------|
 * |   reserved   | stats type   |   pdev_mask  |   msg type   |
 * |-----------------------------------------------------------|
 * |                   config param [0]                        |
 * |-----------------------------------------------------------|
 * |                   config param [1]                        |
 * |-----------------------------------------------------------|
 * |                   config param [2]                        |
 * |-----------------------------------------------------------|
 * |                   config param [3]                        |
 * |-----------------------------------------------------------|
 * |                         reserved                          |
 * |-----------------------------------------------------------|
 * |                        cookie LSBs                        |
 * |-----------------------------------------------------------|
 * |                        cookie MSBs                        |
 * |-----------------------------------------------------------|
 < ASCII >
 * Header fields:
 *  - MSG_TYPE
 *    Bits 7:0
 *    Purpose: identifies this is a extended stats upload request message
 *    Value: 0x10
 *  - PDEV_MASK
 *    Bits 8:15
 *    Purpose: identifies the mask of PDEVs to retrieve stats from
 *    Value: This is a overloaded field, refer to usage and interpretation of
 *           PDEV in interface document.
 *           Bit   8    :  Reserved for SOC stats
 *           Bit 9 - 15 :  Indicates PDEV_MASK in DBDC
 *                         Indicates MACID_MASK in DBS
 *  - STATS_TYPE
 *    Bits 23:16
 *    Purpose: identifies which FW statistics to upload
 *    Value: Defined by htt_dbg_ext_stats_type (see htt_stats.h)
 *  - Reserved
 *    Bits 31:24
 *  - CONFIG_PARAM [0]
 *    Bits 31:0
 *    Purpose: give an opaque configuration value to the specified stats type
 *    Value: stats-type specific configuration value
 *           Refer to htt_stats.h for interpretation for each stats sub_type
 *  - CONFIG_PARAM [1]
 *    Bits 31:0
 *    Purpose: give an opaque configuration value to the specified stats type
 *    Value: stats-type specific configuration value
 *           Refer to htt_stats.h for interpretation for each stats sub_type
 *  - CONFIG_PARAM [2]
 *    Bits 31:0
 *    Purpose: give an opaque configuration value to the specified stats type
 *    Value: stats-type specific configuration value
 *           Refer to htt_stats.h for interpretation for each stats sub_type
 *  - CONFIG_PARAM [3]
 *    Bits 31:0
 *    Purpose: give an opaque configuration value to the specified stats type
 *    Value: stats-type specific configuration value
 *           Refer to htt_stats.h for interpretation for each stats sub_type
 *  - Reserved [31:0] for future use.
 *  - COOKIE_LSBS
 *    Bits 31:0
 *    Purpose: Provide a mechanism to match a target->host stats confirmation
 *        message with its preceding host->target stats request message.
 *    Value: LSBs of the opaque cookie specified by the host-side requestor
 *  - COOKIE_MSBS
 *    Bits 31:0
 *    Purpose: Provide a mechanism to match a target->host stats confirmation
 *        message with its preceding host->target stats request message.
 *    Value: MSBs of the opaque cookie specified by the host-side requestor
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_643.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/ath11k/dp.h#L1570-L1642

```c
/* @brief target -> host extended statistics upload
 *
 * @details
 * The following field definitions describe the format of the HTT target
 * to host stats upload confirmation message.
 * The message contains a cookie echoed from the HTT host->target stats
 * upload request, which identifies which request the confirmation is
 * for, and a single stats can span over multiple HTT stats indication
 * due to the HTT message size limitation so every HTT ext stats indication
 * will have tag-length-value stats information elements.
 * The tag-length header for each HTT stats IND message also includes a
 * status field, to indicate whether the request for the stat type in
 * question was fully met, partially met, unable to be met, or invalid
 * (if the stat type in question is disabled in the target).
 * A Done bit 1's indicate the end of the of stats info elements.
 *
 *
 < ASCII >
 * |31                         16|15    12|11|10 8|7   5|4       0|
 * |--------------------------------------------------------------|
 * |                   reserved                   |    msg type   |
 * |--------------------------------------------------------------|
 * |                         cookie LSBs                          |
 * |--------------------------------------------------------------|
 * |                         cookie MSBs                          |
 * |--------------------------------------------------------------|
 * |      stats entry length     | rsvd   | D|  S |   stat type   |
 * |--------------------------------------------------------------|
 * |                   type-specific stats info                   |
 * |                      (see htt_stats.h)                       |
 * |--------------------------------------------------------------|
 < ASCII >
 * Header fields:
 *  - MSG_TYPE
 *    Bits 7:0
 *    Purpose: Identifies this is a extended statistics upload confirmation
 *             message.
 *    Value: 0x1c
 *  - COOKIE_LSBS
 *    Bits 31:0
 *    Purpose: Provide a mechanism to match a target->host stats confirmation
 *        message with its preceding host->target stats request message.
 *    Value: LSBs of the opaque cookie specified by the host-side requestor
 *  - COOKIE_MSBS
 *    Bits 31:0
 *    Purpose: Provide a mechanism to match a target->host stats confirmation
 *        message with its preceding host->target stats request message.
 *    Value: MSBs of the opaque cookie specified by the host-side requestor
 *
 * Stats Information Element tag-length header fields:
 *  - STAT_TYPE
 *    Bits 7:0
 *    Purpose: identifies the type of statistics info held in the
 *        following information element
 *    Value: htt_dbg_ext_stats_type
 *  - STATUS
 *    Bits 10:8
 *    Purpose: indicate whether the requested stats are present
 *    Value: htt_dbg_ext_stats_status
 *  - DONE
 *    Bits 11
 *    Purpose:
 *        Indicates the completion of the stats entry, this will be the last
 *        stats conf HTT segment for the requested stats type.
 *    Value:
 *        0 -> the stats retrieval is ongoing
 *        1 -> the stats retrieval is complete
 *  - LENGTH
 *    Bits 31:16
 *    Purpose: indicate the stats information size
 *    Value: This field specifies the number of bytes of stats information
 *       that follows the element tag-length header.
 *       It is expected but not required that this length is a multiple of
 *       4 bytes.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_644.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/ath6kl/target.h#L319-L325

```c
/* Fw Mode/SubMode Mask
 < ASCII >
|------------------------------------------------------------------------------|
|   SUB   |   SUB   |   SUB   |  SUB    |         |         |         |
| MODE[3] | MODE[2] | MODE[1] | MODE[0] | MODE[3] | MODE[2] | MODE[1] | MODE[0|
|   (2)   |   (2)   |   (2)   |   (2)   |   (2)   |   (2)   |   (2)   |   (2)
|------------------------------------------------------------------------------|
 < ASCII >
*/
```
## Visual type:
- #custom


== ./linux/linux_645.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/wil6210/wil6210.h#L148-L156

```c
/*
 < ASCII >
 * Mapping
 * RGF File      | Host addr    |  FW addr
 *               |              |
 * user_rgf      | 0x000000     | 0x880000
 *  dma_rgf      | 0x001000     | 0x881000
 * pcie_rgf      | 0x002000     | 0x882000
 *               |              |
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_646.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/wil6210/wmi.c#L69-L78

```c
/* sparrow_fw_mapping provides memory remapping table for sparrow
 *
 * array size should be in sync with the declaration in the wil6210.h
 *
 < ASCII >
 * Sparrow memory mapping:
 * Linker address         PCI/Host address
 *                        0x880000 .. 0xa80000  2Mb BAR0
 * 0x800000 .. 0x808000   0x900000 .. 0x908000  32k DCCM
 * 0x840000 .. 0x860000   0x908000 .. 0x928000  128k PERIPH
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_647.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ath/wil6210/wmi.c#L112-L121

```c
/* talyn_fw_mapping provides memory remapping table for Talyn
 *
 * array size should be in sync with the declaration in the wil6210.h
 *
 < ASCII >
 * Talyn memory mapping:
 * Linker address         PCI/Host address
 *                        0x880000 .. 0xc80000  4Mb BAR0
 * 0x800000 .. 0x820000   0xa00000 .. 0xa20000  128k DCCM
 * 0x840000 .. 0x858000   0xa20000 .. 0xa38000  96k PERIPH
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_648.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/broadcom/brcm80211/brcmsmac/main.c#L1308-L1318

```c
/* set or clear ucode host flag bits
 * it has an optimization for no-change write
 * it only writes through shared memory when the core has clock;
 * pre-CLK changes should use wlc_write_mhf to get around the optimization
 *
 *
 < ASCII >
 * bands values are: BRCM_BAND_AUTO <--- Current band only
 *                   BRCM_BAND_5G   <--- 5G band only
 *                   BRCM_BAND_2G   <--- 2G band only
 *                   BRCM_BAND_ALL  <--- All bands
 < ASCII >
 */
```
## Visual type:



== ./linux/linux_649.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/broadcom/brcm80211/brcmsmac/main.c#L1454-L1460

```c
/* When driver needs ucode to stop beaconing, it has to make sure that
 * MCTL_AP is clear and MCTL_INFRA is set
 < ASCII >
 * Mode           MCTL_AP        MCTL_INFRA
 * AP                1              1
 * STA               0              1 <--- This will ensure no beacons
 * IBSS              0              0
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_65.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/nwfpe/fpopcode.h#L64-L76

```c
/*
TABLE 1
 < ASCII >
+-------------------------+---+---+---------+---------+
|  Precision              | u | v | FPSR.EP | length  |
+-------------------------+---+---+---------+---------+
| Single                  | 0 | 0 |    x    | 1 words |
| Double                  | 1 | 1 |    x    | 2 words |
| Extended                | 1 | 1 |    x    | 3 words |
| Packed decimal          | 1 | 1 |    0    | 3 words |
| Expanded packed decimal | 1 | 1 |    1    | 4 words |
+-------------------------+---+---+---------+---------+
 < ASCII >
Note: x = don't care
*/
```
## Visual type:
- #table


== ./linux/linux_650.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/broadcom/brcm80211/brcmsmac/main.c#L6962-L6975

```c
/*
 * recover 64bit TSF value from the 16bit TSF value in the rx header
 * given the assumption that the TSF passed in header is within 65ms
 * of the current tsf.
 *
 < ASCII >
 * 6       5       4       4       3       2       1
 * 3.......6.......8.......0.......2.......4.......6.......8......0
 * |<---------- tsf_h ----------->||<--- tsf_l -->||<-RxTSFTime ->|
 < ASCII >
 *
 * The RxTSFTime are the lowest 16 bits and provided by the ucode. The
 * tsf_l is filled in by brcms_b_recv, which is done earlier in the
 * receive call sequence after rx interrupt. Only the higher 16 bits
 * are used. Finally, the tsf_h is read from the tsf register.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_651.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/intel/ipw2x00/libipw_tx.c#L32-L110

```c
/*

 < ASCII >
802.11 Data Frame

      ,-------------------------------------------------------------------.
| Bytes                                               | 2    | 2       | 6     | 6   | 6    | 2    | 0..2312 | 4   |
| --------------------------------------------------- | ---- | ------- | ----- | --- | ---- | ---- | ------- |
| Desc.                                               | ctrl | dura    | DA/RA | TA  | SA   | Sequ | Frame   | fcs |
|                                                     | tion | (BSSID) |       |     | ence | data |         |
| `-------------------------------------------------- |      | ------' |
Total: 28 non-data bytes                                 `----.----'
							      |
       .- 'Frame data' expands, if WEP enabled, to <----------'
       |
       V
      ,-----------------------.
| Bytes  | 4      | 0-2296    | 4   |
| ------ | ------ | --------- |
| Desc.  | IV     | Encrypted | ICV |
|        | Packet |           |
| `----- |        | -----'    |
	    `-----.-----'
		  |
       .- 'Encrypted Packet' expands to
       |
       V
      ,---------------------------------------------------.
| Bytes | 1    | 1         | 1          | 3          | 2      | 0-2304 |
| ----- | ---- | --------- | ---------- | ---------- | ------ |
| Desc. | SNAP | SNAP      | Control    | Eth Tunnel | Type   | IP     |
| DSAP  | SSAP |           |            |            | Packet |
| 0xAA  | 0xAA | 0x03 (UI) | 0x00-00-F8 |            |        |
      `----------------------------------------------------
Total: 8 non-data bytes

 < ASCII >
 < ASCII >
802.3 Ethernet Data Frame

      ,-----------------------------------------.
| Bytes | 6     | 6      | 2    | Variable  | 4   |
| ----- | ----- | ------ | ---- | --------- |
| Desc. | Dest. | Source | Type | IP Packet | fcs |
| MAC   | MAC   |        |      |           |
      `-----------------------------------------'
 < ASCII >
Total: 18 non-data bytes

In the event that fragmentation is required, the incoming payload is split into
N parts of size ieee->fts.  The first fragment contains the SNAP header and the
remaining packets are just data.

If encryption is enabled, each fragment payload size is reduced by enough space
to add the prefix and postfix (IV and ICV totalling 8 bytes in the case of WEP)
So if you have 1500 bytes of payload with ieee->fts set to 500 without
encryption it will take 3 frames.  With WEP it will take 4 frames as the
payload of each frame is reduced to 492 bytes.

 < ASCII >
* SKB visualization
*
*  ,- skb->data
* |
* |    ETHERNET HEADER        ,-<-- PAYLOAD
* |                           |     14 bytes from skb->data
* |  2 bytes for Type --> ,T. |     (sizeof ethhdr)
* |                       | | |
* |,-Dest.--. ,--Src.---. | | |
* |  6 bytes| | 6 bytes | | | |
* v         | |         | | | |
* 0         | v       1 | v | v           2
* 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
*     ^     | ^         | ^ |
*     |     | |         | | |
*     |     | |         | `T' <---- 2 bytes for Type
*     |     | |         |
*     |     | '---SNAP--' <-------- 6 bytes for SNAP
*     |     |
*     `-IV--' <-------------------- 4 bytes for IV (WEP)
*
*      SNAP HEADER
 < ASCII >
*
*/
```
## Visual type:
- #memory-layout


== ./linux/linux_652.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/intel/iwlegacy/4965.h#L543-L646

```c
/**
 * 2.4 GHz gain table
 *
 < ASCII >
 * Index    Dsp gain   Radio gain
 *   0        110         0x3f      (highest gain)
 *   1        104         0x3f
 *   2         98         0x3f
 *   3        110         0x3e
 *   4        104         0x3e
 *   5         98         0x3e
 *   6        110         0x3d
 *   7        104         0x3d
 *   8         98         0x3d
 *   9        110         0x3c
 *  10        104         0x3c
 *  11         98         0x3c
 *  12        110         0x3b
 *  13        104         0x3b
 *  14         98         0x3b
 *  15        110         0x3a
 *  16        104         0x3a
 *  17         98         0x3a
 *  18        110         0x39
 *  19        104         0x39
 *  20         98         0x39
 *  21        110         0x38
 *  22        104         0x38
 *  23         98         0x38
 *  24        110         0x37
 *  25        104         0x37
 *  26         98         0x37
 *  27        110         0x36
 *  28        104         0x36
 *  29         98         0x36
 *  30        110         0x35
 *  31        104         0x35
 *  32         98         0x35
 *  33        110         0x34
 *  34        104         0x34
 *  35         98         0x34
 *  36        110         0x33
 *  37        104         0x33
 *  38         98         0x33
 *  39        110         0x32
 *  40        104         0x32
 *  41         98         0x32
 *  42        110         0x31
 *  43        104         0x31
 *  44         98         0x31
 *  45        110         0x30
 *  46        104         0x30
 *  47         98         0x30
 *  48        110          0x6
 *  49        104          0x6
 *  50         98          0x6
 *  51        110          0x5
 *  52        104          0x5
 *  53         98          0x5
 *  54        110          0x4
 *  55        104          0x4
 *  56         98          0x4
 *  57        110          0x3
 *  58        104          0x3
 *  59         98          0x3
 *  60        110          0x2
 *  61        104          0x2
 *  62         98          0x2
 *  63        110          0x1
 *  64        104          0x1
 *  65         98          0x1
 *  66        110          0x0
 *  67        104          0x0
 *  68         98          0x0
 *  69         97            0
 *  70         96            0
 *  71         95            0
 *  72         94            0
 *  73         93            0
 *  74         92            0
 *  75         91            0
 *  76         90            0
 *  77         89            0
 *  78         88            0
 *  79         87            0
 *  80         86            0
 *  81         85            0
 *  82         84            0
 *  83         83            0
 *  84         82            0
 *  85         81            0
 *  86         80            0
 *  87         79            0
 *  88         78            0
 *  89         77            0
 *  90         76            0
 *  91         75            0
 *  92         74            0
 *  93         73            0
 *  94         72            0
 *  95         71            0
 *  96         70            0
 *  97         69            0
 *  98         68            0
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_653.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/intel/iwlegacy/4965.h#L648-L760

```c
/**
 * 5 GHz gain table
 *
 < ASCII >
 * Index    Dsp gain   Radio gain
 *  -9 	      123         0x3F      (highest gain)
 *  -8 	      117         0x3F
 *  -7        110         0x3F
 *  -6        104         0x3F
 *  -5         98         0x3F
 *  -4        110         0x3E
 *  -3        104         0x3E
 *  -2         98         0x3E
 *  -1        110         0x3D
 *   0        104         0x3D
 *   1         98         0x3D
 *   2        110         0x3C
 *   3        104         0x3C
 *   4         98         0x3C
 *   5        110         0x3B
 *   6        104         0x3B
 *   7         98         0x3B
 *   8        110         0x3A
 *   9        104         0x3A
 *  10         98         0x3A
 *  11        110         0x39
 *  12        104         0x39
 *  13         98         0x39
 *  14        110         0x38
 *  15        104         0x38
 *  16         98         0x38
 *  17        110         0x37
 *  18        104         0x37
 *  19         98         0x37
 *  20        110         0x36
 *  21        104         0x36
 *  22         98         0x36
 *  23        110         0x35
 *  24        104         0x35
 *  25         98         0x35
 *  26        110         0x34
 *  27        104         0x34
 *  28         98         0x34
 *  29        110         0x33
 *  30        104         0x33
 *  31         98         0x33
 *  32        110         0x32
 *  33        104         0x32
 *  34         98         0x32
 *  35        110         0x31
 *  36        104         0x31
 *  37         98         0x31
 *  38        110         0x30
 *  39        104         0x30
 *  40         98         0x30
 *  41        110         0x25
 *  42        104         0x25
 *  43         98         0x25
 *  44        110         0x24
 *  45        104         0x24
 *  46         98         0x24
 *  47        110         0x23
 *  48        104         0x23
 *  49         98         0x23
 *  50        110         0x22
 *  51        104         0x18
 *  52         98         0x18
 *  53        110         0x17
 *  54        104         0x17
 *  55         98         0x17
 *  56        110         0x16
 *  57        104         0x16
 *  58         98         0x16
 *  59        110         0x15
 *  60        104         0x15
 *  61         98         0x15
 *  62        110         0x14
 *  63        104         0x14
 *  64         98         0x14
 *  65        110         0x13
 *  66        104         0x13
 *  67         98         0x13
 *  68        110         0x12
 *  69        104         0x08
 *  70         98         0x08
 *  71        110         0x07
 *  72        104         0x07
 *  73         98         0x07
 *  74        110         0x06
 *  75        104         0x06
 *  76         98         0x06
 *  77        110         0x05
 *  78        104         0x05
 *  79         98         0x05
 *  80        110         0x04
 *  81        104         0x04
 *  82         98         0x04
 *  83        110         0x03
 *  84        104         0x03
 *  85         98         0x03
 *  86        110         0x02
 *  87        104         0x02
 *  88         98         0x02
 *  89        110         0x01
 *  90        104         0x01
 *  91         98         0x01
 *  92        110         0x00
 *  93        104         0x00
 *  94         98         0x00
 *  95         93         0x00
 *  96         88         0x00
 *  97         83         0x00
 *  98         78         0x00
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_654.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/intel/iwlegacy/commands.h#L1871-L2058

```c
/*
 * C_TX_LINK_QUALITY_CMD = 0x4e (command, has simple generic response)
 *
 * For 4965 devices only; 3945 uses C_RATE_SCALE.
 *
 * Each station in the 4965 device's internal station table has its own table
 * of 16
 * Tx rates and modulation modes (e.g. legacy/SISO/MIMO) for retrying Tx when
 * an ACK is not received.  This command replaces the entire table for
 * one station.
 *
 * NOTE:  Station must already be in 4965 device's station table.
 *	  Use C_ADD_STA.
 *
 * The rate scaling procedures described below work well.  Of course, other
 * procedures are possible, and may work better for particular environments.
 *
 *
 * FILLING THE RATE TBL
 *
 * Given a particular initial rate and mode, as determined by the rate
 * scaling algorithm described below, the Linux driver uses the following
 * formula to fill the rs_table[LINK_QUAL_MAX_RETRY_NUM] rate table in the
 * Link Quality command:
 *
 *
 * 1)  If using High-throughput (HT) (SISO or MIMO) initial rate:
 *     a) Use this same initial rate for first 3 entries.
 *     b) Find next lower available rate using same mode (SISO or MIMO),
 *        use for next 3 entries.  If no lower rate available, switch to
 *        legacy mode (no HT40 channel, no MIMO, no short guard interval).
 *     c) If using MIMO, set command's mimo_delimiter to number of entries
 *        using MIMO (3 or 6).
 *     d) After trying 2 HT rates, switch to legacy mode (no HT40 channel,
 *        no MIMO, no short guard interval), at the next lower bit rate
 *        (e.g. if second HT bit rate was 54, try 48 legacy), and follow
 *        legacy procedure for remaining table entries.
 *
 * 2)  If using legacy initial rate:
 *     a) Use the initial rate for only one entry.
 *     b) For each following entry, reduce the rate to next lower available
 *        rate, until reaching the lowest available rate.
 *     c) When reducing rate, also switch antenna selection.
 *     d) Once lowest available rate is reached, repeat this rate until
 *        rate table is filled (16 entries), switching antenna each entry.
 *
 *
 * ACCUMULATING HISTORY
 *
 * The rate scaling algorithm for 4965 devices, as implemented in Linux driver,
 * uses two sets of frame Tx success history:  One for the current/active
 * modulation mode, and one for a speculative/search mode that is being
 * attempted. If the speculative mode turns out to be more effective (i.e.
 * actual transfer rate is better), then the driver continues to use the
 * speculative mode as the new current active mode.
 *
 * Each history set contains, separately for each possible rate, data for a
 * sliding win of the 62 most recent tx attempts at that rate.  The data
 * includes a shifting bitmap of success(1)/failure(0), and sums of successful
 * and attempted frames, from which the driver can additionally calculate a
 * success ratio (success / attempted) and number of failures
 * (attempted - success), and control the size of the win (attempted).
 * The driver uses the bit map to remove successes from the success sum, as
 * the oldest tx attempts fall out of the win.
 *
 * When the 4965 device makes multiple tx attempts for a given frame, each
 * attempt might be at a different rate, and have different modulation
 * characteristics (e.g. antenna, fat channel, short guard interval), as set
 * up in the rate scaling table in the Link Quality command.  The driver must
 * determine which rate table entry was used for each tx attempt, to determine
 * which rate-specific history to update, and record only those attempts that
 * match the modulation characteristics of the history set.
 *
 * When using block-ack (aggregation), all frames are transmitted at the same
 * rate, since there is no per-attempt acknowledgment from the destination
 * station.  The Tx response struct il_tx_resp indicates the Tx rate in
 * rate_n_flags field.  After receiving a block-ack, the driver can update
 * history for the entire block all at once.
 *
 *
 * FINDING BEST STARTING RATE:
 *
 * When working with a selected initial modulation mode (see below), the
 * driver attempts to find a best initial rate.  The initial rate is the
 * first entry in the Link Quality command's rate table.
 *
 * 1)  Calculate actual throughput (success ratio * expected throughput, see
 *     table below) for current initial rate.  Do this only if enough frames
 *     have been attempted to make the value meaningful:  at least 6 failed
 *     tx attempts, or at least 8 successes.  If not enough, don't try rate
 *     scaling yet.
 *
 * 2)  Find available rates adjacent to current initial rate.  Available means:
 *     a)  supported by hardware &&
 *     b)  supported by association &&
 *     c)  within any constraints selected by user
 *
 * 3)  Gather measured throughputs for adjacent rates.  These might not have
 *     enough history to calculate a throughput.  That's okay, we might try
 *     using one of them anyway!
 *
 * 4)  Try decreasing rate if, for current rate:
 *     a)  success ratio is < 15% ||
 *     b)  lower adjacent rate has better measured throughput ||
 *     c)  higher adjacent rate has worse throughput, and lower is unmeasured
 *
 *     As a sanity check, if decrease was determined above, leave rate
 *     unchanged if:
 *     a)  lower rate unavailable
 *     b)  success ratio at current rate > 85% (very good)
 *     c)  current measured throughput is better than expected throughput
 *         of lower rate (under perfect 100% tx conditions, see table below)
 *
 * 5)  Try increasing rate if, for current rate:
 *     a)  success ratio is < 15% ||
 *     b)  both adjacent rates' throughputs are unmeasured (try it!) ||
 *     b)  higher adjacent rate has better measured throughput ||
 *     c)  lower adjacent rate has worse throughput, and higher is unmeasured
 *
 *     As a sanity check, if increase was determined above, leave rate
 *     unchanged if:
 *     a)  success ratio at current rate < 70%.  This is not particularly
 *         good performance; higher rate is sure to have poorer success.
 *
 * 6)  Re-evaluate the rate after each tx frame.  If working with block-
 *     acknowledge, history and stats may be calculated for the entire
 *     block (including prior history that fits within the history wins),
 *     before re-evaluation.
 *
 * FINDING BEST STARTING MODULATION MODE:
 *
 * After working with a modulation mode for a "while" (and doing rate scaling),
 * the driver searches for a new initial mode in an attempt to improve
 * throughput.  The "while" is measured by numbers of attempted frames:
 *
 * For legacy mode, search for new mode after:
 *   480 successful frames, or 160 failed frames
 * For high-throughput modes (SISO or MIMO), search for new mode after:
 *   4500 successful frames, or 400 failed frames
 *
 * Mode switch possibilities are (3 for each mode):
 *
 * For legacy:
 *   Change antenna, try SISO (if HT association), try MIMO (if HT association)
 * For SISO:
 *   Change antenna, try MIMO, try shortened guard interval (SGI)
 * For MIMO:
 *   Try SISO antenna A, SISO antenna B, try shortened guard interval (SGI)
 *
 * When trying a new mode, use the same bit rate as the old/current mode when
 * trying antenna switches and shortened guard interval.  When switching to
 * SISO from MIMO or legacy, or to MIMO from SISO or legacy, use a rate
 * for which the expected throughput (under perfect conditions) is about the
 * same or slightly better than the actual measured throughput delivered by
 * the old/current mode.
 *
 * Actual throughput can be estimated by multiplying the expected throughput
 * by the success ratio (successful / attempted tx frames).  Frame size is
 * not considered in this calculation; it assumes that frame size will average
 * out to be fairly consistent over several samples.  The following are
 * metric values for expected throughput assuming 100% success ratio.
 * Only G band has support for CCK rates:
 *
 < ASCII >
 *           RATE:  1    2    5   11    6   9   12   18   24   36   48   54   60
 *
 *              G:  7   13   35   58   40  57   72   98  121  154  177  186  186
 *              A:  0    0    0    0   40  57   72   98  121  154  177  186  186
 *     SISO 20MHz:  0    0    0    0   42  42   76  102  124  159  183  193  202
 * SGI SISO 20MHz:  0    0    0    0   46  46   82  110  132  168  192  202  211
 *     MIMO 20MHz:  0    0    0    0   74  74  123  155  179  214  236  244  251
 * SGI MIMO 20MHz:  0    0    0    0   81  81  131  164  188  222  243  251  257
 *     SISO 40MHz:  0    0    0    0   77  77  127  160  184  220  242  250  257
 * SGI SISO 40MHz:  0    0    0    0   83  83  135  169  193  229  250  257  264
 *     MIMO 40MHz:  0    0    0    0  123 123  182  214  235  264  279  285  289
 * SGI MIMO 40MHz:  0    0    0    0  131 131  191  222  242  270  284  289  293
 < ASCII >
 *
 * After the new mode has been tried for a short while (minimum of 6 failed
 * frames or 8 successful frames), compare success ratio and actual throughput
 * estimate of the new mode with the old.  If either is better with the new
 * mode, continue to use the new mode.
 *
 * Continue comparing modes until all 3 possibilities have been tried.
 * If moving from legacy to HT, try all 3 possibilities from the new HT
 * mode.  After trying all 3, a best mode is found.  Continue to use this mode
 * for the longer "while" described above (e.g. 480 successful frames for
 * legacy), and then repeat the search process.
 *
 */
```
## Visual type:
- #table


== ./linux/linux_655.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/intel/iwlegacy/common.h#L2234-L2244

```c
/*
 < ASCII >
 * we have 8 bits used like this:
 *
 * 7 6 5 4 3 2 1 0
 * | | | | | | | |
 * | | | | | | +-+-------- AC queue (0-3)
 * | | | | | |
 * | +-+-+-+-+------------ HW queue ID
 * |
 * +---------------------- unused
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_656.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/intel/iwlwifi/iwl-trans.h#L855-L896

```c
/**
 * struct iwl_txq - Tx Queue for DMA
 * @q: generic Rx/Tx queue descriptor
 * @tfds: transmit frame descriptors (DMA memory)
 * @first_tb_bufs: start of command headers, including scratch buffers, for
 *	the writeback -- this is DMA memory and an array holding one buffer
 *	for each command on the queue
 * @first_tb_dma: DMA address for the first_tb_bufs start
 * @entries: transmit entries (driver state)
 * @lock: queue lock
 * @stuck_timer: timer that fires if queue gets stuck
 * @trans: pointer back to transport (for timer)
 * @need_update: indicates need to update read/write index
 * @ampdu: true if this queue is an ampdu queue for an specific RA/TID
 * @wd_timeout: queue watchdog timeout (jiffies) - per queue
 * @frozen: tx stuck queue timer is frozen
 * @frozen_expiry_remainder: remember how long until the timer fires
 * @bc_tbl: byte count table of the queue (relevant only for gen2 transport)
 * @write_ptr: 1-st empty entry (index) host_w
 * @read_ptr: last used entry (index) host_r
 * @dma_addr:  physical addr for BD's
 * @n_window: safe queue window
 * @id: queue id
 * @low_mark: low watermark, resume queue if free space more than this
 * @high_mark: high watermark, stop queue if free space less than this
 *
 * A Tx queue consists of circular buffer of BDs (a.k.a. TFDs, transmit frame
 * descriptors) and required locking structures.
 *
 * Note the difference between TFD_QUEUE_SIZE_MAX and n_window: the hardware
 * always assumes 256 descriptors, so TFD_QUEUE_SIZE_MAX is always 256 (unless
 * there might be HW changes in the future). For the normal TX
 * queues, n_window, which is the size of the software queue data
 * is also 256; however, for the command queue, n_window is only
 * 32 since we don't need so many commands pending. Since the HW
 * still uses 256 BDs for DMA though, TFD_QUEUE_SIZE_MAX stays 256.
 < ASCII >
 * This means that we end up with the following:
 *  HW entries: | 0 | ... | N * 32 | ... | N * 32 + 31 | ... | 255 |
 *  SW entries:           | 0      | ... | 31 
 < ASCII >         |
 * where N is a number between 0 and 7. This means that the SW
 * data is a window overlayed over the HW queue.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_657.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/intel/iwlwifi/dvm/commands.h#L1541-L1728

```c
/*
 * REPLY_TX_LINK_QUALITY_CMD = 0x4e (command, has simple generic response)
 *
 * For agn devices
 *
 * Each station in the agn device's internal station table has its own table
 * of 16
 * Tx rates and modulation modes (e.g. legacy/SISO/MIMO) for retrying Tx when
 * an ACK is not received.  This command replaces the entire table for
 * one station.
 *
 * NOTE:  Station must already be in agn device's station table.
 *	  Use REPLY_ADD_STA.
 *
 * The rate scaling procedures described below work well.  Of course, other
 * procedures are possible, and may work better for particular environments.
 *
 *
 * FILLING THE RATE TABLE
 *
 * Given a particular initial rate and mode, as determined by the rate
 * scaling algorithm described below, the Linux driver uses the following
 * formula to fill the rs_table[LINK_QUAL_MAX_RETRY_NUM] rate table in the
 * Link Quality command:
 *
 *
 * 1)  If using High-throughput (HT) (SISO or MIMO) initial rate:
 *     a) Use this same initial rate for first 3 entries.
 *     b) Find next lower available rate using same mode (SISO or MIMO),
 *        use for next 3 entries.  If no lower rate available, switch to
 *        legacy mode (no HT40 channel, no MIMO, no short guard interval).
 *     c) If using MIMO, set command's mimo_delimiter to number of entries
 *        using MIMO (3 or 6).
 *     d) After trying 2 HT rates, switch to legacy mode (no HT40 channel,
 *        no MIMO, no short guard interval), at the next lower bit rate
 *        (e.g. if second HT bit rate was 54, try 48 legacy), and follow
 *        legacy procedure for remaining table entries.
 *
 * 2)  If using legacy initial rate:
 *     a) Use the initial rate for only one entry.
 *     b) For each following entry, reduce the rate to next lower available
 *        rate, until reaching the lowest available rate.
 *     c) When reducing rate, also switch antenna selection.
 *     d) Once lowest available rate is reached, repeat this rate until
 *        rate table is filled (16 entries), switching antenna each entry.
 *
 *
 * ACCUMULATING HISTORY
 *
 * The rate scaling algorithm for agn devices, as implemented in Linux driver,
 * uses two sets of frame Tx success history:  One for the current/active
 * modulation mode, and one for a speculative/search mode that is being
 * attempted. If the speculative mode turns out to be more effective (i.e.
 * actual transfer rate is better), then the driver continues to use the
 * speculative mode as the new current active mode.
 *
 * Each history set contains, separately for each possible rate, data for a
 * sliding window of the 62 most recent tx attempts at that rate.  The data
 * includes a shifting bitmap of success(1)/failure(0), and sums of successful
 * and attempted frames, from which the driver can additionally calculate a
 * success ratio (success / attempted) and number of failures
 * (attempted - success), and control the size of the window (attempted).
 * The driver uses the bit map to remove successes from the success sum, as
 * the oldest tx attempts fall out of the window.
 *
 * When the agn device makes multiple tx attempts for a given frame, each
 * attempt might be at a different rate, and have different modulation
 * characteristics (e.g. antenna, fat channel, short guard interval), as set
 * up in the rate scaling table in the Link Quality command.  The driver must
 * determine which rate table entry was used for each tx attempt, to determine
 * which rate-specific history to update, and record only those attempts that
 * match the modulation characteristics of the history set.
 *
 * When using block-ack (aggregation), all frames are transmitted at the same
 * rate, since there is no per-attempt acknowledgment from the destination
 * station.  The Tx response struct iwl_tx_resp indicates the Tx rate in
 * rate_n_flags field.  After receiving a block-ack, the driver can update
 * history for the entire block all at once.
 *
 *
 * FINDING BEST STARTING RATE:
 *
 * When working with a selected initial modulation mode (see below), the
 * driver attempts to find a best initial rate.  The initial rate is the
 * first entry in the Link Quality command's rate table.
 *
 * 1)  Calculate actual throughput (success ratio * expected throughput, see
 *     table below) for current initial rate.  Do this only if enough frames
 *     have been attempted to make the value meaningful:  at least 6 failed
 *     tx attempts, or at least 8 successes.  If not enough, don't try rate
 *     scaling yet.
 *
 * 2)  Find available rates adjacent to current initial rate.  Available means:
 *     a)  supported by hardware &&
 *     b)  supported by association &&
 *     c)  within any constraints selected by user
 *
 * 3)  Gather measured throughputs for adjacent rates.  These might not have
 *     enough history to calculate a throughput.  That's okay, we might try
 *     using one of them anyway!
 *
 * 4)  Try decreasing rate if, for current rate:
 *     a)  success ratio is < 15% ||
 *     b)  lower adjacent rate has better measured throughput ||
 *     c)  higher adjacent rate has worse throughput, and lower is unmeasured
 *
 *     As a sanity check, if decrease was determined above, leave rate
 *     unchanged if:
 *     a)  lower rate unavailable
 *     b)  success ratio at current rate > 85% (very good)
 *     c)  current measured throughput is better than expected throughput
 *         of lower rate (under perfect 100% tx conditions, see table below)
 *
 * 5)  Try increasing rate if, for current rate:
 *     a)  success ratio is < 15% ||
 *     b)  both adjacent rates' throughputs are unmeasured (try it!) ||
 *     b)  higher adjacent rate has better measured throughput ||
 *     c)  lower adjacent rate has worse throughput, and higher is unmeasured
 *
 *     As a sanity check, if increase was determined above, leave rate
 *     unchanged if:
 *     a)  success ratio at current rate < 70%.  This is not particularly
 *         good performance; higher rate is sure to have poorer success.
 *
 * 6)  Re-evaluate the rate after each tx frame.  If working with block-
 *     acknowledge, history and statistics may be calculated for the entire
 *     block (including prior history that fits within the history windows),
 *     before re-evaluation.
 *
 * FINDING BEST STARTING MODULATION MODE:
 *
 * After working with a modulation mode for a "while" (and doing rate scaling),
 * the driver searches for a new initial mode in an attempt to improve
 * throughput.  The "while" is measured by numbers of attempted frames:
 *
 * For legacy mode, search for new mode after:
 *   480 successful frames, or 160 failed frames
 * For high-throughput modes (SISO or MIMO), search for new mode after:
 *   4500 successful frames, or 400 failed frames
 *
 * Mode switch possibilities are (3 for each mode):
 *
 * For legacy:
 *   Change antenna, try SISO (if HT association), try MIMO (if HT association)
 * For SISO:
 *   Change antenna, try MIMO, try shortened guard interval (SGI)
 * For MIMO:
 *   Try SISO antenna A, SISO antenna B, try shortened guard interval (SGI)
 *
 * When trying a new mode, use the same bit rate as the old/current mode when
 * trying antenna switches and shortened guard interval.  When switching to
 * SISO from MIMO or legacy, or to MIMO from SISO or legacy, use a rate
 * for which the expected throughput (under perfect conditions) is about the
 * same or slightly better than the actual measured throughput delivered by
 * the old/current mode.
 *
 * Actual throughput can be estimated by multiplying the expected throughput
 * by the success ratio (successful / attempted tx frames).  Frame size is
 * not considered in this calculation; it assumes that frame size will average
 * out to be fairly consistent over several samples.  The following are
 * metric values for expected throughput assuming 100% success ratio.
 * Only G band has support for CCK rates:
 *
 < ASCII >
 *           RATE:  1    2    5   11    6   9   12   18   24   36   48   54   60
 *
 *              G:  7   13   35   58   40  57   72   98  121  154  177  186  186
 *              A:  0    0    0    0   40  57   72   98  121  154  177  186  186
 *     SISO 20MHz:  0    0    0    0   42  42   76  102  124  159  183  193  202
 * SGI SISO 20MHz:  0    0    0    0   46  46   82  110  132  168  192  202  211
 *     MIMO 20MHz:  0    0    0    0   74  74  123  155  179  214  236  244  251
 * SGI MIMO 20MHz:  0    0    0    0   81  81  131  164  188  222  243  251  257
 *     SISO 40MHz:  0    0    0    0   77  77  127  160  184  220  242  250  257
 * SGI SISO 40MHz:  0    0    0    0   83  83  135  169  193  229  250  257  264
 *     MIMO 40MHz:  0    0    0    0  123 123  182  214  235  264  279  285  289
 * SGI MIMO 40MHz:  0    0    0    0  131 131  191  222  242  270  284  289  293
 < ASCII >
 *
 * After the new mode has been tried for a short while (minimum of 6 failed
 * frames or 8 successful frames), compare success ratio and actual throughput
 * estimate of the new mode with the old.  If either is better with the new
 * mode, continue to use the new mode.
 *
 * Continue comparing modes until all 3 possibilities have been tried.
 * If moving from legacy to HT, try all 3 possibilities from the new HT
 * mode.  After trying all 3, a best mode is found.  Continue to use this mode
 * for the longer "while" described above (e.g. 480 successful frames for
 * legacy), and then repeat the search process.
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_658.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/intel/iwlwifi/dvm/sta.c#L1296-L1301

```c
/*
 * iwl_update_bcast_station - update broadcast station's LQ command
 *
 * Only used by iwlagn. Placed here to have all bcast station management
 * code together.
 */
```
## Visual type:



== ./linux/linux_659.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/intel/iwlwifi/dvm/tt.c#L325-L345

```c
/*
 * Advance thermal throttling
 * 1) Avoid NIC destruction due to high temperatures
 *	Chip will identify dangerously high temperatures that can
 *	harm the device and will power down
 * 2) Avoid the NIC power down due to high temperature
 *	Throttle early enough to lower the power consumption before
 *	drastic steps are needed
 *	Actions include relaxing the power down sleep thresholds and
 *	decreasing the number of TX streams
 * 3) Avoid throughput performance impact as much as possible
 *
 < ASCII >
 *=============================================================================
 *                 Condition Nxt State  Condition Nxt State Condition Nxt State
 *-----------------------------------------------------------------------------
 *     IWL_TI_0     T >= 114   CT_KILL  114>T>=105   TI_1      N/A      N/A
 *     IWL_TI_1     T >= 114   CT_KILL  114>T>=110   TI_2     T<=95     TI_0
 *     IWL_TI_2     T >= 114   CT_KILL                        T<=100    TI_1
 *    IWL_CT_KILL      N/A       N/A       N/A        N/A     T<=95     TI_0
 *=============================================================================
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_66.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/nwfpe/fpopcode.h#L78-L88

```c
/*
 < ASCII >
TABLE 2
+---+---+---------------------------------+
| w | x | Number of registers to transfer |
+---+---+---------------------------------+
| 0 | 1 |  1                              |
| 1 | 0 |  2                              |
| 1 | 1 |  3                              |
| 0 | 0 |  4                              |
+---+---+---------------------------------+
 < ASCII >
*/
```
## Visual type:
- #table


== ./linux/linux_660.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/intel/iwlwifi/fw/api/phy-ctxt.h#L23-L36

```c
/*
 * Control channel position:
 * For legacy set bit means upper channel, otherwise lower.
 * For VHT - bit-2 marks if the control is lower/upper relative to center-freq
 *   bits-1:0 mark the distance from the center freq. for 20Mhz, offset is 0.
 *                                   center_freq
 * For EHT - bit-3 is used for extended distance
 < ASCII >
 *                                                |
 * 40Mhz                                     |____|____|
 * 80Mhz                                |____|____|____|____|
 * 160Mhz                     |____|____|____|____|____|____|____|____|
 * 320MHz |____|____|____|____|____|____|____|____|____|____|____|____|____|____|____|____|
 * code    1011 1010 1001 1000 0011 0010 0001 0000 0100 0101 0110 0111 1100 1101 1110 1111
 < ASCII >
 */
```
## Visual type:
- #plot


== ./linux/linux_661.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/intel/iwlwifi/mei/iwl-mei.h#L112-L144

```c
/**
 * DOC: CSME behavior regarding the ownership requests
 *
 * The ownership requests from the host can come in two different ways:
 *  - the HW registers in iwl_pcie_set_hw_ready
 *  - using the Software Arbitration Protocol (SAP)
 *
 * The host can ask CSME who owns the device with %SAP_MSG_NOTIF_WHO_OWNS_NIC,
 * and it can request ownership with %SAP_MSG_NOTIF_HOST_ASKS_FOR_NIC_OWNERSHIP.
 * The host will first use %SAP_MSG_NOTIF_WHO_OWNS_NIC to know what state
 * CSME is in. In case CSME thinks it owns the device, the host can ask for
 * ownership with %SAP_MSG_NOTIF_HOST_ASKS_FOR_NIC_OWNERSHIP.
 *
 * Here the table that describes CSME's behavior upon ownership request:
 *
 < ASCII >
 * +-------------------+------------+--------------+-----------------------------+------------+
 * | State             | HW reg bit | Reply for    | Event                       | HW reg bit |
 * |                   | before     | WHO_OWNS_NIC |                             | after      |
 * +===================+============+==============+=============================+============+
 * | WiAMT not         | 0          | Host         | HW register or              | 0          |
 * | operational       | Host owner |              | HOST_ASKS_FOR_NIC_OWNERSHIP | Host owner |
 * +-------------------+------------+--------------+-----------------------------+------------+
 * | Operational &     | 1          | N/A          | HW register                 | 0          |
 * | SAP down &        | CSME owner |              |                             | Host owner |
 * | no session active |            |              |                             |            |
 * +-------------------+------------+--------------+-----------------------------+------------+
 * | Operational &     | 1          | CSME         | HW register                 | 1          |
 * | SAP up            | CSME owner |              |                             | CSME owner |
 * +-------------------+------------+--------------+-----------------------------+------------+
 * | Operational &     | 1          | CSME         | HOST_ASKS_FOR_NIC_OWNERSHIP | 0          |
 * | SAP up            | CSME owner |              |                             | Host owner |
 * +-------------------+------------+--------------+-----------------------------+------------+
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_662.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/intel/iwlwifi/mei/main.c#L88-L104

```c
/*
 * The shared area has the following layout:
 *
 < ASCII >
 * +-----------------------------------+
 * |struct iwl_sap_shared_mem_ctrl_blk |
 * +-----------------------------------+
 * |Host -> ME data queue              |
 * +-----------------------------------+
 * |Host -> ME notif queue             |
 * +-----------------------------------+
 * |ME -> Host data queue              |
 * +-----------------------------------+
 * |ME -> host notif queue             |
 * +-----------------------------------+
 * |SAP control block id (SAP!)        |
 * +-----------------------------------+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_663.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/intersil/orinoco/main.c#L332-L355

```c
/* Add encapsulation and MIC to the existing SKB.
 * The main xmit routine will then send the whole lot to the card.
 * Need 8 bytes headroom
 * Need 8 bytes tailroom
 *
 < ASCII >
 *                          With encapsulated ethernet II frame
 *                          --------
 *                          803.3 header (14 bytes)
 *                           dst[6]
 * --------                  src[6]
 * 803.3 header (14 bytes)   len[2]
 *  dst[6]                  803.2 header (8 bytes)
 *  src[6]                   encaps[6]
 *  len[2] <- leave alone -> len[2]
 * --------                 -------- <-- 0
 * Payload                  Payload
 * ...                      ...
 *
 * --------                 --------
 *                          MIC (8 bytes)
 *                          --------
 < ASCII >
 *
 * returns 0 on success, -ENOMEM on error.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_664.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/intersil/orinoco/main.c#L2129-L2153

```c
/* Allocate private data.
 *
 * This driver has a number of structures associated with it
 *  netdev - Net device structure for each network interface
 *  wiphy - structure associated with wireless phy
 *  wireless_dev (wdev) - structure for each wireless interface
 *  hw - structure for hermes chip info
 *  card - card specific structure for use by the card driver
 *         (airport, orinoco_cs)
 *  priv - orinoco private data
 *  device - generic linux device structure
 *
 < ASCII >
 *  +---------+    +---------+
 *  |  wiphy  |    | netdev  |
 *  | +-------+    | +-------+
 *  | | priv  |    | | wdev  |
 *  | | +-----+    +-+-------+
 *  | | | hw  |
 *  | +-+-----+
 *  | | card  |
 *  +-+-------+
 < ASCII >
 *
 * priv has a link to netdev and device
 * wdev has a link to wiphy
 */
```
## Visual type:
- #custom


== ./linux/linux_665.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/marvell/libertas/debugfs.c#L181-L196

```c
/*
 * When calling CMD_802_11_SUBSCRIBE_EVENT with CMD_ACT_GET, me might
 * get a bunch of vendor-specific TLVs (a.k.a. IEs) back from the
 * firmware. Here's an example:
 < ASCII >
 *	04 01 02 00 00 00 05 01 02 00 00 00 06 01 02 00
 *	00 00 07 01 02 00 3c 00 00 00 00 00 00 00 03 03
 *	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
 < ASCII >
 *
 * The 04 01 is the TLV type (here TLV_TYPE_RSSI_LOW), 02 00 is the length,
 * 00 00 are the data bytes of this TLV. For this TLV, their meaning is
 * defined in mrvlietypes_thresholds
 *
 * This function searches in this TLV data chunk for a given TLV type
 * and returns a pointer to the first data byte of the TLV, or to NULL
 * if the TLV hasn't been found.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_666.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/marvell/mwifiex/11n_aggr.c#L17-L33

```c
/*
 * Creates an AMSDU subframe for aggregation into one AMSDU packet.
 *
 * The resultant AMSDU subframe format is -
 *
 < ASCII >
 * +---- ~ -----+---- ~ ------+---- ~ -----+----- ~ -----+---- ~ -----+
 * |     DA     |     SA      |   Length   | SNAP header |   MSDU     |
 * | data[0..5] | data[6..11] |            |             | data[14..] |
 * +---- ~ -----+---- ~ ------+---- ~ -----+----- ~ -----+---- ~ -----+
 * <--6-bytes--> <--6-bytes--> <--2-bytes--><--8-bytes--> <--n-bytes-->
 < ASCII >
 *
 * This function also computes the amount of padding required to make the
 * buffer length multiple of 4 bytes.
 *
 * Data => |DA|SA|SNAP-TYPE|........    .|
 * MSDU => |DA|SA|Length|SNAP|......   ..|
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_667.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/marvell/mwifiex/11n_aggr.c#L127-L142

```c
/*
 * Create aggregated packet.
 *
 * This function creates an aggregated MSDU packet, by combining buffers
 * from the RA list. Each individual buffer is encapsulated as an AMSDU
 * subframe and all such subframes are concatenated together to form the
 * AMSDU packet.
 *
 * A TxPD is also added to the front of the resultant AMSDU packets for
 * transmission. The resultant packets format is -
 *
 < ASCII >
 * +---- ~ ----+------ ~ ------+------ ~ ------+-..-+------ ~ ------+
 * |    TxPD   |AMSDU sub-frame|AMSDU sub-frame| .. |AMSDU sub-frame|
 * |           |       1       |       2       | .. |       n       |
 * +---- ~ ----+------ ~ ------+------ ~ ------+ .. +------ ~ ------+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_668.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/marvell/mwifiex/join.c#L564-L625

```c
/*
 * Association firmware command response handler
 *
 * The response buffer for the association command has the following
 * memory layout.
 *
 < ASCII >
 * For cases where an association response was not received (indicated
 * by the CapInfo and AId field):
 *
 *     .------------------------------------------------------------.
 *     |  Header(4 * sizeof(t_u16)):  Standard command response hdr |
 *     .------------------------------------------------------------.
 *     |  cap_info/Error Return(t_u16):                             |
 *     |           0xFFFF(-1): Internal error                       |
 *     |           0xFFFE(-2): Authentication unhandled message     |
 *     |           0xFFFD(-3): Authentication refused               |
 *     |           0xFFFC(-4): Timeout waiting for AP response      |
 *     .------------------------------------------------------------.
 *     |  status_code(t_u16):                                       |
 *     |        If cap_info is -1:                                  |
 *     |           An internal firmware failure prevented the       |
 *     |           command from being processed.  The status_code   |
 *     |           will be set to 1.                                |
 *     |                                                            |
 *     |        If cap_info is -2:                                  |
 *     |           An authentication frame was received but was     |
 *     |           not handled by the firmware.  IEEE Status        |
 *     |           code for the failure is returned.                |
 *     |                                                            |
 *     |        If cap_info is -3:                                  |
 *     |           An authentication frame was received and the     |
 *     |           status_code is the IEEE Status reported in the   |
 *     |           response.                                        |
 *     |                                                            |
 *     |        If cap_info is -4:                                  |
 *     |           (1) Association response timeout                 |
 *     |           (2) Authentication response timeout              |
 *     .------------------------------------------------------------.
 *     |  a_id(t_u16): 0xFFFF                                       |
 *     .------------------------------------------------------------.
 *
 *
 * For cases where an association response was received, the IEEE
 * standard association response frame is returned:
 *
 *     .------------------------------------------------------------.
 *     |  Header(4 * sizeof(t_u16)):  Standard command response hdr |
 *     .------------------------------------------------------------.
 *     |  cap_info(t_u16): IEEE Capability                          |
 *     .------------------------------------------------------------.
 *     |  status_code(t_u16): IEEE Status Code                      |
 *     .------------------------------------------------------------.
 *     |  a_id(t_u16): IEEE Association ID                          |
 *     .------------------------------------------------------------.
 *     |  IEEE IEs(variable): Any received IEs comprising the       |
 *     |                      remaining portion of a received       |
 *     |                      association response frame.           |
 *     .------------------------------------------------------------.
 < ASCII >
 *
 * For simplistic handling, the status_code field can be used to determine
 * an association success (0) or failure (non-zero).
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_669.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/marvell/mwifiex/scan.c#L320-L337

```c
/*
 * This function checks if a scanned network is compatible with the driver
 * settings.
 *
 < ASCII >
 *   WEP     WPA    WPA2   ad-hoc encrypt                  Network
 * enabled enabled enabled  AES    mode   Privacy WPA WPA2 Compatible
 *    0       0       0      0     NONE      0     0   0   yes No security
 *    0       1       0      0      x        1x    1   x   yes WPA (disable
 *                                                         HT if no AES)
 *    0       0       1      0      x        1x    x   1   yes WPA2 (disable
 *                                                         HT if no AES)
 *    0       0       0      1     NONE      1     0   0   yes Ad-hoc AES
 *    1       0       0      0     NONE      1     0   0   yes Static WEP
 *                                                         (disable HT)
 *    0       0       0      0    !=NONE     1     0   0   yes Dynamic WEP
 < ASCII >
 *
 * Compatibility is not matched while roaming, except for mode.
 */
```
## Visual type:
- #table


== ./linux/linux_67.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/nwfpe/fpopcode.h#L90-L114

```c
/*
 < ASCII >
TABLE 3: Dyadic Floating Point Opcodes
+---+---+---+---+----------+-----------------------+-----------------------+
| a | b | c | d | Mnemonic | Description           | Operation             |
+---+---+---+---+----------+-----------------------+-----------------------+
| 0 | 0 | 0 | 0 | ADF      | Add                   | Fd := Fn + Fm         |
| 0 | 0 | 0 | 1 | MUF      | Multiply              | Fd := Fn * Fm         |
| 0 | 0 | 1 | 0 | SUF      | Subtract              | Fd := Fn - Fm         |
| 0 | 0 | 1 | 1 | RSF      | Reverse subtract      | Fd := Fm - Fn         |
| 0 | 1 | 0 | 0 | DVF      | Divide                | Fd := Fn / Fm         |
| 0 | 1 | 0 | 1 | RDF      | Reverse divide        | Fd := Fm / Fn         |
| 0 | 1 | 1 | 0 | POW      | Power                 | Fd := Fn ^ Fm         |
| 0 | 1 | 1 | 1 | RPW      | Reverse power         | Fd := Fm ^ Fn         |
| 1 | 0 | 0 | 0 | RMF      | Remainder             | Fd := IEEE rem(Fn/Fm) |
| 1 | 0 | 0 | 1 | FML      | Fast Multiply         | Fd := Fn * Fm         |
| 1 | 0 | 1 | 0 | FDV      | Fast Divide           | Fd := Fn / Fm         |
| 1 | 0 | 1 | 1 | FRD      | Fast reverse divide   | Fd := Fm / Fn         |
| 1 | 1 | 0 | 0 | POL      | Polar angle (ArcTan2) | Fd := arctan2(Fn,Fm)  |
| 1 | 1 | 0 | 1 |          | undefined instruction | trap                  |
| 1 | 1 | 1 | 0 |          | undefined instruction | trap                  |
| 1 | 1 | 1 | 1 |          | undefined instruction | trap                  |
+---+---+---+---+----------+-----------------------+-----------------------+
 < ASCII >
Note: POW, RPW, POL are deprecated, and are available for backwards
      compatibility only.
*/
```
## Visual type:
- #table


== ./linux/linux_670.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/marvell/mwifiex/scan.c#L2082-L2100

```c
/*
 * This function handles the command response of scan.
 *
 * The response buffer for the scan command has the following
 * memory layout:
 *
 < ASCII >
 *      .-------------------------------------------------------------.
 *      |  Header (4 * sizeof(t_u16)):  Standard command response hdr |
 *      .-------------------------------------------------------------.
 *      |  BufSize (t_u16) : sizeof the BSS Description data          |
 *      .-------------------------------------------------------------.
 *      |  NumOfSet (t_u8) : Number of BSS Descs returned             |
 *      .-------------------------------------------------------------.
 *      |  BSSDescription data (variable, size given in BufSize)      |
 *      .-------------------------------------------------------------.
 *      |  TLV data (variable, size calculated using Header->Size,    |
 *      |            BufSize and sizeof the fixed fields above)       |
 *      .-------------------------------------------------------------.
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_671.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ralink/rt2x00/rt2800.h#L2000-L2026

```c
/*
 * Security key table memory.
 *
 * The pairwise key table shares some memory with the beacon frame
 * buffers 6 and 7. That basically means that when beacon 6 & 7
 * are used we should only use the reduced pairwise key table which
 * has a maximum of 222 entries.
 *
 < ASCII >
 * ---------------------------------------------
 * |0x4000 | Pairwise Key   | Reduced Pairwise |
 * |       | Table          | Key Table        |
 * |       | Size: 256 * 32 | Size: 222 * 32   |
 * |0x5BC0 |                |-------------------
 * |       |                | Beacon 6         |
 * |0x5DC0 |                |-------------------
 * |       |                | Beacon 7         |
 * |0x5FC0 |                |-------------------
 * |0x5FFF |                |
 * --------------------------
 < ASCII >
 *
 * MAC_WCID_BASE: 8-bytes (use only 6 bytes) * 256 entry
 * PAIRWISE_KEY_TABLE_BASE: 32-byte * 256 entry
 * MAC_IVEIV_TABLE_BASE: 8-byte * 256-entry
 * MAC_WCID_ATTRIBUTE_BASE: 4-byte * 256-entry
 * SHARED_KEY_TABLE_BASE: 32-byte * 16-entry
 * SHARED_KEY_MODE_BASE: 4-byte * 16-entry
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_672.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/realtek/rtl818x/rtl8180/dev.c#L121-L163

```c
/* Queues for rtl8187se card
 *
 < ASCII >
 * name | reg  |  queue
 *  BC  |  7   |   6
 *  MG  |  1   |   0
 *  HI  |  6   |   1
 *  VO  |  5   |   2
 *  VI  |  4   |   3
 *  BE  |  3   |   4
 *  BK  |  2   |   5
 < ASCII >
 *
 * The complete map for DMA kick reg using use all queue is:
 * static const int rtl8187se_queues_map[RTL8187SE_NR_TX_QUEUES] =
 *	{1, 6, 5, 4, 3, 2, 7};
 *
 * .. but.. Because for mac80211 4 queues are enough for QoS we use this
 *
 < ASCII >
 * name | reg  |  queue
 *  BC  |  7   |   4  <- currently not used yet
 *  MG  |  1   |   x  <- Not used
 *  HI  |  6   |   x  <- Not used
 *  VO  |  5   |   0  <- used
 *  VI  |  4   |   1  <- used
 *  BE  |  3   |   2  <- used
 *  BK  |  2   |   3  <- used
 < ASCII >
 *
 * Beacon queue could be used, but this is not finished yet.
 *
 * I thougth about using the other two queues but I decided not to do this:
 *
 * - I'm unsure whether the mac80211 will ever try to use more than 4 queues
 *   by itself.
 *
 * - I could route MGMT frames (currently sent over VO queue) to the MGMT
 *   queue but since mac80211 will do not know about it, I will probably gain
 *   some HW priority whenever the VO queue is not empty, but this gain is
 *   limited by the fact that I had to stop the mac80211 queue whenever one of
 *   the VO or MGMT queues is full, stopping also submitting of MGMT frame
 *   to the driver.
 *
 * - I don't know how to set in the HW the contention window params for MGMT
 *   and HI-prio queues.
 */
```
## Visual type:
- #table


== ./linux/linux_673.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/realtek/rtl818x/rtl8180/dev.c#L167-L188

```c
/* Queues for rtl8180/rtl8185 cards
 *
 < ASCII >
 * name | reg  |  prio
 *  BC  |  7   |   3
 *  HI  |  6   |   0
 *  NO  |  5   |   1
 *  LO  |  4   |   2
 < ASCII >
 *
 * The complete map for DMA kick reg using all queue is:
 * static const int rtl8180_queues_map[RTL8180_NR_TX_QUEUES] = {6, 5, 4, 7};
 *
 * .. but .. Because the mac80211 needs at least 4 queues for QoS or
 * otherwise QoS can't be done, we use just one.
 * Beacon queue could be used, but this is not finished yet.
 * Actual map is:
 *
 < ASCII >
 * name | reg  |  prio
 *  BC  |  7   |   1  <- currently not used yet.
 *  HI  |  6   |   x  <- not used
 *  NO  |  5   |   x  <- not used
 *  LO  |  4   |   0  <- used
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_674.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/realtek/rtw88/efuse.c#L31-L39

```c
/* efuse header format
 *
 < ASCII >
 * | 7        5   4    0 | 7        4   3          0 | 15  8  7   0 |
 *   block[2:0]   0 1111   block[6:3]   word_en[3:0]   byte0  byte1
 * | header 1 (optional) |          header 2         |    word N    |
 < ASCII >
 *
 * word_en: 4 bits each word. 0 -> write; 1 -> not write
 * N: 1~4, depends on word_en
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_675.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ti/wl1251/acx.h#L447-L470

```c
/*
 < ASCII >
 * ACXBeaconFilterEntry (not 221)
 * Byte Offset     Size (Bytes)    Definition
 * ===========     ============    ==========
 * 0				1               IE identifier
 * 1               1               Treatment bit mask
 *
 * ACXBeaconFilterEntry (221)
 * Byte Offset     Size (Bytes)    Definition
 * ===========     ============    ==========
 * 0               1               IE identifier
 * 1               1               Treatment bit mask
 * 2               3               OUI
 * 5               1               Type
 * 6               2               Version
 < ASCII >
 *
 *
 * Treatment bit mask - The information element handling:
 * bit 0 - The information element is compared and transferred
 * in case of change.
 * bit 1 - The information element is transferred to the host
 * with each appearance or disappearance.
 * Note that both bits can be set at the same time.
 */
```
## Visual type:
- #table


== ./linux/linux_676.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ti/wl1251/cmd.h#L360-L375

```c
/*
 *
 < ASCII >
 * key_type_e   key size    key format
 * ----------   ---------   ----------
 * 0x00         5, 13, 29   Key data
 * 0x01         5, 13, 29   Key data
 * 0x04         16          16 bytes of key data
 * 0x05         16          16 bytes of key data
 * 0x0a         32          16 bytes of TKIP key data
 *                          8 bytes of RX MIC key data
 *                          8 bytes of TX MIC key data
 * 0x0b         32          16 bytes of TKIP key data
 *                          8 bytes of RX MIC key data
 *                          8 bytes of TX MIC key data
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_677.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ti/wl1251/io.c#L87-L119

```c
/* Set the partitions to access the chip addresses.
 *
 * There are two VIRTUAL partitions (the memory partition and the
 * registers partition), which are mapped to two different areas of the
 * PHYSICAL (hardware) memory.  This function also makes other checks to
 * ensure that the partitions are not overlapping.  In the diagram below, the
 * memory partition comes before the register partition, but the opposite is
 * also supported.
 < ASCII >
 *
 *                               PHYSICAL address
 *                                     space
 *
 *                                    |    |
 *                                 ...+----+--> mem_start
 *          VIRTUAL address     ...   |    |
 *               space       ...      |    | [PART_0]
 *                        ...         |    |
 * 0x00000000 <--+----+...         ...+----+--> mem_start + mem_size
 *               |    |         ...   |    |
 *               |MEM |      ...      |    |
 *               |    |   ...         |    |
 *  part_size <--+----+...            |    | {unused area)
 *               |    |   ...         |    |
 *               |REG |      ...      |    |
 *  part_size    |    |         ...   |    |
 *      +     <--+----+...         ...+----+--> reg_start
 *  reg_size              ...         |    |
 *                           ...      |    | [PART_1]
 *                              ...   |    |
 *                                 ...+----+--> reg_start + reg_size
 *                                    |    |
 < ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_678.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ti/wlcore/acx.h#L229-L252

```c
/*
 < ASCII >
 * ACXBeaconFilterEntry (not 221)
 * Byte Offset     Size (Bytes)    Definition
 * ===========     ============    ==========
 * 0               1               IE identifier
 * 1               1               Treatment bit mask
 *
 * ACXBeaconFilterEntry (221)
 * Byte Offset     Size (Bytes)    Definition
 * ===========     ============    ==========
 * 0               1               IE identifier
 * 1               1               Treatment bit mask
 * 2               3               OUI
 * 5               1               Type
 * 6               2               Version
 < ASCII >
 *
 *
 * Treatment bit mask - The information element handling:
 * bit 0 - The information element is compared and transferred
 * in case of change.
 * bit 1 - The information element is transferred to the host
 * with each appearance or disappearance.
 * Note that both bits can be set at the same time.
 */
```
## Visual type:
- #table


== ./linux/linux_679.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wireless/ti/wlcore/io.c#L89-L122

```c
/* Set the partitions to access the chip addresses
 *
 * To simplify driver code, a fixed (virtual) memory map is defined for
 * register and memory addresses. Because in the chipset, in different stages
 * of operation, those addresses will move around, an address translation
 * mechanism is required.
 *
 * There are four partitions (three memory and one register partition),
 * which are mapped to two different areas of the hardware memory.
 *
 < ASCII >
 *                                Virtual address
 *                                     space
 *
 *                                    |    |
 *                                 ...+----+--> mem.start
 *          Physical address    ...   |    |
 *               space       ...      |    | [PART_0]
 *                        ...         |    |
 *  00000000  <--+----+...         ...+----+--> mem.start + mem.size
 *               |    |         ...   |    |
 *               |MEM |      ...      |    |
 *               |    |   ...         |    |
 *  mem.size  <--+----+...            |    | {unused area)
 *               |    |   ...         |    |
 *               |REG |      ...      |    |
 *  mem.size     |    |         ...   |    |
 *      +     <--+----+...         ...+----+--> reg.start
 *  reg.size     |    |   ...         |    |
 *               |MEM2|      ...      |    | [PART_1]
 *               |    |         ...   |    |
 *                                 ...+----+--> reg.start + reg.size
 *                                    |    |
 < ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_68.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/nwfpe/fpopcode.h#L116-L140

```c
/*
 < ASCII >
TABLE 4: Monadic Floating Point Opcodes
+---+---+---+---+----------+-----------------------+-----------------------+
| a | b | c | d | Mnemonic | Description           | Operation             |
+---+---+---+---+----------+-----------------------+-----------------------+
| 0 | 0 | 0 | 0 | MVF      | Move                  | Fd := Fm              |
| 0 | 0 | 0 | 1 | MNF      | Move negated          | Fd := - Fm            |
| 0 | 0 | 1 | 0 | ABS      | Absolute value        | Fd := abs(Fm)         |
| 0 | 0 | 1 | 1 | RND      | Round to integer      | Fd := int(Fm)         |
| 0 | 1 | 0 | 0 | SQT      | Square root           | Fd := sqrt(Fm)        |
| 0 | 1 | 0 | 1 | LOG      | Log base 10           | Fd := log10(Fm)       |
| 0 | 1 | 1 | 0 | LGN      | Log base e            | Fd := ln(Fm)          |
| 0 | 1 | 1 | 1 | EXP      | Exponent              | Fd := e ^ Fm          |
| 1 | 0 | 0 | 0 | SIN      | Sine                  | Fd := sin(Fm)         |
| 1 | 0 | 0 | 1 | COS      | Cosine                | Fd := cos(Fm)         |
| 1 | 0 | 1 | 0 | TAN      | Tangent               | Fd := tan(Fm)         |
| 1 | 0 | 1 | 1 | ASN      | Arc Sine              | Fd := arcsin(Fm)      |
| 1 | 1 | 0 | 0 | ACS      | Arc Cosine            | Fd := arccos(Fm)      |
| 1 | 1 | 0 | 1 | ATN      | Arc Tangent           | Fd := arctan(Fm)      |
| 1 | 1 | 1 | 0 | URD      | Unnormalized round    | Fd := int(Fm)         |
| 1 | 1 | 1 | 1 | NRM      | Normalize             | Fd := norm(Fm)        |
+---+---+---+---+----------+-----------------------+-----------------------+
 < ASCII >
Note: LOG, LGN, EXP, SIN, COS, TAN, ASN, ACS, ATN are deprecated, and are
      available for backwards compatibility only.
*/
```
## Visual type:
- #table


== ./linux/linux_680.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/wwan/t7xx/t7xx_modem_ops.c#L238-L258

```c
/* Modem Exception Handshake Flow
 *
 < ASCII >
 * Modem HW Exception interrupt received
 *           (MD_IRQ_CCIF_EX)
 *                   |
 *         +---------v--------+
 *         |   HIF_EX_INIT    | : Disable and clear TXQ
 *         +------------------+
 *                   |
 *         +---------v--------+
 *         | HIF_EX_INIT_DONE | : Wait for the init to be done
 *         +------------------+
 *                   |
 *         +---------v--------+
 *         |HIF_EX_CLEARQ_DONE| : Disable and clear RXQ
 *         +------------------+ : Flush TX/RX workqueues
 *                   |
 *         +---------v--------+
 *         |HIF_EX_ALLQ_RESET | : Restart HW and CLDMA
 *         +------------------+
 < ASCII >
 */
```
## Visual type:
- #flowchart


== ./linux/linux_681.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/net/xen-netback/xenbus.c#L301-L320

```c
/* Handle backend state transitions:
 *
 * The backend state starts in Initialising and the following transitions are
 * allowed.
 *
 < ASCII >
 * Initialising -> InitWait -> Connected
 *          \
 *           \        ^    \         |
 *            \       |     \        |
 *             \      |      \       |
 *              \     |       \      |
 *               \    |        \     |
 *                \   |         \    |
 *                 V  |          V   V
 *
 *                  Closed  <-> Closing
 < ASCII >
 *
 * The state argument specifies the eventual state of the backend and the
 * function transitions to that state via the shortest path.
 */
```
## Visual type:
- #state-machine


== ./linux/linux_682.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/nvdimm/btt.h#L47-L82

```c
/*
 * A log group represents one log 'lane', and consists of four log entries.
 * Two of the four entries are valid entries, and the remaining two are
 * padding. Due to an old bug in the padding location, we need to perform a
 * test to determine the padding scheme being used, and use that scheme
 * thereafter.
 *
 * In kernels prior to 4.15, 'log group' would have actual log entries at
 * indices (0, 2) and padding at indices (1, 3), where as the correct/updated
 * format has log entries at indices (0, 1) and padding at indices (2, 3).
 *
 < ASCII >
 * Old (pre 4.15) format:
 * +-----------------+-----------------+
 * |      ent[0]     |      ent[1]     |
 * |       16B       |       16B       |
 * | lba/old/new/seq |       pad       |
 * +-----------------------------------+
 * |      ent[2]     |      ent[3]     |
 * |       16B       |       16B       |
 * | lba/old/new/seq |       pad       |
 * +-----------------+-----------------+
 *
 * New format:
 * +-----------------+-----------------+
 * |      ent[0]     |      ent[1]     |
 * |       16B       |       16B       |
 * | lba/old/new/seq | lba/old/new/seq |
 * +-----------------------------------+
 * |      ent[2]     |      ent[3]     |
 * |       16B       |       16B       |
 * |       pad       |       pad       |
 * +-----------------+-----------------+
 < ASCII >
 *
 * We detect during start-up which format is in use, and set
 * arena->log_index[(0, 1)] with the detected format.
 */
```
## Visual type:
- #custom


== ./linux/linux_683.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/nvmem/jz4780-efuse.c#L9-L22

```c
/*
 * Currently supports JZ4780 efuse which has 8K programmable bit.
 * Efuse is separated into seven segments as below:
 *
 < ASCII >
 * -----------------------------------------------------------------------
 * | 64 bit | 128 bit | 128 bit | 3520 bit | 8 bit | 2296 bit | 2048 bit |
 * -----------------------------------------------------------------------
 < ASCII >
 *
 * The rom itself is accessed using a 9 bit address line and an 8 word wide bus
 * which reads/writes based on strobes. The strobe is configured in the config
 * register and is based on number of cycles of the bus clock.
 *
 * Driver supports read only as the writes are done in the Factory.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_684.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/nvmem/microchip-otpc.c#L94-L145

```c
/*
 * OTPC memory is organized into packets. Each packets contains a header and
 * a payload. Header is 4 bytes long and contains the size of the payload.
 * Payload size varies. The memory footprint is something as follows:
 *
 < ASCII >
 * Memory offset  Memory footprint     Packet ID
 * -------------  ----------------     ---------
 *
 * 0x0            +------------+   <-- packet 0
 *                | header  0  |
 * 0x4            +------------+
 *                | payload 0  |
 *                .            .
 *                .    ...     .
 *                .            .
 * offset1        +------------+   <-- packet 1
 *                | header  1  |
 * offset1 + 0x4  +------------+
 *                | payload 1  |
 *                .            .
 *                .    ...     .
 *                .            .
 * offset2        +------------+   <-- packet 2
 *                .            .
 *                .    ...     .
 *                .            .
 * offsetN        +------------+   <-- packet N
 *                | header  N  |
 * offsetN + 0x4  +------------+
 *                | payload N  |
 *                .            .
 *                .    ...     .
 *                .            .
 *                +------------+
 < ASCII >
 *
 * where offset1, offset2, offsetN depends on the size of payload 0, payload 1,
 * payload N-1.
 *
 * The access to memory is done on a per packet basis: the control registers
 * need to be updated with an offset address (within a packet range) and the
 * data registers will be update by controller with information contained by
 * that packet. E.g. if control registers are updated with any address within
 * the range [offset1, offset2) the data registers are updated by controller
 * with packet 1. Header data is accessible though MCHP_OTPC_HR register.
 * Payload data is accessible though MCHP_OTPC_DR and MCHP_OTPC_AR registers.
 * There is no direct mapping b/w the offset requested by software and the
 * offset returned by hardware.
 *
 * For this, the read function will return the first requested bytes in the
 * packet. The user will have to be aware of the memory footprint before doing
 * the read request.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_685.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/parisc/ccio-dma.c#L526-L554

```c
/**
 * ccio_io_pdir_entry - Initialize an I/O Pdir.
 * @pdir_ptr: A pointer into I/O Pdir.
 * @sid: The Space Identifier.
 * @vba: The virtual address.
 * @hints: The DMA Hint.
 *
 * Given a virtual address (vba, arg2) and space id, (sid, arg1),
 * load the I/O PDIR entry pointed to by pdir_ptr (arg0). Each IO Pdir
 * entry consists of 8 bytes as shown below (MSB == bit 0):
 *
 *
 < ASCII >
 * WORD 0:
 * +------+----------------+-----------------------------------------------+
 * | Phys | Virtual Index  |               Phys                            |
 * | 0:3  |     0:11       |               4:19                            |
 * |4 bits|   12 bits      |              16 bits                          |
 * +------+----------------+-----------------------------------------------+
 * WORD 1:
 * +-----------------------+-----------------------------------------------+
 * |      Phys    |  Rsvd  | Prefetch |Update |Rsvd  |Lock  |Safe  |Valid  |
 * |     20:39    |        | Enable   |Enable |      |Enable|DMA   |       |
 * |    20 bits   | 5 bits | 1 bit    |1 bit  |2 bits|1 bit |1 bit |1 bit  |
 * +-----------------------+-----------------------------------------------+
 < ASCII >
 *
 * The virtual index field is filled with the results of the LCI
 * (Load Coherence Index) instruction.  The 8 bits used for the virtual
 * index are bits 12:19 of the value returned by LCI.
 */ 
```
## Visual type:
- #memory-layout


== ./linux/linux_686.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/parisc/sba_iommu.c#L531-L569

```c
/**
 * sba_io_pdir_entry - fill in one IO PDIR entry
 * @pdir_ptr:  pointer to IO PDIR entry
 * @sid: process Space ID - currently only support KERNEL_SPACE
 * @vba: Virtual CPU address of buffer to map
 * @hint: DMA hint set to use for this mapping
 *
 * SBA Mapping Routine
 *
 * Given a virtual address (vba, arg2) and space id, (sid, arg1)
 * sba_io_pdir_entry() loads the I/O PDIR entry pointed to by
 * pdir_ptr (arg0). 
 * Using the bass-ackwards HP bit numbering, Each IO Pdir entry
 * for Astro/Ike looks like:
 *
 *
 < ASCII >
 *  0                    19                                 51   55       63
 * +-+---------------------+----------------------------------+----+--------+
 * |V|        U            |            PPN[43:12]            | U  |   VI   |
 * +-+---------------------+----------------------------------+----+--------+
 *
 * Pluto is basically identical, supports fewer physical address bits:
 *
 *  0                       23                              51   55       63
 * +-+------------------------+-------------------------------+----+--------+
 * |V|        U               |         PPN[39:12]            | U  |   VI   |
 * +-+------------------------+-------------------------------+----+--------+
 < ASCII >
 *
 *  V  == Valid Bit  (Most Significant Bit is bit 0)
 *  U  == Unused
 * PPN == Physical Page Number
 * VI  == Virtual Index (aka Coherent Index)
 *
 * LPA instruction output is put into PPN field.
 * LCI (Load Coherence Index) instruction provides the "VI" bits.
 *
 * We pre-swap the bytes since PCX-W is Big Endian and the
 * IOMMU uses little endian for the pdir.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_687.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/p2pdma.c#L537-L572

```c
/*
 * Calculate the P2PDMA mapping type and distance between two PCI devices.
 *
 * If the two devices are the same PCI function, return
 * PCI_P2PDMA_MAP_BUS_ADDR and a distance of 0.
 *
 * If they are two functions of the same device, return
 * PCI_P2PDMA_MAP_BUS_ADDR and a distance of 2 (one hop up to the bridge,
 * then one hop back down to another function of the same device).
 *
 * In the case where two devices are connected to the same PCIe switch,
 * return a distance of 4. This corresponds to the following PCI tree:
 *
 < ASCII >
 *     -+  Root Port
 *      \+ Switch Upstream Port
 *       +-+ Switch Downstream Port 0
 *       + \- Device A
 *       \-+ Switch Downstream Port 1
 *         \- Device B
 < ASCII >
 *
 * The distance is 4 because we traverse from Device A to Downstream Port 0
 * to the common Switch Upstream Port, back down to Downstream Port 1 and
 * then to Device B. The mapping type returned depends on the ACS
 * redirection setting of the ports along the path.
 *
 * If ACS redirect is set on any port in the path, traffic between the
 * devices will go through the host bridge, so return
 * PCI_P2PDMA_MAP_THRU_HOST_BRIDGE; otherwise return
 * PCI_P2PDMA_MAP_BUS_ADDR.
 *
 * Any two devices that have a data path that goes through the host bridge
 * will consult a whitelist. If the host bridge is in the whitelist, return
 * PCI_P2PDMA_MAP_THRU_HOST_BRIDGE with the distance set to the number of
 * ports per above. If the device is not in the whitelist, return
 * PCI_P2PDMA_MAP_NOT_SUPPORTED.
 */
```
## Visual type:
- #tree


== ./linux/linux_688.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-ntb.c#L9-L35

```c
/*
 * The PCI NTB function driver configures the SoC with multiple PCIe Endpoint
 * (EP) controller instances (see diagram below) in such a way that
 * transactions from one EP controller are routed to the other EP controller.
 * Once PCI NTB function driver configures the SoC with multiple EP instances,
 * HOST1 and HOST2 can communicate with each other using SoC as a bridge.
 *
 < ASCII >
 *    +-------------+                                   +-------------+
 *    |             |                                   |             |
 *    |    HOST1    |                                   |    HOST2    |
 *    |             |                                   |             |
 *    +------^------+                                   +------^------+
 *           |                                                 |
 *           |                                                 |
 * +---------|-------------------------------------------------|---------+
 * |  +------v------+                                   +------v------+  |
 * |  |             |                                   |             |  |
 * |  |     EP      |                                   |     EP      |  |
 * |  | CONTROLLER1 |                                   | CONTROLLER2 |  |
 * |  |             <----------------------------------->             |  |
 * |  |             |                                   |             |  |
 * |  |             |                                   |             |  |
 * |  |             |  SoC With Multiple EP Instances   |             |  |
 * |  |             |  (Configured using NTB Function)  |             |  |
 * |  +-------------+                                   +-------------+  |
 * +---------------------------------------------------------------------+
 < ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_689.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-ntb.c#L175-L234

```c
/**
 * epf_ntb_configure_mw() - Configure the Outbound Address Space for one host
 *   to access the memory window of other host
 * @ntb: NTB device that facilitates communication between HOST1 and HOST2
 * @type: PRIMARY interface or SECONDARY interface
 * @mw: Index of the memory window (either 0, 1, 2 or 3)
 *
 < ASCII >
 * +-----------------+    +---->+----------------+-----------+-----------------+
 * |       BAR0      |    |     |   Doorbell 1   +-----------> MSI|X ADDRESS 1 |
 * +-----------------+    |     +----------------+           +-----------------+
 * |       BAR1      |    |     |   Doorbell 2   +---------+ |                 |
 * +-----------------+----+     +----------------+         | |                 |
 * |       BAR2      |          |   Doorbell 3   +-------+ | +-----------------+
 * +-----------------+----+     +----------------+       | +-> MSI|X ADDRESS 2 |
 * |       BAR3      |    |     |   Doorbell 4   +-----+ |   +-----------------+
 * +-----------------+    |     |----------------+     | |   |                 |
 * |       BAR4      |    |     |                |     | |   +-----------------+
 * +-----------------+    |     |      MW1       +---+ | +-->+ MSI|X ADDRESS 3||
 * |       BAR5      |    |     |                |   | |     +-----------------+
 * +-----------------+    +---->-----------------+   | |     |                 |
 *   EP CONTROLLER 1            |                |   | |     +-----------------+
 *                              |                |   | +---->+ MSI|X ADDRESS 4 |
 *                              +----------------+   |       +-----------------+
 *                      (A)      EP CONTROLLER 2     |       |                 |
 *                                 (OB SPACE)        |       |                 |
 *                                                   +------->      MW1        |
 *                                                           |                 |
 *                                                           |                 |
 *                                                   (B)     +-----------------+
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           +-----------------+
 *                                                           PCI Address Space
 *                                                           (Managed by HOST2)
 < ASCII >
 *
 * This function performs stage (B) in the above diagram (see MW1) i.e., map OB
 * address space of memory window to PCI address space.
 *
 * This operation requires 3 parameters
 *  1) Address in the outbound address space
 *  2) Address in the PCI Address space
 *  3) Size of the address region to be mapped
 *
 * The address in the outbound address space (for MW1, MW2, MW3 and MW4) is
 * stored in epf_bar corresponding to BAR_DB_MW1 for MW1 and BAR_MW2, BAR_MW3
 * BAR_MW4 for rest of the BARs of epf_ntb_epc that is connected to HOST1. This
 * is populated in epf_ntb_alloc_peer_mem() in this driver.
 *
 * The address and size of the PCI address region that has to be mapped would
 * be provided by HOST2 in ctrl->addr and ctrl->size of epf_ntb_epc that is
 * connected to HOST2.
 *
 * Please note Memory window1 (MW1) and Doorbell registers together will be
 * mapped to a single BAR (BAR2) above for 32-bit BARs. The exact BAR that's
 * used for Memory window (MW) can be obtained from epf_ntb_bar[BAR_DB_MW1],
 * epf_ntb_bar[BAR_MW2], epf_ntb_bar[BAR_MW2], epf_ntb_bar[BAR_MW2].
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_69.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/plat-orion/gpio.c#L325-L349

```c
/*****************************************************************************
 * Orion GPIO IRQ
 *
 * GPIO_IN_POL register controls whether GPIO_DATA_IN will hold the same
 * value of the line or the opposite value.
 *
 * Level IRQ handlers: DATA_IN is used directly as cause register.
 *                     Interrupt are masked by LEVEL_MASK registers.
 * Edge IRQ handlers:  Change in DATA_IN are latched in EDGE_CAUSE.
 *                     Interrupt are masked by EDGE_MASK registers.
 * Both-edge handlers: Similar to regular Edge handlers, but also swaps
 *                     the polarity to catch the next line transaction.
 *                     This is a race condition that might not perfectly
 *                     work on some use cases.
 *
 * Every eight GPIO lines are grouped (OR'ed) before going up to main
 * cause register.
 < ASCII >
 *
 *                    EDGE  cause    mask
 *        data-in   /--------| |-----| |----\
 *     -----| |-----                         ---- to main cause reg
 *           X      \----------------| |----/
 *        polarity    LEVEL          mask
 < ASCII >
 *
 ****************************************************************************/
```
## Visual type:
- #custom


== ./linux/linux_690.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-ntb.c#L322-L382

```c
/**
 * epf_ntb_configure_msi() - Map OB address space to MSI address
 * @ntb: NTB device that facilitates communication between HOST1 and HOST2
 * @type: PRIMARY interface or SECONDARY interface
 * @db_count: Number of doorbell interrupts to map
 *
 < ASCII >
 *+-----------------+    +----->+----------------+-----------+-----------------+
 *|       BAR0      |    |      |   Doorbell 1   +---+------->   MSI ADDRESS   |
 *+-----------------+    |      +----------------+   |       +-----------------+
 *|       BAR1      |    |      |   Doorbell 2   +---+       |                 |
 *+-----------------+----+      +----------------+   |       |                 |
 *|       BAR2      |           |   Doorbell 3   +---+       |                 |
 *+-----------------+----+      +----------------+   |       |                 |
 *|       BAR3      |    |      |   Doorbell 4   +---+       |                 |
 *+-----------------+    |      |----------------+           |                 |
 *|       BAR4      |    |      |                |           |                 |
 *+-----------------+    |      |      MW1       |           |                 |
 *|       BAR5      |    |      |                |           |                 |
 *+-----------------+    +----->-----------------+           |                 |
 *  EP CONTROLLER 1             |                |           |                 |
 *                              |                |           |                 |
 *                              +----------------+           +-----------------+
 *                     (A)       EP CONTROLLER 2             |                 |
 *                                 (OB SPACE)                |                 |
 *                                                           |      MW1        |
 *                                                           |                 |
 *                                                           |                 |
 *                                                   (B)     +-----------------+
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           +-----------------+
 *                                                           PCI Address Space
 *                                                           (Managed by HOST2)
 < ASCII >
 *
 *
 * This function performs stage (B) in the above diagram (see Doorbell 1,
 * Doorbell 2, Doorbell 3, Doorbell 4) i.e map OB address space corresponding to
 * doorbell to MSI address in PCI address space.
 *
 * This operation requires 3 parameters
 *  1) Address reserved for doorbell in the outbound address space
 *  2) MSI-X address in the PCIe Address space
 *  3) Number of MSI-X interrupts that has to be configured
 *
 * The address in the outbound address space (for the Doorbell) is stored in
 * epf_bar corresponding to BAR_DB_MW1 of epf_ntb_epc that is connected to
 * HOST1. This is populated in epf_ntb_alloc_peer_mem() in this driver along
 * with address for MW1.
 *
 * pci_epc_map_msi_irq() takes the MSI address from MSI capability register
 * and maps the OB address (obtained in epf_ntb_alloc_peer_mem()) to the MSI
 * address.
 *
 * epf_ntb_configure_msi() also stores the MSI data to raise each interrupt
 * in db_data of the peer's control region. This helps the peer to raise
 * doorbell of the other host by writing db_data to the BAR corresponding to
 * BAR_DB_MW1.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_691.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-ntb.c#L425-L486

```c
/**
 * epf_ntb_configure_msix() - Map OB address space to MSI-X address
 * @ntb: NTB device that facilitates communication between HOST1 and HOST2
 * @type: PRIMARY interface or SECONDARY interface
 * @db_count: Number of doorbell interrupts to map
 *
 < ASCII >
 *+-----------------+    +----->+----------------+-----------+-----------------+
 *|       BAR0      |    |      |   Doorbell 1   +-----------> MSI-X ADDRESS 1 |
 *+-----------------+    |      +----------------+           +-----------------+
 *|       BAR1      |    |      |   Doorbell 2   +---------+ |                 |
 *+-----------------+----+      +----------------+         | |                 |
 *|       BAR2      |           |   Doorbell 3   +-------+ | +-----------------+
 *+-----------------+----+      +----------------+       | +-> MSI-X ADDRESS 2 |
 *|       BAR3      |    |      |   Doorbell 4   +-----+ |   +-----------------+
 *+-----------------+    |      |----------------+     | |   |                 |
 *|       BAR4      |    |      |                |     | |   +-----------------+
 *+-----------------+    |      |      MW1       +     | +-->+ MSI-X ADDRESS 3||
 *|       BAR5      |    |      |                |     |     +-----------------+
 *+-----------------+    +----->-----------------+     |     |                 |
 *  EP CONTROLLER 1             |                |     |     +-----------------+
 *                              |                |     +---->+ MSI-X ADDRESS 4 |
 *                              +----------------+           +-----------------+
 *                     (A)       EP CONTROLLER 2             |                 |
 *                                 (OB SPACE)                |                 |
 *                                                           |      MW1        |
 *                                                           |                 |
 *                                                           |                 |
 *                                                   (B)     +-----------------+
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           +-----------------+
 *                                                           PCI Address Space
 *                                                           (Managed by HOST2)
 < ASCII >
 *
 * This function performs stage (B) in the above diagram (see Doorbell 1,
 * Doorbell 2, Doorbell 3, Doorbell 4) i.e map OB address space corresponding to
 * doorbell to MSI-X address in PCI address space.
 *
 * This operation requires 3 parameters
 *  1) Address reserved for doorbell in the outbound address space
 *  2) MSI-X address in the PCIe Address space
 *  3) Number of MSI-X interrupts that has to be configured
 *
 * The address in the outbound address space (for the Doorbell) is stored in
 * epf_bar corresponding to BAR_DB_MW1 of epf_ntb_epc that is connected to
 * HOST1. This is populated in epf_ntb_alloc_peer_mem() in this driver along
 * with address for MW1.
 *
 * The MSI-X address is in the MSI-X table of EP CONTROLLER 2 and
 * the count of doorbell is in ctrl->argument of epf_ntb_epc that is connected
 * to HOST2. MSI-X table is stored memory mapped to ntb_epc->msix_bar and the
 * offset is in ntb_epc->msix_table_offset. From this epf_ntb_configure_msix()
 * gets the MSI-X address and data.
 *
 * epf_ntb_configure_msix() also stores the MSI-X data to raise each interrupt
 * in db_data of the peer's control region. This helps the peer to raise
 * doorbell of the other host by writing db_data to the BAR corresponding to
 * BAR_DB_MW1.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_692.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-ntb.c#L704-L733

```c
/**
 * epf_ntb_peer_spad_bar_clear() - Clear Peer Scratchpad BAR
 * @ntb_epc: EPC associated with one of the HOST which holds peer's outbound
 *	     address.
 *
 < ASCII >
 *+-----------------+------->+------------------+        +-----------------+
 *|       BAR0      |        |  CONFIG REGION   |        |       BAR0      |
 *+-----------------+----+   +------------------+<-------+-----------------+
 *|       BAR1      |    |   |SCRATCHPAD REGION |        |       BAR1      |
 *+-----------------+    +-->+------------------+<-------+-----------------+
 *|       BAR2      |            Local Memory            |       BAR2      |
 *+-----------------+                                    +-----------------+
 *|       BAR3      |                                    |       BAR3      |
 *+-----------------+                                    +-----------------+
 *|       BAR4      |                                    |       BAR4      |
 *+-----------------+                                    +-----------------+
 *|       BAR5      |                                    |       BAR5      |
 *+-----------------+                                    +-----------------+
 *  EP CONTROLLER 1                                        EP CONTROLLER 2
 < ASCII >
 *
 * Clear BAR1 of EP CONTROLLER 2 which contains the HOST2's peer scratchpad
 * region. While BAR1 is the default peer scratchpad BAR, an NTB could have
 * other BARs for peer scratchpad (because of 64-bit BARs or reserved BARs).
 * This function can get the exact BAR used for peer scratchpad from
 * epf_ntb_bar[BAR_PEER_SPAD].
 *
 * Since HOST2's peer scratchpad is also HOST1's self scratchpad, this function
 * gets the address of peer scratchpad from
 * peer_ntb_epc->epf_ntb_bar[BAR_CONFIG].
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_693.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-ntb.c#L749-L778

```c
/**
 * epf_ntb_peer_spad_bar_set() - Set peer scratchpad BAR
 * @ntb: NTB device that facilitates communication between HOST1 and HOST2
 * @type: PRIMARY interface or SECONDARY interface
 *
 < ASCII >
 *+-----------------+------->+------------------+        +-----------------+
 *|       BAR0      |        |  CONFIG REGION   |        |       BAR0      |
 *+-----------------+----+   +------------------+<-------+-----------------+
 *|       BAR1      |    |   |SCRATCHPAD REGION |        |       BAR1      |
 *+-----------------+    +-->+------------------+<-------+-----------------+
 *|       BAR2      |            Local Memory            |       BAR2      |
 *+-----------------+                                    +-----------------+
 *|       BAR3      |                                    |       BAR3      |
 *+-----------------+                                    +-----------------+
 *|       BAR4      |                                    |       BAR4      |
 *+-----------------+                                    +-----------------+
 *|       BAR5      |                                    |       BAR5      |
 *+-----------------+                                    +-----------------+
 *  EP CONTROLLER 1                                        EP CONTROLLER 2
 < ASCII >
 *
 * Set BAR1 of EP CONTROLLER 2 which contains the HOST2's peer scratchpad
 * region. While BAR1 is the default peer scratchpad BAR, an NTB could have
 * other BARs for peer scratchpad (because of 64-bit BARs or reserved BARs).
 * This function can get the exact BAR used for peer scratchpad from
 * epf_ntb_bar[BAR_PEER_SPAD].
 *
 * Since HOST2's peer scratchpad is also HOST1's self scratchpad, this function
 * gets the address of peer scratchpad from
 * peer_ntb_epc->epf_ntb_bar[BAR_CONFIG].
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_694.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-ntb.c#L820-L849

```c
/**
 * epf_ntb_config_sspad_bar_clear() - Clear Config + Self scratchpad BAR
 * @ntb_epc: EPC associated with one of the HOST which holds peer's outbound
 *	     address.
 *
 < ASCII >
 * +-----------------+------->+------------------+        +-----------------+
 * |       BAR0      |        |  CONFIG REGION   |        |       BAR0      |
 * +-----------------+----+   +------------------+<-------+-----------------+
 * |       BAR1      |    |   |SCRATCHPAD REGION |        |       BAR1      |
 * +-----------------+    +-->+------------------+<-------+-----------------+
 * |       BAR2      |            Local Memory            |       BAR2      |
 * +-----------------+                                    +-----------------+
 * |       BAR3      |                                    |       BAR3      |
 * +-----------------+                                    +-----------------+
 * |       BAR4      |                                    |       BAR4      |
 * +-----------------+                                    +-----------------+
 * |       BAR5      |                                    |       BAR5      |
 * +-----------------+                                    +-----------------+
 *   EP CONTROLLER 1                                        EP CONTROLLER 2
 < ASCII >
 *
 * Clear BAR0 of EP CONTROLLER 1 which contains the HOST1's config and
 * self scratchpad region (removes inbound ATU configuration). While BAR0 is
 * the default self scratchpad BAR, an NTB could have other BARs for self
 * scratchpad (because of reserved BARs). This function can get the exact BAR
 * used for self scratchpad from epf_ntb_bar[BAR_CONFIG].
 *
 * Please note the self scratchpad region and config region is combined to
 * a single region and mapped using the same BAR. Also note HOST2's peer
 * scratchpad is HOST1's self scratchpad.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_695.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-ntb.c#L865-L894

```c
/**
 * epf_ntb_config_sspad_bar_set() - Set Config + Self scratchpad BAR
 * @ntb_epc: EPC associated with one of the HOST which holds peer's outbound
 *	     address.
 *
 < ASCII >
 * +-----------------+------->+------------------+        +-----------------+
 * |       BAR0      |        |  CONFIG REGION   |        |       BAR0      |
 * +-----------------+----+   +------------------+<-------+-----------------+
 * |       BAR1      |    |   |SCRATCHPAD REGION |        |       BAR1      |
 * +-----------------+    +-->+------------------+<-------+-----------------+
 * |       BAR2      |            Local Memory            |       BAR2      |
 * +-----------------+                                    +-----------------+
 * |       BAR3      |                                    |       BAR3      |
 * +-----------------+                                    +-----------------+
 * |       BAR4      |                                    |       BAR4      |
 * +-----------------+                                    +-----------------+
 * |       BAR5      |                                    |       BAR5      |
 * +-----------------+                                    +-----------------+
 *   EP CONTROLLER 1                                        EP CONTROLLER 2
 < ASCII >
 *
 * Map BAR0 of EP CONTROLLER 1 which contains the HOST1's config and
 * self scratchpad region. While BAR0 is the default self scratchpad BAR, an
 * NTB could have other BARs for self scratchpad (because of reserved BARs).
 * This function can get the exact BAR used for self scratchpad from
 * epf_ntb_bar[BAR_CONFIG].
 *
 * Please note the self scratchpad region and config region is combined to
 * a single region and mapped using the same BAR. Also note HOST2's peer
 * scratchpad is HOST1's self scratchpad.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_696.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-ntb.c#L924-L947

```c
/**
 * epf_ntb_config_spad_bar_free() - Free the physical memory associated with
 *   config + scratchpad region
 * @ntb: NTB device that facilitates communication between HOST1 and HOST2
 *
 < ASCII >
 * +-----------------+------->+------------------+        +-----------------+
 * |       BAR0      |        |  CONFIG REGION   |        |       BAR0      |
 * +-----------------+----+   +------------------+<-------+-----------------+
 * |       BAR1      |    |   |SCRATCHPAD REGION |        |       BAR1      |
 * +-----------------+    +-->+------------------+<-------+-----------------+
 * |       BAR2      |            Local Memory            |       BAR2      |
 * +-----------------+                                    +-----------------+
 * |       BAR3      |                                    |       BAR3      |
 * +-----------------+                                    +-----------------+
 * |       BAR4      |                                    |       BAR4      |
 * +-----------------+                                    +-----------------+
 * |       BAR5      |                                    |       BAR5      |
 * +-----------------+                                    +-----------------+
 *   EP CONTROLLER 1                                        EP CONTROLLER 2
 < ASCII >
 *
 * Free the Local Memory mentioned in the above diagram. After invoking this
 * function, any of config + self scratchpad region of HOST1 or peer scratchpad
 * region of HOST2 should not be accessed.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_697.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-ntb.c#L964-L992

```c
/**
 * epf_ntb_config_spad_bar_alloc() - Allocate memory for config + scratchpad
 *   region
 * @ntb: NTB device that facilitates communication between HOST1 and HOST2
 * @type: PRIMARY interface or SECONDARY interface
 *
 < ASCII >
 * +-----------------+------->+------------------+        +-----------------+
 * |       BAR0      |        |  CONFIG REGION   |        |       BAR0      |
 * +-----------------+----+   +------------------+<-------+-----------------+
 * |       BAR1      |    |   |SCRATCHPAD REGION |        |       BAR1      |
 * +-----------------+    +-->+------------------+<-------+-----------------+
 * |       BAR2      |            Local Memory            |       BAR2      |
 * +-----------------+                                    +-----------------+
 * |       BAR3      |                                    |       BAR3      |
 * +-----------------+                                    +-----------------+
 * |       BAR4      |                                    |       BAR4      |
 * +-----------------+                                    +-----------------+
 * |       BAR5      |                                    |       BAR5      |
 * +-----------------+                                    +-----------------+
 *   EP CONTROLLER 1                                        EP CONTROLLER 2
 < ASCII >
 *
 * Allocate the Local Memory mentioned in the above diagram. The size of
 * CONFIG REGION is sizeof(struct epf_ntb_ctrl) and size of SCRATCHPAD REGION
 * is obtained from "spad-count" configfs entry.
 *
 * The size of both config region and scratchpad region has to be aligned,
 * since the scratchpad region will also be mapped as PEER SCRATCHPAD of
 * other host using a separate BAR.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_698.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-ntb.c#L1117-L1157

```c
/**
 * epf_ntb_free_peer_mem() - Free memory allocated in peers outbound address
 *   space
 * @ntb_epc: EPC associated with one of the HOST which holds peers outbound
 *   address regions
 *
 < ASCII >
 * +-----------------+    +---->+----------------+-----------+-----------------+
 * |       BAR0      |    |     |   Doorbell 1   +-----------> MSI|X ADDRESS 1 |
 * +-----------------+    |     +----------------+           +-----------------+
 * |       BAR1      |    |     |   Doorbell 2   +---------+ |                 |
 * +-----------------+----+     +----------------+         | |                 |
 * |       BAR2      |          |   Doorbell 3   +-------+ | +-----------------+
 * +-----------------+----+     +----------------+       | +-> MSI|X ADDRESS 2 |
 * |       BAR3      |    |     |   Doorbell 4   +-----+ |   +-----------------+
 * +-----------------+    |     |----------------+     | |   |                 |
 * |       BAR4      |    |     |                |     | |   +-----------------+
 * +-----------------+    |     |      MW1       +---+ | +-->+ MSI|X ADDRESS 3||
 * |       BAR5      |    |     |                |   | |     +-----------------+
 * +-----------------+    +---->-----------------+   | |     |                 |
 *   EP CONTROLLER 1            |                |   | |     +-----------------+
 *                              |                |   | +---->+ MSI|X ADDRESS 4 |
 *                              +----------------+   |       +-----------------+
 *                      (A)      EP CONTROLLER 2     |       |                 |
 *                                 (OB SPACE)        |       |                 |
 *                                                   +------->      MW1        |
 *                                                           |                 |
 *                                                           |                 |
 *                                                   (B)     +-----------------+
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           +-----------------+
 *                                                           PCI Address Space
 *                                                           (Managed by HOST2)
 < ASCII >
 *
 * Free memory allocated in EP CONTROLLER 2 (OB SPACE) in the above diagram.
 * It'll free Doorbell 1, Doorbell 2, Doorbell 3, Doorbell 4, MW1 (and MW2, MW3,
 * MW4).
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_699.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-ntb.c#L1183-L1222

```c
/**
 * epf_ntb_db_mw_bar_clear() - Clear doorbell and memory BAR
 * @ntb_epc: EPC associated with one of the HOST which holds peer's outbound
 *   address
 *
 < ASCII >
 * +-----------------+    +---->+----------------+-----------+-----------------+
 * |       BAR0      |    |     |   Doorbell 1   +-----------> MSI|X ADDRESS 1 |
 * +-----------------+    |     +----------------+           +-----------------+
 * |       BAR1      |    |     |   Doorbell 2   +---------+ |                 |
 * +-----------------+----+     +----------------+         | |                 |
 * |       BAR2      |          |   Doorbell 3   +-------+ | +-----------------+
 * +-----------------+----+     +----------------+       | +-> MSI|X ADDRESS 2 |
 * |       BAR3      |    |     |   Doorbell 4   +-----+ |   +-----------------+
 * +-----------------+    |     |----------------+     | |   |                 |
 * |       BAR4      |    |     |                |     | |   +-----------------+
 * +-----------------+    |     |      MW1       +---+ | +-->+ MSI|X ADDRESS 3||
 * |       BAR5      |    |     |                |   | |     +-----------------+
 * +-----------------+    +---->-----------------+   | |     |                 |
 *   EP CONTROLLER 1            |                |   | |     +-----------------+
 *                              |                |   | +---->+ MSI|X ADDRESS 4 |
 *                              +----------------+   |       +-----------------+
 *                      (A)      EP CONTROLLER 2     |       |                 |
 *                                 (OB SPACE)        |       |                 |
 *                                                   +------->      MW1        |
 *                                                           |                 |
 *                                                           |                 |
 *                                                   (B)     +-----------------+
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           +-----------------+
 *                                                           PCI Address Space
 *                                                           (Managed by HOST2)
 < ASCII >
 *
 * Clear doorbell and memory BARs (remove inbound ATU configuration). In the above
 * diagram it clears BAR2 TO BAR5 of EP CONTROLLER 1 (Doorbell BAR, MW1 BAR, MW2
 * BAR, MW3 BAR and MW4 BAR).
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_7.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/include/asm/dma.h#L28-L74

```c
/*
 * NOTES about DMA transfers:
 *
 *  controller 1: channels 0-3, byte operations, ports 00-1F
 *  controller 2: channels 4-7, word operations, ports C0-DF
 *
 *  - ALL registers are 8 bits only, regardless of transfer size
 *  - channel 4 is not used - cascades 1 into 2.
 *  - channels 0-3 are byte - addresses/counts are for physical bytes
 *  - channels 5-7 are word - addresses/counts are for physical words
 *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
 *  - transfer count loaded to registers is 1 less than actual count
 *  - controller 2 offsets are all even (2x offsets for controller 1)
 *  - page registers for 5-7 don't use data bit 0, represent 128K pages
 *  - page registers for 0-3 use bit 0, represent 64K pages
 *
 * DMA transfers are limited to the lower 16MB of _physical_ memory.  
 * Note that addresses loaded into registers must be _physical_ addresses,
 * not logical addresses (which may differ if paging is active).
 *
 < ASCII >
 *  Address mapping for channels 0-3:
 *
 *   A23 ... A16 A15 ... A8  A7 ... A0    (Physical addresses)
 *    |  ...  |   |  ... |   |  ... |
 *    |  ...  |   |  ... |   |  ... |
 *    |  ...  |   |  ... |   |  ... |
 *   P7  ...  P0  A7 ... A0  A7 ... A0   
 * |    Page    | Addr MSB | Addr LSB |   (DMA registers)
 *
 *  Address mapping for channels 5-7:
 *
 *   A23 ... A17 A16 A15 ... A9 A8 A7 ... A1 A0    (Physical addresses)
 *    |  ...  |   \   \   ... \  \  \  ... \  \
 *    |  ...  |    \   \   ... \  \  \  ... \  (not used)
 *    |  ...  |     \   \   ... \  \  \  ... \
 *   P7  ...  P1 (0) A7 A6  ... A0 A7 A6 ... A0   
 * |      Page      |  Addr MSB   |  Addr LSB  |   (DMA registers)
 < ASCII >
 *
 * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
 * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
 * the hardware level, so odd-byte transfers aren't possible).
 *
 * Transfer count (_not # bytes_) is limited to 64K, represented as actual
 * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
 * and up to 128K bytes may be transferred on channels 5-7 in one operation. 
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_70.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/probes/decode.c#L237-L245

```c
/*
 * When we modify the register numbers encoded in an instruction to be emulated,
 * the new values come from this define. For ARM and 32-bit Thumb instructions
 * this gives...
 *
 < ASCII >
 *	bit position	  16  12   8   4   0
 *	---------------+---+---+---+---+---+
 *	register	 r2  r0  r1  --  r3
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_700.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-ntb.c#L1330-L1375

```c
/**
 * epf_ntb_alloc_peer_mem() - Allocate memory in peer's outbound address space
 * @dev: The PCI device.
 * @ntb_epc: EPC associated with one of the HOST whose BAR holds peer's outbound
 *   address
 * @bar: BAR of @ntb_epc in for which memory has to be allocated (could be
 *   BAR_DB_MW1, BAR_MW2, BAR_MW3, BAR_MW4)
 * @peer_ntb_epc: EPC associated with HOST whose outbound address space is
 *   used by @ntb_epc
 * @size: Size of the address region that has to be allocated in peers OB SPACE
 *
 *
 < ASCII >
 * +-----------------+    +---->+----------------+-----------+-----------------+
 * |       BAR0      |    |     |   Doorbell 1   +-----------> MSI|X ADDRESS 1 |
 * +-----------------+    |     +----------------+           +-----------------+
 * |       BAR1      |    |     |   Doorbell 2   +---------+ |                 |
 * +-----------------+----+     +----------------+         | |                 |
 * |       BAR2      |          |   Doorbell 3   +-------+ | +-----------------+
 * +-----------------+----+     +----------------+       | +-> MSI|X ADDRESS 2 |
 * |       BAR3      |    |     |   Doorbell 4   +-----+ |   +-----------------+
 * +-----------------+    |     |----------------+     | |   |                 |
 * |       BAR4      |    |     |                |     | |   +-----------------+
 * +-----------------+    |     |      MW1       +---+ | +-->+ MSI|X ADDRESS 3||
 * |       BAR5      |    |     |                |   | |     +-----------------+
 * +-----------------+    +---->-----------------+   | |     |                 |
 *   EP CONTROLLER 1            |                |   | |     +-----------------+
 *                              |                |   | +---->+ MSI|X ADDRESS 4 |
 *                              +----------------+   |       +-----------------+
 *                      (A)      EP CONTROLLER 2     |       |                 |
 *                                 (OB SPACE)        |       |                 |
 *                                                   +------->      MW1        |
 *                                                           |                 |
 *                                                           |                 |
 *                                                   (B)     +-----------------+
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           |                 |
 *                                                           +-----------------+
 *                                                           PCI Address Space
 *                                                           (Managed by HOST2)
 < ASCII >
 *
 * Allocate memory in OB space of EP CONTROLLER 2 in the above diagram. Allocate
 * for Doorbell 1, Doorbell 2, Doorbell 3, Doorbell 4, MW1 (and MW2, MW3, MW4).
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_701.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-vntb.c#L14-L37

```c
/*
 < ASCII >
 * +------------+         +---------------------------------------+
 * |            |         |                                       |
 * +------------+         |                        +--------------+
 * | NTB        |         |                        | NTB          |
 * | NetDev     |         |                        | NetDev       |
 * +------------+         |                        +--------------+
 * | NTB        |         |                        | NTB          |
 * | Transfer   |         |                        | Transfer     |
 * +------------+         |                        +--------------+
 * |            |         |                        |              |
 * |  PCI NTB   |         |                        |              |
 * |    EPF     |         |                        |              |
 * |   Driver   |         |                        | PCI Virtual  |
 * |            |         +---------------+        | NTB Driver   |
 * |            |         | PCI EP NTB    |<------>|              |
 * |            |         |  FN Driver    |        |              |
 * +------------+         +---------------+        +--------------+
 * |            |         |               |        |              |
 * |  PCI Bus   | <-----> |  PCI EP Bus   |        |  Virtual PCI |
 * |            |  PCI    |               |        |     Bus      |
 * +------------+         +---------------+--------+--------------+
 * PCIe Root Port                        PCI EP
 < ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_702.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-vntb.c#L78-L100

```c
/*
 < ASCII >
 * +--------------------------------------------------+ Base
 * |                                                  |
 * |                                                  |
 * |                                                  |
 * |          Common Control Register                 |
 * |                                                  |
 * |                                                  |
 * |                                                  |
 * +-----------------------+--------------------------+ Base+span_offset
 * |                       |                          |
 * |    Peer Span Space    |    Span Space            |
 * |                       |                          |
 * |                       |                          |
 * +-----------------------+--------------------------+ Base+span_offset
 * |                       |                          |     +span_count * 4
 * |                       |                          |
 * |     Span Space        |   Peer Span Space        |
 * |                       |                          |
 * +-----------------------+--------------------------+
 *       Virtual PCI             PCIe Endpoint
 *       NTB Driver               NTB Driver
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_703.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pci/endpoint/functions/pci-epf-vntb.c#L178-L201

```c
/**
 * epf_ntb_configure_mw() - Configure the Outbound Address Space for VHOST
 *   to access the memory window of HOST
 * @ntb: NTB device that facilitates communication between HOST and VHOST
 * @mw: Index of the memory window (either 0, 1, 2 or 3)
 *
 < ASCII >
 *                          EP Outbound Window
 * +--------+              +-----------+
 * |        |              |           |
 * |        |              |           |
 * |        |              |           |
 * |        |              |           |
 * |        |              +-----------+
 * | Virtual|              | Memory Win|
 * | NTB    | -----------> |           |
 * | Driver |              |           |
 * |        |              +-----------+
 * |        |              |           |
 * |        |              |           |
 * +--------+              +-----------+
 *  VHOST                   PCI EP
 < ASCII >
 *
 * Returns: Zero for success, or an error code in case of failure
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_704.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/perf/hisilicon/hns3_pmu.c#L76-L105

```c
/*
 * Each hardware event contains two registers (counter and ext_counter) for
 * bandwidth, packet rate, latency and interrupt rate. These two registers will
 * be triggered to run at the same when a hardware event is enabled. The meaning
 * of counter and ext_counter of different event type are different, their
 * meaning show as follow:
 *
 < ASCII >
 * +----------------+------------------+---------------+
 * |   event type   |     counter      |  ext_counter  |
 * +----------------+------------------+---------------+
 * | bandwidth      | byte number      | cycle number  |
 * +----------------+------------------+---------------+
 * | packet rate    | packet number    | cycle number  |
 * +----------------+------------------+---------------+
 * | latency        | cycle number     | packet number |
 * +----------------+------------------+---------------+
 * | interrupt rate | interrupt number | cycle number  |
 * +----------------+------------------+---------------+
 < ASCII >
 *
 * The cycle number indicates increment of counter of hardware timer, the
 * frequency of hardware timer can be read from hw_clk_freq file.
 *
 * Performance of each hardware event is calculated by: counter / ext_counter.
 *
 * Since processing of data is preferred to be done in userspace, we expose
 * ext_counter as a separate event for userspace and use bit 16 to indicate it.
 * For example, event 0x00001 and 0x10001 are actually one event for hardware
 * because bit 0-15 are same. If the bit 16 of one event is 0 means to read
 * counter register, otherwise means to read ext_counter register.
 */
```
## Visual type:
- #table


== ./linux/linux_705.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/phy/qualcomm/phy-qcom-edp.c#L613-L661

```c
/*
 * Embedded Display Port PLL driver block diagram for branch clocks
 *
 < ASCII >
 *              +------------------------------+
 *              |        EDP_VCO_CLK           |
 *              |                              |
 *              |    +-------------------+     |
 *              |    |  (EDP PLL/VCO)    |     |
 *              |    +---------+---------+     |
 *              |              v               |
 *              |   +----------+-----------+   |
 *              |   | hsclk_divsel_clk_src |   |
 *              |   +----------+-----------+   |
 *              +------------------------------+
 *                              |
 *          +---------<---------v------------>----------+
 *          |                                           |
 * +--------v----------------+                          |
 * |   edp_phy_pll_link_clk  |                          |
 * |     link_clk            |                          |
 * +--------+----------------+                          |
 *          |                                           |
 *          |                                           |
 *          v                                           v
 * Input to DISPCC block                                |
 * for link clk, crypto clk                             |
 * and interface clock                                  |
 *                                                      |
 *                                                      |
 *      +--------<------------+-----------------+---<---+
 *      |                     |                 |
 * +----v---------+  +--------v-----+  +--------v------+
 * | vco_divided  |  | vco_divided  |  | vco_divided   |
 * |    _clk_src  |  |    _clk_src  |  |    _clk_src   |
 * |              |  |              |  |               |
 * |divsel_six    |  |  divsel_two  |  |  divsel_four  |
 * +-------+------+  +-----+--------+  +--------+------+
 *         |                 |                  |
 *         v---->----------v-------------<------v
 *                         |
 *              +----------+-----------------+
 *              |   edp_phy_pll_vco_div_clk  |
 *              +---------+------------------+
 *                        |
 *                        v
 *              Input to DISPCC block
 *              for EDP pixel clock
 < ASCII >
 *
 */
```
## Visual type:
- #schematic


== ./linux/linux_706.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/phy/qualcomm/phy-qcom-pcie2.c#L205-L222

```c
/*
 * Register a fixed rate pipe clock.
 *
 * The <s>_pipe_clksrc generated by PHY goes to the GCC that gate
 * controls it. The <s>_pipe_clk coming out of the GCC is requested
 * by the PHY driver for its operations.
 * We register the <s>_pipe_clksrc here. The gcc driver takes care
 * of assigning this <s>_pipe_clksrc as parent to <s>_pipe_clk.
 * Below picture shows this relationship.
 *
 < ASCII >
 *         +---------------+
 *         |   PHY block   |<<---------------------------------------+
 *         |               |                                         |
 *         |   +-------+   |                   +-----+               |
 *   I/P---^-->|  PLL  |---^--->pipe_clksrc--->| GCC |--->pipe_clk---+
 *    clk  |   +-------+   |                   +-----+
 *         +---------------+
 < ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_707.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/phy/qualcomm/phy-qcom-qmp-combo.c#L2254-L2271

```c
/*
 * Register a fixed rate pipe clock.
 *
 * The <s>_pipe_clksrc generated by PHY goes to the GCC that gate
 * controls it. The <s>_pipe_clk coming out of the GCC is requested
 * by the PHY driver for its operations.
 * We register the <s>_pipe_clksrc here. The gcc driver takes care
 * of assigning this <s>_pipe_clksrc as parent to <s>_pipe_clk.
 * Below picture shows this relationship.
 *
 < ASCII >
 *         +---------------+
 *         |   PHY block   |<<---------------------------------------+
 *         |               |                                         |
 *         |   +-------+   |                   +-----+               |
 *   I/P---^-->|  PLL  |---^--->pipe_clksrc--->| GCC |--->pipe_clk---+
 *    clk  |   +-------+   |                   +-----+
 *         +---------------+
 < ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_708.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/phy/qualcomm/phy-qcom-qmp-combo.c#L2289-L2337

```c
/*
 * Display Port PLL driver block diagram for branch clocks
 *
 < ASCII >
 *              +------------------------------+
 *              |         DP_VCO_CLK           |
 *              |                              |
 *              |    +-------------------+     |
 *              |    |   (DP PLL/VCO)    |     |
 *              |    +---------+---------+     |
 *              |              v               |
 *              |   +----------+-----------+   |
 *              |   | hsclk_divsel_clk_src |   |
 *              |   +----------+-----------+   |
 *              +------------------------------+
 *                              |
 *          +---------<---------v------------>----------+
 *          |                                           |
 * +--------v----------------+                          |
 * |    dp_phy_pll_link_clk  |                          |
 * |     link_clk            |                          |
 * +--------+----------------+                          |
 *          |                                           |
 *          |                                           |
 *          v                                           v
 * Input to DISPCC block                                |
 * for link clk, crypto clk                             |
 * and interface clock                                  |
 *                                                      |
 *                                                      |
 *      +--------<------------+-----------------+---<---+
 *      |                     |                 |
 * +----v---------+  +--------v-----+  +--------v------+
 * | vco_divided  |  | vco_divided  |  | vco_divided   |
 * |    _clk_src  |  |    _clk_src  |  |    _clk_src   |
 * |              |  |              |  |               |
 * |divsel_six    |  |  divsel_two  |  |  divsel_four  |
 * +-------+------+  +-----+--------+  +--------+------+
 *         |                 |                  |
 *         v---->----------v-------------<------v
 *                         |
 *              +----------+-----------------+
 *              |   dp_phy_pll_vco_div_clk   |
 *              +---------+------------------+
 *                        |
 *                        v
 *              Input to DISPCC block
 *              for DP pixel clock
 < ASCII >
 *
 */
```
## Visual type:
- #schematic


== ./linux/linux_709.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/phy/qualcomm/phy-qcom-qmp-pcie-msm8996.c#L643-L660

```c
/*
 * Register a fixed rate pipe clock.
 *
 * The <s>_pipe_clksrc generated by PHY goes to the GCC that gate
 * controls it. The <s>_pipe_clk coming out of the GCC is requested
 * by the PHY driver for its operations.
 * We register the <s>_pipe_clksrc here. The gcc driver takes care
 * of assigning this <s>_pipe_clksrc as parent to <s>_pipe_clk.
 * Below picture shows this relationship.
 *
 < ASCII >
 *         +---------------+
 *         |   PHY block   |<<---------------------------------------+
 *         |               |                                         |
 *         |   +-------+   |                   +-----+               |
 *   I/P---^-->|  PLL  |---^--->pipe_clksrc--->| GCC |--->pipe_clk---+
 *    clk  |   +-------+   |                   +-----+
 *         +---------------+
 < ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_71.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/probes/decode.h#L111-L225

```c
/*
 * The following definitions and macros are used to build instruction
 * decoding tables for use by probes_decode_insn.
 *
 * These tables are a concatenation of entries each of which consist of one of
 * the decode_* structs. All of the fields in every type of decode structure
 * are of the union type decode_item, therefore the entire decode table can be
 * viewed as an array of these and declared like:
 *
 *	static const union decode_item table_name[] = {};
 *
 * In order to construct each entry in the table, macros are used to
 * initialise a number of sequential decode_item values in a layout which
 * matches the relevant struct. E.g. DECODE_SIMULATE initialise a struct
 * decode_simulate by initialising four decode_item objects like this...
 *
 *	{.bits = _type},
 *	{.bits = _mask},
 *	{.bits = _value},
 *	{.action = _handler},
 *
 * Initialising a specified member of the union means that the compiler
 * will produce a warning if the argument is of an incorrect type.
 *
 * Below is a list of each of the macros used to initialise entries and a
 * description of the action performed when that entry is matched to an
 * instruction. A match is found when (instruction & mask) == value.
 *
 * DECODE_TABLE(mask, value, table)
 *	Instruction decoding jumps to parsing the new sub-table 'table'.
 *
 * DECODE_CUSTOM(mask, value, decoder)
 *	The value of 'decoder' is used as an index into the array of
 *	action functions, and the retrieved decoder function is invoked
 *	to complete decoding of the instruction.
 *
 * DECODE_SIMULATE(mask, value, handler)
 *	The probes instruction handler is set to the value found by
 *	indexing into the action array using the value of 'handler'. This
 *	will be used to simulate the instruction when the probe is hit.
 *	Decoding returns with INSN_GOOD_NO_SLOT.
 *
 * DECODE_EMULATE(mask, value, handler)
 *	The probes instruction handler is set to the value found by
 *	indexing into the action array using the value of 'handler'. This
 *	will be used to emulate the instruction when the probe is hit. The
 *	modified instruction (see below) is placed in the probes instruction
 *	slot so it may be called by the emulation code. Decoding returns
 *	with INSN_GOOD.
 *
 * DECODE_REJECT(mask, value)
 *	Instruction decoding fails with INSN_REJECTED
 *
 * DECODE_OR(mask, value)
 *	This allows the mask/value test of multiple table entries to be
 *	logically ORed. Once an 'or' entry is matched the decoding action to
 *	be performed is that of the next entry which isn't an 'or'. E.g.
 *
 *		DECODE_OR	(mask1, value1)
 *		DECODE_OR	(mask2, value2)
 *		DECODE_SIMULATE	(mask3, value3, simulation_handler)
 *
 *	This means that if any of the three mask/value pairs match the
 *	instruction being decoded, then 'simulation_handler' will be used
 *	for it.
 *
 * Both the SIMULATE and EMULATE macros have a second form which take an
 * additional 'regs' argument.
 *
 *	DECODE_SIMULATEX(mask, value, handler, regs)
 *	DECODE_EMULATEX	(mask, value, handler, regs)
 *
 * These are used to specify what kind of CPU register is encoded in each of the
 * least significant 5 nibbles of the instruction being decoded. The regs value
 * is specified using the REGS macro, this takes any of the REG_TYPE_* values
 * from enum decode_reg_type as arguments; only the '*' part of the name is
 * given. E.g.
 *
 *	REGS(0, ANY, NOPC, 0, ANY)
 *
 * This indicates an instruction is encoded like:
 *
 *	bits 19..16	ignore
 *	bits 15..12	any register allowed here
 *	bits 11.. 8	any register except PC allowed here
 *	bits  7.. 4	ignore
 *	bits  3.. 0	any register allowed here
 *
 * This register specification is checked after a decode table entry is found to
 * match an instruction (through the mask/value test). Any invalid register then
 * found in the instruction will cause decoding to fail with INSN_REJECTED. In
 * the above example this would happen if bits 11..8 of the instruction were
 * 1111, indicating R15 or PC.
 *
 * As well as checking for legal combinations of registers, this data is also
 * used to modify the registers encoded in the instructions so that an
 * emulation routines can use it. (See decode_regs() and INSN_NEW_BITS.)
 *
 * Here is a real example which matches ARM instructions of the form
 * "AND <Rd>,<Rn>,<Rm>,<shift> <Rs>"
 *
 *	DECODE_EMULATEX	(0x0e000090, 0x00000010, PROBES_DATA_PROCESSING_REG,
 *						 REGS(ANY, ANY, NOPC, 0, ANY)),
 *						      ^    ^    ^        ^
 *						      Rn   Rd   Rs       Rm
 *
 * Decoding the instruction "AND R4, R5, R6, ASL R15" will be rejected because
 * Rs == R15
 *
 * Decoding the instruction "AND R4, R5, R6, ASL R7" will be accepted and the
 * instruction will be modified to "AND R0, R2, R3, ASL R1" and then placed into
 * the kprobes instruction slot. This can then be called later by the handler
 * function emulate_rd12rn16rm0rs8_rwflags (a pointer to which is retrieved from
 * the indicated slot in the action array), in order to simulate the instruction.
 */
```
## Visual type:



== ./linux/linux_710.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/phy/qualcomm/phy-qcom-qmp-pcie.c#L2401-L2418

```c
/*
 * Register a fixed rate pipe clock.
 *
 * The <s>_pipe_clksrc generated by PHY goes to the GCC that gate
 * controls it. The <s>_pipe_clk coming out of the GCC is requested
 * by the PHY driver for its operations.
 * We register the <s>_pipe_clksrc here. The gcc driver takes care
 * of assigning this <s>_pipe_clksrc as parent to <s>_pipe_clk.
 * Below picture shows this relationship.
 *
 < ASCII >
 *         +---------------+
 *         |   PHY block   |<<---------------------------------------+
 *         |               |                                         |
 *         |   +-------+   |                   +-----+               |
 *   I/P---^-->|  PLL  |---^--->pipe_clksrc--->| GCC |--->pipe_clk---+
 *    clk  |   +-------+   |                   +-----+
 *         +---------------+
 < ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_711.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/phy/qualcomm/phy-qcom-qmp-usb.c#L2342-L2359

```c
/*
 * Register a fixed rate pipe clock.
 *
 * The <s>_pipe_clksrc generated by PHY goes to the GCC that gate
 * controls it. The <s>_pipe_clk coming out of the GCC is requested
 * by the PHY driver for its operations.
 * We register the <s>_pipe_clksrc here. The gcc driver takes care
 * of assigning this <s>_pipe_clksrc as parent to <s>_pipe_clk.
 * Below picture shows this relationship.
 *
 < ASCII >
 *         +---------------+
 *         |   PHY block   |<<---------------------------------------+
 *         |               |                                         |
 *         |   +-------+   |                   +-----+               |
 *   I/P---^-->|  PLL  |---^--->pipe_clksrc--->| GCC |--->pipe_clk---+
 *    clk  |   +-------+   |                   +-----+
 *         +---------------+
 < ASCII >
 */
```
## Visual type:
- #schematic


== ./linux/linux_712.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/phy/renesas/phy-rcar-gen3-usb2.c#L132-L141

```c
/*
 * Combination about is_otg_channel and uses_otg_pins:
 *
 < ASCII >
 * Parameters				|| Behaviors
 * is_otg_channel	| uses_otg_pins	|| irqs		| role sysfs
 * ---------------------+---------------++--------------+------------
 * true			| true		|| enabled	| enabled
 * true                 | false		|| disabled	| enabled
 * false                | any		|| disabled	| disabled
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_713.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/pinctrl-st.c#L271-L296

```c
/*
 * Edge triggers are not supported at hardware level, it is supported by
 * software by exploiting the level trigger support in hardware.
 * Software uses a virtual register (EDGE_CONF) for edge trigger configuration
 * of each gpio pin in a GPIO bank.
 *
 * Each bank has a 32 bit EDGE_CONF register which is divided in to 8 parts of
 * 4-bits. Each 4-bit space is allocated for each pin in a gpio bank.
 *
 < ASCII >
 * bit allocation per pin is:
 * Bits:  [0 - 3] | [4 - 7]  [8 - 11] ... ... ... ...  [ 28 - 31]
 *       --------------------------------------------------------
 *       |  pin-0  |  pin-2 | pin-3  | ... ... ... ... | pin -7 |
 *       --------------------------------------------------------
 < ASCII >
 *
 *  A pin can have one of following the values in its edge configuration field.
 *
 < ASCII >
 *	-------   ----------------------------
 *	[0-3]	- Description
 *	-------   ----------------------------
 *	0000	- No edge IRQ.
 *	0001	- Falling edge IRQ.
 *	0010	- Rising edge IRQ.
 *	0011	- Rising and Falling edge IRQ.
 *	-------   ----------------------------
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_714.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/pinctrl-st.c#L1389-L1412

```c
/*
 * As edge triggers are not supported at hardware level, it is supported by
 * software by exploiting the level trigger support in hardware.
 *
 * Steps for detection raising edge interrupt in software.
 *
 * Step 1: CONFIGURE pin to detect level LOW interrupts.
 *
 * Step 2: DETECT level LOW interrupt and in irqmux/gpio bank interrupt handler,
 * if the value of pin is low, then CONFIGURE pin for level HIGH interrupt.
 * IGNORE calling the actual interrupt handler for the pin at this stage.
 *
 * Step 3: DETECT level HIGH interrupt and in irqmux/gpio-bank interrupt handler
 * if the value of pin is HIGH, CONFIGURE pin for level LOW interrupt and then
 * DISPATCH the interrupt to the interrupt handler of the pin.
 *
 < ASCII >
 *		 step-1  ________     __________
 *				|     | step - 3
 *			        |     |
 *			step -2 |_____|
 < ASCII >
 *
 * falling edge is also detected int the same way.
 *
 */
```
## Visual type:
- #plot


== ./linux/linux_715.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/aspeed/pinmux-aspeed.h#L9-L420

```c
/*
 * The ASPEED SoCs provide typically more than 200 pins for GPIO and other
 * functions. The SoC function enabled on a pin is determined on a priority
 * basis where a given pin can provide a number of different signal types.
 *
 * The signal active on a pin is described by both a priority level and
 * compound logical expressions involving multiple operators, registers and
 * bits. Some difficulty arises as the pin's function bit masks for each
 * priority level are frequently not the same (i.e. cannot just flip a bit to
 * change from a high to low priority signal), or even in the same register.
 * Further, not all signals can be unmuxed, as some expressions depend on
 * values in the hardware strapping register (which may be treated as
 * read-only).
 *
 * SoC Multi-function Pin Expression Examples
 * ------------------------------------------
 *
 * Here are some sample mux configurations from the AST2400 and AST2500
 * datasheets to illustrate the corner cases, roughly in order of least to most
 * corner. The signal priorities are in decending order from P0 (highest).
 *
 * D6 is a pin with a single function (beside GPIO); a high priority signal
 * that participates in one function:
 < ASCII >
 *
 * Ball | Default | P0 Signal | P0 Expression               | P1 Signal | P1 Expression | Other
 * -----+---------+-----------+-----------------------------+-----------+---------------+----------
 *  D6    GPIOA0    MAC1LINK    SCU80[0]=1                                                GPIOA0
 * -----+---------+-----------+-----------------------------+-----------+---------------+----------
 < ASCII >
 *
 * C5 is a multi-signal pin (high and low priority signals). Here we touch
 * different registers for the different functions that enable each signal:
 < ASCII >
 *
 * -----+---------+-----------+-----------------------------+-----------+---------------+----------
 *  C5    GPIOA4    SCL9        SCU90[22]=1                   TIMER5      SCU80[4]=1      GPIOA4
 * -----+---------+-----------+-----------------------------+-----------+---------------+----------
 < ASCII >
 *
 * E19 is a single-signal pin with two functions that influence the active
 * signal. In this case both bits have the same meaning - enable a dedicated
 * LPC reset pin. However it's not always the case that the bits in the
 * OR-relationship have the same meaning.
 *
 < ASCII >
 * -----+---------+-----------+-----------------------------+-----------+---------------+----------
 *  E19   GPIOB4    LPCRST#     SCU80[12]=1 | Strap[14]=1                                 GPIOB4
 * -----+---------+-----------+-----------------------------+-----------+---------------+----------
 < ASCII >
 *
 * For example, pin B19 has a low-priority signal that's enabled by two
 * distinct SoC functions: A specific SIOPBI bit in register SCUA4, and an ACPI
 * bit in the STRAP register. The ACPI bit configures signals on pins in
 * addition to B19. Both of the low priority functions as well as the high
 * priority function must be disabled for GPIOF1 to be used.
 *
 < ASCII >
 * Ball | Default | P0 Signal | P0 Expression                           | P1 Signal | P1 Expression                          | Other
 * -----+---------+-----------+-----------------------------------------+-----------+----------------------------------------+----------
 *  B19   GPIOF1    NDCD4       SCU80[25]=1                               SIOPBI#     SCUA4[12]=1 | Strap[19]=0                GPIOF1
 * -----+---------+-----------+-----------------------------------------+-----------+----------------------------------------+----------
 < ASCII >
 *
 * For pin E18, the SoC ANDs the expected state of three bits to determine the
 * pin's active signal:
 *
 * * SCU3C[3]: Enable external SOC reset function
 * * SCU80[15]: Enable SPICS1# or EXTRST# function pin
 * * SCU90[31]: Select SPI interface CS# output
 *
 < ASCII >
 * -----+---------+-----------+-----------------------------------------+-----------+----------------------------------------+----------
 *  E18   GPIOB7    EXTRST#     SCU3C[3]=1 & SCU80[15]=1 & SCU90[31]=0    SPICS1#     SCU3C[3]=1 & SCU80[15]=1 & SCU90[31]=1   GPIOB7
 * -----+---------+-----------+-----------------------------------------+-----------+----------------------------------------+----------
 < ASCII >
 *
 * (Bits SCU3C[3] and SCU80[15] appear to only be used in the expressions for
 * selecting the signals on pin E18)
 *
 * Pin T5 is a multi-signal pin with a more complex configuration:
 *
 < ASCII >
 * Ball | Default | P0 Signal | P0 Expression                | P1 Signal | P1 Expression | Other
 * -----+---------+-----------+------------------------------+-----------+---------------+----------
 *  T5    GPIOL1    VPIDE       SCU90[5:4]!=0 & SCU84[17]=1    NDCD1       SCU84[17]=1     GPIOL1
 * -----+---------+-----------+------------------------------+-----------+---------------+----------
 < ASCII >
 *
 * The high priority signal configuration is best thought of in terms of its
 * exploded form, with reference to the SCU90[5:4] bits:
 *
 * * SCU90[5:4]=00: disable
 * * SCU90[5:4]=01: 18 bits (R6/G6/B6) video mode.
 * * SCU90[5:4]=10: 24 bits (R8/G8/B8) video mode.
 * * SCU90[5:4]=11: 30 bits (R10/G10/B10) video mode.
 *
 * Re-writing:
 *
 < ASCII >
 * -----+---------+-----------+------------------------------+-----------+---------------+----------
 *  T5    GPIOL1    VPIDE      (SCU90[5:4]=1 & SCU84[17]=1)    NDCD1       SCU84[17]=1     GPIOL1
 *                             | (SCU90[5:4]=2 & SCU84[17]=1)
 *                             | (SCU90[5:4]=3 & SCU84[17]=1)
 * -----+---------+-----------+------------------------------+-----------+---------------+----------
 < ASCII >
 *
 * For reference the SCU84[17] bit configure the "UART1 NDCD1 or Video VPIDE
 * function pin", where the signal itself is determined by whether SCU94[5:4]
 * is disabled or in one of the 18, 24 or 30bit video modes.
 *
 * Other video-input-related pins require an explicit state in SCU90[5:4], e.g.
 * W1 and U5:
 *
 < ASCII >
 * -----+---------+-----------+------------------------------+-----------+---------------+----------
 *  W1    GPIOL6    VPIB0       SCU90[5:4]=3 & SCU84[22]=1     TXD1        SCU84[22]=1     GPIOL6
 *  U5    GPIOL7    VPIB1       SCU90[5:4]=3 & SCU84[23]=1     RXD1        SCU84[23]=1     GPIOL7
 * -----+---------+-----------+------------------------------+-----------+---------------+----------
 < ASCII >
 *
 * The examples of T5 and W1 are particularly fertile, as they also demonstrate
 * that despite operating as part of the video input bus each signal needs to
 * be enabled individually via it's own SCU84 (in the cases of T5 and W1)
 * register bit. This is a little crazy if the bus doesn't have optional
 * signals, but is used to decent effect with some of the UARTs where not all
 * signals are required. However, this isn't done consistently - UART1 is
 * enabled on a per-pin basis, and by contrast, all signals for UART6 are
 * enabled by a single bit.
 *
 * Further, the high and low priority signals listed in the table above share
 * a configuration bit. The VPI signals should operate in concert in a single
 * function, but the UART signals should retain the ability to be configured
 * independently. This pushes the implementation down the path of tagging a
 * signal's expressions with the function they participate in, rather than
 * defining masks affecting multiple signals per function. The latter approach
 * fails in this instance where applying the configuration for the UART pin of
 * interest will stomp on the state of other UART signals when disabling the
 * VPI functions on the current pin.
 *
 < ASCII >
 * Ball |  Default   | P0 Signal | P0 Expression             | P1 Signal | P1 Expression | Other
 * -----+------------+-----------+---------------------------+-----------+---------------+------------
 *  A12   RGMII1TXCK   GPIOT0      SCUA0[0]=1                  RMII1TXEN   Strap[6]=0      RGMII1TXCK
 *  B12   RGMII1TXCTL  GPIOT1      SCUA0[1]=1                  –           Strap[6]=0      RGMII1TXCTL
 * -----+------------+-----------+---------------------------+-----------+---------------+------------
 < ASCII >
 *
 * A12 demonstrates that the "Other" signal isn't always GPIO - in this case
 * GPIOT0 is a high-priority signal and RGMII1TXCK is Other. Thus, GPIO
 * should be treated like any other signal type with full function expression
 * requirements, and not assumed to be the default case. Separately, GPIOT0 and
 * GPIOT1's signal descriptor bits are distinct, therefore we must iterate all
 * pins in the function's group to disable the higher-priority signals such
 * that the signal for the function of interest is correctly enabled.
 *
 * Finally, three priority levels aren't always enough; the AST2500 brings with
 * it 18 pins of five priority levels, however the 18 pins only use three of
 * the five priority levels.
 *
 * Ultimately the requirement to control pins in the examples above drive the
 * design:
 *
 * * Pins provide signals according to functions activated in the mux
 *   configuration
 *
 * * Pins provide up to five signal types in a priority order
 *
 * * For priorities levels defined on a pin, each priority provides one signal
 *
 * * Enabling lower priority signals requires higher priority signals be
 *   disabled
 *
 * * A function represents a set of signals; functions are distinct if they
 *   do not share a subset of signals (and may be distinct if they are a
 *   strict subset).
 *
 * * Signals participate in one or more functions or groups
 *
 * * A function is described by an expression of one or more signal
 *   descriptors, which compare bit values in a register
 *
 * * A signal expression is the smallest set of signal descriptors whose
 *   comparisons must evaluate 'true' for a signal to be enabled on a pin.
 *
 * * A signal participating in a function is active on a pin if evaluating all
 *   signal descriptors in the pin's signal expression for the function yields
 *   a 'true' result
 *
 * * A signal at a given priority on a given pin is active if any of the
 *   functions in which the signal participates are active, and no higher
 *   priority signal on the pin is active
 *
 * * GPIO is configured per-pin
 *
 * And so:
 *
 * * To disable a signal, any function(s) activating the signal must be
 *   disabled
 *
 * * Each pin must know the signal expressions of functions in which it
 *   participates, for the purpose of enabling the Other function. This is done
 *   by deactivating all functions that activate higher priority signals on the
 *   pin.
 *
 * As a concrete example:
 *
 * * T5 provides three signals types: VPIDE, NDCD1 and GPIO
 *
 * * The VPIDE signal participates in 3 functions: VPI18, VPI24 and VPI30
 *
 * * The NDCD1 signal participates in just its own NDCD1 function
 *
 * * VPIDE is high priority, NDCD1 is low priority, and GPIOL1 is the least
 *   prioritised
 *
 * * The prerequisit for activating the NDCD1 signal is that the VPI18, VPI24
 *   and VPI30 functions all be disabled
 *
 * * Similarly, all of VPI18, VPI24, VPI30 and NDCD1 functions must be disabled
 *   to provide GPIOL6
 *
 * Considerations
 * --------------
 *
 * If pinctrl allows us to allocate a pin we can configure a function without
 * concern for the function of already allocated pins, if pin groups are
 * created with respect to the SoC functions in which they participate. This is
 * intuitive, but it did not feel obvious from the bit/pin relationships.
 *
 * Conversely, failing to allocate all pins in a group indicates some bits (as
 * well as pins) required for the group's configuration will already be in use,
 * likely in a way that's inconsistent with the requirements of the failed
 * group.
 *
 * Implementation
 * --------------
 *
 * Beyond the documentation below the various structures and helper macros that
 * allow the implementation to hang together are defined. The macros are fairly
 * dense, so below we walk through some raw examples of the configuration
 * tables in an effort to clarify the concepts.
 *
 * The complexity of configuring the mux combined with the scale of the pins
 * and functions was a concern, so the table design along with the macro jungle
 * is an attempt to address it. The rough principles of the approach are:
 *
 * 1. Use a data-driven solution rather than embedding state into code
 * 2. Minimise editing to the specifics of the given mux configuration
 * 3. Detect as many errors as possible at compile time
 *
 * Addressing point 3 leads to naming of symbols in terms of the four
 * properties associated with a given mux configuration: The pin, the signal,
 * the group and the function. In this way copy/paste errors cause duplicate
 * symbols to be defined, which prevents successful compilation. Failing to
 * properly parent the tables leads to unused symbol warnings, and use of
 * designated initialisers and additional warnings ensures that there are
 * no override errors in the pin, group and function arrays.
 *
 * Addressing point 2 drives the development of the macro jungle, as it
 * centralises the definition noise at the cost of taking some time to
 * understand.
 *
 * Here's a complete, concrete "pre-processed" example of the table structures
 * used to describe the D6 ball from the examples above:
 *
 * ```
 * static const struct aspeed_sig_desc sig_descs_MAC1LINK_MAC1LINK[] = {
 *     {
 *         .ip = ASPEED_IP_SCU,
 *         .reg = 0x80,
 *         .mask = BIT(0),
 *         .enable = 1,
 *         .disable = 0
 *     },
 * };
 *
 * static const struct aspeed_sig_expr sig_expr_MAC1LINK_MAC1LINK = {
 *     .signal = "MAC1LINK",
 *     .function = "MAC1LINK",
 *     .ndescs = ARRAY_SIZE(sig_descs_MAC1LINK_MAC1LINK),
 *     .descs = &(sig_descs_MAC1LINK_MAC1LINK)[0],
 * };
 *
 * static const struct aspeed_sig_expr *sig_exprs_MAC1LINK_MAC1LINK[] = {
 *     &sig_expr_MAC1LINK_MAC1LINK,
 *     NULL,
 * };
 *
 * static const struct aspeed_sig_desc sig_descs_GPIOA0_GPIOA0[] = { };
 *
 * static const struct aspeed_sig_expr sig_expr_GPIOA0_GPIOA0 = {
 *     .signal = "GPIOA0",
 *     .function = "GPIOA0",
 *     .ndescs = ARRAY_SIZE(sig_descs_GPIOA0_GPIOA0),
 *     .descs = &(sig_descs_GPIOA0_GPIOA0)[0],
 * };
 *
 * static const struct aspeed_sig_expr *sig_exprs_GPIOA0_GPIOA0[] = {
 *     &sig_expr_GPIOA0_GPIOA0,
 *     NULL
 * };
 *
 * static const struct aspeed_sig_expr **pin_exprs_0[] = {
 *     sig_exprs_MAC1LINK_MAC1LINK,
 *     sig_exprs_GPIOA0_GPIOA0,
 *     NULL
 * };
 *
 * static const struct aspeed_pin_desc pin_0 = { "0", (&pin_exprs_0[0]) };
 * static const int group_pins_MAC1LINK[] = { 0 };
 * static const char *func_groups_MAC1LINK[] = { "MAC1LINK" };
 *
 * static struct pinctrl_pin_desc aspeed_g4_pins[] = {
 *     [0] = { .number = 0, .name = "D6", .drv_data = &pin_0 },
 * };
 *
 * static const struct aspeed_pin_group aspeed_g4_groups[] = {
 *     {
 *         .name = "MAC1LINK",
 *         .pins = &(group_pins_MAC1LINK)[0],
 *         .npins = ARRAY_SIZE(group_pins_MAC1LINK),
 *     },
 * };
 *
 * static const struct aspeed_pin_function aspeed_g4_functions[] = {
 *     {
 *         .name = "MAC1LINK",
 *         .groups = &func_groups_MAC1LINK[0],
 *         .ngroups = ARRAY_SIZE(func_groups_MAC1LINK),
 *     },
 * };
 * ```
 *
 * At the end of the day much of the above code is compressed into the
 * following two lines:
 *
 * ```
 * #define D6 0
 * SSSF_PIN_DECL(D6, GPIOA0, MAC1LINK, SIG_DESC_SET(SCU80, 0));
 * ```
 *
 * The two examples below show just the differences from the example above.
 *
 * Ball E18 demonstrates a function, EXTRST, that requires multiple descriptors
 * be set for it to be muxed:
 *
 * ```
 * static const struct aspeed_sig_desc sig_descs_EXTRST_EXTRST[] = {
 *     {
 *         .ip = ASPEED_IP_SCU,
 *         .reg = 0x3C,
 *         .mask = BIT(3),
 *         .enable = 1,
 *         .disable = 0
 *     },
 *     {
 *         .ip = ASPEED_IP_SCU,
 *         .reg = 0x80,
 *         .mask = BIT(15),
 *         .enable = 1,
 *         .disable = 0
 *     },
 *     {
 *         .ip = ASPEED_IP_SCU,
 *         .reg = 0x90,
 *         .mask = BIT(31),
 *         .enable = 0,
 *         .disable = 1
 *     },
 * };
 *
 * static const struct aspeed_sig_expr sig_expr_EXTRST_EXTRST = {
 *     .signal = "EXTRST",
 *     .function = "EXTRST",
 *     .ndescs = ARRAY_SIZE(sig_descs_EXTRST_EXTRST),
 *     .descs = &(sig_descs_EXTRST_EXTRST)[0],
 * };
 * ...
 * ```
 *
 * For ball E19, we have multiple functions enabling a single signal, LPCRST#.
 * The data structures look like:
 *
 * static const struct aspeed_sig_desc sig_descs_LPCRST_LPCRST[] = {
 *     {
 *         .ip = ASPEED_IP_SCU,
 *         .reg = 0x80,
 *         .mask = BIT(12),
 *         .enable = 1,
 *         .disable = 0
 *     },
 * };
 *
 * static const struct aspeed_sig_expr sig_expr_LPCRST_LPCRST = {
 *     .signal = "LPCRST",
 *     .function = "LPCRST",
 *     .ndescs = ARRAY_SIZE(sig_descs_LPCRST_LPCRST),
 *     .descs = &(sig_descs_LPCRST_LPCRST)[0],
 * };
 *
 * static const struct aspeed_sig_desc sig_descs_LPCRST_LPCRSTS[] = {
 *     {
 *         .ip = ASPEED_IP_SCU,
 *         .reg = 0x70,
 *         .mask = BIT(14),
 *         .enable = 1,
 *         .disable = 0
 *     },
 * };
 *
 * static const struct aspeed_sig_expr sig_expr_LPCRST_LPCRSTS = {
 *     .signal = "LPCRST",
 *     .function = "LPCRSTS",
 *     .ndescs = ARRAY_SIZE(sig_descs_LPCRST_LPCRSTS),
 *     .descs = &(sig_descs_LPCRST_LPCRSTS)[0],
 * };
 *
 * static const struct aspeed_sig_expr *sig_exprs_LPCRST_LPCRST[] = {
 *     &sig_expr_LPCRST_LPCRST,
 *     &sig_expr_LPCRST_LPCRSTS,
 *     NULL,
 * };
 * ...
 * ```
 *
 * Both expressions listed in the sig_exprs_LPCRST_LPCRST array need to be set
 * to disabled for the associated GPIO to be muxed.
 *
 */
```
## Visual type:
- #table


== ./linux/linux_716.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/mediatek/pinctrl-mt7986.c#L19-L58

```c
/**
 * enum - Locking variants of the iocfg bases
 *
 * MT7986 have multiple bases to program pin configuration listed as the below:
 * iocfg_rt:0x11c30000, iocfg_rb:0x11c40000, iocfg_lt:0x11e20000,
 * iocfg_lb:0x11e30000, iocfg_tr:0x11f00000, iocfg_tl:0x11f10000,
 * _i_based could be used to indicate what base the pin should be mapped into.
 *
 * Each iocfg register base control different group of pads on the SoC
 *
 *
 < ASCII >
 *  chip carrier
 *
 *      A  B  C  D  E  F  G  H
 *    +------------------------+
 *  8 | o  o  o  o  o  o  o  o |
 *  7 | o  o  o  o  o  o  o  o |
 *  6 | o  o  o  o  o  o  o  o |
 *  5 | o  o  o  o  o  o  o  o |
 *  4 | o  o  o  o  o  o  o  o |
 *  3 | o  o  o  o  o  o  o  o |
 *  2 | o  o  o  o  o  o  o  o |
 *  1 | o  o  o  o  o  o  o  o |
 *    +------------------------+
 *
 *  inside Chip carrier
 *
 *      A  B  C  D  E  F  G  H
 *    +------------------------+
 *  8 |                        |
 *  7 |        TL  TR          |
 *  6 |      +---------+       |
 *  5 |   LT |         | RT    |
 *  4 |      |         |       |
 *  3 |   LB |         | RB    |
 *  2 |      +---------+       |
 *  1 |                        |
 *    +------------------------+
 < ASCII >
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_717.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/mediatek/pinctrl-paris.c#L56-L71

```c
/*
 * This section supports converting to/from custom MTK_PIN_CONFIG_DRV_ADV
 * and standard PIN_CONFIG_DRIVE_STRENGTH_UA pin configs.
 *
 * The custom value encodes three hardware bits as follows:
 *
 < ASCII >
 *   |           Bits           |
 *   | 2 (E1) | 1 (E0) | 0 (EN) | drive strength (uA)
 *   ------------------------------------------------
 *   |    x   |    x   |    0   | disabled, use standard drive strength
 *   -------------------------------------
 *   |    0   |    0   |    1   |  125 uA
 *   |    0   |    1   |    1   |  250 uA
 *   |    1   |    0   |    1   |  500 uA
 *   |    1   |    1   |    1   | 1000 uA
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_718.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/nomadik/pinctrl-ab8500.c#L355-L388

```c
/*
 * this table translates what's is in the AB8500 specification regarding the
 * balls alternate functions (as for DB, default, ALT_A, ALT_B and ALT_C).
 * ALTERNATE_FUNCTIONS(GPIO_NUMBER, GPIOSEL bit, ALTERNATFUNC bit1,
 * ALTERNATEFUNC bit2, ALTA val, ALTB val, ALTC val),
 *
 * example :
 *
 *	ALTERNATE_FUNCTIONS(13,     4,      3,      4, 0, 1 ,2),
 *	means that pin AB8500_PIN_W17 (pin 13) supports 4 mux (default/ALT_A,
 *	ALT_B and ALT_C), so GPIOSEL and ALTERNATFUNC registers are used to
 *	select the mux.  ALTA, ALTB and ALTC val indicates values to write in
 *	ALTERNATFUNC register. We need to specifies these values as SOC
 *	designers didn't apply the same logic on how to select mux in the
 *	ABx500 family.
 *
 *	As this pins supports at least ALT_B mux, default mux is
 *	selected by writing 1 in GPIOSEL bit :
 *
 < ASCII >
 *		| GPIOSEL bit=4 | alternatfunc bit2=4 | alternatfunc bit1=3
 *	default	|       1       |          0          |          0
 *	alt_A	|       0       |          0          |          0
 *	alt_B	|       0       |          0          |          1
 *	alt_C	|       0       |          1          |          0
 < ASCII >
 *
 *	ALTERNATE_FUNCTIONS(8,      7, UNUSED, UNUSED),
 *	means that pin AB8500_PIN_W18 (pin 8) supports 2 mux, so only GPIOSEL
 *	register is used to select the mux. As this pins doesn't support at
 *	least ALT_B mux, default mux is by writing 0 in GPIOSEL bit :
 *
 < ASCII >
 *		| GPIOSEL bit=7 | alternatfunc bit2=  | alternatfunc bit1=
 *	default	|       0       |          0          |          0
 *	alt_A	|       1       |          0          |          0
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_719.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/nomadik/pinctrl-ab8505.c#L238-L271

```c
/*
 * this table translates what's is in the AB8505 specification regarding the
 * balls alternate functions (as for DB, default, ALT_A, ALT_B and ALT_C).
 * ALTERNATE_FUNCTIONS(GPIO_NUMBER, GPIOSEL bit, ALTERNATFUNC bit1,
 * ALTERNATEFUNC bit2, ALTA val, ALTB val, ALTC val),
 *
 * example :
 *
 *	ALTERNATE_FUNCTIONS(13,     4,      3,      4, 1, 0, 2),
 *	means that pin AB8505_PIN_D18 (pin 13) supports 4 mux (default/ALT_A,
 *	ALT_B and ALT_C), so GPIOSEL and ALTERNATFUNC registers are used to
 *	select the mux. ALTA, ALTB and ALTC val indicates values to write in
 *	ALTERNATFUNC register. We need to specifies these values as SOC
 *	designers didn't apply the same logic on how to select mux in the
 *	ABx500 family.
 *
 *	As this pins supports at least ALT_B mux, default mux is
 *	selected by writing 1 in GPIOSEL bit :
 *
 < ASCII >
 *		| GPIOSEL bit=4 | alternatfunc bit2=4 | alternatfunc bit1=3
 *	default	|       1       |          0          |          0
 *	alt_A	|       0       |          0          |          1
 *	alt_B	|       0       |          0          |          0
 *	alt_C	|       0       |          1          |          0
 < ASCII >
 *
 *	ALTERNATE_FUNCTIONS(1,      0, UNUSED, UNUSED),
 *	means that pin AB9540_PIN_R4 (pin 1) supports 2 mux, so only GPIOSEL
 *	register is used to select the mux. As this pins doesn't support at
 *	least ALT_B mux, default mux is by writing 0 in GPIOSEL bit :
 *
 < ASCII >
 *		| GPIOSEL bit=0 | alternatfunc bit2=  | alternatfunc bit1=
 *	default	|       0       |          0          |          0
 *	alt_A	|       1       |          0          |          0
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_72.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm/probes/kprobes/checkers-arm.c#L136-L147

```c
/*
 < ASCII >
 *                                    | Rn |Rt/d|         | Rm |
 * LDRD (register)      cccc 000x x0x0 xxxx xxxx xxxx 1101 xxxx
 * STRD (register)      cccc 000x x0x0 xxxx xxxx xxxx 1111 xxxx
 *                                    | Rn |Rt/d|         |imm4L|
 * LDRD (immediate)     cccc 000x x1x0 xxxx xxxx xxxx 1101 xxxx
 * STRD (immediate)     cccc 000x x1x0 xxxx xxxx xxxx 1111 xxxx
 < ASCII >
 *
 * Such instructions access Rt/d and its next register, so different
 * from others, a specific checker is required to handle this extra
 * implicit register usage.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_720.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/starfive/pinctrl-starfive-jh7100.c#L157-L167

```c
/*
 < ASCII >
 * The packed pinmux values from the device tree look like this:
 *
 *  | 31 - 24 | 23 - 16 | 15 - 8 |     7    |     6    |  5 - 0  |
 *  |  dout   |  doen   |  din   | dout rev | doen rev | gpio nr |
 *
 * ..but the GPOn_DOUT_CFG and GPOn_DOEN_CFG registers look like this:
 *
 *  |      31       | 30 - 8 |   7 - 0   |
 *  | dout/doen rev | unused | dout/doen |
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_721.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/starfive/pinctrl-starfive-jh7100.c#L188-L195

```c
/*
 * The maximum GPIO output current depends on the chosen drive strength:
 *
 < ASCII >
 *  DS:   0     1     2     3     4     5     6     7
 *  mA:  14.2  21.2  28.2  35.2  42.2  49.1  56.0  62.8
 *
 * After rounding that is 7*DS + 14 mA
 < ASCII >
 */
```
## Visual type:
- #sequence


== ./linux/linux_722.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/sunplus/sppctl.c#L150-L174

```c
/**
 * sppctl_func_set() - Set pin of fully-pinmux function.
 *
 * Mask-fields and control-fields of fully-pinmux function of SP7021 are
 * arranged as shown below:
 *
 < ASCII >
 *  func# | register |  mask-field  | control-field
 * -------+----------+--------------+---------------
 *    0   | base[0]  |  (22 : 16)   |   ( 6 : 0)
 *    1   | base[0]  |  (30 : 24)   |   (14 : 8)
 *    2   | base[1]  |  (22 : 16)   |   ( 6 : 0)
 *    3   | baeg[1]  |  (30 : 24)   |   (14 : 8)
 *    :   |    :     |      :       |       :
 < ASCII >
 *
 * where mask-fields are used to protect control-fields from write-in
 * accidentally. Set the corresponding bits in the mask-field before
 * you write a value into a control-field.
 *
 * Control-fields are used to set where the function pin is going to
 * be routed to.
 *
 * Note that mask-fields and control-fields of even number of 'func'
 * are located at bits (22:16) and (6:0), while odd number of 'func's
 * are located at bits (30:24) and (14:8).
 */
```
## Visual type:
- #table


== ./linux/linux_723.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/sunplus/sppctl.c#L207-L226

```c
/**
 * sppctl_gmx_set() - Set pin of group-pinmux.
 *
 * Mask-fields and control-fields of group-pinmux function of SP7021 are
 * arranged as shown below:
 *
 < ASCII >
 *  register |  mask-fields | control-fields
 * ----------+--------------+----------------
 *  base[0]  |  (31 : 16)   |   (15 : 0)
 *  base[1]  |  (31 : 24)   |   (15 : 0)
 *  base[2]  |  (31 : 24)   |   (15 : 0)
 *     :     |      :       |       :
 < ASCII >
 *
 * where mask-fields are used to protect control-fields from write-in
 * accidentally. Set the corresponding bits in the mask-field before
 * you write a value into a control-field.
 *
 * Control-fields are used to set where the function pin is going to
 * be routed to. A control-field consists of one or more bits.
 */
```
## Visual type:
- #table


== ./linux/linux_724.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/sunplus/sppctl.c#L243-L260

```c
/**
 * sppctl_first_get() - get bit of FIRST register.
 *
 * There are 4 FIRST registers. Each has 32 control-bits.
 * Totally, there are 4 * 32 = 128 control-bits.
 * Control-bits are arranged as shown below:
 *
 < ASCII >
 *  registers | control-bits
 * -----------+--------------
 *  first[0]  |  (31 :  0)
 *  first[1]  |  (63 : 32)
 *  first[2]  |  (95 : 64)
 *  first[3]  | (127 : 96)
 < ASCII >
 *
 * Each control-bit sets type of a GPIO pin.
 *   0: a fully-pinmux pin
 *   1: a GPIO or IOP pin
 */
```
## Visual type:
- #table


== ./linux/linux_725.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/sunplus/sppctl.c#L272-L295

```c
/**
 * sppctl_master_get() - get bit of MASTER register.
 *
 * There are 8 MASTER registers. Each has 16 mask-bits and 16 control-bits.
 * Upper 16-bit of MASTER registers are mask-bits while lower 16-bit are
 * control-bits. Totally, there are 128 mask-bits and 128 control-bits.
 * They are arranged as shown below:
 *
 < ASCII >
 *  register  |  mask-bits  | control-bits
 * -----------+-------------+--------------
 *  master[0] |  (15 :   0) |  (15 :   0)
 *  master[1] |  (31 :  16) |  (31 :  16)
 *  master[2] |  (47 :  32) |  (47 :  32)
 *     :      |      :      |      :
 *  master[7] | (127 : 112) | (127 : 112)
 < ASCII >
 *
 * where mask-bits are used to protect control-bits from write-in
 * accidentally. Set the corresponding mask-bit before you write
 * a value into a control-bit.
 *
 * Each control-bit sets type of a GPIO pin when FIRST bit is 1.
 *   0: a IOP pin
 *   1: a GPIO pin
 */
```
## Visual type:
- #table


== ./linux/linux_726.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/sunplus/sppctl.c#L680-L694

```c
/**
 * sppctl_fully_pinmux_conv - Convert GPIO# to fully-pinmux control-field setting
 *
 * Each fully-pinmux function can be mapped to any of GPIO 8 ~ 71 by
 * settings its control-field. Refer to following table:
 *
 < ASCII >
 * control-field |  GPIO
 * --------------+--------
 *        0      |  No map
 *        1      |    8
 *        2      |    9
 *        3      |   10
 *        :      |    :
 *       65      |   71
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_727.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pinctrl/sunplus/sppctl.h#L32-L46

```c
/*
 * Mask-fields and control-fields of MOON registers of SP7021 are
 * arranged as shown below:
 *
 < ASCII >
 *  register |  mask-fields | control-fields
 * ----------+--------------+----------------
 *  base[0]  |  (31 : 16)   |   (15 : 0)
 *  base[1]  |  (31 : 24)   |   (15 : 0)
 *  base[2]  |  (31 : 24)   |   (15 : 0)
 *     :     |      :       |       :
 < ASCII >
 *
 * where mask-fields are used to protect control-fields from write-in
 * accidentally. Set the corresponding bits in the mask-field before
 * you write a value into a control-field.
 */
```
## Visual type:
- #table


== ./linux/linux_728.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/platform/chrome/cros_ec_sensorhub_ring.c#L687-L707

```c
/*
 * cros_ec_sensor_ring_spread_add_legacy: Calculate proper timestamps then
 * add to ringbuffer (legacy).
 *
 * Note: This assumes we're running old firmware, where timestamp
 * is inserted after its sample(s)e. There can be several samples between
 * timestamps, so several samples can have the same timestamp.
 *
 < ASCII >
 *                        timestamp | count
 *                        -----------------
 *          1st sample --> TS1      | 1
 *                         TS2      | 2
 *                         TS2      | 3
 *                         TS3      | 4
 *           last_out -->
 < ASCII >
 *
 *
 * We spread time for the samples using perod p = (current - TS1)/4.
 * between TS1 and TS2: [TS1+p/4, TS1+2p/4, TS1+3p/4, current_timestamp].
 *
 */
```
## Visual type:
- #table


== ./linux/linux_729.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/platform/x86/asus-nb-wmi.c#L31-L39

```c
/*
 * WAPF defines the behavior of the Fn+Fx wlan key
 * The significance of values is yet to be found, but
 * most of the time:
 < ASCII >
 * Bit | Bluetooth | WLAN
 *  0  | Hardware  | Hardware
 *  1  | Hardware  | Software
 *  4  | Software  | Software
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_73.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/include/asm/cpufeature.h#L106-L239

```c
/*
 * CPU capabilities:
 *
 * We use arm64_cpu_capabilities to represent system features, errata work
 * arounds (both used internally by kernel and tracked in cpu_hwcaps) and
 * ELF HWCAPs (which are exposed to user).
 *
 * To support systems with heterogeneous CPUs, we need to make sure that we
 * detect the capabilities correctly on the system and take appropriate
 * measures to ensure there are no incompatibilities.
 *
 * This comment tries to explain how we treat the capabilities.
 * Each capability has the following list of attributes :
 *
 * 1) Scope of Detection : The system detects a given capability by
 *    performing some checks at runtime. This could be, e.g, checking the
 *    value of a field in CPU ID feature register or checking the cpu
 *    model. The capability provides a call back ( @matches() ) to
 *    perform the check. Scope defines how the checks should be performed.
 *    There are three cases:
 *
 *     a) SCOPE_LOCAL_CPU: check all the CPUs and "detect" if at least one
 *        matches. This implies, we have to run the check on all the
 *        booting CPUs, until the system decides that state of the
 *        capability is finalised. (See section 2 below)
 *		Or
 *     b) SCOPE_SYSTEM: check all the CPUs and "detect" if all the CPUs
 *        matches. This implies, we run the check only once, when the
 *        system decides to finalise the state of the capability. If the
 *        capability relies on a field in one of the CPU ID feature
 *        registers, we use the sanitised value of the register from the
 *        CPU feature infrastructure to make the decision.
 *		Or
 *     c) SCOPE_BOOT_CPU: Check only on the primary boot CPU to detect the
 *        feature. This category is for features that are "finalised"
 *        (or used) by the kernel very early even before the SMP cpus
 *        are brought up.
 *
 *    The process of detection is usually denoted by "update" capability
 *    state in the code.
 *
 * 2) Finalise the state : The kernel should finalise the state of a
 *    capability at some point during its execution and take necessary
 *    actions if any. Usually, this is done, after all the boot-time
 *    enabled CPUs are brought up by the kernel, so that it can make
 *    better decision based on the available set of CPUs. However, there
 *    are some special cases, where the action is taken during the early
 *    boot by the primary boot CPU. (e.g, running the kernel at EL2 with
 *    Virtualisation Host Extensions). The kernel usually disallows any
 *    changes to the state of a capability once it finalises the capability
 *    and takes any action, as it may be impossible to execute the actions
 *    safely. A CPU brought up after a capability is "finalised" is
 *    referred to as "Late CPU" w.r.t the capability. e.g, all secondary
 *    CPUs are treated "late CPUs" for capabilities determined by the boot
 *    CPU.
 *
 *    At the moment there are two passes of finalising the capabilities.
 *      a) Boot CPU scope capabilities - Finalised by primary boot CPU via
 *         setup_boot_cpu_capabilities().
 *      b) Everything except (a) - Run via setup_system_capabilities().
 *
 * 3) Verification: When a CPU is brought online (e.g, by user or by the
 *    kernel), the kernel should make sure that it is safe to use the CPU,
 *    by verifying that the CPU is compliant with the state of the
 *    capabilities finalised already. This happens via :
 *
 *	secondary_start_kernel()-> check_local_cpu_capabilities()
 *
 *    As explained in (2) above, capabilities could be finalised at
 *    different points in the execution. Each newly booted CPU is verified
 *    against the capabilities that have been finalised by the time it
 *    boots.
 *
 *	a) SCOPE_BOOT_CPU : All CPUs are verified against the capability
 *	except for the primary boot CPU.
 *
 *	b) SCOPE_LOCAL_CPU, SCOPE_SYSTEM: All CPUs hotplugged on by the
 *	user after the kernel boot are verified against the capability.
 *
 *    If there is a conflict, the kernel takes an action, based on the
 *    severity (e.g, a CPU could be prevented from booting or cause a
 *    kernel panic). The CPU is allowed to "affect" the state of the
 *    capability, if it has not been finalised already. See section 5
 *    for more details on conflicts.
 *
 * 4) Action: As mentioned in (2), the kernel can take an action for each
 *    detected capability, on all CPUs on the system. Appropriate actions
 *    include, turning on an architectural feature, modifying the control
 *    registers (e.g, SCTLR, TCR etc.) or patching the kernel via
 *    alternatives. The kernel patching is batched and performed at later
 *    point. The actions are always initiated only after the capability
 *    is finalised. This is usally denoted by "enabling" the capability.
 *    The actions are initiated as follows :
 *	a) Action is triggered on all online CPUs, after the capability is
 *	finalised, invoked within the stop_machine() context from
 *	enable_cpu_capabilitie().
 *
 *	b) Any late CPU, brought up after (1), the action is triggered via:
 *
 *	  check_local_cpu_capabilities() -> verify_local_cpu_capabilities()
 *
 * 5) Conflicts: Based on the state of the capability on a late CPU vs.
 *    the system state, we could have the following combinations :
 *
 < ASCII >
 *		x-----------------------------x
 *		| Type  | System   | Late CPU |
 *		|-----------------------------|
 *		|  a    |   y      |    n     |
 *		|-----------------------------|
 *		|  b    |   n      |    y     |
 *		x-----------------------------x
 < ASCII >
 *
 *     Two separate flag bits are defined to indicate whether each kind of
 *     conflict can be allowed:
 *		ARM64_CPUCAP_OPTIONAL_FOR_LATE_CPU - Case(a) is allowed
 *		ARM64_CPUCAP_PERMITTED_FOR_LATE_CPU - Case(b) is allowed
 *
 *     Case (a) is not permitted for a capability that the system requires
 *     all CPUs to have in order for the capability to be enabled. This is
 *     typical for capabilities that represent enhanced functionality.
 *
 *     Case (b) is not permitted for a capability that must be enabled
 *     during boot if any CPU in the system requires it in order to run
 *     safely. This is typical for erratum work arounds that cannot be
 *     enabled after the corresponding capability is finalised.
 *
 *     In some non-typical cases either both (a) and (b), or neither,
 *     should be permitted. This can be described by including neither
 *     or both flags in the capability's type field.
 *
 *     In case of a conflict, the CPU is prevented from booting. If the
 *     ARM64_CPUCAP_PANIC_ON_CONFLICT flag is specified for the capability,
 *     then a kernel panic is triggered.
 */
```
## Visual type:
- #table


== ./linux/linux_730.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/platform/x86/dell/dell-wmi-descriptor.c#L91-L100

```c
/*
 * Descriptor buffer is 128 byte long and contains:
 *
 < ASCII >
 *       Name             Offset  Length  Value
 * Vendor Signature          0       4    "DELL"
 * Object Signature          4       4    " WMI"
 * WMI Interface Version     8       4    <version>
 * WMI buffer length        12       4    <length>
 * WMI hotfix number        16       4    <hotfix>
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_731.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/platform/x86/intel/ifs/ifs.h#L7-L126

```c
/**
 * DOC: In-Field Scan
 *
 * =============
 * In-Field Scan
 * =============
 *
 * Introduction
 * ------------
 *
 * In Field Scan (IFS) is a hardware feature to run circuit level tests on
 * a CPU core to detect problems that are not caught by parity or ECC checks.
 * Future CPUs will support more than one type of test which will show up
 * with a new platform-device instance-id, for now only .0 is exposed.
 *
 *
 * IFS Image
 * ---------
 *
 * Intel provides a firmware file containing the scan tests via
 * github [#f1]_.  Similar to microcode there is a separate file for each
 * family-model-stepping.
 *
 * IFS Image Loading
 * -----------------
 *
 * The driver loads the tests into memory reserved BIOS local to each CPU
 * socket in a two step process using writes to MSRs to first load the
 * SHA hashes for the test. Then the tests themselves. Status MSRs provide
 * feedback on the success/failure of these steps.
 *
 * The test files are kept in a fixed location: /lib/firmware/intel/ifs_0/
 * For e.g if there are 3 test files, they would be named in the following
 * fashion:
 * ff-mm-ss-01.scan
 * ff-mm-ss-02.scan
 * ff-mm-ss-03.scan
 * (where ff refers to family, mm indicates model and ss indicates stepping)
 *
 * A different test file can be loaded by writing the numerical portion
 * (e.g 1, 2 or 3 in the above scenario) into the curent_batch file.
 * To load ff-mm-ss-02.scan, the following command can be used::
 *
 *   # echo 2 > /sys/devices/virtual/misc/intel_ifs_0/current_batch
 *
 * The above file can also be read to know the currently loaded image.
 *
 * Running tests
 * -------------
 *
 * Tests are run by the driver synchronizing execution of all threads on a
 * core and then writing to the ACTIVATE_SCAN MSR on all threads. Instruction
 * execution continues when:
 *
 * 1) All tests have completed.
 * 2) Execution was interrupted.
 * 3) A test detected a problem.
 *
 * Note that ALL THREADS ON THE CORE ARE EFFECTIVELY OFFLINE FOR THE
 * DURATION OF THE TEST. This can be up to 200 milliseconds. If the system
 * is running latency sensitive applications that cannot tolerate an
 * interruption of this magnitude, the system administrator must arrange
 * to migrate those applications to other cores before running a core test.
 * It may also be necessary to redirect interrupts to other CPUs.
 *
 * In all cases reading the SCAN_STATUS MSR provides details on what
 * happened. The driver makes the value of this MSR visible to applications
 * via the "details" file (see below). Interrupted tests may be restarted.
 *
 * The IFS driver provides sysfs interfaces via /sys/devices/virtual/misc/intel_ifs_0/
 * to control execution:
 *
 * Test a specific core::
 *
 *   # echo <cpu#> > /sys/devices/virtual/misc/intel_ifs_0/run_test
 *
 * when HT is enabled any of the sibling cpu# can be specified to test
 * its corresponding physical core. Since the tests are per physical core,
 * the result of testing any thread is same. All siblings must be online
 * to run a core test. It is only necessary to test one thread.
 *
 * For e.g. to test core corresponding to cpu5
 *
 *   # echo 5 > /sys/devices/virtual/misc/intel_ifs_0/run_test
 *
 * Results of the last test is provided in /sys::
 *
 *   $ cat /sys/devices/virtual/misc/intel_ifs_0/status
 *   pass
 *
 * Status can be one of pass, fail, untested
 *
 * Additional details of the last test is provided by the details file::
 *
 *   $ cat /sys/devices/virtual/misc/intel_ifs_0/details
 *   0x8081
 *
 * The details file reports the hex value of the SCAN_STATUS MSR.
 * Hardware defined error codes are documented in volume 4 of the Intel
 * Software Developer's Manual but the error_code field may contain one of
 * the following driver defined software codes:
 *
 < ASCII >
 * +------+--------------------+
 * | 0xFD | Software timeout   |
 * +------+--------------------+
 * | 0xFE | Partial completion |
 * +------+--------------------+
 < ASCII >
 *
 * Driver design choices
 * ---------------------
 *
 * 1) The ACTIVATE_SCAN MSR allows for running any consecutive subrange of
 * available tests. But the driver always tries to run all tests and only
 * uses the subrange feature to restart an interrupted test.
 *
 * 2) Hardware allows for some number of cores to be tested in parallel.
 * The driver does not make use of this, it only tests one core at a time.
 *
 * .. [#f1] https://github.com/intel/TBD
 */
```
## Visual type:
- #table


== ./linux/linux_732.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/power/supply/bd99954-charger.c#L13-L56

```c
/*
 *   The battery charging profile of BD99954.
 *
 *   Curve (1) represents charging current.
 *   Curve (2) represents battery voltage.
 *
 *   The BD99954 data sheet divides charging to three phases.
 *   a) Trickle-charge with constant current (8).
 *   b) pre-charge with constant current (6)
 *   c) fast-charge, first with constant current (5) phase. After
 *      the battery voltage has reached target level (4) we have constant
 *      voltage phase until charging current has dropped to termination
 *      level (7)
 < ASCII >
 *
 *    V ^                                                        ^ I
 *      .                                                        .
 *      .                                                        .
 *(4)` `.` ` ` ` ` ` ` ` ` ` ` ` ` ` ----------------------------.
 *      .                           :/                           .
 *      .                     o----+/:/ ` ` ` ` ` ` ` ` ` ` ` ` `.` ` (5)
 *      .                     +   ::  +                          .
 *      .                     +  /-   --                         .
 *      .                     +`/-     +                         .
 *      .                     o/-      -:                        .
 *      .                    .s.        +`                       .
 *      .                  .--+         `/                       .
 *      .               ..``  +          .:                      .
 *      .             -`      +           --                     .
 *      .    (2)  ...``       +            :-                    .
 *      .    ...``            +             -:                   .
 *(3)` `.`.""  ` ` ` `+-------- ` ` ` ` ` ` `.:` ` ` ` ` ` ` ` ` .` ` (6)
 *      .             +                       `:.                .
 *      .             +                         -:               .
 *      .             +                           -:.            .
 *      .             +                             .--.         .
 *      .   (1)       +                                `.+` ` ` `.` ` (7)
 *      -..............` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` + ` ` ` .` ` (8)
 *      .                                                +       -
 *      -------------------------------------------------+++++++++-->
 *      |   trickle   |  pre  |          fast            |
 < ASCII >
 *
 * Details of DT properties for different limits can be found from BD99954
 * device tree binding documentation.
 */
```
## Visual type:
- #plot


== ./linux/linux_733.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/pwm/pwm-stm32.c#L75-L107

```c
/*
 * Capture using PWM input mode:
 < ASCII >
 *                              ___          ___
 * TI[1, 2, 3 or 4]: ........._|   |________|
 *                             ^0  ^1       ^2
 *                              .   .        .
 *                              .   .        XXXXX
 *                              .   .   XXXXX     |
 *                              .  XXXXX     .    |
 *                            XXXXX .        .    |
 * COUNTER:        ______XXXXX  .   .        .    |_XXX
 *                 start^       .   .        .        ^stop
 *                      .       .   .        .
 *                      v       v   .        v
 *                                  v
 * CCR1/CCR3:       tx..........t0...........t2
 * CCR2/CCR4:       tx..............t1.........
 *
 * DMA burst transfer:          |            |
 *                              v            v
 * DMA buffer:                  { t0, tx }   { t2, t1 }
 * DMA done:                                 ^
 < ASCII >
 *
 * 0: IC1/3 snapchot on rising edge: counter value -> CCR1/CCR3
 *    + DMA transfer CCR[1/3] & CCR[2/4] values (t0, tx: doesn't care)
 * 1: IC2/4 snapchot on falling edge: counter value -> CCR2/CCR4
 * 2: IC1/3 snapchot on rising edge: counter value -> CCR1/CCR3
 *    + DMA transfer CCR[1/3] & CCR[2/4] values (t2, t1)
 *
 * DMA done, compute:
 * - Period     = t2 - t0
 * - Duty cycle = t1 - t0
 */
```
## Visual type:
- #plot


== ./linux/linux_734.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/rtc/rtc-s5m.c#L44-L59

```c
/*
 * Registers used by the driver which are different between chipsets.
 *
 * Operations like read time and write alarm/time require updating
 * specific fields in UDR register. These fields usually are auto-cleared
 * (with some exceptions).
 *
 < ASCII >
 * Table of operations per device:
 *
 * Device     | Write time | Read time | Write alarm
 * =================================================
 * S5M8767    | UDR + TIME |           | UDR
 * S2MPS11/14 | WUDR       | RUDR      | WUDR + RUDR
 * S2MPS13    | WUDR       | RUDR      | WUDR + AUDR
 * S2MPS15    | WUDR       | RUDR      | AUDR
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_735.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/rtc/rtc-sunplus.c#L166-L179

```c
/*
 < ASCII >
 * -------------------------------------------------------------------------------------
 * bat_charge_rsel   bat_charge_dsel   bat_charge_en     Remarks
 *         x              x                 0            Disable
 *         0              0                 1            0.86mA (2K Ohm with diode)
 *         1              0                 1            1.81mA (250 Ohm with diode)
 *         2              0                 1            2.07mA (50 Ohm with diode)
 *         3              0                 1            16.0mA (0 Ohm with diode)
 *         0              1                 1            1.36mA (2K Ohm without diode)
 *         1              1                 1            3.99mA (250 Ohm without diode)
 *         2              1                 1            4.41mA (50 Ohm without diode)
 *         3              1                 1            16.0mA (0 Ohm without diode)
 * -------------------------------------------------------------------------------------
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_736.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/scsi/advansys.c#L2748-L2770

```c
/*
 * Add serial number to information bar if signature AAh
 * is found in at bit 15-9 (7 bits) of word 1.
 *
 * Serial Number consists fo 12 alpha-numeric digits.
 *
 < ASCII >
 *       1 - Product type (A,B,C,D..)  Word0: 15-13 (3 bits)
 *       2 - MFG Location (A,B,C,D..)  Word0: 12-10 (3 bits)
 *     3-4 - Product ID (0-99)         Word0: 9-0 (10 bits)
 *       5 - Product revision (A-J)    Word0:  "         "
 *
 *           Signature                 Word1: 15-9 (7 bits)
 *       6 - Year (0-9)                Word1: 8-6 (3 bits) & Word2: 15 (1 bit)
 *     7-8 - Week of the year (1-52)   Word1: 5-0 (6 bits)
 *
 *    9-12 - Serial Number (A001-Z999) Word2: 14-0 (15 bits)
 < ASCII >
 *
 * Note 1: Only production cards will have a serial number.
 *
 * Note 2: Signature is most significant 7 bits (0xFE).
 *
 * Returns ASC_TRUE if serial number found, otherwise returns ASC_FALSE.
 */
```
## Visual type:
- #sequence


== ./linux/linux_737.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/scsi/nsp32.c#L2956-L2982

```c
/*
 * AT24C01A (Logitec: LHA-600S), AT24C02 (Melco Buffalo: IFC-USLP) data map:
 *
 *   ROMADDR
 *   0x00 - 0x06 :  Device Synchronous Transfer Period (SCSI ID 0 - 6)
 *			Value 0x0: ASYNC, 0x0c: Ultra-20M, 0x19: Fast-10M
 *   0x07        :  HBA Synchronous Transfer Period
 *			Value 0: AutoSync, 1: Manual Setting
 *   0x08 - 0x0f :  Not Used? (0x0)
 *   0x10        :  Bus Termination
 *			Value 0: Auto[ON], 1: ON, 2: OFF
 *   0x11        :  Not Used? (0)
 *   0x12        :  Bus Reset Delay Time (0x03)
 *   0x13        :  Bootable CD Support
 *			Value 0: Disable, 1: Enable
 < ASCII >
 *   0x14        :  Device Scan
 *			Bit   7  6  5  4  3  2  1  0
 *			      |  <----------------->
 *			      |    SCSI ID: Value 0: Skip, 1: YES
 *			      |->  Value 0: ALL scan,  Value 1: Manual
 < ASCII >
 *   0x15 - 0x1b :  Not Used? (0)
 *   0x1c        :  Constant? (0x01) (clock div?)
 *   0x1d - 0x7c :  Not Used (0xff)
 *   0x7d	 :  Not Used? (0xff)
 *   0x7e        :  Constant (0x55), Validity signature
 *   0x7f        :  Constant (0xaa), Validity signature
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_738.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/scsi/aic7xxx/aic7xxx_93cx6.c#L34-L65

```c
/*
 *   The instruction set of the 93C66/56/46/26/06 chips are as follows:
 *
 < ASCII >
 *               Start  OP	    *
 *     Function   Bit  Code  Address**  Data     Description
 *     -------------------------------------------------------------------
 *     READ        1    10   A5 - A0             Reads data stored in memory,
 *                                               starting at specified address
 *     EWEN        1    00   11XXXX              Write enable must precede
 *                                               all programming modes
 *     ERASE       1    11   A5 - A0             Erase register A5A4A3A2A1A0
 *     WRITE       1    01   A5 - A0   D15 - D0  Writes register
 *     ERAL        1    00   10XXXX              Erase all registers
 *     WRAL        1    00   01XXXX    D15 - D0  Writes to all registers
 *     EWDS        1    00   00XXXX              Disables all programming
 *                                               instructions
 < ASCII >
 *     *Note: A value of X for address is a don't care condition.
 *    **Note: There are 8 address bits for the 93C56/66 chips unlike
 *	      the 93C46/26/06 chips which have 6 address bits.
 *
 *   The 93C46 has a four wire interface: clock, chip select, data in, and
 *   data out.  In order to perform one of the above functions, you need
 *   to enable the chip select for a clock period (typically a minimum of
 *   1 usec, with the clock high and low a minimum of 750 and 250 nsec
 *   respectively).  While the chip select remains high, you can clock in
 *   the instructions (above) starting with the start bit, followed by the
 *   OP code, Address, and Data (if needed).  For the READ instruction, the
 *   requested 16-bit register contents is read from the data out line but
 *   is preceded by an initial zero (leading 0, followed by 16-bits, MSB
 *   first).  The clock cycling from low to high initiates the next data
 *   bit to be sent from the chip.
 */
```
## Visual type:
- #table


== ./linux/linux_739.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/scsi/aic7xxx/queue.h#L33-L102

```c
/*
 * This file defines five types of data structures: singly-linked lists,
 * singly-linked tail queues, lists, tail queues, and circular queues.
 *
 * A singly-linked list is headed by a single forward pointer. The elements
 * are singly linked for minimum space and pointer manipulation overhead at
 * the expense of O(n) removal for arbitrary elements. New elements can be
 * added to the list after an existing element or at the head of the list.
 * Elements being removed from the head of the list should use the explicit
 * macro for this purpose for optimum efficiency. A singly-linked list may
 * only be traversed in the forward direction.  Singly-linked lists are ideal
 * for applications with large datasets and few or no removals or for
 * implementing a LIFO queue.
 *
 * A singly-linked tail queue is headed by a pair of pointers, one to the
 * head of the list and the other to the tail of the list. The elements are
 * singly linked for minimum space and pointer manipulation overhead at the
 * expense of O(n) removal for arbitrary elements. New elements can be added
 * to the list after an existing element, at the head of the list, or at the
 * end of the list. Elements being removed from the head of the tail queue
 * should use the explicit macro for this purpose for optimum efficiency.
 * A singly-linked tail queue may only be traversed in the forward direction.
 * Singly-linked tail queues are ideal for applications with large datasets
 * and few or no removals or for implementing a FIFO queue.
 *
 * A list is headed by a single forward pointer (or an array of forward
 * pointers for a hash table header). The elements are doubly linked
 * so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before
 * or after an existing element or at the head of the list. A list
 * may only be traversed in the forward direction.
 *
 * A tail queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or
 * after an existing element, at the head of the list, or at the end of
 * the list. A tail queue may be traversed in either direction.
 *
 * A circle queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or after
 * an existing element, at the head of the list, or at the end of the list.
 * A circle queue may be traversed in either direction, but has a more
 * complex end of list detection.
 *
 * For details on the use of these macros, see the queue(3) manual page.
 *
 *
 < ASCII >
 *			SLIST	LIST	STAILQ	TAILQ	CIRCLEQ
 * _HEAD		+	+	+	+	+
 * _HEAD_INITIALIZER	+	+	+	+	+
 * _ENTRY		+	+	+	+	+
 * _INIT		+	+	+	+	+
 * _EMPTY		+	+	+	+	+
 * _FIRST		+	+	+	+	+
 * _NEXT		+	+	+	+	+
 * _PREV		-	-	-	+	+
 * _LAST		-	-	+	+	+
 * _FOREACH		+	+	+	+	+
 * _FOREACH_REVERSE	-	-	-	+	+
 * _INSERT_HEAD		+	+	+	+	+
 * _INSERT_BEFORE	-	+	-	+	+
 * _INSERT_AFTER	+	+	+	+	+
 * _INSERT_TAIL		-	-	+	+	+
 * _REMOVE_HEAD		+	-	+	-	-
 * _REMOVE		+	+	+	+	+
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_74.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/include/asm/elf.h#L99-L119

```c
/*
 * An executable for which elf_read_implies_exec() returns TRUE will
 * have the READ_IMPLIES_EXEC personality flag set automatically.
 *
 * The decision process for determining the results are:
 *
 < ASCII >
 *                CPU*: | arm32      | arm64      |
 * ELF:                 |            |            |
 * ---------------------|------------|------------|
 * missing PT_GNU_STACK | exec-all   | exec-none  |
 * PT_GNU_STACK == RWX  | exec-stack | exec-stack |
 * PT_GNU_STACK == RW   | exec-none  | exec-none  |
 < ASCII >
 *
 *  exec-all  : all PROT_READ user mappings are executable, except when
 *              backed by files on a noexec-filesystem.
 *  exec-none : only PROT_EXEC user mappings are executable.
 *  exec-stack: only the stack and PROT_EXEC user mappings are executable.
 *
 *  *all arm64 CPUs support NX, so there is no "lacks NX" column.
 *
 */
```
## Visual type:
- #table


== ./linux/linux_740.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/scsi/cxlflash/sislite.h#L456-L471

```c
/*
 * CXL Flash Memory Map
 *
 < ASCII >
 *	+-------------------------------+
 *	|    512 * 64 KB User MMIO      |
 *	|        (per context)          |
 *	|       User Accessible         |
 *	+-------------------------------+
 *	|    512 * 128 B per context    |
 *	|    Provisioning and Control   |
 *	|   Trusted Process accessible  |
 *	+-------------------------------+
 *	|         64 KB Global          |
 *	|   Trusted Process accessible  |
 *	+-------------------------------+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_741.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/scsi/cxlflash/vlun.h#L22-L46

```c
/*
 * LXT - LBA Translation Table
 *
 < ASCII >
 * +-------+-------+-------+-------+-------+-------+-------+---+---+
 * | RLBA_BASE                                     |LUN_IDX| P |SEL|
 * +-------+-------+-------+-------+-------+-------+-------+---+---+
 < ASCII >
 *
 * The LXT Entry contains the physical LBA where the chunk starts (RLBA_BASE).
 * AFU ORes the low order bits from the virtual LBA (offset into the chunk)
 * with RLBA_BASE. The result is the physical LBA to be sent to storage.
 * The LXT Entry also contains an index to a LUN TBL and a bitmask of which
 * outgoing (FC) * ports can be selected. The port select bit-mask is ANDed
 * with a global port select bit-mask maintained by the driver.
 * In addition, it has permission bits that are ANDed with the
 * RHT permissions to arrive at the final permissions for the chunk.
 *
 * LXT tables are allocated dynamically in groups. This is done to avoid
 * a malloc/free overhead each time the LXT has to grow or shrink.
 *
 * Based on the current lxt_cnt (used), it is always possible to know
 * how many are allocated (used+free). The number of allocated entries is
 * not stored anywhere.
 *
 * The LXT table is re-allocated whenever it needs to cross into another group.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_742.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/scsi/lpfc/lpfc.h#L1791-L1809

```c
/**
 * lpfc_is_vmid_enabled - returns if VMID is enabled for either switch types
 * @phba: Pointer to HBA context object.
 *
 * Relationship between the enable, target support and if vmid tag is required
 * for the particular combination
 < ASCII >
 * ---------------------------------------------------
 * Switch    Enable Flag  Target Support  VMID Needed
 * ---------------------------------------------------
 * App Id     0              NA              N
 * App Id     1               0              N
 * App Id     1               1              Y
 * Pr Tag     0              NA              N
 * Pr Tag     1               0              N
 * Pr Tag     1               1              Y
 * Pr Tag     2               *              Y
 ---------------------------------------------------
 < ASCII >
 *
 **/
```
## Visual type:
- #table


== ./linux/linux_743.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/scsi/lpfc/lpfc_scsi.c#L1509-L1539

```c
/**
 * lpfc_bg_setup_bpl - Setup BlockGuard BPL with no protection data
 * @phba: The Hba for which this call is being executed.
 * @sc: pointer to scsi command we're working on
 * @bpl: pointer to buffer list for protection groups
 * @datasegcnt: number of segments of data that have been dma mapped
 *
 * This function sets up BPL buffer list for protection groups of
 * type LPFC_PG_TYPE_NO_DIF
 *
 * This is usually used when the HBA is instructed to generate
 * DIFs and insert them into data stream (or strip DIF from
 * incoming data stream)
 *
 * The buffer list consists of just one protection group described
 * below:
 < ASCII >
 *                                +-------------------------+
 *   start of prot group  -->     |          PDE_5          |
 *                                +-------------------------+
 *                                |          PDE_6          |
 *                                +-------------------------+
 *                                |         Data BDE        |
 *                                +-------------------------+
 *                                |more Data BDE's ... (opt)|
 *                                +-------------------------+
 < ASCII >
 *
 *
 * Note: Data s/g buffers have been dma mapped
 *
 * Returns the number of BDEs added to the BPL.
 **/
```
## Visual type:
- #memory-layout


== ./linux/linux_744.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/scsi/lpfc/lpfc_scsi.c#L1643-L1681

```c
/**
 * lpfc_bg_setup_bpl_prot - Setup BlockGuard BPL with protection data
 * @phba: The Hba for which this call is being executed.
 * @sc: pointer to scsi command we're working on
 * @bpl: pointer to buffer list for protection groups
 * @datacnt: number of segments of data that have been dma mapped
 * @protcnt: number of segment of protection data that have been dma mapped
 *
 * This function sets up BPL buffer list for protection groups of
 * type LPFC_PG_TYPE_DIF
 *
 * This is usually used when DIFs are in their own buffers,
 * separate from the data. The HBA can then by instructed
 * to place the DIFs in the outgoing stream.  For read operations,
 * The HBA could extract the DIFs and place it in DIF buffers.
 *
 * The buffer list for this type consists of one or more of the
 * protection groups described below:
 < ASCII >
 *                                    +-------------------------+
 *   start of first prot group  -->   |          PDE_5          |
 *                                    +-------------------------+
 *                                    |          PDE_6          |
 *                                    +-------------------------+
 *                                    |      PDE_7 (Prot BDE)   |
 *                                    +-------------------------+
 *                                    |        Data BDE         |
 *                                    +-------------------------+
 *                                    |more Data BDE's ... (opt)|
 *                                    +-------------------------+
 *   start of new  prot group  -->    |          PDE_5          |
 *                                    +-------------------------+
 *                                    |          ...            |
 *                                    +-------------------------+
 < ASCII >
 *
 * Note: It is assumed that both data and protection s/g buffers have been
 *       mapped for DMA
 *
 * Returns the number of BDEs added to the BPL.
 **/
```
## Visual type:
- #memory-layout


== ./linux/linux_745.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/scsi/lpfc/lpfc_scsi.c#L1900-L1929

```c
/**
 * lpfc_bg_setup_sgl - Setup BlockGuard SGL with no protection data
 * @phba: The Hba for which this call is being executed.
 * @sc: pointer to scsi command we're working on
 * @sgl: pointer to buffer list for protection groups
 * @datasegcnt: number of segments of data that have been dma mapped
 * @lpfc_cmd: lpfc scsi command object pointer.
 *
 * This function sets up SGL buffer list for protection groups of
 * type LPFC_PG_TYPE_NO_DIF
 *
 * This is usually used when the HBA is instructed to generate
 * DIFs and insert them into data stream (or strip DIF from
 * incoming data stream)
 *
 * The buffer list consists of just one protection group described
 * below:
 < ASCII >
 *                                +-------------------------+
 *   start of prot group  -->     |         DI_SEED         |
 *                                +-------------------------+
 *                                |         Data SGE        |
 *                                +-------------------------+
 *                                |more Data SGE's ... (opt)|
 *                                +-------------------------+
 < ASCII >
 *
 *
 * Note: Data s/g buffers have been dma mapped
 *
 * Returns the number of SGEs added to the SGL.
 **/
```
## Visual type:
- #memory-layout


== ./linux/linux_746.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/scsi/lpfc/lpfc_scsi.c#L2075-L2112

```c
/**
 * lpfc_bg_setup_sgl_prot - Setup BlockGuard SGL with protection data
 * @phba: The Hba for which this call is being executed.
 * @sc: pointer to scsi command we're working on
 * @sgl: pointer to buffer list for protection groups
 * @datacnt: number of segments of data that have been dma mapped
 * @protcnt: number of segment of protection data that have been dma mapped
 * @lpfc_cmd: lpfc scsi command object pointer.
 *
 * This function sets up SGL buffer list for protection groups of
 * type LPFC_PG_TYPE_DIF
 *
 * This is usually used when DIFs are in their own buffers,
 * separate from the data. The HBA can then by instructed
 * to place the DIFs in the outgoing stream.  For read operations,
 * The HBA could extract the DIFs and place it in DIF buffers.
 *
 * The buffer list for this type consists of one or more of the
 * protection groups described below:
 < ASCII >
 *                                    +-------------------------+
 *   start of first prot group  -->   |         DISEED          |
 *                                    +-------------------------+
 *                                    |      DIF (Prot SGE)     |
 *                                    +-------------------------+
 *                                    |        Data SGE         |
 *                                    +-------------------------+
 *                                    |more Data SGE's ... (opt)|
 *                                    +-------------------------+
 *   start of new  prot group  -->    |         DISEED          |
 *                                    +-------------------------+
 *                                    |          ...            |
 *                                    +-------------------------+
 < ASCII >
 *
 * Note: It is assumed that both data and protection s/g buffers have been
 *       mapped for DMA
 *
 * Returns the number of SGEs added to the SGL.
 **/
```
## Visual type:
- #memory-layout


== ./linux/linux_747.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/scsi/qla2xxx/qla_dbg.c#L7-L63

```c
/*
 * Table for showing the current message id in use for particular level
 * Change this table for addition of log/debug messages.
 < ASCII >
 * ----------------------------------------------------------------------
 * |             Level            |   Last Value Used  |     Holes	|
 * ----------------------------------------------------------------------
 * | Module Init and Probe        |       0x0199       |                |
 * | Mailbox commands             |       0x1206       | 0x11a5-0x11ff	|
 * | Device Discovery             |       0x2134       | 0x210e-0x2115  |
 * |                              |                    | 0x211c-0x2128  |
 * |                              |                    | 0x212c-0x2134  |
 * | Queue Command and IO tracing |       0x3074       | 0x300b         |
 * |                              |                    | 0x3027-0x3028  |
 * |                              |                    | 0x303d-0x3041  |
 * |                              |                    | 0x302d,0x3033  |
 * |                              |                    | 0x3036,0x3038  |
 * |                              |                    | 0x303a		|
 * | DPC Thread                   |       0x4023       | 0x4002,0x4013  |
 * | Async Events                 |       0x509c       |                |
 * | Timer Routines               |       0x6012       |                |
 * | User Space Interactions      |       0x70e3       | 0x7018,0x702e  |
 * |				  |		       | 0x7020,0x7024  |
 * |                              |                    | 0x7039,0x7045  |
 * |                              |                    | 0x7073-0x7075  |
 * |                              |                    | 0x70a5-0x70a6  |
 * |                              |                    | 0x70a8,0x70ab  |
 * |                              |                    | 0x70ad-0x70ae  |
 * |                              |                    | 0x70d0-0x70d6	|
 * |                              |                    | 0x70d7-0x70db  |
 * | Task Management              |       0x8042       | 0x8000         |
 * |                              |                    | 0x8019         |
 * |                              |                    | 0x8025,0x8026  |
 * |                              |                    | 0x8031,0x8032  |
 * |                              |                    | 0x8039,0x803c  |
 * | AER/EEH                      |       0x9011       |		|
 * | Virtual Port                 |       0xa007       |		|
 * | ISP82XX Specific             |       0xb157       | 0xb002,0xb024  |
 * |                              |                    | 0xb09e,0xb0ae  |
 * |				  |		       | 0xb0c3,0xb0c6  |
 * |                              |                    | 0xb0e0-0xb0ef  |
 * |                              |                    | 0xb085,0xb0dc  |
 * |                              |                    | 0xb107,0xb108  |
 * |                              |                    | 0xb111,0xb11e  |
 * |                              |                    | 0xb12c,0xb12d  |
 * |                              |                    | 0xb13a,0xb142  |
 * |                              |                    | 0xb13c-0xb140  |
 * |                              |                    | 0xb149		|
 * | MultiQ                       |       0xc010       |		|
 * | Misc                         |       0xd303       | 0xd031-0xd0ff	|
 * |                              |                    | 0xd101-0xd1fe	|
 * |                              |                    | 0xd214-0xd2fe	|
 * | Target Mode		  |	  0xe081       |		|
 * | Target Mode Management	  |	  0xf09b       | 0xf002		|
 * |                              |                    | 0xf046-0xf049  |
 * | Target Mode Task Management  |	  0x1000d      |		|
 * ----------------------------------------------------------------------
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_748.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/soc/pxa/mfp.c#L41-L56

```c
/*
 * Table that determines the low power modes outputs, with actual settings
 * used in parentheses for don't-care values. Except for the float output,
 * the configured driven and pulled levels match, so if there is a need for
 * non-LPM pulled output, the same configuration could probably be used.
 *
 < ASCII >
 * Output value  sleep_oe_n  sleep_data  pullup_en  pulldown_en  pull_sel
 *                 (bit 7)    (bit 8)    (bit 14)     (bit 13)   (bit 15)
 *
 * Input            0          X(0)        X(0)        X(0)       0
 * Drive 0          0          0           0           X(1)       0
 * Drive 1          0          1           X(1)        0	  0
 * Pull hi (1)      1          X(1)        1           0	  0
 * Pull lo (0)      1          X(0)        0           1	  0
 * Z (float)        1          X(0)        0           0	  0
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_749.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/soc/pxa/mfp.c#L65-L77

```c
/*
 * The pullup and pulldown state of the MFP pin at run mode is by default
 * determined by the selected alternate function. In case that some buggy
 * devices need to override this default behavior,  the definitions below
 * indicates the setting of corresponding MFPR bits
 *
 < ASCII >
 * Definition       pull_sel  pullup_en  pulldown_en
 * MFPR_PULL_NONE       0         0        0
 * MFPR_PULL_LOW        1         0        1
 * MFPR_PULL_HIGH       1         1        0
 * MFPR_PULL_BOTH       1         1        1
 * MFPR_PULL_FLOAT	1         0        0
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_75.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/include/asm/kvm_arm.h#L148-L176

```c
/*
 * VTCR_EL2:SL0 indicates the entry level for Stage2 translation.
 * Interestingly, it depends on the page size.
 * See D.10.2.121, VTCR_EL2, in ARM DDI 0487C.a
 *
 < ASCII >
 *	-----------------------------------------
 *	| Entry level		|  4K  | 16K/64K |
 *	------------------------------------------
 *	| Level: 0		|  2   |   -     |
 *	------------------------------------------
 *	| Level: 1		|  1   |   2     |
 *	------------------------------------------
 *	| Level: 2		|  0   |   1     |
 *	------------------------------------------
 *	| Level: 3		|  -   |   0     |
 *	------------------------------------------
 < ASCII >
 *
 * The table roughly translates to :
 *
 *	SL0(PAGE_SIZE, Entry_level) = TGRAN_SL0_BASE - Entry_Level
 *
 * Where TGRAN_SL0_BASE is a magic number depending on the page size:
 * 	TGRAN_SL0_BASE(4K) = 2
 *	TGRAN_SL0_BASE(16K) = 3
 *	TGRAN_SL0_BASE(64K) = 3
 * provided we take care of ruling out the unsupported cases and
 * Entry_Level = 4 - Number_of_levels.
 *
 */
```
## Visual type:
- #table


== ./linux/linux_750.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/soc/qcom/qcom-geni-se.c#L28-L65

```c
/**
 * DOC: Hardware description
 *
 * GENI based QUP is a highly-flexible and programmable module for supporting
 * a wide range of serial interfaces like UART, SPI, I2C, I3C, etc. A single
 * QUP module can provide upto 8 serial interfaces, using its internal
 * serial engines. The actual configuration is determined by the target
 * platform configuration. The protocol supported by each interface is
 * determined by the firmware loaded to the serial engine. Each SE consists
 * of a DMA Engine and GENI sub modules which enable serial engines to
 * support FIFO and DMA modes of operation.
 *
 *
 < ASCII >
 *                      +-----------------------------------------+
 *                      |QUP Wrapper                              |
 *                      |         +----------------------------+  |
 *   --QUP & SE Clocks-->         | Serial Engine N            |  +-IO------>
 *                      |         | ...                        |  | Interface
 *   <---Clock Perf.----+    +----+-----------------------+    |  |
 *     State Interface  |    | Serial Engine 1            |    |  |
 *                      |    |                            |    |  |
 *                      |    |                            |    |  |
 *   <--------AHB------->    |                            |    |  |
 *                      |    |                            +----+  |
 *                      |    |                            |       |
 *                      |    |                            |       |
 *   <------SE IRQ------+    +----------------------------+       |
 *                      |                                         |
 *                      +-----------------------------------------+
 *
 *                         Figure 1: GENI based QUP Wrapper
 < ASCII >
 *
 * The GENI submodules include primary and secondary sequencers which are
 * used to drive TX & RX operations. On serial interfaces that operate using
 * master-slave model, primary sequencer drives both TX & RX operations. On
 * serial interfaces that operate using peer-to-peer model, primary sequencer
 * drives TX operation and secondary sequencer drives RX operation.
 */
```
## Visual type:
- #schematic


== ./linux/linux_751.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/soc/qcom/qcom-geni-se.c#L389-L431

```c
/**
 * DOC: Overview
 *
 * GENI FIFO packing is highly configurable. TX/RX packing/unpacking consist
 * of up to 4 operations, each operation represented by 4 configuration vectors
 * of 10 bits programmed in GENI_TX_PACKING_CFG0 and GENI_TX_PACKING_CFG1 for
 * TX FIFO and in GENI_RX_PACKING_CFG0 and GENI_RX_PACKING_CFG1 for RX FIFO.
 * Refer to below examples for detailed bit-field description.
 *
 < ASCII >
 * Example 1: word_size = 7, packing_mode = 4 x 8, msb_to_lsb = 1
 *
 *        +-----------+-------+-------+-------+-------+
 *        |           | vec_0 | vec_1 | vec_2 | vec_3 |
 *        +-----------+-------+-------+-------+-------+
 *        | start     | 0x6   | 0xe   | 0x16  | 0x1e  |
 *        | direction | 1     | 1     | 1     | 1     |
 *        | length    | 6     | 6     | 6     | 6     |
 *        | stop      | 0     | 0     | 0     | 1     |
 *        +-----------+-------+-------+-------+-------+
 *
 * Example 2: word_size = 15, packing_mode = 2 x 16, msb_to_lsb = 0
 *
 *        +-----------+-------+-------+-------+-------+
 *        |           | vec_0 | vec_1 | vec_2 | vec_3 |
 *        +-----------+-------+-------+-------+-------+
 *        | start     | 0x0   | 0x8   | 0x10  | 0x18  |
 *        | direction | 0     | 0     | 0     | 0     |
 *        | length    | 7     | 6     | 7     | 6     |
 *        | stop      | 0     | 0     | 0     | 1     |
 *        +-----------+-------+-------+-------+-------+
 *
 * Example 3: word_size = 23, packing_mode = 1 x 32, msb_to_lsb = 1
 *
 *        +-----------+-------+-------+-------+-------+
 *        |           | vec_0 | vec_1 | vec_2 | vec_3 |
 *        +-----------+-------+-------+-------+-------+
 *        | start     | 0x16  | 0xe   | 0x6   | 0x0   |
 *        | direction | 1     | 1     | 1     | 1     |
 *        | length    | 7     | 7     | 6     | 0     |
 *        | stop      | 0     | 0     | 1     | 0     |
 *        +-----------+-------+-------+-------+-------+
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_752.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/soc/qcom/rpmh-rsc.c#L94-L146

```c
/*
 * Here's a high level overview of how all the registers in RPMH work
 * together:
 *
 * - The main rpmh-rsc address is the base of a register space that can
 *   be used to find overall configuration of the hardware
 *   (DRV_PRNT_CHLD_CONFIG). Also found within the rpmh-rsc register
 *   space are all the TCS blocks. The offset of the TCS blocks is
 *   specified in the device tree by "qcom,tcs-offset" and used to
 *   compute tcs_base.
 * - TCS blocks come one after another. Type, count, and order are
 *   specified by the device tree as "qcom,tcs-config".
 * - Each TCS block has some registers, then space for up to 16 commands.
 *   Note that though address space is reserved for 16 commands, fewer
 *   might be present. See ncpt (num cmds per TCS).
 *
 < ASCII >
 * Here's a picture:
 *
 *  +---------------------------------------------------+
 *  |RSC                                                |
 *  | ctrl                                              |
 *  |                                                   |
 *  | Drvs:                                             |
 *  | +-----------------------------------------------+ |
 *  | |DRV0                                           | |
 *  | | ctrl/config                                   | |
 *  | | IRQ                                           | |
 *  | |                                               | |
 *  | | TCSes:                                        | |
 *  | | +------------------------------------------+  | |
 *  | | |TCS0  |  |  |  |  |  |  |  |  |  |  |  |  |  | |
 *  | | | ctrl | 0| 1| 2| 3| 4| 5| .| .| .| .|14|15|  | |
 *  | | |      |  |  |  |  |  |  |  |  |  |  |  |  |  | |
 *  | | +------------------------------------------+  | |
 *  | | +------------------------------------------+  | |
 *  | | |TCS1  |  |  |  |  |  |  |  |  |  |  |  |  |  | |
 *  | | | ctrl | 0| 1| 2| 3| 4| 5| .| .| .| .|14|15|  | |
 *  | | |      |  |  |  |  |  |  |  |  |  |  |  |  |  | |
 *  | | +------------------------------------------+  | |
 *  | | +------------------------------------------+  | |
 *  | | |TCS2  |  |  |  |  |  |  |  |  |  |  |  |  |  | |
 *  | | | ctrl | 0| 1| 2| 3| 4| 5| .| .| .| .|14|15|  | |
 *  | | |      |  |  |  |  |  |  |  |  |  |  |  |  |  | |
 *  | | +------------------------------------------+  | |
 *  | |                    ......                     | |
 *  | +-----------------------------------------------+ |
 *  | +-----------------------------------------------+ |
 *  | |DRV1                                           | |
 *  | | (same as DRV0)                                | |
 *  | +-----------------------------------------------+ |
 *  |                      ......                       |
 *  +---------------------------------------------------+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_753.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/soundwire/master.c#L20-L35

```c
/*
 * The sysfs for properties reflects the MIPI description as given
 * in the MIPI DisCo spec
 *
 < ASCII >
 * Base file is:
 *	sdw-master-N
 *      |---- revision
 *      |---- clk_stop_modes
 *      |---- max_clk_freq
 *      |---- clk_freq
 *      |---- clk_gears
 *      |---- default_row
 *      |---- default_col
 *      |---- dynamic_shape
 *      |---- err_threshold
 < ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_754.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/spi/spi-dw-dma.c#L497-L527

```c
/*
 * In case if at least one of the requested DMA channels doesn't support the
 * hardware accelerated SG list entries traverse, the DMA driver will most
 * likely work that around by performing the IRQ-based SG list entries
 * resubmission. That might and will cause a problem if the DMA Tx channel is
 * recharged and re-executed before the Rx DMA channel. Due to
 * non-deterministic IRQ-handler execution latency the DMA Tx channel will
 * start pushing data to the SPI bus before the Rx DMA channel is even
 * reinitialized with the next inbound SG list entry. By doing so the DMA Tx
 * channel will implicitly start filling the DW APB SSI Rx FIFO up, which while
 * the DMA Rx channel being recharged and re-executed will eventually be
 * overflown.
 *
 * In order to solve the problem we have to feed the DMA engine with SG list
 * entries one-by-one. It shall keep the DW APB SSI Tx and Rx FIFOs
 * synchronized and prevent the Rx FIFO overflow. Since in general the tx_sg
 * and rx_sg lists may have different number of entries of different lengths
 * (though total length should match) let's virtually split the SG-lists to the
 * set of DMA transfers, which length is a minimum of the ordered SG-entries
 * lengths. An ASCII-sketch of the implemented algo is following:
 < ASCII >
 *                  xfer->len
 *                |___________|
 * tx_sg list:    |___|____|__|
 * rx_sg list:    |_|____|____|
 * DMA transfers: |_|_|__|_|__|
 < ASCII >
 *
 * Note in order to have this workaround solving the denoted problem the DMA
 * engine driver should properly initialize the max_sg_burst capability and set
 * the DMA device max segment size parameter with maximum data block size the
 * DMA engine supports.
 */
```
## Visual type:
- #sequence


== ./linux/linux_755.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/spi/spi-gpio.c#L20-L31

```c
/*
 * This bitbanging SPI master driver should help make systems usable
 * when a native hardware SPI engine is not available, perhaps because
 * its driver isn't yet working or because the I/O pins it requires
 * are used for other purposes.
 *
 * platform_device->driver_data ... points to spi_gpio
 *
 * spi->controller_state ... reserved for bitbang framework code
 *
 * spi->master->dev.driver_data ... points to spi_gpio->bitbang
 */
```
## Visual type:



== ./linux/linux_756.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/spi/spi-lm70llp.c#L22-L59

```c
/*
 * The LM70 communicates with a host processor using a 3-wire variant of
 * the SPI/Microwire bus interface. This driver specifically supports an
 * NS LM70 LLP Evaluation Board, interfacing to a PC using its parallel
 * port to bitbang an SPI-parport bridge.  Accordingly, this is an SPI
 * master controller driver.  The hwmon/lm70 driver is a "SPI protocol
 * driver", layered on top of this one and usable without the lm70llp.
 *
 * Datasheet and Schematic:
 * The LM70 is a temperature sensor chip from National Semiconductor; its
 * datasheet is available at http://www.national.com/pf/LM/LM70.html
 * The schematic for this particular board (the LM70EVAL-LLP) is
 * available (on page 4) here:
 *  http://www.national.com/appinfo/tempsensors/files/LM70LLPEVALmanual.pdf
 *
 * Also see Documentation/spi/spi-lm70llp.rst.  The SPI<->parport code here is
 * (heavily) based on spi-butterfly by David Brownell.
 *
 * The LM70 LLP connects to the PC parallel port in the following manner:
 *
 < ASCII >
 *   Parallel                 LM70 LLP
 *     Port      Direction   JP2 Header
 *  -----------  ---------  ------------
 *      D0    2      -         -
 *      D1    3     -->      V+   5
 *      D2    4     -->      V+   5
 *      D3    5     -->      V+   5
 *      D4    6     -->      V+   5
 *      D5    7     -->      nCS  8
 *      D6    8     -->      SCLK 3
 *      D7    9     -->      SI/O 5
 *     GND   25      -       GND  7
 *    Select 13     <--      SI/O 1
 < ASCII >
 *
 * Note that parport pin 13 actually gets inverted by the transistor
 * arrangement which lets either the parport or the LM70 drive the
 * SI/SO signal (see the schematic for details).
 */
```
## Visual type:
- #table


== ./linux/linux_757.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/spi/spi-meson-spicc.c#L555-L581

```c
/*
 < ASCII >
 * The Clock Mux
 *            x-----------------x   x------------x    x------\
 *        |---| pow2 fixed div  |---| pow2 div   |----|      |
 *        |   x-----------------x   x------------x    |      |
 * src ---|                                           | mux  |-- out
 *        |   x-----------------x   x------------x    |      |
 *        |---| enh fixed div   |---| enh div    |0---|      |
 *            x-----------------x   x------------x    x------/
 < ASCII >
 *
 * Clk path for GX series:
 *    src -> pow2 fixed div -> pow2 div -> out
 *
 * Clk path for AXG series:
 *    src -> pow2 fixed div -> pow2 div -> mux -> out
 *    src -> enh fixed div -> enh div -> mux -> out
 *
 * Clk path for G12A series:
 *    pclk -> pow2 fixed div -> pow2 div -> mux -> out
 *    pclk -> enh fixed div -> enh div -> mux -> out
 *
 * The pow2 divider is tied to the controller HW state, and the
 * divider is only valid when the controller is initialized.
 *
 * A set of clock ops is added to make sure we don't read/set this
 * clock rate while the controller is in an unknown state.
 */
```
## Visual type:
- #schematic


== ./linux/linux_758.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/spi/spi-nxp-fspi.c#L618-L655

```c
/*
 * In FlexSPI controller, flash access is based on value of FSPI_FLSHXXCR0
 * register and start base address of the slave device.
 *
 < ASCII >
 *							    (Higher address)
 *				--------    <-- FLSHB2CR0
 *				|  B2  |
 *				|      |
 *	B2 start address -->	--------    <-- FLSHB1CR0
 *				|  B1  |
 *				|      |
 *	B1 start address -->	--------    <-- FLSHA2CR0
 *				|  A2  |
 *				|      |
 *	A2 start address -->	--------    <-- FLSHA1CR0
 *				|  A1  |
 *				|      |
 *	A1 start address -->	--------		    (Lower address)
 < ASCII >
 *
 *
 * Start base address defines the starting address range for given CS and
 * FSPI_FLSHXXCR0 defines the size of the slave device connected at given CS.
 *
 * But, different targets are having different combinations of number of CS,
 * some targets only have single CS or two CS covering controller's full
 * memory mapped space area.
 * Thus, implementation is being done as independent of the size and number
 * of the connected slave device.
 * Assign controller memory mapped space size as the size to the connected
 * slave device.
 * Mark FLSHxxCR0 as zero initially and then assign value only to the selected
 * chip-select Flash configuration register.
 *
 * For e.g. to access CS2 (B1), FLSHB1CR0 register would be equal to the
 * memory mapped size of the controller.
 * Value for rest of the CS FLSHxxCR0 register would be zero.
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_759.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/spi/spi-wpcm-fiu.c#L183-L190

```c
/*
 < ASCII >
 * 4-byte addressing.
 *
 * Flash view:  [ C  A  A  A   A     D  D  D  D]
 * bytes:        13 aa bb cc  dd -> 5a a5 f0 0f
 * FIU's view:  [ C  A  A  A][ C     D  D  D  D]
 * FIU mode:    [ read/write][      read       ]
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_76.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/include/asm/kvm_arm.h#L204-L266

```c
/*
 * ARM VMSAv8-64 defines an algorithm for finding the translation table
 * descriptors in section D4.2.8 in ARM DDI 0487C.a.
 *
 * The algorithm defines the expectations on the translation table
 * addresses for each level, based on PAGE_SIZE, entry level
 * and the translation table size (T0SZ). The variable "x" in the
 * algorithm determines the alignment of a table base address at a given
 * level and thus determines the alignment of VTTBR:BADDR for stage2
 * page table entry level.
 * Since the number of bits resolved at the entry level could vary
 * depending on the T0SZ, the value of "x" is defined based on a
 * Magic constant for a given PAGE_SIZE and Entry Level. The
 * intermediate levels must be always aligned to the PAGE_SIZE (i.e,
 * x = PAGE_SHIFT).
 *
 * The value of "x" for entry level is calculated as :
 *    x = Magic_N - T0SZ
 *
 * where Magic_N is an integer depending on the page size and the entry
 * level of the page table as below:
 < ASCII >
 *
 *	--------------------------------------------
 *	| Entry level		|  4K    16K   64K |
 *	--------------------------------------------
 *	| Level: 0 (4 levels)	| 28   |  -  |  -  |
 *	--------------------------------------------
 *	| Level: 1 (3 levels)	| 37   | 31  | 25  |
 *	--------------------------------------------
 *	| Level: 2 (2 levels)	| 46   | 42  | 38  |
 *	--------------------------------------------
 *	| Level: 3 (1 level)	| -    | 53  | 51  |
 *	--------------------------------------------
 < ASCII >
 *
 * We have a magic formula for the Magic_N below:
 *
 *  Magic_N(PAGE_SIZE, Level) = 64 - ((PAGE_SHIFT - 3) * Number_of_levels)
 *
 * where Number_of_levels = (4 - Level). We are only interested in the
 * value for Entry_Level for the stage2 page table.
 *
 * So, given that T0SZ = (64 - IPA_SHIFT), we can compute 'x' as follows:
 *
 *	x = (64 - ((PAGE_SHIFT - 3) * Number_of_levels)) - (64 - IPA_SHIFT)
 *	  = IPA_SHIFT - ((PAGE_SHIFT - 3) * Number of levels)
 *
 * Here is one way to explain the Magic Formula:
 *
 *  x = log2(Size_of_Entry_Level_Table)
 *
 * Since, we can resolve (PAGE_SHIFT - 3) bits at each level, and another
 * PAGE_SHIFT bits in the PTE, we have :
 *
 *  Bits_Entry_level = IPA_SHIFT - ((PAGE_SHIFT - 3) * (n - 1) + PAGE_SHIFT)
 *		     = IPA_SHIFT - (PAGE_SHIFT - 3) * n - 3
 *  where n = number of levels, and since each pointer is 8bytes, we have:
 *
 *  x = Bits_Entry_Level + 3
 *    = IPA_SHIFT - (PAGE_SHIFT - 3) * n
 *
 * The only constraint here is that, we have to find the number of page table
 * levels for a given IPA size (which we do, see stage2_pt_levels())
 */
```
## Visual type:
- #table


== ./linux/linux_760.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/spi/spi-wpcm-fiu.c#L261-L266

```c
/*
 * With some dummy bytes.
 *
 < ASCII >
 *  C A A A  X*  X D D D D
 * [C A A A  D*][C D D D D]
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_761.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/staging/fieldbus/anybuss/host.c#L8-L140

```c
/*
 * Architecture Overview
 * =====================
 * This driver (running on the CPU/SoC) and the Anybus-S card communicate
 * by reading and writing data to/from the Anybus-S Dual-Port RAM (dpram).
 * This is memory connected to both the SoC and Anybus-S card, which both sides
 * can access freely and concurrently.
 *
 * Synchronization happens by means of two registers located in the dpram:
 * IND_AB: written exclusively by the Anybus card; and
 * IND_AP: written exclusively by this driver.
 *
 * Communication happens using one of the following mechanisms:
 * 1. reserve, read/write, release dpram memory areas:
 *	using an IND_AB/IND_AP protocol, the driver is able to reserve certain
 *	memory areas. no dpram memory can be read or written except if reserved.
 *	(with a few limited exceptions)
 * 2. send and receive data structures via a shared mailbox:
 *	using an IND_AB/IND_AP protocol, the driver and Anybus card are able to
 *	exchange commands and responses using a shared mailbox.
 * 3. receive software interrupts:
 *	using an IND_AB/IND_AP protocol, the Anybus card is able to notify the
 *	driver of certain events such as: bus online/offline, data available.
 *	note that software interrupt event bits are located in a memory area
 *	which must be reserved before it can be accessed.
 *
 * The manual[1] is silent on whether these mechanisms can happen concurrently,
 * or how they should be synchronized. However, section 13 (Driver Example)
 * provides the following suggestion for developing a driver:
 * a) an interrupt handler which updates global variables;
 * b) a continuously-running task handling area requests (1 above)
 * c) a continuously-running task handling mailbox requests (2 above)
 * The example conspicuously leaves out software interrupts (3 above), which
 * is the thorniest issue to get right (see below).
 *
 * The naive, straightforward way to implement this would be:
 * - create an isr which updates shared variables;
 * - create a work_struct which handles software interrupts on a queue;
 * - create a function which does reserve/update/unlock in a loop;
 * - create a function which does mailbox send/receive in a loop;
 * - call the above functions from the driver's read/write/ioctl;
 * - synchronize using mutexes/spinlocks:
 *	+ only one area request at a time
 *	+ only one mailbox request at a time
 *	+ protect AB_IND, AB_IND against data hazards (e.g. read-after-write)
 *
 * Unfortunately, the presence of the software interrupt causes subtle yet
 * considerable synchronization issues; especially problematic is the
 * requirement to reserve/release the area which contains the status bits.
 *
 * The driver architecture presented here sidesteps these synchronization issues
 * by accessing the dpram from a single kernel thread only. User-space throws
 * "tasks" (i.e. 1, 2 above) into a task queue, waits for their completion,
 * and the kernel thread runs them to completion.
 *
 * Each task has a task_function, which is called/run by the queue thread.
 * That function communicates with the Anybus card, and returns either
 * 0 (OK), a negative error code (error), or -EINPROGRESS (waiting).
 * On OK or error, the queue thread completes and dequeues the task,
 * which also releases the user space thread which may still be waiting for it.
 * On -EINPROGRESS (waiting), the queue thread will leave the task on the queue,
 * and revisit (call again) whenever an interrupt event comes in.
 *
 * Each task has a state machine, which is run by calling its task_function.
 * It ensures that the task will go through its various stages over time,
 * returning -EINPROGRESS if it wants to wait for an event to happen.
 *
 * Note that according to the manual's driver example, the following operations
 * may run independent of each other:
 * - area reserve/read/write/release	(point 1 above)
 * - mailbox operations			(point 2 above)
 * - switching power on/off
 *
 * To allow them to run independently, each operation class gets its own queue.
 *
 * Userspace processes A, B, C, D post tasks to the appropriate queue,
 * and wait for task completion:
 *
 < ASCII >
 *	process A	B	C	D
 *		|	|	|	|
 *		v	v	v	v
 *	|<-----	========================================
 *	|		|	   |		|
 *	|		v	   v		v-------<-------+
 *	|	+--------------------------------------+	|
 *	|	| power q     | mbox q    | area q     |	|
 *	|	|------------|------------|------------|	|
 *	|	| task       | task       | task       |	|
 *	|	| task       | task       | task       |	|
 *	|	| task wait  | task wait  | task wait  |	|
 *	|	+--------------------------------------+	|
 *	|		^	   ^		^		|
 *	|		|	   |		|		^
 *	|	+--------------------------------------+	|
 *	|	|	     queue thread	       |	|
 *	|	|--------------------------------------|	|
 *	|	| single-threaded:		       |	|
 *	|	| loop:				       |	|
 *	v	|   for each queue:		       |	|
 *	|	|     run task state machine	       |	|
 *	|	|     if task waiting:		       |	|
 *	|	|       leave on queue		       |	|
 *	|	|     if task done:		       |	|
 *	|	|       complete task, remove from q   |	|
 *	|	|   if software irq event bits set:    |	|
 *	|	|     notify userspace		       |	|
 *	|	|     post clear event bits task------>|>-------+
 *	|	|   wait for IND_AB changed event OR   |
 *	|	|            task added event	  OR   |
 *	|	|	     timeout		       |
 *	|	| end loop			       |
 *	|	+--------------------------------------+
 *	|	+		wake up		       +
 *	|	+--------------------------------------+
 *	|		^			^
 *	|		|			|
 *	+-------->-------			|
 *						|
 *		+--------------------------------------+
 *		|	interrupt service routine      |
 *		|--------------------------------------|
 *		| wake up queue thread on IND_AB change|
 *		+--------------------------------------+
 < ASCII >
 *
 * Note that the Anybus interrupt is dual-purpose:
 * - after a reset, triggered when the card becomes ready;
 * - during normal operation, triggered when AB_IND changes.
 * This is why the interrupt service routine doesn't just wake up the
 * queue thread, but also completes the card_boot completion.
 *
 * [1] https://www.anybus.com/docs/librariesprovider7/default-document-library/
 *	manuals-design-guides/hms-hmsi-27-275.pdf
 */
```
## Visual type:
- #flowchart


== ./linux/linux_762.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/staging/media/atomisp/pci/gdc_v2_defs.h#L41-L43

```c
 < ASCII >
//     31  30  29    25 24                     0
//  |-----|---|--------|------------------------|
//  | CMD | C | Reg_ID |        Value           |
 < ASCII >
```
## Visual type:
- #memory-layout


== ./linux/linux_763.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/staging/media/atomisp/pci/gdc_v2_defs.h#L111-L118

```c
// FRYIPXFRX is the only register where we store two values in one field,
// to save one token in the scaling protocol.
// Like this, we have three tokens in the scaling protocol,
// Otherwise, we would have had four.
// The register bit-map is:
 < ASCII >
//   31  26 25      16 15  10 9        0
//  |------|----------|------|----------|
//  | XXXX |   FRY    |  IPX |   FRX    |
 < ASCII >
```
## Visual type:
- #memory-layout


== ./linux/linux_764.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/staging/media/atomisp/pci/gdc_v2_defs.h#L126-L132

```c
// CHK_ENGINE register bit-map:
 < ASCII >
//   31            16 15        2 1  0
//  |----------------|-----------|----|
//  |      OPX       |    OPY    |FSM0|
 < ASCII >
// However, for the time being at least,
// this implementation is meaningless in hss model,
// So, we just return 0
```
## Visual type:
- #memory-layout


== ./linux/linux_765.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/staging/media/atomisp/pci/sh_css_params.c#L752-L766

```c
/* ****************************************************
 * Each coefficient is stored as 7bits to fit 2 of them into one
 * ISP vector element, so we will store 4 coefficents on every
 * memory word (32bits)
 *
 * 0: Coefficient 0 used bits
 * 1: Coefficient 1 used bits
 * 2: Coefficient 2 used bits
 * 3: Coefficient 3 used bits
 * x: not used
 *
 < ASCII >
 * xx33333332222222 | xx11111110000000
 < ASCII >
 *
 * ***************************************************
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_766.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/staging/media/atomisp/pci/sh_css_param_shading.c#L32-L73

```c
/* Bilinear interpolation on shading tables:
 * For each target point T, we calculate the 4 surrounding source points:
 * ul (upper left), ur (upper right), ll (lower left) and lr (lower right).
 * We then calculate the distances from the T to the source points: x0, x1,
 * y0 and y1.
 * We then calculate the value of T:
 *   dx0*dy0*Slr + dx0*dy1*Sur + dx1*dy0*Sll + dx1*dy1*Sul.
 * We choose a grid size of 1x1 which means:
 *   dx1 = 1-dx0
 *   dy1 = 1-dy0
 *
 < ASCII >
 *   Sul dx0         dx1      Sur
 *    .<----->|<------------->.
 *    ^
 * dy0|
 *    v        T
 *    -        .
 *    ^
 *    |
 * dy1|
 *    v
 *    .                        .
 *   Sll                      Slr
 < ASCII >
 *
 * Padding:
 * The area that the ISP operates on can include padding both on the left
 * and the right. We need to padd the shading table such that the shading
 * values end up on the correct pixel values. This means we must padd the
 * shading table to match the ISP padding.
 * We can have 5 cases:
 * 1. All 4 points fall in the left padding.
 * 2. The left 2 points fall in the left padding.
 * 3. All 4 points fall in the cropped (target) region.
 * 4. The right 2 points fall in the right padding.
 * 5. All 4 points fall in the right padding.
 * Cases 1 and 5 are easy to handle: we simply use the
 * value 1 in the shading table.
 * Cases 2 and 4 require interpolation that takes into
 * account how far into the padding area the pixels
 * fall. We extrapolate the shading table into the
 * padded area and then interpolate.
 */
```
## Visual type:
- #custom


== ./linux/linux_767.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/staging/r8188eu/core/rtw_br_ext.c#L38-L47

```c
/*-----------------------------------------------------------------
 < ASCII >
  How database records network address:
	   0    1    2    3    4    5    6    7    8    9   10
	|----|----|----|----|----|----|----|----|----|----|----|
  IPv4  |type|                             |      IP addr      |
  IPX   |type|      Net addr     |          Node addr          |
  IPX   |type|      Net addr     |Sckt addr|
  Apple |type| Network |node|
  PPPoE |type|   SID   |           AC MAC            |
 < ASCII >
-----------------------------------------------------------------*/
```
## Visual type:
- #memory-layout


== ./linux/linux_768.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/staging/rtl8192e/rtllib.h#L673-L681

```c
/* 802.11 data frame from AP
 < ASCII >
 *       ,-------------------------------------------------------------------.
 * Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
 *       |------|------|---------|---------|---------|------|---------|------|
 * Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  frame  |  fcs |
 *       |      | tion | (BSSID) |         |         | ence |  data   |      |
 *       `-------------------------------------------------------------------'
 * Total: 28-2340 bytes
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_769.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/staging/rtl8192e/rtllib_tx.c#L36-L129

```c
/* 802.11 Data Frame
 *
 *
 < ASCII >
 * 802.11 frame_control for data frames - 2 bytes
 *      ,--------------------------------------------------------------------.
 * bits | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |  9 |  a |  b  |  c  |  d  | e  |
 *      |---|---|---|---|---|---|---|---|---|----|----|-----|-----|-----|----|
 * val  | 0 | 0 | 0 | 1 | x | 0 | 0 | 0 | 1 |  0 |  x |  x  |  x  |  x  | x  |
 *      |---|---|---|---|---|---|---|---|---|----|----|-----|-----|-----|----|
 * desc |  ver  | type  |  ^-subtype-^  |to |from|more|retry| pwr |more |wep |
 *      |       |       | x=0 data      |DS | DS |frag|     | mgm |data |    |
 *      |       |       | x=1 data+ack  |   |    |    |     |     |     |    |
 *      '--------------------------------------------------------------------'
 *                                           /\
 *                                           |
 * 802.11 Data Frame                         |
 *          ,--------- 'ctrl' expands to >---'
 *          |
 *       ,--'---,-------------------------------------------------------------.
 * Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
 *       |------|------|---------|---------|---------|------|---------|------|
 * Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  Frame  |  fcs |
 *       |      | tion | (BSSID) |         |         | ence |  data   |      |
 *       `--------------------------------------------------|         |------'
 * Total: 28 non-data bytes                                 `----.----'
 *                                                               |
 *        .- 'Frame data' expands to <---------------------------'
 *        |
 *        V
 *       ,---------------------------------------------------.
 * Bytes |  1   |  1   |    1    |    3     |  2   |  0-2304 |
 *       |------|------|---------|----------|------|---------|
 * Desc. | SNAP | SNAP | Control |Eth Tunnel| Type | IP      |
 *       | DSAP | SSAP |         |          |      | Packet  |
 *       | 0xAA | 0xAA |0x03 (UI)|0x00-00-F8|      |         |
 *       `-----------------------------------------|         |
 * Total: 8 non-data bytes                         `----.----'
 *                                                      |
 *        .- 'IP Packet' expands, if WEP enabled, to <--'
 *        |
 *        V
 *       ,-----------------------.
 * Bytes |  4  |   0-2296  |  4  |
 *       |-----|-----------|-----|
 * Desc. | IV  | Encrypted | ICV |
 *       |     | IP Packet |     |
 *       `-----------------------'
 * Total: 8 non-data bytes
 *
 *
 * 802.3 Ethernet Data Frame
 *
 *       ,-----------------------------------------.
 * Bytes |   6   |   6   |  2   |  Variable |   4  |
 *       |-------|-------|------|-----------|------|
 * Desc. | Dest. | Source| Type | IP Packet |  fcs |
 *       |  MAC  |  MAC  |      |	   |      |
 *       `-----------------------------------------'
 * Total: 18 non-data bytes
 < ASCII >
 *
 * In the event that fragmentation is required, the incoming payload is split
 * into N parts of size ieee->fts.  The first fragment contains the SNAP header
 * and the remaining packets are just data.
 *
 * If encryption is enabled, each fragment payload size is reduced by enough
 * space to add the prefix and postfix (IV and ICV totalling 8 bytes in
 * the case of WEP) So if you have 1500 bytes of payload with ieee->fts set to
 * 500 without encryption it will take 3 frames.  With WEP it will take 4 frames
 * as the payload of each frame is reduced to 492 bytes.
 *
 < ASCII >
 * SKB visualization
 *
 * ,- skb->data
 * |
 * |    ETHERNET HEADER        ,-<-- PAYLOAD
 * |                           |     14 bytes from skb->data
 * |  2 bytes for Type --> ,T. |     (sizeof ethhdr)
 * |                       | | |
 * |,-Dest.--. ,--Src.---. | | |
 * |  6 bytes| | 6 bytes | | | |
 * v         | |         | | | |
 * 0         | v       1 | v | v           2
 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
 *     ^     | ^         | ^ |
 *     |     | |         | | |
 *     |     | |         | `T' <---- 2 bytes for Type
 *     |     | |         |
 *     |     | '---SNAP--' <-------- 6 bytes for SNAP
 *     |     |
 *     `-IV--' <-------------------- 4 bytes for IV (WEP)
 *
 *      SNAP HEADER
 < ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_77.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/include/asm/kvm_emulate.h#L186-L205

```c
/*
 * The layout of SPSR for an AArch32 state is different when observed from an
 * AArch64 SPSR_ELx or an AArch32 SPSR_*. This function generates the AArch32
 * view given an AArch64 view.
 *
 * In ARM DDI 0487E.a see:
 *
 * - The AArch64 view (SPSR_EL2) in section C5.2.18, page C5-426
 * - The AArch32 view (SPSR_abt) in section G8.2.126, page G8-6256
 * - The AArch32 view (SPSR_und) in section G8.2.132, page G8-6280
 *
 * Which show the following differences:
 < ASCII >
 *
 * | Bit | AA64 | AA32 | Notes                       |
 * +-----+------+------+-----------------------------|
 * | 24  | DIT  | J    | J is RES0 in ARMv8          |
 * | 21  | SS   | DIT  | SS doesn't exist in AArch32 |
 < ASCII >
 *
 * ... and all other bits are (currently) common.
 */
```
## Visual type:
- #table


== ./linux/linux_770.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/staging/rtl8192u/ieee80211/ieee80211.h#L774-L783

```c
/*
 < ASCII >
 *  802.11 data frame from AP
 *       ,-------------------------------------------------------------------.
 * Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
 *       |------|------|---------|---------|---------|------|---------|------|
 * Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  frame  |  fcs |
 *       |      | tion | (BSSID) |         |         | ence |  data   |      |
 *       `-------------------------------------------------------------------'
 *  Total: 28-2340 bytes
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_771.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/staging/rtl8192u/ieee80211/ieee80211_tx.c#L41-L136

```c
/*
 *
 *
 * 802.11 Data Frame
 *
 *
 < ASCII >
 * 802.11 frame_contorl for data frames - 2 bytes
 *      ,-----------------------------------------------------------------------------------------.
 * bits | 0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  a  |  b  |  c  |  d  |  e   |
 *      |----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|------|
 * val  | 0  |  0  |  0  |  1  |  x  |  0  |  0  |  0  |  1  |  0  |  x  |  x  |  x  |  x  |  x   |
 *      |----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|------|
 * desc | ^-ver-^  |  ^type-^  |  ^-----subtype-----^  | to  |from |more |retry| pwr |more |wep   |
 *      |          |           | x=0 data,x=1 data+ack | DS  | DS  |frag |     | mgm |data |      |
 *      '-----------------------------------------------------------------------------------------'
 *                                                    /\
 *                                                    |
 * 802.11 Data Frame                                  |
 *           ,--------- 'ctrl' expands to >-----------'
 *           |
 *        ,--'---,-------------------------------------------------------------.
 *  Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
 *        |------|------|---------|---------|---------|------|---------|------|
 *  Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  Frame  |  fcs |
 *        |      | tion | (BSSID) |         |         | ence |  data   |      |
 *        `--------------------------------------------------|         |------'
 *  Total: 28 non-data bytes                                 `----.----'
 *                                                                |
 *         .- 'Frame data' expands to <---------------------------'
 *         |
 *         V
 *        ,---------------------------------------------------.
 *  Bytes |  1   |  1   |    1    |    3     |  2   |  0-2304 |
 *        |------|------|---------|----------|------|---------|
 *  Desc. | SNAP | SNAP | Control |Eth Tunnel| Type | IP      |
 *        | DSAP | SSAP |         |          |      | Packet  |
 *        | 0xAA | 0xAA |0x03 (UI)|0x00-00-F8|      |         |
 *        `-----------------------------------------|         |
 *  Total: 8 non-data bytes                         `----.----'
 *                                                       |
 *         .- 'IP Packet' expands, if WEP enabled, to <--'
 *         |
 *         V
 *        ,-----------------------.
 *  Bytes |  4  |   0-2296  |  4  |
 *        |-----|-----------|-----|
 *  Desc. | IV  | Encrypted | ICV |
 *        |     | IP Packet |     |
 *        `-----------------------'
 *  Total: 8 non-data bytes
 *
 *
 *  802.3 Ethernet Data Frame
 *
 *        ,-----------------------------------------.
 *  Bytes |   6   |   6   |  2   |  Variable |   4  |
 *        |-------|-------|------|-----------|------|
 *  Desc. | Dest. | Source| Type | IP Packet |  fcs |
 *        |  MAC  |  MAC  |      |           |      |
 *        `-----------------------------------------'
 *  Total: 18 non-data bytes
 < ASCII >
 *
 *  In the event that fragmentation is required, the incoming payload is split into
 *  N parts of size ieee->fts.  The first fragment contains the SNAP header and the
 *  remaining packets are just data.
 *
 *  If encryption is enabled, each fragment payload size is reduced by enough space
 *  to add the prefix and postfix (IV and ICV totalling 8 bytes in the case of WEP)
 *  So if you have 1500 bytes of payload with ieee->fts set to 500 without
 *  encryption it will take 3 frames.  With WEP it will take 4 frames as the
 *  payload of each frame is reduced to 492 bytes.
 *
 < ASCII >
 * SKB visualization
 *
 *  ,- skb->data
 * |
 * |    ETHERNET HEADER        ,-<-- PAYLOAD
 * |                           |     14 bytes from skb->data
 * |  2 bytes for Type --> ,T. |     (sizeof ethhdr)
 * |                       | | |
 * |,-Dest.--. ,--Src.---. | | |
 * |  6 bytes| | 6 bytes | | | |
 * v         | |         | | | |
 * 0         | v       1 | v | v           2
 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
 *     ^     | ^         | ^ |
 *     |     | |         | | |
 *     |     | |         | `T' <---- 2 bytes for Type
 *     |     | |         |
 *     |     | '---SNAP--' <-------- 6 bytes for SNAP
 *     |     |
 *     `-IV--' <-------------------- 4 bytes for IV (WEP)
 *
 *      SNAP HEADER
 < ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_772.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/staging/sm750fb/ddk750_swi2c.c#L15-L51

```c
/*
 * I2C Software Master Driver:
 * ===========================
 * Each i2c cycle is split into 4 sections. Each of these section marks
 * a point in time where the SCL or SDA may be changed.
 < ASCII >
 *
 * 1 Cycle == |  Section I. |  Section 2. |  Section 3. |  Section 4. |
 *            +-------------+-------------+-------------+-------------+
 *            | SCL set LOW |SCL no change| SCL set HIGH|SCL no change|
 *
 *                                          ____________ _____________
 * SCL == XXXX _____________ ____________ /
 < ASCII >
 *
 * I.e. the SCL may only be changed in section 1. and section 3. while
 * the SDA may only be changed in section 2. and section 4. The table
 * below gives the changes for these 2 lines in the varios sections.
 *
 * Section changes Table:
 * ======================
 * blank = no change, L = set bit LOW, H = set bit HIGH
 < ASCII >
 *
 *                                | 1.| 2.| 3.| 4.|
 *                 ---------------+---+---+---+---+
 *                 Tx Start   SDA |   | H |   | L |
 *                            SCL | L |   | H |   |
 *                 ---------------+---+---+---+---+
 *                 Tx Stop    SDA |   | L |   | H |
 *                            SCL | L |   | H |   |
 *                 ---------------+---+---+---+---+
 *                 Tx bit H   SDA |   | H |   |   |
 *                            SCL | L |   | H |   |
 *                 ---------------+---+---+---+---+
 *                 Tx bit L   SDA |   | L |   |   |
 *                            SCL | L |   | H |   |
 *                 ---------------+---+---+---+---+
 < ASCII >
 *
 */
```
## Visual type:
- #plot


== ./linux/linux_773.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/staging/wlan-ng/p80211types.h#L122-L134

```c
/*----------------------------------------------------------------
 * The following constants and macros are used to construct and
 * deconstruct the Data ID codes.  The coding is as follows:
 *
 < ASCII >
 *     ...rwtnnnnnnnniiiiiiggggggssssss      s - Section
 *                                           g - Group
 *                                           i - Item
 *                                           n - Index
 *                                           t - Table flag
 *                                           w - Write flag
 *                                           r - Read flag
 *                                           . - Unused
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_774.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/staging/wlan-ng/prism2fw.c#L812-L872

```c
/*----------------------------------------------------------------
 * read_fwfile
 *
 * Reads the given fw file which should have been compiled from an srec
 * file. Each record in the fw file will either be a plain data record,
 * a start address record, or other records used for plugging.
 *
 * Note that data records are expected to be sorted into
 * ascending address order in the fw file.
 *
 * Note also that the start address record, originally an S7 record in
 * the srec file, is expected in the fw file to be like a data record but
 * with a certain address to make it identifiable.
 *
 * Here's the SREC format that the fw should have come from:
 * S[37]nnaaaaaaaaddd...dddcc
 *
 *       nn - number of bytes starting with the address field
 * aaaaaaaa - address in readable (or big endian) format
 * dd....dd - 0-245 data bytes (two chars per byte)
 *       cc - checksum
 *
 * The S7 record's (there should be only one) address value gets
 * converted to an S3 record with address of 0xff400000, with the
 * start address being stored as a 4 byte data word. That address is
 * the start execution address used for RAM downloads.
 *
 * The S3 records have a collection of subformats indicated by the
 * value of aaaaaaaa:
 < ASCII >
 *   0xff000000 - Plug record, data field format:
 *                xxxxxxxxaaaaaaaassssssss
 *                x - PDR code number (little endian)
 *                a - Address in load image to plug (little endian)
 *                s - Length of plug data area (little endian)
 *
 *   0xff100000 - CRC16 generation record, data field format:
 *                aaaaaaaassssssssbbbbbbbb
 *                a - Start address for CRC calculation (little endian)
 *                s - Length of data to  calculate over (little endian)
 *                b - Boolean, true=write crc, false=don't write
 *
 *   0xff200000 - Info record, data field format:
 *                ssssttttdd..dd
 *                s - Size in words (little endian)
 *                t - Info type (little endian), see #defines and
 *                    struct s3inforec for details about types.
 *                d - (s - 1) little endian words giving the contents of
 *                    the given info type.
 *
 *   0xff400000 - Start address record, data field format:
 *                aaaaaaaa
 *                a - Address in load image to plug (little endian)
 < ASCII >
 *
 * Arguments:
 *	record	firmware image (ihex record structure) in kernel memory
 *
 * Returns:
 *	0	- success
 *	~0	- failure (probably an errno)
 *----------------------------------------------------------------
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_775.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/thermal/cpufreq_cooling.c#L28-L40

```c
/*
 * Cooling state <-> CPUFreq frequency
 *
 * Cooling states are translated to frequencies throughout this driver and this
 * is the relation between them.
 *
 * Highest cooling state corresponds to lowest possible frequency.
 *
 * i.e.
 *	level 0 --> 1st Max Freq
 *	level 1 --> 2nd Max Freq
 *	...
 */
```
## Visual type:
- #ignore


== ./linux/linux_776.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/thermal/gov_bang_bang.c#L68-L94

```c
/**
 * bang_bang_control - controls devices associated with the given zone
 * @tz: thermal_zone_device
 * @trip: the trip point
 *
 * Regulation Logic: a two point regulation, deliver cooling state depending
 * on the previous state shown in this diagram:
 *
 < ASCII >
 *                Fan:   OFF    ON
 *
 *                              |
 *                              |
 *          trip_temp:    +---->+
 *                        |     |        ^
 *                        |     |        |
 *                        |     |   Temperature
 * (trip_temp - hyst):    +<----+
 *                        |
 *                        |
 *                        |
 < ASCII >
 *
 *   * If the fan is not running and temperature exceeds trip_temp, the fan
 *     gets turned on.
 *   * In case the fan is running, temperature must fall below
 *     (trip_temp - hyst) so that the fan gets turned off again.
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_777.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/thermal/tegra/soctherm-fuse.c#L21-L47

```c
/*
 < ASCII >
 * Tegra210: Layout of bits in FUSE_TSENSOR_COMMON:
 *    3                   2                   1                   0
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |       BASE_FT       |      BASE_CP      | SHFT_FT | SHIFT_CP  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 *
 * Tegra12x, etc:
 * In chips prior to Tegra210, this fuse was incorrectly sized as 26 bits,
 * and didn't hold SHIFT_CP in [31:26]. Therefore these missing six bits
 * were obtained via the FUSE_SPARE_REALIGNMENT_REG register [5:0].
 *
 < ASCII >
 * FUSE_TSENSOR_COMMON:
 *    3                   2                   1                   0
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |-----------| SHFT_FT |       BASE_FT       |      BASE_CP      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 * FUSE_SPARE_REALIGNMENT_REG:
 *    3                   2                   1                   0
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |---------------------------------------------------| SHIFT_CP  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_778.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/thermal/ti-soc-thermal/ti-bandgap.h#L22-L61

```c
/**
 * DOC: bandgap driver data structure
 * ==================================
 *
 < ASCII >
 *   +----------+----------------+
 *   | struct temp_sensor_regval |
 *   +---------------------------+
 *              * (Array of)
 *              |
 *              |
 *   +-------------------+   +-----------------+
 *   | struct ti_bandgap |-->| struct device * |
 *   +----------+--------+   +-----------------+
 *              |
 *              |
 *              V
 *   +------------------------+
 *   | struct ti_bandgap_data |
 *   +------------------------+
 *              |
 *              |
 *              * (Array of)
 * +------------+------------------------------------------------------+
 * | +----------+------------+   +-------------------------+           |
 * | | struct ti_temp_sensor |-->| struct temp_sensor_data |           |
 * | +-----------------------+   +------------+------------+           |
 * |            |                                                      |
 * |            +                                                      |
 * |            V                                                      |
 * | +----------+-------------------+                                  |
 * | | struct temp_sensor_registers |                                  |
 * | +------------------------------+                                  |
 * |                                                                   |
 * +-------------------------------------------------------------------+
 < ASCII >
 *
 * Above is a simple diagram describing how the data structure below
 * are organized. For each bandgap device there should be a ti_bandgap_data
 * containing the device instance configuration, as well as, an array of
 * sensors, representing every sensor instance present in this bandgap.
 */
```
## Visual type:
- #custom


== ./linux/linux_779.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/tty/mips_ejtag_fdc.c#L195-L213

```c
/*
 * This is a compact encoding which allows every 1 byte, 2 byte, and 3 byte
 * sequence to be encoded in a single word, while allowing the majority of 4
 * byte sequences (including all ASCII and common binary data) to be encoded in
 * a single word too.
 < ASCII >
 *    _______________________ _____________
 *   |       FDC Word        |             |
 *   |31-24|23-16|15-8 | 7-0 |    Bytes    |
 *   |_____|_____|_____|_____|_____________|
 *   |     |     |     |     |             |
 *   |0x80 |0x80 |0x80 |  WW | WW          |
 *   |0x81 |0x81 |  XX |  WW | WW XX       |
 *   |0x82 |  YY |  XX |  WW | WW XX YY    |
 *   |  ZZ |  YY |  XX |  WW | WW XX YY ZZ |
 *   |_____|_____|_____|_____|_____________|
 < ASCII >
 *
 * Note that the 4-byte encoding can only be used where none of the other 3
 * encodings match, otherwise it must fall back to the 3 byte encoding.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_78.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/include/asm/mmu.h#L30-L55

```c
/*
 * We use atomic64_read() here because the ASID for an 'mm_struct' can
 * be reallocated when scheduling one of its threads following a
 * rollover event (see new_context() and flush_context()). In this case,
 * a concurrent TLBI (e.g. via try_to_unmap_one() and ptep_clear_flush())
 * may use a stale ASID. This is fine in principle as the new ASID is
 * guaranteed to be clean in the TLB, but the TLBI routines have to take
 * care to handle the following race:
 *
 < ASCII >
 *    CPU 0                    CPU 1                          CPU 2
 *
 *    // ptep_clear_flush(mm)
 *    xchg_relaxed(pte, 0)
 *    DSB ISHST
 *    old = ASID(mm)
 *         |                                                  <rollover>
 *         |                   new = new_context(mm)
 *         \-----------------> atomic_set(mm->context.id, new)
 *                             cpu_switch_mm(mm)
 *                             // Hardware walk of pte using new ASID
 *    TLBI(old)
 < ASCII >
 *
 * In this scenario, the barrier on CPU 0 and the dependency on CPU 1
 * ensure that the page-table walker on CPU 1 *must* see the invalid PTE
 * written by CPU 0.
 */
```
## Visual type:
- #sequence-diagram


== ./linux/linux_780.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/usb/atm/cxacru.c#L94-L108

```c
/* commands for interaction with the flash memory
 *
 * read:  response is the contents of the first 60 bytes of flash memory
 * write: request contains the 60 bytes of data to write to flash memory
 *        response is the contents of the first 60 bytes of flash memory
 *
 < ASCII >
 * layout: PP PP VV VV  MM MM MM MM  MM MM ?? ??  SS SS SS SS  SS SS SS SS
 *         SS SS SS SS  SS SS SS SS  00 00 00 00  00 00 00 00  00 00 00 00
 *         00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
 < ASCII >
 *
 *   P: le16  USB Product ID
 *   V: le16  USB Vendor ID
 *   M: be48  MAC Address
 *   S: le16  ASCII Serial Number
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_781.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/usb/common/usb-conn-gpio.c#L47-L63

```c
/*
 * "DEVICE" = VBUS and "HOST" = !ID, so we have:
 * Both "DEVICE" and "HOST" can't be set as active at the same time
 * so if "HOST" is active (i.e. ID is 0)  we keep "DEVICE" inactive
 * even if VBUS is on.
 *
 < ASCII >
 *  Role          |   ID  |  VBUS
 * ------------------------------------
 *  [1] DEVICE    |   H   |   H
 *  [2] NONE      |   H   |   L
 *  [3] HOST      |   L   |   H
 *  [4] HOST      |   L   |   L
 < ASCII >
 *
 * In case we have only one of these signals:
 * - VBUS only - we want to distinguish between [1] and [2], so ID is always 1
 * - ID only - we want to distinguish between [1] and [4], so VBUS = ID
 */
```
## Visual type:
- #table


== ./linux/linux_782.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/usb/dwc2/hcd_queue.c#L111-L201

```c
/**
 * pmap_schedule() - Schedule time in a periodic bitmap (pmap).
 *
 * @map:             The bitmap representing the schedule; will be updated
 *                   upon success.
 * @bits_per_period: The schedule represents several periods.  This is how many
 *                   bits are in each period.  It's assumed that the beginning
 *                   of the schedule will repeat after its end.
 * @periods_in_map:  The number of periods in the schedule.
 * @num_bits:        The number of bits we need per period we want to reserve
 *                   in this function call.
 * @interval:        How often we need to be scheduled for the reservation this
 *                   time.  1 means every period.  2 means every other period.
 *                   ...you get the picture?
 * @start:           The bit number to start at.  Normally 0.  Must be within
 *                   the interval or we return failure right away.
 * @only_one_period: Normally we'll allow picking a start anywhere within the
 *                   first interval, since we can still make all repetition
 *                   requirements by doing that.  However, if you pass true
 *                   here then we'll return failure if we can't fit within
 *                   the period that "start" is in.
 *
 * The idea here is that we want to schedule time for repeating events that all
 * want the same resource.  The resource is divided into fixed-sized periods
 * and the events want to repeat every "interval" periods.  The schedule
 * granularity is one bit.
 *
 * To keep things "simple", we'll represent our schedule with a bitmap that
 * contains a fixed number of periods.  This gets rid of a lot of complexity
 * but does mean that we need to handle things specially (and non-ideally) if
 * the number of the periods in the schedule doesn't match well with the
 * intervals that we're trying to schedule.
 *
 * Here's an explanation of the scheme we'll implement, assuming 8 periods.
 * - If interval is 1, we need to take up space in each of the 8
 *   periods we're scheduling.  Easy.
 * - If interval is 2, we need to take up space in half of the
 *   periods.  Again, easy.
 * - If interval is 3, we actually need to fall back to interval 1.
 *   Why?  Because we might need time in any period.  AKA for the
 *   first 8 periods, we'll be in slot 0, 3, 6.  Then we'll be
 *   in slot 1, 4, 7.  Then we'll be in 2, 5.  Then we'll be back to
 *   0, 3, and 6.  Since we could be in any frame we need to reserve
 *   for all of them.  Sucks, but that's what you gotta do.  Note that
 *   if we were instead scheduling 8 * 3 = 24 we'd do much better, but
 *   then we need more memory and time to do scheduling.
 * - If interval is 4, easy.
 * - If interval is 5, we again need interval 1.  The schedule will be
 *   0, 5, 2, 7, 4, 1, 6, 3, 0
 * - If interval is 6, we need interval 2.  0, 6, 4, 2.
 * - If interval is 7, we need interval 1.
 * - If interval is 8, we need interval 8.
 *
 * If you do the math, you'll see that we need to pretend that interval is
 * equal to the greatest_common_divisor(interval, periods_in_map).
 *
 * Note that at the moment this function tends to front-pack the schedule.
 * In some cases that's really non-ideal (it's hard to schedule things that
 * need to repeat every period).  In other cases it's perfect (you can easily
 * schedule bigger, less often repeating things).
 *
 < ASCII >
 * Here's the algorithm in action (8 periods, 5 bits per period):
 *  |**   |     |**   |     |**   |     |**   |     |   OK 2 bits, intv 2 at 0
 *  |*****|  ***|*****|  ***|*****|  ***|*****|  ***|   OK 3 bits, intv 3 at 2
 *  |*****|* ***|*****|  ***|*****|* ***|*****|  ***|   OK 1 bits, intv 4 at 5
 *  |**   |*    |**   |     |**   |*    |**   |     | Remv 3 bits, intv 3 at 2
 *  |***  |*    |***  |     |***  |*    |***  |     |   OK 1 bits, intv 6 at 2
 *  |**** |*  * |**** |   * |**** |*  * |**** |   * |   OK 1 bits, intv 1 at 3
 *  |**** |**** |**** | *** |**** |**** |**** | *** |   OK 2 bits, intv 2 at 6
 *  |*****|*****|*****| ****|*****|*****|*****| ****|   OK 1 bits, intv 1 at 4
 *  |*****|*****|*****| ****|*****|*****|*****| ****| FAIL 1 bits, intv 1
 *  |  ***|*****|  ***| ****|  ***|*****|  ***| ****| Remv 2 bits, intv 2 at 0
 *  |  ***| ****|  ***| ****|  ***| ****|  ***| ****| Remv 1 bits, intv 4 at 5
 *  |   **| ****|   **| ****|   **| ****|   **| ****| Remv 1 bits, intv 6 at 2
 *  |    *| ** *|    *| ** *|    *| ** *|    *| ** *| Remv 1 bits, intv 1 at 3
 *  |    *|    *|    *|    *|    *|    *|    *|    *| Remv 2 bits, intv 2 at 6
 *  |     |     |     |     |     |     |     |     | Remv 1 bits, intv 1 at 4
 *  |**   |     |**   |     |**   |     |**   |     |   OK 2 bits, intv 2 at 0
 *  |***  |     |**   |     |***  |     |**   |     |   OK 1 bits, intv 4 at 2
 *  |*****|     |** **|     |*****|     |** **|     |   OK 2 bits, intv 2 at 3
 *  |*****|*    |** **|     |*****|*    |** **|     |   OK 1 bits, intv 4 at 5
 *  |*****|***  |** **| **  |*****|***  |** **| **  |   OK 2 bits, intv 2 at 6
 *  |*****|*****|** **| ****|*****|*****|** **| ****|   OK 2 bits, intv 2 at 8
 *  |*****|*****|*****| ****|*****|*****|*****| ****|   OK 1 bits, intv 4 at 12
 < ASCII >
 *
 * This function is pretty generic and could be easily abstracted if anything
 * needed similar scheduling.
 *
 * Returns either -ENOSPC or a >= 0 start bit which should be passed to the
 * unschedule routine.  The map bitmap will be updated on a non-error result.
 */
```
## Visual type:
- #custom


== ./linux/linux_783.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/usb/dwc2/platform.c#L29-L51

```c
/*
 * Check the dr_mode against the module configuration and hardware
 * capabilities.
 *
 * The hardware, module, and dr_mode, can each be set to host, device,
 * or otg. Check that all these values are compatible and adjust the
 * value of dr_mode if possible.
 *
 < ASCII >
 *                      actual
 *    HW  MOD dr_mode   dr_mode
 *  ------------------------------
 *   HST  HST  any    :  HST
 *   HST  DEV  any    :  ---
 *   HST  OTG  any    :  HST
 *
 *   DEV  HST  any    :  ---
 *   DEV  DEV  any    :  DEV
 *   DEV  OTG  any    :  DEV
 *
 *   OTG  HST  any    :  HST
 *   OTG  DEV  any    :  DEV
 *   OTG  OTG  any    :  dr_mode
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_784.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/usb/host/ohci.h#L501-L534

```c
/*
 * While most USB host controllers implement their registers and
 * in-memory communication descriptors in little-endian format,
 * a minority (notably the IBM STB04XXX and the Motorola MPC5200
 * processors) implement them in big endian format.
 *
 * In addition some more exotic implementations like the Toshiba
 * Spider (aka SCC) cell southbridge are "mixed" endian, that is,
 * they have a different endianness for registers vs. in-memory
 * descriptors.
 *
 * This attempts to support either format at compile time without a
 * runtime penalty, or both formats with the additional overhead
 * of checking a flag bit.
 *
 * That leads to some tricky Kconfig rules howevber. There are
 * different defaults based on some arch/ppc platforms, though
 * the basic rules are:
 *
 < ASCII >
 * Controller type              Kconfig options needed
 * ---------------              ----------------------
 * little endian                CONFIG_USB_OHCI_LITTLE_ENDIAN
 *
 * fully big endian             CONFIG_USB_OHCI_BIG_ENDIAN_DESC _and_
 *                              CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
 *
 * mixed endian                 CONFIG_USB_OHCI_LITTLE_ENDIAN _and_
 *                              CONFIG_USB_OHCI_BIG_ENDIAN_{MMIO,DESC}
 < ASCII >
 *
 * (If you have a mixed endian controller, you -must- also define
 * CONFIG_USB_OHCI_LITTLE_ENDIAN or things will not work when building
 * both your mixed endian and a fully big endian controller support in
 * the same kernel image).
 */
```
## Visual type:
- #table


== ./linux/linux_785.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/usb/musb/musb_host.c#L1495-L1528

```c
/* Host side RX (IN) using Mentor DMA works as follows:
 < ASCII >
	submit_urb ->
		- if queue was empty, ProgramEndpoint
		- first IN token is sent out (by setting ReqPkt)
	LinuxIsr -> RxReady()
	/\	=> first packet is received
	|	- Set in mode 0 (DmaEnab, ~ReqPkt)
	|		-> DMA Isr (transfer complete) -> RxReady()
	|		    - Ack receive (~RxPktRdy), turn off DMA (~DmaEnab)
	|		    - if urb not complete, send next IN token (ReqPkt)
	|			   |		else complete urb.
	|			   |
	---------------------------
 < ASCII >
 *
 * Nuances of mode 1:
 *	For short packets, no ack (+RxPktRdy) is sent automatically
 *	(even if AutoClear is ON)
 *	For full packets, ack (~RxPktRdy) and next IN token (+ReqPkt) is sent
 *	automatically => major problem, as collecting the next packet becomes
 *	difficult. Hence mode 1 is not used.
 *
 * REVISIT
 *	All we care about at this driver level is that
 *       (a) all URBs terminate with REQPKT cleared and fifo(s) empty;
 *       (b) termination conditions are: short RX, or buffer full;
 *       (c) fault modes include
 *           - iff URB_SHORT_NOT_OK, short RX status is -EREMOTEIO.
 *             (and that endpoint's dma queue stops immediately)
 *           - overflow (full, PLUS more bytes in the terminal packet)
 *
 *	So for example, usb-storage sets URB_SHORT_NOT_OK, and would
 *	thus be a great candidate for using mode 1 ... for all but the
 *	last packet of one URB's transfer.
 */
```
## Visual type:
- #custom


== ./linux/linux_786.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/usb/renesas_usbhs/mod_host.c#L30-L58

```c
/*
 < ASCII >
 *		image of mod_host
 *
 * +--------+
 * | udev 0 | --> it is used when set address
 * +--------+
 *
 * +--------+					pipes are reused for each uep.
 * | udev 1 |-+- [uep 0 (dcp) ] --+		pipe will be switched when
 * +--------+ |			  |		other device requested
 *	      +- [uep 1 (bulk)]	--|---+		   +--------------+
 *	      |			  +--------------> | pipe0 (dcp)  |
 *	      +- [uep 2 (bulk)]	-@    |		   +--------------+
 *				      |		   | pipe1 (isoc) |
 * +--------+			      |		   +--------------+
 * | udev 2 |-+- [uep 0 (dcp) ]	-@    +----------> | pipe2 (bulk) |
 * +--------+ |					   +--------------+
 *	      +- [uep 1 (int) ]	----+	  +------> | pipe3 (bulk) |
 *				    |	  |	   +--------------+
 * +--------+			    +-----|------> | pipe4 (int)  |
 * | udev 3 |-+- [uep 0 (dcp) ]	-@	  |	   +--------------+
 * +--------+ |				  |	   | ....	  |
 *	      +- [uep 1 (bulk)]	-@	  |	   | ....	  |
 *	      |				  |
 *	      +- [uep 2 (bulk)]-----------+
 < ASCII >
 *
 * @ :	uep requested free pipe, but all have been used.
 *	now it is waiting for free pipe
 */
```
## Visual type:
- #custom


== ./linux/linux_787.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/usb/serial/safe_serial.c#L13-L59

```c
/*
 * The encapsultaion is designed to overcome difficulties with some USB
 * hardware.
 *
 * While the USB protocol has a CRC over the data while in transit, i.e. while
 * being carried over the bus, there is no end to end protection. If the
 * hardware has any problems getting the data into or out of the USB transmit
 * and receive FIFO's then data can be lost.
 *
 * This protocol adds a two byte trailer to each USB packet to specify the
 * number of bytes of valid data and a 10 bit CRC that will allow the receiver
 * to verify that the entire USB packet was received without error.
 *
 * Because in this case the sender and receiver are the class and function
 * drivers there is now end to end protection.
 *
 * There is an additional option that can be used to force all transmitted
 * packets to be padded to the maximum packet size. This provides a work
 * around for some devices which have problems with small USB packets.
 *
 * Assuming a packetsize of N:
 *
 *      0..N-2  data and optional padding
 *
 *      N-2     bits 7-2 - number of bytes of valid data
 *              bits 1-0 top two bits of 10 bit CRC
 *      N-1     bottom 8 bits of 10 bit CRC
 *
 *
 < ASCII >
 *      | Data Length       | 10 bit CRC                                |
 *      + 7 . 6 . 5 . 4 . 3 . 2 . 1 . 0 | 7 . 6 . 5 . 4 . 3 . 2 . 1 . 0 +
 < ASCII >
 *
 * The 10 bit CRC is computed across the sent data, followed by the trailer
 * with the length set and the CRC set to zero. The CRC is then OR'd into
 * the trailer.
 *
 * When received a 10 bit CRC is computed over the entire frame including
 * the trailer and should be equal to zero.
 *
 * Two module parameters are used to control the encapsulation, if both are
 * turned of the module works as a simple serial device with NO
 * encapsulation.
 *
 * See linux/drivers/usbd/serial_fd for a device function driver
 * implementation of this.
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_788.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/video/fbdev/acornfb.c#L246-L263

```c
/*
 * We have to take note of the VIDC20's 16-bit palette here.
 * The VIDC20 looks up a 16 bit pixel as follows:
 *
 < ASCII >
 *   bits   111111
 *          5432109876543210
 *   red            ++++++++  (8 bits,  7 to 0)
 *  green       ++++++++      (8 bits, 11 to 4)
 *   blue   ++++++++          (8 bits, 15 to 8)
 < ASCII >
 *
 * We use a pixel which looks like:
 *
 < ASCII >
 *   bits   111111
 *          5432109876543210
 *   red               +++++  (5 bits,  4 to  0)
 *  green         +++++       (5 bits,  9 to  5)
 *   blue    +++++            (5 bits, 14 to 10)
 < ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_789.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/video/fbdev/amifb.c#L103-L366

```c
/*******************************************************************************


   Generic video timings
   ---------------------

   Timings used by the frame buffer interface:

 < ASCII >
   +----------+---------------------------------------------+----------+-------+
   |          |                ^                            |          |       |
   |          |                |upper_margin                |          |       |
   |          |                v                            |          |       |
   +----------###############################################----------+-------+
   |          #                ^                            #          |       |
   |          #                |                            #          |       |
   |          #                |                            #          |       |
   |          #                |                            #          |       |
   |   left   #                |                            #  right   | hsync |
   |  margin  #                |       xres                 #  margin  |  len  |
   |<-------->#<---------------+--------------------------->#<-------->|<----->|
   |          #                |                            #          |       |
   |          #                |                            #          |       |
   |          #                |                            #          |       |
   |          #                |yres                        #          |       |
   |          #                |                            #          |       |
   |          #                |                            #          |       |
   |          #                |                            #          |       |
   |          #                |                            #          |       |
   |          #                |                            #          |       |
   |          #                |                            #          |       |
   |          #                |                            #          |       |
   |          #                |                            #          |       |
   |          #                v                            #          |       |
   +----------###############################################----------+-------+
   |          |                ^                            |          |       |
   |          |                |lower_margin                |          |       |
   |          |                v                            |          |       |
   +----------+---------------------------------------------+----------+-------+
   |          |                ^                            |          |       |
   |          |                |vsync_len                   |          |       |
   |          |                v                            |          |       |
   +----------+---------------------------------------------+----------+-------+

 < ASCII >

   Amiga video timings
   -------------------

   The Amiga native chipsets uses another timing scheme:

      - hsstrt:   Start of horizontal synchronization pulse
      - hsstop:   End of horizontal synchronization pulse
      - htotal:   Last value on the line (i.e. line length = htotal + 1)
      - vsstrt:   Start of vertical synchronization pulse
      - vsstop:   End of vertical synchronization pulse
      - vtotal:   Last line value (i.e. number of lines = vtotal + 1)
      - hcenter:  Start of vertical retrace for interlace

   You can specify the blanking timings independently. Currently I just set
   them equal to the respective synchronization values:

      - hbstrt:   Start of horizontal blank
      - hbstop:   End of horizontal blank
      - vbstrt:   Start of vertical blank
      - vbstop:   End of vertical blank

   Horizontal values are in color clock cycles (280 ns), vertical values are in
   scanlines.

   (0, 0) is somewhere in the upper-left corner :-)


   Amiga visible window definitions
   --------------------------------

   Currently I only have values for AGA, SHRES (28 MHz dotclock). Feel free to
   make corrections and/or additions.

   Within the above synchronization specifications, the visible window is
   defined by the following parameters (actual register resolutions may be
   different; all horizontal values are normalized with respect to the pixel
   clock):

      - diwstrt_h:   Horizontal start of the visible window
      - diwstop_h:   Horizontal stop + 1(*) of the visible window
      - diwstrt_v:   Vertical start of the visible window
      - diwstop_v:   Vertical stop of the visible window
      - ddfstrt:     Horizontal start of display DMA
      - ddfstop:     Horizontal stop of display DMA
      - hscroll:     Horizontal display output delay

   Sprite positioning:

      - sprstrt_h:   Horizontal start - 4 of sprite
      - sprstrt_v:   Vertical start of sprite

   (*) Even Commodore did it wrong in the AGA monitor drivers by not adding 1.

   Horizontal values are in dotclock cycles (35 ns), vertical values are in
   scanlines.

   (0, 0) is somewhere in the upper-left corner :-)


   Dependencies (AGA, SHRES (35 ns dotclock))
   -------------------------------------------

   Since there are much more parameters for the Amiga display than for the
   frame buffer interface, there must be some dependencies among the Amiga
   display parameters. Here's what I found out:

      - ddfstrt and ddfstop are best aligned to 64 pixels.
      - the chipset needs 64 + 4 horizontal pixels after the DMA start before
	the first pixel is output, so diwstrt_h = ddfstrt + 64 + 4 if you want
	to display the first pixel on the line too. Increase diwstrt_h for
	virtual screen panning.
      - the display DMA always fetches 64 pixels at a time (fmode = 3).
      - ddfstop is ddfstrt+#pixels - 64.
      - diwstop_h = diwstrt_h + xres + 1. Because of the additional 1 this can
	be 1 more than htotal.
      - hscroll simply adds a delay to the display output. Smooth horizontal
	panning needs an extra 64 pixels on the left to prefetch the pixels that
	`fall off' on the left.
      - if ddfstrt < 192, the sprite DMA cycles are all stolen by the bitplane
	DMA, so it's best to make the DMA start as late as possible.
      - you really don't want to make ddfstrt < 128, since this will steal DMA
	cycles from the other DMA channels (audio, floppy and Chip RAM refresh).
      - I make diwstop_h and diwstop_v as large as possible.

   General dependencies
   --------------------

      - all values are SHRES pixel (35ns)

 < ASCII >
		  table 1:fetchstart  table 2:prefetch    table 3:fetchsize
		  ------------------  ----------------    -----------------
   Pixclock     # SHRES|HIRES|LORES # SHRES|HIRES|LORES # SHRES|HIRES|LORES
   -------------#------+-----+------#------+-----+------#------+-----+------
   Bus width 1x #   16 |  32 |  64  #   16 |  32 |  64  #   64 |  64 |  64
   Bus width 2x #   32 |  64 | 128  #   32 |  64 |  64  #   64 |  64 | 128
   Bus width 4x #   64 | 128 | 256  #   64 |  64 |  64  #   64 | 128 | 256
 < ASCII >

      - chipset needs 4 pixels before the first pixel is output
      - ddfstrt must be aligned to fetchstart (table 1)
      - chipset needs also prefetch (table 2) to get first pixel data, so
	ddfstrt = ((diwstrt_h - 4) & -fetchstart) - prefetch
      - for horizontal panning decrease diwstrt_h
      - the length of a fetchline must be aligned to fetchsize (table 3)
      - if fetchstart is smaller than fetchsize, then ddfstrt can a little bit
	moved to optimize use of dma (useful for OCS/ECS overscan displays)
      - ddfstop is ddfstrt + ddfsize - fetchsize
      - If C= didn't change anything for AGA, then at following positions the
	dma bus is already used:
	ddfstrt <  48 -> memory refresh
		<  96 -> disk dma
		< 160 -> audio dma
		< 192 -> sprite 0 dma
		< 416 -> sprite dma (32 per sprite)
      - in accordance with the hardware reference manual a hardware stop is at
	192, but AGA (ECS?) can go below this.

   DMA priorities
   --------------

   Since there are limits on the earliest start value for display DMA and the
   display of sprites, I use the following policy on horizontal panning and
   the hardware cursor:

      - if you want to start display DMA too early, you lose the ability to
	do smooth horizontal panning (xpanstep 1 -> 64).
      - if you want to go even further, you lose the hardware cursor too.

   IMHO a hardware cursor is more important for X than horizontal scrolling,
   so that's my motivation.


   Implementation
   --------------

   ami_decode_var() converts the frame buffer values to the Amiga values. It's
   just a `straightforward' implementation of the above rules.


   Standard VGA timings
   --------------------

 < ASCII >
	       xres  yres    left  right  upper  lower    hsync    vsync
	       ----  ----    ----  -----  -----  -----    -----    -----
      80x25     720   400      27     45     35     12      108        2
      80x30     720   480      27     45     30      9      108        2
 < ASCII >

   These were taken from a XFree86 configuration file, recalculated for a 28 MHz
   dotclock (Amigas don't have a 25 MHz dotclock) and converted to frame buffer
   generic timings.

   As a comparison, graphics/monitor.h suggests the following:

 < ASCII >
	       xres  yres    left  right  upper  lower    hsync    vsync
	       ----  ----    ----  -----  -----  -----    -----    -----

      VGA       640   480      52    112     24     19    112 -      2 +
      VGA70     640   400      52    112     27     21    112 -      2 -
 < ASCII >


   Sync polarities
   ---------------

 < ASCII >
      VSYNC    HSYNC    Vertical size    Vertical total
      -----    -----    -------------    --------------
	+        +           Reserved          Reserved
	+        -                400               414
	-        +                350               362
	-        -                480               496
 < ASCII >

   Source: CL-GD542X Technical Reference Manual, Cirrus Logic, Oct 1992


   Broadcast video timings
   -----------------------

   According to the CCIR and RETMA specifications, we have the following values:

   CCIR -> PAL
   -----------

      - a scanline is 64 µs long, of which 52.48 µs are visible. This is about
	736 visible 70 ns pixels per line.
      - we have 625 scanlines, of which 575 are visible (interlaced); after
	rounding this becomes 576.

   RETMA -> NTSC
   -------------

      - a scanline is 63.5 µs long, of which 53.5 µs are visible.  This is about
	736 visible 70 ns pixels per line.
      - we have 525 scanlines, of which 485 are visible (interlaced); after
	rounding this becomes 484.

   Thus if you want a PAL compatible display, you have to do the following:

      - set the FB_SYNC_BROADCAST flag to indicate that standard broadcast
	timings are to be used.
      - make sure upper_margin + yres + lower_margin + vsync_len = 625 for an
	interlaced, 312 for a non-interlaced and 156 for a doublescanned
	display.
      - make sure left_margin + xres + right_margin + hsync_len = 1816 for a
	SHRES, 908 for a HIRES and 454 for a LORES display.
      - the left visible part begins at 360 (SHRES; HIRES:180, LORES:90),
	left_margin + 2 * hsync_len must be greater or equal.
      - the upper visible part begins at 48 (interlaced; non-interlaced:24,
	doublescanned:12), upper_margin + 2 * vsync_len must be greater or
	equal.
      - ami_encode_var() calculates margins with a hsync of 5320 ns and a vsync
	of 4 scanlines

   The settings for a NTSC compatible display are straightforward.

   Note that in a strict sense the PAL and NTSC standards only define the
   encoding of the color part (chrominance) of the video signal and don't say
   anything about horizontal/vertical synchronization nor refresh rates.


							    -- Geert --

*******************************************************************************/
```
## Visual type:
- #custom


== ./linux/linux_79.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/include/asm/pgtable.h#L279-L293

```c
/*
 * PTE bits configuration in the presence of hardware Dirty Bit Management
 * (PTE_WRITE == PTE_DBM):
 *
 < ASCII >
 * Dirty  Writable | PTE_RDONLY  PTE_WRITE  PTE_DIRTY (sw)
 *   0      0      |   1           0          0
 *   0      1      |   1           1          0
 *   1      0      |   1           0          1
 *   1      1      |   0           1          x
 < ASCII >
 *
 * When hardware DBM is not present, the sofware PTE_DIRTY bit is updated via
 * the page fault mechanism. Checking the dirty status of a pte becomes:
 *
 *   PTE_DIRTY || (PTE_WRITE && !PTE_RDONLY)
 */
```
## Visual type:
- #table


== ./linux/linux_790.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/video/fbdev/pxafb.c#L988-L1017

```c
/*
 * Calculate the PCD value from the clock rate (in picoseconds).
 * We take account of the PPCR clock setting.
 * From PXA Developer's Manual:
 *
 < ASCII >
 *   PixelClock =      LCLK
 *                -------------
 *                2 ( PCD + 1 )
 *
 *   PCD =      LCLK
 *         ------------- - 1
 *         2(PixelClock)
 < ASCII >
 *
 * Where:
 *   LCLK = LCD/Memory Clock
 *   PCD = LCCR3[7:0]
 *
 * PixelClock here is in Hz while the pixclock argument given is the
 * period in picoseconds. Hence PixelClock = 1 / ( pixclock * 10^-12 )
 *
 * The function get_lclk_frequency_10khz returns LCLK in units of
 * 10khz. Calling the result of this function lclk gives us the
 * following
 < ASCII >
 *
 *    PCD = (lclk * 10^4 ) * ( pixclock * 10^-12 )
 *          -------------------------------------- - 1
 *                          2
 < ASCII >
 *
 * Factoring the 10^4 and 10^-12 out gives 10^-8 == 1 / 100000000 as used below.
 */
```
## Visual type:
- #formula


== ./linux/linux_791.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/video/fbdev/sm501fb.c#L141-L160

```c
/* sm501_alloc_mem
 *
 * This is an attempt to lay out memory for the two framebuffers and
 * everything else
 *
 < ASCII >
 * |fbmem_res->start					       fbmem_res->end|
 * |									     |
 * |fb[0].fix.smem_start    |	      |fb[1].fix.smem_start    |     2K	     |
 * |-> fb[0].fix.smem_len <-| spare   |-> fb[1].fix.smem_len <-|-> cursors <-|
 < ASCII >
 *
 * The "spare" space is for the 2d engine data
 * the fixed is space for the cursors (2x1Kbyte)
 *
 * we need to allocate memory for the 2D acceleration engine
 * command list and the data for the engine to deal with.
 *
 * - all allocations must be 128bit aligned
 * - cursors are 64x64x2 bits (1Kbyte)
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_792.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/video/fbdev/aty/mach64_cursor.c#L20-L58

```c
/*
 * The hardware cursor definition requires 2 bits per pixel. The
 * Cursor size reguardless of the visible cursor size is 64 pixels
 * by 64 lines. The total memory required to define the cursor is
 * 16 bytes / line for 64 lines or 1024 bytes of data. The data
 * must be in a contigiuos format. The 2 bit cursor code values are
 * as follows:
 *
 *	00 - pixel colour = CURSOR_CLR_0
 *	01 - pixel colour = CURSOR_CLR_1
 *	10 - pixel colour = transparent (current display pixel)
 *	11 - pixel colour = 1's complement of current display pixel
 < ASCII >
 *
 *	Cursor Offset        64 pixels		 Actual Displayed Area
 *            \_________________________/
 *	      |			|	|	|
 *	      |<--------------->|	|	|
 *	      | CURS_HORZ_OFFSET|	|	|
 *	      |			|_______|	|  64 Lines
 *	      |			   ^	|	|
 *	      |			   |	|	|
 *	      |		CURS_VERT_OFFSET|	|
 *	      |			   |	|	|
 *	      |____________________|____|	|
 < ASCII >
 *
 *
 * The Screen position of the top left corner of the displayed
 * cursor is specificed by CURS_HORZ_VERT_POSN. Care must be taken
 * when the cursor hot spot is not the top left corner and the
 * physical cursor position becomes negative. It will be displayed
 * if either the horizontal or vertical cursor position is negative
 *
 * If x becomes negative the cursor manager must adjust the CURS_HORZ_OFFSET
 * to a larger number and saturate CUR_HORZ_POSN to zero.
 *
 * if Y becomes negative, CUR_VERT_OFFSET must be adjusted to a larger number,
 * CUR_OFFSET must be adjusted to a point to the appropriate line in the cursor
 * definitation and CUR_VERT_POSN must be saturated to zero.
 */
```
## Visual type:
- #custom


== ./linux/linux_793.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/video/fbdev/core/fbmon.c#L1085-L1104

```c
/**
 * fb_get_hblank_by_dclk - get horizontal blank time given pixelclock
 * @dclk: pixelclock in Hz
 * @xres: horizontal resolution in pixels
 *
 * DESCRIPTION:
 *
 < ASCII >
 *           xres * duty_cycle
 * hblank = ------------------
 *           100 - duty_cycle
 < ASCII >
 *
 * duty cycle = percent of htotal assigned to inactive display
 * duty cycle = C - (M * h_period)
 *
 < ASCII >
 * where: h_period = SQRT(100 - C + (0.4 * xres * M)/dclk) + C - 100
 *                   -----------------------------------------------
 *                                    2 * M
 < ASCII >
 *        M = 300;
 *        C = 30;
 */
```
## Visual type:
- #formula


== ./linux/linux_794.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/video/fbdev/i810/i810_main.c#L55-L78

```c
/*
 * voffset - framebuffer offset in MiB from aperture start address.  In order for
 * the driver to work with X, we must try to use memory holes left untouched by X. The
 * following table lists where X's different surfaces start at.
 *
 < ASCII >
 * ---------------------------------------------
 * :                :  64 MiB     : 32 MiB      :
 * ----------------------------------------------
 * : FrontBuffer    :   0         :  0          :
 * : DepthBuffer    :   48        :  16         :
 * : BackBuffer     :   56        :  24         :
 * ----------------------------------------------
 < ASCII >
 *
 * So for chipsets with 64 MiB Aperture sizes, 32 MiB for v_offset is okay, allowing up to
 * 15 + 1 MiB of Framebuffer memory.  For 32 MiB Aperture sizes, a v_offset of 8 MiB should
 * work, allowing 7 + 1 MiB of Framebuffer memory.
 * Note, the size of the hole may change depending on how much memory you allocate to X,
 * and how the memory is split up between these surfaces.
 *
 * Note: Anytime the DepthBuffer or FrontBuffer is overlapped, X would still run but with
 * DRI disabled.  But if the Frontbuffer is overlapped, X will fail to load.
 *
 * Experiment with v_offset to find out which works best for you.
 */
```
## Visual type:
- #table


== ./linux/linux_795.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/video/fbdev/omap2/omapfb/dss/apply.c#L21-L48

```c
/*
 * We have 4 levels of cache for the dispc settings. First two are in SW and
 * the latter two in HW.
 *
 < ASCII >
 *       set_info()
 *          v
 * +--------------------+
 * |     user_info      |
 * +--------------------+
 *          v
 *        apply()
 *          v
 * +--------------------+
 * |       info         |
 * +--------------------+
 *          v
 *      write_regs()
 *          v
 * +--------------------+
 * |  shadow registers  |
 * +--------------------+
 *          v
 * VFP or lcd/digit_enable
 *          v
 * +--------------------+
 * |      registers     |
 * +--------------------+
 < ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_796.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/virt/coco/efi_secret/efi_secret.c#L40-L60

```c
/*
 * Structure of the EFI secret area
 *
 < ASCII >
 * Offset   Length
 * (bytes)  (bytes)  Usage
 * -------  -------  -----
 *       0       16  Secret table header GUID (must be 1e74f542-71dd-4d66-963e-ef4287ff173b)
 *      16        4  Length of bytes of the entire secret area
 *
 *      20       16  First secret entry's GUID
 *      36        4  First secret entry's length in bytes (= 16 + 4 + x)
 *      40        x  First secret entry's data
 *
 *    40+x       16  Second secret entry's GUID
 *    56+x        4  Second secret entry's length in bytes (= 16 + 4 + y)
 *    60+x        y  Second secret entry's data
 < ASCII >
 *
 * (... and so on for additional entries)
 *
 * The GUID of each secret entry designates the usage of the secret data.
 */
```
## Visual type:
- #table


== ./linux/linux_797.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/watchdog/cpwd.c#L97-L145

```c
/* Sun uses Altera PLD EPF8820ATC144-4
 * providing three hardware watchdogs:
 *
 * 1) RIC - sends an interrupt when triggered
 * 2) XIR - asserts XIR_B_RESET when triggered, resets CPU
 * 3) POR - asserts POR_B_RESET when triggered, resets CPU, backplane, board
 *
 *** Timer register block definition (struct wd_timer_regblk)
 *
 < ASCII >
 * dcntr and limit registers (halfword access):
 * -------------------
 * | 15 | ...| 1 | 0 |
 * -------------------
 * |-  counter val  -|
 * -------------------
 < ASCII >
 * dcntr -	Current 16-bit downcounter value.
 *			When downcounter reaches '0' watchdog expires.
 *			Reading this register resets downcounter with
 *			'limit' value.
 * limit -	16-bit countdown value in 1/10th second increments.
 *			Writing this register begins countdown with input value.
 *			Reading from this register does not affect counter.
 * NOTES:	After watchdog reset, dcntr and limit contain '1'
 *
 < ASCII >
 * status register (byte access):
 * ---------------------------
 * | 7 | ... | 2 |  1  |  0  |
 * --------------+------------
 * |-   UNUSED  -| EXP | RUN |
 * ---------------------------
 < ASCII >
 * status-	Bit 0 - Watchdog is running
 *			Bit 1 - Watchdog has expired
 *
 *** PLD register block definition (struct wd_pld_regblk)
 *
 < ASCII >
 * intr_mask register (byte access):
 * ---------------------------------
 * | 7 | ... | 3 |  2  |  1  |  0  |
 * +-------------+------------------
 * |-   UNUSED  -| WD3 | WD2 | WD1 |
 * ---------------------------------
 < ASCII >
 * WD3 -  1 == Interrupt disabled for watchdog 3
 * WD2 -  1 == Interrupt disabled for watchdog 2
 * WD1 -  1 == Interrupt disabled for watchdog 1
 *
 * pld_status register (byte access):
 * UNKNOWN, MAGICAL MYSTERY REGISTER
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_798.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/watchdog/ib700wdt.c#L54-L88

```c
/*
 *
 * Watchdog Timer Configuration
 *
 * The function of the watchdog timer is to reset the system
 * automatically and is defined at I/O port 0443H.  To enable the
 * watchdog timer and allow the system to reset, write I/O port 0443H.
 * To disable the timer, write I/O port 0441H for the system to stop the
 * watchdog function.  The timer has a tolerance of 20% for its
 * intervals.
 *
 * The following describes how the timer should be programmed.
 *
 * Enabling Watchdog:
 * MOV AX,000FH (Choose the values from 0 to F)
 * MOV DX,0443H
 * OUT DX,AX
 *
 * Disabling Watchdog:
 * MOV AX,000FH (Any value is fine.)
 * MOV DX,0441H
 * OUT DX,AX
 *
 < ASCII >
 * Watchdog timer control table:
 * Level   Value  Time/sec | Level Value Time/sec
 *   1       F       0     |   9     7      16
 *   2       E       2     |   10    6      18
 *   3       D       4     |   11    5      20
 *   4       C       6     |   12    4      22
 *   5       B       8     |   13    3      24
 *   6       A       10    |   14    2      26
 *   7       9       12    |   15    1      28
 *   8       8       14    |   16    0      30
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_799.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/drivers/watchdog/npcm_wdt.c#L27-L42

```c
/*
 < ASCII >
 * Watchdog timeouts
 *
 * 170     msec:    WTCLK=01 WTIS=00     VAL= 0x400
 * 670     msec:    WTCLK=01 WTIS=01     VAL= 0x410
 * 1360    msec:    WTCLK=10 WTIS=00     VAL= 0x800
 * 2700    msec:    WTCLK=01 WTIS=10     VAL= 0x420
 * 5360    msec:    WTCLK=10 WTIS=01     VAL= 0x810
 * 10700   msec:    WTCLK=01 WTIS=11     VAL= 0x430
 * 21600   msec:    WTCLK=10 WTIS=10     VAL= 0x820
 * 43000   msec:    WTCLK=11 WTIS=00     VAL= 0xC00
 * 85600   msec:    WTCLK=10 WTIS=11     VAL= 0x830
 * 172000  msec:    WTCLK=11 WTIS=01     VAL= 0xC10
 * 687000  msec:    WTCLK=11 WTIS=10     VAL= 0xC20
 * 2750000 msec:    WTCLK=11 WTIS=11     VAL= 0xC30
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_8.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/include/asm/mmu_context.h#L83-L89

```c
/*
 < ASCII >
 * cpu_last_asn(processor):
 * 63                                            0
 * +-------------+----------------+--------------+
 * | asn version | this processor | hardware asn |
 * +-------------+----------------+--------------+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_80.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/include/asm/tlbflush.h#L123-L135

```c
/*
 * This macro creates a properly formatted VA operand for the TLB RANGE.
 * The value bit assignments are:
 *
 < ASCII >
 * +----------+------+-------+-------+-------+----------------------+
 * |   ASID   |  TG  | SCALE |  NUM  |  TTL  |        BADDR         |
 * +-----------------+-------+-------+-------+----------------------+
 * |63      48|47  46|45   44|43   39|38   37|36                   0|
 < ASCII >
 *
 * The address range is determined by below formula:
 * [BADDR, BADDR + (NUM + 1) * 2^(5*SCALE + 1) * PAGESIZE)
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_800.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/fs-writeback.c#L1416-L1426

```c
/*
 < ASCII >
 * Queue all expired dirty inodes for io, eldest first.
 * Before
 *         newly dirtied     b_dirty    b_io    b_more_io
 *         =============>    gf         edc     BA
 * After
 *         newly dirtied     b_dirty    b_io    b_more_io
 *         =============>    g          fBAedc
 *                                           |
 *                                           +--> dequeue for IO
 < ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_801.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/namespace.c#L2240-L2302

```c
/*
 *  @source_mnt : mount tree to be attached
 *  @nd         : place the mount tree @source_mnt is attached
 *  @parent_nd  : if non-null, detach the source_mnt from its parent and
 *  		   store the parent mount and mountpoint dentry.
 *  		   (done when source_mnt is moved)
 *
 *  NOTE: in the table below explains the semantics when a source mount
 *  of a given type is attached to a destination mount of a given type.
 < ASCII >
 * ---------------------------------------------------------------------------
 * |         BIND MOUNT OPERATION                                            |
 * |**************************************************************************
 * | source-->| shared        |       private  |       slave    | unbindable |
 * | dest     |               |                |                |            |
 * |   |      |               |                |                |            |
 * |   v      |               |                |                |            |
 * |**************************************************************************
 * |  shared  | shared (++)   |     shared (+) |     shared(+++)|  invalid   |
 * |          |               |                |                |            |
 * |non-shared| shared (+)    |      private   |      slave (*) |  invalid   |
 * ***************************************************************************
 < ASCII >
 * A bind operation clones the source mount and mounts the clone on the
 * destination mount.
 *
 * (++)  the cloned mount is propagated to all the mounts in the propagation
 * 	 tree of the destination mount and the cloned mount is added to
 * 	 the peer group of the source mount.
 * (+)   the cloned mount is created under the destination mount and is marked
 *       as shared. The cloned mount is added to the peer group of the source
 *       mount.
 * (+++) the mount is propagated to all the mounts in the propagation tree
 *       of the destination mount and the cloned mount is made slave
 *       of the same master as that of the source mount. The cloned mount
 *       is marked as 'shared and slave'.
 * (*)   the cloned mount is made a slave of the same master as that of the
 * 	 source mount.
 *
 < ASCII >
 * ---------------------------------------------------------------------------
 * |         		MOVE MOUNT OPERATION                                 |
 * |**************************************************************************
 * | source-->| shared        |       private  |       slave    | unbindable |
 * | dest     |               |                |                |            |
 * |   |      |               |                |                |            |
 * |   v      |               |                |                |            |
 * |**************************************************************************
 * |  shared  | shared (+)    |     shared (+) |    shared(+++) |  invalid   |
 * |          |               |                |                |            |
 * |non-shared| shared (+*)   |      private   |    slave (*)   | unbindable |
 * ***************************************************************************
 < ASCII >
 *
 * (+)  the mount is moved to the destination. And is then propagated to
 * 	all the mounts in the propagation tree of the destination mount.
 * (+*)  the mount is moved to the destination.
 * (+++)  the mount is moved to the destination and is then propagated to
 * 	all the mounts belonging to the destination mount's propagation tree.
 * 	the mount is marked as 'shared and slave'.
 * (*)	the mount continues to be a slave at the new location.
 *
 * if the source mount is a tree, the operations explained above is
 * applied to each mount in the tree.
 * Must be called without spinlocks held, since this function can sleep
 * in allocations.
 */
```
## Visual type:
- #table


== ./linux/linux_802.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/backref.c#L352-L389

```c
/*
 * the rules for all callers of this function are:
 * - obtaining the parent is the goal
 * - if you add a key, you must know that it is a correct key
 * - if you cannot add the parent or a correct key, then we will look into the
 *   block later to set a correct key
 *
 < ASCII >
 * delayed refs
 * ============
 *        backref type | shared | indirect | shared | indirect
 * information         |   tree |     tree |   data |     data
 * --------------------+--------+----------+--------+----------
 *      parent logical |    y   |     -    |    -   |     -
 *      key to resolve |    -   |     y    |    y   |     y
 *  tree block logical |    -   |     -    |    -   |     -
 *  root for resolving |    y   |     y    |    y   |     y
 < ASCII >
 *
 * - column 1:       we've the parent -> done
 * - column 2, 3, 4: we use the key to find the parent
 *
 < ASCII >
 * on disk refs (inline or keyed)
 * ==============================
 *        backref type | shared | indirect | shared | indirect
 * information         |   tree |     tree |   data |     data
 * --------------------+--------+----------+--------+----------
 *      parent logical |    y   |     -    |    y   |     -
 *      key to resolve |    -   |     -    |    -   |     y
 *  tree block logical |    y   |     y    |    y   |     y
 *  root for resolving |    -   |     y    |    y   |     y
 < ASCII >
 *
 * - column 1, 3: we've the parent -> done
 * - column 2:    we take the first key from the block to find the parent
 *                (see add_missing_keys)
 * - column 4:    we use the key to find the parent
 *
 * additional information that's available but not required to find the parent
 * block might help in merging entries to gain some speed.
 */
```
## Visual type:
- #table


== ./linux/linux_803.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/ctree.c#L2596-L2615

```c
/*
 * Check key order of two sibling extent buffers.
 *
 * Return true if something is wrong.
 * Return false if everything is fine.
 *
 * Tree-checker only works inside one tree block, thus the following
 * corruption can not be detected by tree-checker:
 *
 < ASCII >
 * Leaf @left			| Leaf @right
 * --------------------------------------------------------------
 * | 1 | 2 | 3 | 4 | 5 | f6 |   | 7 | 8 |
 < ASCII >
 *
 * Key f6 in leaf @left itself is valid, but not valid when the next
 * key in leaf @right is 7.
 * This can only be checked at tree block merge time.
 * And since tree checker has ensured all key order in each tree block
 * is correct, we only need to bother the last key of @left and the first
 * key of @right.
 */
```
## Visual type:
- #sequence


== ./linux/linux_804.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/ctree.c#L3519-L3528

```c
/*
 * double splits happen when we need to insert a big item in the middle
 * of a leaf.  A double split can leave us with 3 mostly empty leaves:
 < ASCII >
 * leaf: [ slots 0 - N] [ our target ] [ N + 1 - total in leaf ]
 *          A                 B                 C
 < ASCII >
 *
 * We avoid this by trying to push the items on either side of our target
 * into the adjacent leaves.  If all goes well we can avoid the double split
 * completely.
 */
```
## Visual type:
- #sequence


== ./linux/linux_805.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/extent-tree.c#L4236-L4260

```c
/*
 * walks the btree of allocated extents and find a hole of a given size.
 * The key ins is changed to record the hole:
 * ins->objectid == start position
 * ins->flags = BTRFS_EXTENT_ITEM_KEY
 * ins->offset == the size of the hole.
 * Any available blocks before search_start are skipped.
 *
 * If there is no suitable free space, we will record the max size of
 * the free space extent currently.
 *
 * The overall logic and call chain:
 *
 < ASCII >
 * find_free_extent()
 * |- Iterate through all block groups
 * |  |- Get a valid block group
 * |  |- Try to do clustered allocation in that block group
 * |  |- Try to do unclustered allocation in that block group
 * |  |- Check if the result is valid
 * |  |  |- If valid, then exit
 * |  |- Jump to next block group
 * |
 * |- Push harder to find free extents
 *    |- If not found, re-iterate all block groups
 < ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_806.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/extent_io.c#L3473-L3483

```c
/*
 * Emit last fiemap cache
 *
 < ASCII >
 * The last fiemap cache may still be cached in the following case:
 * 0		      4k		    8k
 * |<- Fiemap range ->|
 * |<------------  First extent ----------->|
 < ASCII >
 *
 * In this case, the first extent range will be cached but not emitted.
 * So we must emit it before ending extent_fiemap().
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_807.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/lzo.c#L23-L58

```c
/*
 * Btrfs LZO compression format
 *
 * Regular and inlined LZO compressed data extents consist of:
 *
 * 1.  Header
 *     Fixed size. LZO_LEN (4) bytes long, LE32.
 *     Records the total size (including the header) of compressed data.
 *
 * 2.  Segment(s)
 *     Variable size. Each segment includes one segment header, followed by data
 *     payload.
 *     One regular LZO compressed extent can have one or more segments.
 *     For inlined LZO compressed extent, only one segment is allowed.
 *     One segment represents at most one sector of uncompressed data.
 *
 * 2.1 Segment header
 *     Fixed size. LZO_LEN (4) bytes long, LE32.
 *     Records the total size of the segment (not including the header).
 *     Segment header never crosses sector boundary, thus it's possible to
 *     have at most 3 padding zeros at the end of the sector.
 *
 * 2.2 Data Payload
 *     Variable size. Size up limit should be lzo1x_worst_compress(sectorsize)
 *     which is 4419 for a 4KiB sectorsize.
 *
 < ASCII >
 * Example with 4K sectorsize:
 * Page 1:
 *          0     0x2   0x4   0x6   0x8   0xa   0xc   0xe     0x10
 * 0x0000   |  Header   | SegHdr 01 | Data payload 01 ...     |
 * ...
 * 0x0ff0   | SegHdr  N | Data payload  N     ...          |00|
 *                                                          ^^ padding zeros
 * Page 2:
 * 0x1000   | SegHdr N+1| Data payload N+1 ...                |
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_808.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/qgroup.c#L1980-L2025

```c
/*
 * Helper function to trace a subtree tree block swap.
 *
 * The swap will happen in highest tree block, but there may be a lot of
 * tree blocks involved.
 *
 * For example:
 *  OO = Old tree blocks
 *  NN = New tree blocks allocated during balance
 *
 < ASCII >
 *           File tree (257)                  Reloc tree for 257
 * L2              OO                                NN
 *               /    \                            /    \
 * L1          OO      OO (a)                    OO      NN (a)
 *            / \     / \                       / \     / \
 * L0       OO   OO OO   OO                   OO   OO NN   NN
 *                  (b)  (c)                          (b)  (c)
 < ASCII >
 *
 * When calling qgroup_trace_extent_swap(), we will pass:
 * @src_eb = OO(a)
 * @dst_path = [ nodes[1] = NN(a), nodes[0] = NN(c) ]
 * @dst_level = 0
 * @root_level = 1
 *
 * In that case, qgroup_trace_extent_swap() will search from OO(a) to
 * reach OO(c), then mark both OO(c) and NN(c) as qgroup dirty.
 *
 * The main work of qgroup_trace_extent_swap() can be split into 3 parts:
 *
 * 1) Tree search from @src_eb
 *    It should acts as a simplified btrfs_search_slot().
 *    The key for search can be extracted from @dst_path->nodes[dst_level]
 *    (first key).
 *
 * 2) Mark the final tree blocks in @src_path and @dst_path qgroup dirty
 *    NOTE: In above case, OO(a) and NN(a) won't be marked qgroup dirty.
 *    They should be marked during previous (@dst_level = 1) iteration.
 *
 * 3) Mark file extents in leaves dirty
 *    We don't have good way to pick out new file extents only.
 *    So we still follow the old method by scanning all file extents in
 *    the leave.
 *
 * This function can free us from keeping two paths, thus later we only need
 * to care about how to iterate all new tree blocks in reloc tree.
 */
```
## Visual type:
- #tree


== ./linux/linux_809.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/qgroup.c#L2130-L2151

```c
/*
 * Helper function to do recursive generation-aware depth-first search, to
 * locate all new tree blocks in a subtree of reloc tree.
 *
 < ASCII >
 * E.g. (OO = Old tree blocks, NN = New tree blocks, whose gen == last_snapshot)
 *         reloc tree
 * L2         NN (a)
 *          /    \
 * L1    OO        NN (b)
 *      /  \      /  \
 * L0  OO  OO    OO  NN
 *               (c) (d)
 < ASCII >
 * If we pass:
 * @dst_path = [ nodes[1] = NN(b), nodes[0] = NULL ],
 * @cur_level = 1
 * @root_level = 1
 *
 * We will iterate through tree blocks NN(b), NN(d) and info qgroup to trace
 * above tree blocks along with their counter parts in file tree.
 * While during search, old tree blocks OO(c) will be skipped as tree block swap
 * won't affect OO(c).
 */
```
## Visual type:
- #tree


== ./linux/linux_81.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/include/uapi/asm/ptrace.h#L171-L198

```c
/*
 * (flags & SVE_PT_REGS_MASK) == SVE_PT_REGS_SVE case:
 *
 * The payload starts at offset SVE_PT_SVE_OFFSET, and is of size
 * SVE_PT_SVE_SIZE(vq, flags).
 *
 * Additional macros describe the contents and layout of the payload.
 * For each, SVE_PT_SVE_x_OFFSET(args) is the start offset relative to
 * the start of struct user_sve_header, and SVE_PT_SVE_x_SIZE(args) is
 * the size in bytes:
 *
 < ASCII >
 *	x	type				description
 *	-	----				-----------
 *	ZREGS		\
 *	ZREG		|
 *	PREGS		| refer to <asm/sigcontext.h>
 *	PREG		|
 *	FFR		/
 *
 *	FPSR	uint32_t			FPSR
 *	FPCR	uint32_t			FPCR
 < ASCII >
 *
 * Additional data might be appended in the future.
 *
 * The Z-, P- and FFR registers are represented in memory in an endianness-
 * invariant layout which differs from the layout used for the FPSIMD
 * V-registers on big-endian systems: see sigcontext.h for more explanation.
 */
```
## Visual type:
- #table


== ./linux/linux_810.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/qgroup.c#L2492-L2527

```c
/*
 * Update qgroup rfer/excl counters.
 * Rfer update is easy, codes can explain themselves.
 *
 * Excl update is tricky, the update is split into 2 parts.
 < ASCII >
 * Part 1: Possible exclusive <-> sharing detect:
 *	|	A	|	!A	|
 *  -------------------------------------
 *  B	|	*	|	-	|
 *  -------------------------------------
 *  !B	|	+	|	**	|
 *  -------------------------------------
 < ASCII >
 *
 * Conditions:
 * A:	cur_old_roots < nr_old_roots	(not exclusive before)
 * !A:	cur_old_roots == nr_old_roots	(possible exclusive before)
 * B:	cur_new_roots < nr_new_roots	(not exclusive now)
 * !B:	cur_new_roots == nr_new_roots	(possible exclusive now)
 *
 * Results:
 * +: Possible sharing -> exclusive	-: Possible exclusive -> sharing
 * *: Definitely not changed.		**: Possible unchanged.
 *
 * For !A and !B condition, the exception is cur_old/new_roots == 0 case.
 *
 * To make the logic clear, we first use condition A and B to split
 * combination into 4 results.
 *
 * Then, for result "+" and "-", check old/new_roots == 0 case, as in them
 * only on variant maybe 0.
 *
 * Lastly, check result **, since there are 2 variants maybe 0, split them
 * again(2x2).
 * But this time we don't need to consider other things, the codes and logic
 * is easy to understand now.
 */
```
## Visual type:
- #table


== ./linux/linux_811.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/relocation.c#L40-L85

```c
/*
 * Relocation overview
 *
 * [What does relocation do]
 *
 * The objective of relocation is to relocate all extents of the target block
 * group to other block groups.
 * This is utilized by resize (shrink only), profile converting, compacting
 * space, or balance routine to spread chunks over devices.
 *
 < ASCII >
 * 		Before		|		After
 * ------------------------------------------------------------------
 *  BG A: 10 data extents	| BG A: deleted
 *  BG B:  2 data extents	| BG B: 10 data extents (2 old + 8 relocated)
 *  BG C:  1 extents		| BG C:  3 data extents (1 old + 2 relocated)
 < ASCII >
 *
 * [How does relocation work]
 *
 * 1.   Mark the target block group read-only
 *      New extents won't be allocated from the target block group.
 *
 * 2.1  Record each extent in the target block group
 *      To build a proper map of extents to be relocated.
 *
 * 2.2  Build data reloc tree and reloc trees
 *      Data reloc tree will contain an inode, recording all newly relocated
 *      data extents.
 *      There will be only one data reloc tree for one data block group.
 *
 *      Reloc tree will be a special snapshot of its source tree, containing
 *      relocated tree blocks.
 *      Each tree referring to a tree block in target block group will get its
 *      reloc tree built.
 *
 * 2.3  Swap source tree with its corresponding reloc tree
 *      Each involved tree only refers to new extents after swap.
 *
 * 3.   Cleanup reloc trees and data reloc tree.
 *      As old extents in the target block group are still referenced by reloc
 *      trees, we need to clean them up before really freeing the target block
 *      group.
 *
 * The main complexity is in steps 2.2 and 2.3.
 *
 * The entry point of relocation is relocate_block_group() function.
 */
```
## Visual type:
- #table


== ./linux/linux_812.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/send.c#L3699-L3734

```c
/*
 * We might need to delay a directory rename even when no ancestor directory
 * (in the send root) with a higher inode number than ours (sctx->cur_ino) was
 * renamed. This happens when we rename a directory to the old name (the name
 * in the parent root) of some other unrelated directory that got its rename
 * delayed due to some ancestor with higher number that got renamed.
 *
 < ASCII >
 * Example:
 *
 * Parent snapshot:
 * .                                       (ino 256)
 * |---- a/                                (ino 257)
 * |     |---- file                        (ino 260)
 * |
 * |---- b/                                (ino 258)
 * |---- c/                                (ino 259)
 *
 * Send snapshot:
 * .                                       (ino 256)
 * |---- a/                                (ino 258)
 * |---- x/                                (ino 259)
 *       |---- y/                          (ino 257)
 *             |----- file                 (ino 260)
 < ASCII >
 *
 * Here we can not rename 258 from 'b' to 'a' without the rename of inode 257
 * from 'a' to 'x/y' happening first, which in turn depends on the rename of
 * inode 259 from 'c' to 'x'. So the order of rename commands the send stream
 * must issue is:
 *
 * 1 - rename 259 from 'c' to 'x'
 * 2 - rename 257 from 'a' to 'x/y'
 * 3 - rename 258 from 'b' to 'a'
 *
 * Returns 1 if the rename of sctx->cur_ino needs to be delayed, 0 if it can
 * be done right away and < 0 on error.
 */
```
## Visual type:
- #tree


== ./linux/linux_813.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/send.c#L4072-L4112

```c
/*
 * When processing the new references for an inode we may orphanize an existing
 * directory inode because its old name conflicts with one of the new references
 * of the current inode. Later, when processing another new reference of our
 * inode, we might need to orphanize another inode, but the path we have in the
 * reference reflects the pre-orphanization name of the directory we previously
 * orphanized. For example:
 *
 < ASCII >
 * parent snapshot looks like:
 *
 * .                                     (ino 256)
 * |----- f1                             (ino 257)
 * |----- f2                             (ino 258)
 * |----- d1/                            (ino 259)
 *        |----- d2/                     (ino 260)
 *
 * send snapshot looks like:
 *
 * .                                     (ino 256)
 * |----- d1                             (ino 258)
 * |----- f2/                            (ino 259)
 *        |----- f2_link/                (ino 260)
 *        |       |----- f1              (ino 257)
 *        |
 *        |----- d2                      (ino 258)
 < ASCII >
 *
 * When processing inode 257 we compute the name for inode 259 as "d1", and we
 * cache it in the name cache. Later when we start processing inode 258, when
 * collecting all its new references we set a full path of "d1/d2" for its new
 * reference with name "d2". When we start processing the new references we
 * start by processing the new reference with name "d1", and this results in
 * orphanizing inode 259, since its old reference causes a conflict. Then we
 * move on the next new reference, with name "d2", and we find out we must
 * orphanize inode 260, as its old reference conflicts with ours - but for the
 * orphanization we use a source path corresponding to the path we stored in the
 * new reference, which is "d1/d2" and not "o259-6-0/d2" - this makes the
 * receiver fail since the path component "d1/" no longer exists, it was renamed
 * to "o259-6-0/" when processing the previous new reference. So in this case we
 * must recompute the path in the new reference and use it for the new
 * orphanization operation.
 */
```
## Visual type:
- #tree


== ./linux/linux_814.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/transaction.c#L42-L112

```c
/*
 * Transaction states and transitions
 *
 < ASCII >
 * No running transaction (fs tree blocks are not modified)
 * |
 * | To next stage:
 * |  Call start_transaction() variants. Except btrfs_join_transaction_nostart().
 * V
 * Transaction N [[TRANS_STATE_RUNNING]]
 * |
 * | New trans handles can be attached to transaction N by calling all
 * | start_transaction() variants.
 * |
 * | To next stage:
 * |  Call btrfs_commit_transaction() on any trans handle attached to
 * |  transaction N
 * V
 * Transaction N [[TRANS_STATE_COMMIT_START]]
 * |
 * | Will wait for previous running transaction to completely finish if there
 * | is one
 * |
 * | Then one of the following happes:
 * | - Wait for all other trans handle holders to release.
 * |   The btrfs_commit_transaction() caller will do the commit work.
 * | - Wait for current transaction to be committed by others.
 * |   Other btrfs_commit_transaction() caller will do the commit work.
 * |
 * | At this stage, only btrfs_join_transaction*() variants can attach
 * | to this running transaction.
 * | All other variants will wait for current one to finish and attach to
 * | transaction N+1.
 * |
 * | To next stage:
 * |  Caller is chosen to commit transaction N, and all other trans handle
 * |  haven been released.
 * V
 * Transaction N [[TRANS_STATE_COMMIT_DOING]]
 * |
 * | The heavy lifting transaction work is started.
 * | From running delayed refs (modifying extent tree) to creating pending
 * | snapshots, running qgroups.
 * | In short, modify supporting trees to reflect modifications of subvolume
 * | trees.
 * |
 * | At this stage, all start_transaction() calls will wait for this
 * | transaction to finish and attach to transaction N+1.
 * |
 * | To next stage:
 * |  Until all supporting trees are updated.
 * V
 * Transaction N [[TRANS_STATE_UNBLOCKED]]
 * |						    Transaction N+1
 * | All needed trees are modified, thus we only    [[TRANS_STATE_RUNNING]]
 * | need to write them back to disk and update	    |
 * | super blocks.				    |
 * |						    |
 * | At this stage, new transaction is allowed to   |
 * | start.					    |
 * | All new start_transaction() calls will be	    |
 * | attached to transid N+1.			    |
 * |						    |
 * | To next stage:				    |
 * |  Until all tree blocks are super blocks are    |
 * |  written to block devices			    |
 * V						    |
 * Transaction N [[TRANS_STATE_COMPLETED]]	    V
 *   All tree blocks and super blocks are written.  Transaction N+1
 *   This transaction is finished and all its	    [[TRANS_STATE_COMMIT_START]]
 *   data structures will be cleaned up.	    | Life goes on
 < ASCII >
 */
```
## Visual type:
- #state-machine


== ./linux/linux_815.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/tests/extent-map-tests.c#L39-L54

```c
/*
 * Test scenario:
 *
 * Suppose that no extent map has been loaded into memory yet, there is a file
 * extent [0, 16K), followed by another file extent [16K, 20K), two dio reads
 * are entering btrfs_get_extent() concurrently, t1 is reading [8K, 16K), t2 is
 * reading [0, 8K)
 *
 < ASCII >
 *     t1                            t2
 *  btrfs_get_extent()              btrfs_get_extent()
 *    -> lookup_extent_mapping()      ->lookup_extent_mapping()
 *    -> add_extent_mapping(0, 16K)
 *    -> return em
 *                                    ->add_extent_mapping(0, 16K)
 *                                    -> #handle -EEXIST
 < ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_816.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/tests/extent-map-tests.c#L294-L309

```c
/*
 * Test scenario:
 *
 * Suppose that no extent map has been loaded into memory yet.
 * There is a file extent [0, 16K), two jobs are running concurrently
 * against it, t1 is buffered writing to [4K, 8K) and t2 is doing dio
 * read from [0, 4K) or [8K, 12K) or [12K, 16K).
 *
 * t1 goes ahead of t2 and adds em [4K, 8K) into tree.
 < ASCII >
 *
 *         t1                       t2
 *  cow_file_range()	     btrfs_get_extent()
 *                            -> lookup_extent_mapping()
 *   -> add_extent_mapping()
 *                            -> add_extent_mapping()
 < ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_817.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/tests/extent-map-tests.c#L407-L431

```c
/*
 * Test scenario:
 *
 * Suppose that no extent map has been loaded into memory yet.
 * There is a file extent [0, 32K), two jobs are running concurrently
 * against it, t1 is doing dio write to [8K, 32K) and t2 is doing dio
 * read from [0, 4K) or [4K, 8K).
 *
 * t1 goes ahead of t2 and splits em [0, 32K) to em [0K, 8K) and [8K 32K).
 *
 < ASCII >
 *         t1                                t2
 *  btrfs_get_blocks_direct()	       btrfs_get_blocks_direct()
 *   -> btrfs_get_extent()              -> btrfs_get_extent()
 *       -> lookup_extent_mapping()
 *       -> add_extent_mapping()            -> lookup_extent_mapping()
 *          # load [0, 32K)
 *   -> btrfs_new_extent_direct()
 *       -> btrfs_drop_extent_cache()
 *          # split [0, 32K)
 *       -> add_extent_mapping()
 *          # add [8K, 32K)
 *                                          -> add_extent_mapping()
 *                                             # handle -EEXIST when adding
 *                                             # [0, 32K)
 < ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_818.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/btrfs/tests/inode-tests.c#L70-L87

```c
/*
 * Build the most complicated map of extents the earth has ever seen.  We want
 * this so we can test all of the corner cases of btrfs_get_extent.  Here is a
 * diagram of how the extents will look though this may not be possible we still
 * want to make sure everything acts normally (the last number is not inclusive)
 *
 < ASCII >
 * [0  - 6][     6 - 4096     ][ 4096 - 4100][4100 - 8195][8195  -  12291]
 * [inline][hole but no extent][    hole    ][   regular ][regular1 split]
 *
 * [12291 - 16387][16387 - 24579][24579 - 28675][ 28675 - 32771][32771 - 36867 ]
 * [    hole    ][regular1 split][   prealloc ][   prealloc1  ][prealloc1 written]
 *
 * [36867 - 45059][45059 - 53251][53251 - 57347][57347 - 61443][61443- 69635]
 * [  prealloc1  ][ compressed  ][ compressed1 ][    regular  ][ compressed1]
 *
 * [69635-73731][   73731 - 86019   ][86019-90115]
 * [  regular  ][ hole but no extent][  regular  ]
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_819.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/cifs/smb2status.h#L12-L17

```c
/*
 < ASCII >
 *  0 1 2 3 4 5 6 7 8 9 0 A B C D E F 0 1 2 3 4 5 6 7 8 9 A B C D E F
 *  SEV C N <-------Facility--------> <------Error Status Code------>
 < ASCII >
 *
 *  C is set if "customer defined" error, N bit is reserved and MBZ
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_82.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/kernel/compat_alignment.c#L101-L113

```c
/*
 * LDM/STM alignment handler.
 *
 * There are 4 variants of this instruction:
 *
 < ASCII >
 * B = rn pointer before instruction, A = rn pointer after instruction
 *              ------ increasing address ----->
 *	        |    | r0 | r1 | ... | rx |    |
 * PU = 01             B                    A
 * PU = 11        B                    A
 * PU = 00        A                    B
 * PU = 10             A                    B
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_820.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/dlm/midcomms.c#L12-L122

```c
/*
 * midcomms.c
 *
 * This is the appallingly named "mid-level" comms layer. It takes care about
 * deliver an on application layer "reliable" communication above the used
 * lowcomms transport layer.
 *
 * How it works:
 *
 * Each nodes keeps track of all send DLM messages in send_queue with a sequence
 * number. The receive will send an DLM_ACK message back for every DLM message
 * received at the other side. If a reconnect happens in lowcomms we will send
 * all unacknowledged dlm messages again. The receiving side might drop any already
 * received message by comparing sequence numbers.
 *
 * How version detection works:
 *
 * Due the fact that dlm has pre-configured node addresses on every side
 * it is in it's nature that every side connects at starts to transmit
 * dlm messages which ends in a race. However DLM_RCOM_NAMES, DLM_RCOM_STATUS
 * and their replies are the first messages which are exchanges. Due backwards
 * compatibility these messages are not covered by the midcomms re-transmission
 * layer. These messages have their own re-transmission handling in the dlm
 * application layer. The version field of every node will be set on these RCOM
 * messages as soon as they arrived and the node isn't yet part of the nodes
 * hash. There exists also logic to detect version mismatched if something weird
 * going on or the first messages isn't an expected one.
 *
 * Termination:
 *
 * The midcomms layer does a 4 way handshake for termination on DLM protocol
 * like TCP supports it with half-closed socket support. SCTP doesn't support
 * half-closed socket, so we do it on DLM layer. Also socket shutdown() can be
 * interrupted by .e.g. tcp reset itself. Additional there exists the othercon
 * paradigm in lowcomms which cannot be easily without breaking backwards
 * compatibility. A node cannot send anything to another node when a DLM_FIN
 * message was send. There exists additional logic to print a warning if
 * DLM wants to do it. There exists a state handling like RFC 793 but reduced
 * to termination only. The event "member removal event" describes the cluster
 * manager removed the node from internal lists, at this point DLM does not
 * send any message to the other node. There exists two cases:
 *
 * 1. The cluster member was removed and we received a FIN
 * OR
 * 2. We received a FIN but the member was not removed yet
 *
 * One of these cases will do the CLOSE_WAIT to LAST_ACK change.
 *
 *
 < ASCII >
 *                              +---------+
 *                              | CLOSED  |
 *                              +---------+
 *                                   | add member/receive RCOM version
 *                                   |            detection msg
 *                                   V
 *                              +---------+
 *                              |  ESTAB  |
 *                              +---------+
 *                       CLOSE    |     |    rcv FIN
 *                      -------   |     |    -------
 * +---------+          snd FIN  /       \   snd ACK          +---------+
 * |  FIN    |<-----------------           ------------------>|  CLOSE  |
 * | WAIT-1  |------------------                              |   WAIT  |
 * +---------+          rcv FIN  \                            +---------+
 * | rcv ACK of FIN   -------   |                            CLOSE  | member
 * | --------------   snd ACK   |                           ------- | removal
 * V        x                   V                           snd FIN V event
 * +---------+                  +---------+                   +---------+
 * |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|
 * +---------+                  +---------+                   +---------+
 * |                rcv ACK of FIN |                 rcv ACK of FIN |
 * |  rcv FIN       -------------- |                 -------------- |
 * |  -------              x       V                        x       V
 *  \ snd ACK                 +---------+                   +---------+
 *   ------------------------>| CLOSED  |                   | CLOSED  |
 *                            +---------+                   +---------+
 < ASCII >
 *
 * NOTE: any state can interrupted by midcomms_close() and state will be
 * switched to CLOSED in case of fencing. There exists also some timeout
 * handling when we receive the version detection RCOM messages which is
 * made by observation.
 *
 * Future improvements:
 *
 * There exists some known issues/improvements of the dlm handling. Some
 * of them should be done in a next major dlm version bump which makes
 * it incompatible with previous versions.
 *
 * Unaligned memory access:
 *
 * There exists cases when the dlm message buffer length is not aligned
 * to 8 byte. However seems nobody detected any problem with it. This
 * can be fixed in the next major version bump of dlm.
 *
 * Version detection:
 *
 * The version detection and how it's done is related to backwards
 * compatibility. There exists better ways to make a better handling.
 * However this should be changed in the next major version bump of dlm.
 *
 * Tail Size checking:
 *
 * There exists a message tail payload in e.g. DLM_MSG however we don't
 * check it against the message length yet regarding to the receive buffer
 * length. That need to be validated.
 *
 * Fencing bad nodes:
 *
 * At timeout places or weird sequence number behaviours we should send
 * a fencing request to the cluster manager.
 */
```
## Visual type:
- #state-machine


== ./linux/linux_821.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/dlm/user.c#L508-L524

```c
/*
 < ASCII >
 * device_write
 *
 *   device_user_lock
 *     dlm_user_request -> request_lock
 *     dlm_user_convert -> convert_lock
 *
 *   device_user_unlock
 *     dlm_user_unlock -> unlock_lock
 *     dlm_user_cancel -> cancel_lock
 *
 *   device_create_lockspace
 *     dlm_new_lockspace
 *
 *   device_remove_lockspace
 *     dlm_release_lockspace
 < ASCII >
 */
```
## Visual type:



== ./linux/linux_822.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/ecryptfs/crypto.c#L1015-L1045

```c
/**
 * ecryptfs_write_headers_virt
 * @page_virt: The virtual address to write the headers to
 * @max: The size of memory allocated at page_virt
 * @size: Set to the number of bytes written by this function
 * @crypt_stat: The cryptographic context
 * @ecryptfs_dentry: The eCryptfs dentry
 *
 < ASCII >
 * Format version: 1
 *
 *   Header Extent:
 *     Octets 0-7:        Unencrypted file size (big-endian)
 *     Octets 8-15:       eCryptfs special marker
 *     Octets 16-19:      Flags
 *      Octet 16:         File format version number (between 0 and 255)
 *      Octets 17-18:     Reserved
 *      Octet 19:         Bit 1 (lsb): Reserved
 *                        Bit 2: Encrypted?
 *                        Bits 3-8: Reserved
 *     Octets 20-23:      Header extent size (big-endian)
 *     Octets 24-25:      Number of header extents at front of file
 *                        (big-endian)
 *     Octet  26:         Begin RFC 2440 authentication token packet set
 *   Data Extent 0:
 *     Lower data (CBC encrypted)
 *   Data Extent 1:
 *     Lower data (CBC encrypted)
 *   ...
 < ASCII >
 *
 * Returns zero on success
 */
```
## Visual type:



== ./linux/linux_823.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/erofs/erofs_fs.h#L205-L215

```c
/*
 < ASCII >
 * inline xattrs (n == i_xattr_icount):
 * erofs_xattr_ibody_header(1) + (n - 1) * 4 bytes
 *          12 bytes           /                   \
 *                            /                     \
 *                           /-----------------------\
 *                           |  erofs_xattr_entries+ |
 *                           +-----------------------+
 < ASCII >
 * inline xattrs must starts in erofs_xattr_ibody_header,
 * for read-only fs, no need to introduce h_refcount
 */
```
## Visual type:
- #custom


== ./linux/linux_824.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/ext2/xattr.c#L15-L55

```c
/*
 * Extended attributes are stored on disk blocks allocated outside of
 * any inode. The i_file_acl field is then made to point to this allocated
 * block. If all extended attributes of an inode are identical, these
 * inodes may share the same extended attribute block. Such situations
 * are automatically detected by keeping a cache of recent attribute block
 * numbers and hashes over the block's contents in memory.
 *
 *
 < ASCII >
 * Extended attribute block layout:
 *
 *   +------------------+
 *   | header           |
 *   | entry 1          | |
 *   | entry 2          | | growing downwards
 *   | entry 3          | v
 *   | four null bytes  |
 *   | . . .            |
 *   | value 1          | ^
 *   | value 3          | | growing upwards
 *   | value 2          | |
 *   +------------------+
 < ASCII >
 *
 * The block header is followed by multiple entry descriptors. These entry
 * descriptors are variable in size, and aligned to EXT2_XATTR_PAD
 * byte boundaries. The entry descriptors are sorted by attribute name,
 * so that two extended attribute blocks can be compared efficiently.
 *
 * Attribute values are aligned to the end of the block, stored in
 * no specific order. They are also padded to EXT2_XATTR_PAD byte
 * boundaries. No additional gaps are left between them.
 *
 * Locking strategy
 * ----------------
 * EXT2_I(inode)->i_file_acl is protected by EXT2_I(inode)->xattr_sem.
 * EA blocks are only changed if they are exclusive to an inode, so
 * holding xattr_sem also means that nothing but the EA block's reference
 * count will change. Multiple writers to an EA block are synchronized
 * by the bh lock. No more than a single bh lock is held at any time
 * to avoid deadlocks.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_825.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/ext4/ext4.h#L884-L903

```c
/*
 * We use an encoding that preserves the times for extra epoch "00":
 *
 < ASCII >
 * extra  msb of                         adjust for signed
 * epoch  32-bit                         32-bit tv_sec to
 * bits   time    decoded 64-bit tv_sec  64-bit tv_sec      valid time range
 * 0 0    1    -0x80000000..-0x00000001  0x000000000 1901-12-13..1969-12-31
 * 0 0    0    0x000000000..0x07fffffff  0x000000000 1970-01-01..2038-01-19
 * 0 1    1    0x080000000..0x0ffffffff  0x100000000 2038-01-19..2106-02-07
 * 0 1    0    0x100000000..0x17fffffff  0x100000000 2106-02-07..2174-02-25
 * 1 0    1    0x180000000..0x1ffffffff  0x200000000 2174-02-25..2242-03-16
 * 1 0    0    0x200000000..0x27fffffff  0x200000000 2242-03-16..2310-04-04
 * 1 1    1    0x280000000..0x2ffffffff  0x300000000 2310-04-04..2378-04-22
 * 1 1    0    0x300000000..0x37fffffff  0x300000000 2378-04-22..2446-05-10
 < ASCII >
 *
 * Note that previous versions of the kernel on 64-bit systems would
 * incorrectly use extra epoch bits 1,1 for dates between 1901 and
 * 1970.  e2fsck will correct this, assuming that it is run on the
 * affected filesystem before 2242.
 */
```
## Visual type:
- #table


== ./linux/linux_826.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/ext4/extents.c#L3964-L4004

```c
/*
 * get_implied_cluster_alloc - check to see if the requested
 * allocation (in the map structure) overlaps with a cluster already
 * allocated in an extent.
 *	@sb	The filesystem superblock structure
 *	@map	The requested lblk->pblk mapping
 *	@ex	The extent structure which might contain an implied
 *			cluster allocation
 *
 * This function is called by ext4_ext_map_blocks() after we failed to
 * find blocks that were already in the inode's extent tree.  Hence,
 * we know that the beginning of the requested region cannot overlap
 * the extent from the inode's extent tree.  There are three cases we
 * want to catch.  The first is this case:
 *
 < ASCII >
 *		 |--- cluster # N--|
 *    |--- extent ---|	|---- requested region ---|
 *			|==========|
 < ASCII >
 *
 * The second case that we need to test for is this one:
 *
 < ASCII >
 *   |--------- cluster # N ----------------|
 *	   |--- requested region --|   |------- extent ----|
 *	   |=======================|
 < ASCII >
 *
 * The third case is when the requested region lies between two extents
 * within the same cluster:
 < ASCII >
 *          |------------- cluster # N-------------|
 * |----- ex -----|                  |---- ex_right ----|
 *                  |------ requested region ------|
 *                  |================|
 < ASCII >
 *
 * In each of the above cases, we need to set the map->m_pblk and
 * map->m_len so it corresponds to the return the extent labelled as
 * "|====|" from cluster #N, since it is already in use for data in
 * cluster EXT4_B2C(sbi, map->m_lblk).	We will then return 1 to
 * signal to ext4_ext_map_blocks() that map->m_pblk should be treated
 * as a new "allocated" block region.  Otherwise, we will return 0 and
 * ext4_ext_map_blocks() will then allocate one or more new clusters
 * by calling ext4_mb_new_blocks().
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_827.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/ext4/fast_commit.c#L15-L166

```c
/*
 * Ext4 Fast Commits
 * -----------------
 *
 * Ext4 fast commits implement fine grained journalling for Ext4.
 *
 * Fast commits are organized as a log of tag-length-value (TLV) structs. (See
 * struct ext4_fc_tl). Each TLV contains some delta that is replayed TLV by
 * TLV during the recovery phase. For the scenarios for which we currently
 * don't have replay code, fast commit falls back to full commits.
 * Fast commits record delta in one of the following three categories.
 *
 * (A) Directory entry updates:
 *
 * - EXT4_FC_TAG_UNLINK		- records directory entry unlink
 * - EXT4_FC_TAG_LINK		- records directory entry link
 * - EXT4_FC_TAG_CREAT		- records inode and directory entry creation
 *
 * (B) File specific data range updates:
 *
 * - EXT4_FC_TAG_ADD_RANGE	- records addition of new blocks to an inode
 * - EXT4_FC_TAG_DEL_RANGE	- records deletion of blocks from an inode
 *
 * (C) Inode metadata (mtime / ctime etc):
 *
 * - EXT4_FC_TAG_INODE		- record the inode that should be replayed
 *				  during recovery. Note that iblocks field is
 *				  not replayed and instead derived during
 *				  replay.
 * Commit Operation
 * ----------------
 * With fast commits, we maintain all the directory entry operations in the
 * order in which they are issued in an in-memory queue. This queue is flushed
 * to disk during the commit operation. We also maintain a list of inodes
 * that need to be committed during a fast commit in another in memory queue of
 * inodes. During the commit operation, we commit in the following order:
 *
 * [1] Lock inodes for any further data updates by setting COMMITTING state
 * [2] Submit data buffers of all the inodes
 * [3] Wait for [2] to complete
 * [4] Commit all the directory entry updates in the fast commit space
 * [5] Commit all the changed inode structures
 * [6] Write tail tag (this tag ensures the atomicity, please read the following
 *     section for more details).
 * [7] Wait for [4], [5] and [6] to complete.
 *
 * All the inode updates must call ext4_fc_start_update() before starting an
 * update. If such an ongoing update is present, fast commit waits for it to
 * complete. The completion of such an update is marked by
 * ext4_fc_stop_update().
 *
 * Fast Commit Ineligibility
 * -------------------------
 *
 * Not all operations are supported by fast commits today (e.g extended
 * attributes). Fast commit ineligibility is marked by calling
 * ext4_fc_mark_ineligible(): This makes next fast commit operation to fall back
 * to full commit.
 *
 * Atomicity of commits
 * --------------------
 * In order to guarantee atomicity during the commit operation, fast commit
 * uses "EXT4_FC_TAG_TAIL" tag that marks a fast commit as complete. Tail
 * tag contains CRC of the contents and TID of the transaction after which
 * this fast commit should be applied. Recovery code replays fast commit
 * logs only if there's at least 1 valid tail present. For every fast commit
 * operation, there is 1 tail. This means, we may end up with multiple tails
 * in the fast commit space. Here's an example:
 *
 * - Create a new file A and remove existing file B
 * - fsync()
 * - Append contents to file A
 * - Truncate file A
 * - fsync()
 *
 * The fast commit space at the end of above operations would look like this:
 *      [HEAD] [CREAT A] [UNLINK B] [TAIL] [ADD_RANGE A] [DEL_RANGE A] [TAIL]
 *             |<---  Fast Commit 1   --->|<---      Fast Commit 2     ---->|
 *
 * Replay code should thus check for all the valid tails in the FC area.
 *
 * Fast Commit Replay Idempotence
 * ------------------------------
 *
 * Fast commits tags are idempotent in nature provided the recovery code follows
 * certain rules. The guiding principle that the commit path follows while
 * committing is that it stores the result of a particular operation instead of
 * storing the procedure.
 *
 * Let's consider this rename operation: 'mv /a /b'. Let's assume dirent '/a'
 * was associated with inode 10. During fast commit, instead of storing this
 * operation as a procedure "rename a to b", we store the resulting file system
 * state as a "series" of outcomes:
 *
 * - Link dirent b to inode 10
 * - Unlink dirent a
 * - Inode <10> with valid refcount
 *
 * Now when recovery code runs, it needs "enforce" this state on the file
 * system. This is what guarantees idempotence of fast commit replay.
 *
 * Let's take an example of a procedure that is not idempotent and see how fast
 * commits make it idempotent. Consider following sequence of operations:
 *
 < ASCII >
 *     rm A;    mv B A;    read A
 *  (x)     (y)        (z)
 < ASCII >
 *
 * (x), (y) and (z) are the points at which we can crash. If we store this
 * sequence of operations as is then the replay is not idempotent. Let's say
 * while in replay, we crash at (z). During the second replay, file A (which was
 * actually created as a result of "mv B A" operation) would get deleted. Thus,
 * file named A would be absent when we try to read A. So, this sequence of
 * operations is not idempotent. However, as mentioned above, instead of storing
 * the procedure fast commits store the outcome of each procedure. Thus the fast
 * commit log for above procedure would be as follows:
 *
 * (Let's assume dirent A was linked to inode 10 and dirent B was linked to
 * inode 11 before the replay)
 *
 < ASCII >
 *    [Unlink A]   [Link A to inode 11]   [Unlink B]   [Inode 11]
 * (w)          (x)                    (y)          (z)
 < ASCII >
 *
 * If we crash at (z), we will have file A linked to inode 11. During the second
 * replay, we will remove file A (inode 11). But we will create it back and make
 * it point to inode 11. We won't find B, so we'll just skip that step. At this
 * point, the refcount for inode 11 is not reliable, but that gets fixed by the
 * replay of last inode 11 tag. Crashes at points (w), (x) and (y) get handled
 * similarly. Thus, by converting a non-idempotent procedure into a series of
 * idempotent outcomes, fast commits ensured idempotence during the replay.
 *
 * TODOs
 * -----
 *
 * 0) Fast commit replay path hardening: Fast commit replay code should use
 *    journal handles to make sure all the updates it does during the replay
 *    path are atomic. With that if we crash during fast commit replay, after
 *    trying to do recovery again, we will find a file system where fast commit
 *    area is invalid (because new full commit would be found). In order to deal
 *    with that, fast commit replay code should ensure that the "FC_REPLAY"
 *    superblock state is persisted before starting the replay, so that after
 *    the crash, fast commit recovery code can look at that flag and perform
 *    fast commit recovery even if that area is invalidated by later full
 *    commits.
 *
 * 1) Fast commit's commit path locks the entire file system during fast
 *    commit. This has significant performance penalty. Instead of that, we
 *    should use ext4_fc_start/stop_update functions to start inode level
 *    updates from ext4_journal_start/stop. Once we do that we can drop file
 *    system locking during commit path.
 *
 * 2) Handle more ineligible cases.
 */
```
## Visual type:
- #custom


== ./linux/linux_828.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/ext4/xattr.c#L17-L52

```c
/*
 * Extended attributes are stored directly in inodes (on file systems with
 * inodes bigger than 128 bytes) and on additional disk blocks. The i_file_acl
 * field contains the block number if an inode uses an additional block. All
 * attributes must fit in the inode and one additional block. Blocks that
 * contain the identical set of attributes may be shared among several inodes.
 * Identical blocks are detected by keeping a cache of blocks that have
 * recently been accessed.
 *
 * The attributes in inodes and on blocks have a different header; the entries
 * are stored in the same format:
 *
 < ASCII >
 *   +------------------+
 *   | header           |
 *   | entry 1          | |
 *   | entry 2          | | growing downwards
 *   | entry 3          | v
 *   | four null bytes  |
 *   | . . .            |
 *   | value 1          | ^
 *   | value 3          | | growing upwards
 *   | value 2          | |
 *   +------------------+
 < ASCII >
 *
 * The header is followed by multiple entry descriptors. In disk blocks, the
 * entry descriptors are kept sorted. In inodes, they are unsorted. The
 * attribute values are aligned to the end of the block in no specific order.
 *
 * Locking strategy
 * ----------------
 * EXT4_I(inode)->i_file_acl is protected by EXT4_I(inode)->xattr_sem.
 * EA blocks are only changed if they are exclusive to an inode, so
 * holding xattr_sem also means that nothing but the EA block's reference
 * count can change. Multiple writers to the same block are synchronized
 * by the buffer lock.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_829.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/f2fs/node.h#L327-L347

```c
/*
 * f2fs assigns the following node offsets described as (num).
 * N = NIDS_PER_BLOCK
 *
 < ASCII >
 *  Inode block (0)
 *    |- direct node (1)
 *    |- direct node (2)
 *    |- indirect node (3)
 *    |            `- direct node (4 => 4 + N - 1)
 *    |- indirect node (4 + N)
 *    |            `- direct node (5 + N => 5 + 2N - 1)
 *    `- double indirect node (5 + 2N)
 *                 `- indirect node (6 + 2N)
 *                       `- direct node
 *                 ......
 *                 `- indirect node ((6 + 2N) + x(N + 1))
 *                       `- direct node
 *                 ......
 *                 `- indirect node ((6 + 2N) + (N - 1)(N + 1))
 *                       `- direct node
 < ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_83.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/kernel/entry-ftrace.S#L101-L131

```c
/*
 * Gcc with -pg will put the following code in the beginning of each function:
 *      mov x0, x30
 *      bl _mcount
 *	[function's body ...]
 * "bl _mcount" may be replaced to "bl ftrace_caller" or NOP if dynamic
 * ftrace is enabled.
 *
 * Please note that x0 as an argument will not be used here because we can
 * get lr(x30) of instrumented function at any time by winding up call stack
 * as long as the kernel is compiled without -fomit-frame-pointer.
 * (or CONFIG_FRAME_POINTER, this is forced on arm64)
 *
 * stack layout after mcount_enter in _mcount():
 *
 < ASCII >
 * current sp/fp =>  0:+-----+
 * in _mcount()        | x29 | -> instrumented function's fp
 *                     +-----+
 *                     | x30 | -> _mcount()'s lr (= instrumented function's pc)
 * old sp       => +16:+-----+
 * when instrumented   |     |
 * function calls      | ... |
 * _mcount()           |     |
 *                     |     |
 * instrumented => +xx:+-----+
 * function's fp       | x29 | -> parent's fp
 *                     +-----+
 *                     | x30 | -> instrumented function's lr (= parent's pc)
 *                     +-----+
 *                     | ... |
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_830.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/f2fs/recovery.c#L16-L45

```c
/*
 * Roll forward recovery scenarios.
 *
 * [Term] F: fsync_mark, D: dentry_mark
 *
 < ASCII >
 * 1. inode(x) | CP | inode(x) | dnode(F)
 * -> Update the latest inode(x).
 *
 * 2. inode(x) | CP | inode(F) | dnode(F)
 * -> No problem.
 *
 * 3. inode(x) | CP | dnode(F) | inode(x)
 * -> Recover to the latest dnode(F), and drop the last inode(x)
 *
 * 4. inode(x) | CP | dnode(F) | inode(F)
 * -> No problem.
 *
 * 5. CP | inode(x) | dnode(F)
 * -> The inode(DF) was missing. Should drop this dnode(F).
 *
 * 6. CP | inode(DF) | dnode(F)
 * -> No problem.
 *
 * 7. CP | dnode(F) | inode(DF)
 * -> If f2fs_iget fails, then goto next to find inode(DF).
 *
 * 8. CP | dnode(F) | inode(x)
 * -> If f2fs_iget fails, then goto next to find inode(DF).
 *    But it will fail due to no inode(DF).
 < ASCII >
 */
```
## Visual type:
- #sequence


== ./linux/linux_831.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/f2fs/xattr.h#L92-L119

```c
/*
 * On-disk structure of f2fs_xattr
 * We use inline xattrs space + 1 block for xattr.
 *
 < ASCII >
 * +--------------------+
 * | f2fs_xattr_header  |
 * |                    |
 * +--------------------+
 * | f2fs_xattr_entry   |
 * | .e_name_index = 1  |
 * | .e_name_len = 3    |
 * | .e_value_size = 14 |
 * | .e_name = "foo"    |
 * | "value_of_xattr"   |<- value_offs = e_name + e_name_len
 * +--------------------+
 * | f2fs_xattr_entry   |
 * | .e_name_index = 4  |
 * | .e_name = "bar"    |
 * +--------------------+
 * |                    |
 * |        Free        |
 * |                    |
 * +--------------------+<- MIN_OFFSET
 * |   node_footer      |
 * | (nid, ino, offset) |
 * +--------------------+
 < ASCII >
 *
 **/
```
## Visual type:
- #memory-layout


== ./linux/linux_832.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/fat/misc.c#L171-L180

```c
/*
 < ASCII >
 * The epoch of FAT timestamp is 1980.
 *     :  bits :     value
 * date:  0 -  4: day	(1 -  31)
 * date:  5 -  8: month	(1 -  12)
 * date:  9 - 15: year	(0 - 127) from 1980
 * time:  0 -  4: sec	(0 -  29) 2sec counts
 * time:  5 - 10: min	(0 -  59)
 * time: 11 - 15: hour	(0 -  23)
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_833.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/fscache/main.c#L31-L40

```c
/*
 < ASCII >
 * Mixing scores (in bits) for (7,20):
 * Input delta: 1-bit      2-bit
 * 1 round:     330.3     9201.6
 * 2 rounds:   1246.4    25475.4
 * 3 rounds:   1907.1    31295.1
 * 4 rounds:   2042.3    31718.6
 * Perfect:    2048      31744
 *            (32*64)   (32*31/2 * 64)
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_834.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/gfs2/bmap.c#L176-L233

```c
/**
 * find_metapath - Find path through the metadata tree
 * @sdp: The superblock
 * @block: The disk block to look up
 * @mp: The metapath to return the result in
 * @height: The pre-calculated height of the metadata tree
 *
 *   This routine returns a struct metapath structure that defines a path
 *   through the metadata of inode "ip" to get to block "block".
 *
 *   Example:
 *   Given:  "ip" is a height 3 file, "offset" is 101342453, and this is a
 *   filesystem with a blocksize of 4096.
 *
 *   find_metapath() would return a struct metapath structure set to:
 *   mp_fheight = 3, mp_list[0] = 0, mp_list[1] = 48, and mp_list[2] = 165.
 *
 *   That means that in order to get to the block containing the byte at
 *   offset 101342453, we would load the indirect block pointed to by pointer
 *   0 in the dinode.  We would then load the indirect block pointed to by
 *   pointer 48 in that indirect block.  We would then load the data block
 *   pointed to by pointer 165 in that indirect block.
 < ASCII >
 *
 *             ----------------------------------------
 *             | Dinode |                             |
 *             |        |                            4|
 *             |        |0 1 2 3 4 5                 9|
 *             |        |                            6|
 *             ----------------------------------------
 *                       |
 *                       |
 *                       V
 *             ----------------------------------------
 *             | Indirect Block                       |
 *             |                                     5|
 *             |            4 4 4 4 4 5 5            1|
 *             |0           5 6 7 8 9 0 1            2|
 *             ----------------------------------------
 *                                |
 *                                |
 *                                V
 *             ----------------------------------------
 *             | Indirect Block                       |
 *             |                         1 1 1 1 1   5|
 *             |                         6 6 6 6 6   1|
 *             |0                        3 4 5 6 7   2|
 *             ----------------------------------------
 *                                           |
 *                                           |
 *                                           V
 *             ----------------------------------------
 *             | Data block containing offset         |
 *             |            101342453                 |
 *             |                                      |
 *             |                                      |
 *             ----------------------------------------
 < ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_835.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/iomap/buffered-io.c#L1017-L1046

```c
/*
 * When a short write occurs, the filesystem may need to remove reserved space
 * that was allocated in ->iomap_begin from it's ->iomap_end method. For
 * filesystems that use delayed allocation, we need to punch out delalloc
 * extents from the range that are not dirty in the page cache. As the write can
 * race with page faults, there can be dirty pages over the delalloc extent
 * outside the range of a short write but still within the delalloc extent
 * allocated for this iomap.
 *
 * This function uses [start_byte, end_byte) intervals (i.e. open ended) to
 * simplify range iterations.
 *
 * The punch() callback *must* only punch delalloc extents in the range passed
 * to it. It must skip over all other types of extents in the range and leave
 * them completely unchanged. It must do this punch atomically with respect to
 * other extent modifications.
 *
 * The punch() callback may be called with a folio locked to prevent writeback
 * extent allocation racing at the edge of the range we are currently punching.
 * The locked folio may or may not cover the range being punched, so it is not
 * safe for the punch() callback to lock folios itself.
 *
 < ASCII >
 * Lock order is:
 *
 * inode->i_rwsem (shared or exclusive)
 *   inode->i_mapping->invalidate_lock (exclusive)
 *     folio_lock()
 *       ->punch
 *         internal filesystem allocation lock
 < ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_836.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/jfs/jfs_dmap.c#L3313-L3329

```c
/*
 * NAME:	dbExtendFS()
 *
 * FUNCTION:	extend bmap from blkno for nblocks;
 *		dbExtendFS() updates bmap ready for dbAllocBottomUp();
 *
 < ASCII >
 * L2
 *  |
 *   L1---------------------------------L1
 *    |					 |
 *     L0---------L0---------L0		  L0---------L0---------L0
 *      |	   |	      |		   |	      |		 |
 *	 d0,...,dn  d0,...,dn  d0,...,dn    d0,...,dn  d0,...,dn  d0,.,dm;
 * L2L1L0d0,...,dnL0d0,...,dnL0d0,...,dnL1L0d0,...,dnL0d0,...,dnL0d0,..dm
 *
 * <---old---><----------------------------extend----------------------->
 < ASCII >
 */
```
## Visual type:
- #tree


== ./linux/linux_837.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/jfs/jfs_dtree.h#L157-L179

```c
/*
 *	directory regular page:
 *
 *	entry slot array of 32 byte slot
 *
 * sorted entry slot index table (stbl):
 * contiguous slots at slot specified by stblindex,
 * 1-byte per entry
 *   512 byte block:  16 entry tbl (1 slot)
 *  1024 byte block:  32 entry tbl (1 slot)
 *  2048 byte block:  64 entry tbl (2 slot)
 *  4096 byte block: 128 entry tbl (4 slot)
 *
 * data area:
 *   512 byte block:  16 - 2 =  14 slot
 *  1024 byte block:  32 - 2 =  30 slot
 *  2048 byte block:  64 - 3 =  61 slot
 *  4096 byte block: 128 - 5 = 123 slot
 *
 * N.B. index is 0-based; index fields refer to slot index
 * except nextindex which refers to entry index in stbl;
 * end of entry stot list or freelist is marked with -1.
 */
```
## Visual type:



== ./linux/linux_838.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/jfs/jfs_mount.c#L6-L35

```c
/*
 * Module: jfs_mount.c
 *
 * note: file system in transition to aggregate/fileset:
 *
 * file system mount is interpreted as the mount of aggregate,
 * if not already mounted, and mount of the single/only fileset in
 * the aggregate;
 *
 * a file system/aggregate is represented by an internal inode
 * (aka mount inode) initialized with aggregate superblock;
 * each vfs represents a fileset, and points to its "fileset inode
 * allocation map inode" (aka fileset inode):
 * (an aggregate itself is structured recursively as a filset:
 * an internal vfs is constructed and points to its "fileset inode
 * allocation map inode" (aka aggregate inode) where each inode
 * represents a fileset inode) so that inode number is mapped to
 * on-disk inode in uniform way at both aggregate and fileset level;
 *
 * each vnode/inode of a fileset is linked to its vfs (to facilitate
 * per fileset inode operations, e.g., unmount of a fileset, etc.);
 * each inode points to the mount inode (to facilitate access to
 * per aggregate information, e.g., block size, etc.) as well as
 * its file set inode.
 *
 < ASCII >
 *   aggregate
 *   ipmnt
 *   mntvfs -> fileset ipimap+ -> aggregate ipbmap -> aggregate ipaimap;
 *             fileset vfs     -> vp(1) <-> ... <-> vp(n) <->vproot;
 < ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_839.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/jfs/resize.c#L29-L49

```c
/*
 *	jfs_extendfs()
 *
 * function: extend file system;
 < ASCII >
 *
 *   |-------------------------------|----------|----------|
 *   file system space               fsck       inline log
 *                                   workspace  space
 < ASCII >
 *
 * input:
 *	new LVSize: in LV blocks (required)
 *	new LogSize: in LV blocks (optional)
 *	new FSSize: in LV blocks (optional)
 *
 * new configuration:
 * 1. set new LogSize as specified or default from new LVSize;
 * 2. compute new FSCKSize from new LVSize;
 * 3. set new FSSize as MIN(FSSize, LVSize-(LogSize+FSCKSize)) where
 *    assert(new FSSize >= old FSSize),
 *    i.e., file system must not be shrunk;
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_84.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/kvm/va_layout.c#L49-L59

```c
/*
 * We want to generate a hyp VA with the following format (with V ==
 * vabits_actual):
 *
 < ASCII >
 *  63 ... V |     V-1    | V-2 .. tag_lsb | tag_lsb - 1 .. 0
 *  ---------------------------------------------------------
 * | 0000000 | hyp_va_msb |   random tag   |  kern linear VA |
 *           |--------- tag_val -----------|----- va_mask ---|
 < ASCII >
 *
 * which does not conflict with the idmap regions.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_840.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/jfs/xattr.c#L24-L57

```c
/*
 *	jfs_xattr.c: extended attribute service
 *
 * Overall design --
 *
 * Format:
 *
 *   Extended attribute lists (jfs_ea_list) consist of an overall size (32 bit
 *   value) and a variable (0 or more) number of extended attribute
 *   entries.  Each extended attribute entry (jfs_ea) is a <name,value> double
 *   where <name> is constructed from a null-terminated ascii string
 *   (1 ... 255 bytes in the name) and <value> is arbitrary 8 bit data
 *   (1 ... 65535 bytes).  The in-memory format is
 *
 < ASCII >
 *   0       1        2        4                4 + namelen + 1
 *   +-------+--------+--------+----------------+-------------------+
 *   | Flags | Name   | Value  | Name String \0 | Data . . . .      |
 *   |       | Length | Length |                |                   |
 *   +-------+--------+--------+----------------+-------------------+
 *
 *   A jfs_ea_list then is structured as
 *
 *   0            4                   4 + EA_SIZE(ea1)
 *   +------------+-------------------+--------------------+-----
 *   | Overall EA | First FEA Element | Second FEA Element | .....
 *   | List Size  |                   |                    |
 *   +------------+-------------------+--------------------+-----
 < ASCII >
 *
 *   On-disk:
 *
 *	FEALISTs are stored on disk using blocks allocated by dbAlloc() and
 *	written directly. An EA list may be in-lined in the inode if there is
 *	sufficient room available.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_841.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/ksmbd/smbstatus.h#L12-L17

```c
/*
 < ASCII >
 *  0 1 2 3 4 5 6 7 8 9 0 A B C D E F 0 1 2 3 4 5 6 7 8 9 A B C D E F
 *  SEV C N <-------Facility--------> <------Error Status Code------>
 < ASCII >
 *
 *  C is set if "customer defined" error, N bit is reserved and MBZ
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_842.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/nfs/pnfs.c#L622-L628

```c
/*
 < ASCII >
 * is l2 fully contained in l1?
 *   start1                             end1
 *   [----------------------------------)
 *           start2           end2
 *           [----------------)
 < ASCII >
 */
```
## Visual type:
- #interval


== ./linux/linux_843.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/nfs/pnfs.c#L1771-L1783

```c
/*
 < ASCII >
 * iomode matching rules:
 * iomode	lseg	strict match
 *                      iomode
 * -----	-----	------ -----
 * ANY		READ	N/A    true
 * ANY		RW	N/A    true
 * RW		READ	N/A    false
 * RW		RW	N/A    true
 * READ		READ	N/A    true
 * READ		RW	true   false
 * READ		RW	false  true
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_844.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/nfs/pnfs.h#L656-L662

```c
/*
 < ASCII >
 * Are 2 ranges intersecting?
 *   start1                             end1
 *   [----------------------------------)
 *                                start2           end2
 *                                [----------------)
 < ASCII >
 */
```
## Visual type:
- #interval


== ./linux/linux_845.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/nfsd/state.h#L286-L301

```c
/*
 < ASCII >
 *       State                Meaning                  Where set
 * --------------------------------------------------------------------------
 * | NFSD4_ACTIVE      | Confirmed, active    | Default                     |
 * |------------------- ----------------------------------------------------|
 * | NFSD4_COURTESY    | Courtesy state.      | nfs4_get_client_reaplist    |
 * |                   | Lease/lock/share     |                             |
 * |                   | reservation conflict |                             |
 * |                   | can cause Courtesy   |                             |
 * |                   | client to be expired |                             |
 * |------------------------------------------------------------------------|
 * | NFSD4_EXPIRABLE   | Courtesy client to be| nfs4_laundromat             |
 * |                   | expired by Laundromat| try_to_expire_client        |
 * |                   | due to conflict      |                             |
 * |------------------------------------------------------------------------|
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_846.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/ntfs3/ntfs.h#L1004-L1025

```c
/*
 < ASCII >
 * The reparse tags are a ULONG. The 32 bits are laid out as follows:
 *
 *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+-+-+-+-----------------------+-------------------------------+
 *  |M|R|N|R|	  Reserved bits     |	    Reparse Tag Value	    |
 *  +-+-+-+-+-----------------------+-------------------------------+
 < ASCII >
 *
 * M is the Microsoft bit. When set to 1, it denotes a tag owned by Microsoft.
 *   All ISVs must use a tag with a 0 in this position.
 *   Note: If a Microsoft tag is used by non-Microsoft software, the
 *   behavior is not defined.
 *
 * R is reserved.  Must be zero for non-Microsoft tags.
 *
 * N is name surrogate. When set to 1, the file represents another named
 *   entity in the system.
 *
 * The M and N bits are OR-able.
 * The following macros check for the M and N bit values:
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_847.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/ocfs2/dlmglue.c#L1007-L1063

```c
/*
 * OCFS2_LOCK_PENDING and l_pending_gen.
 *
 * Why does OCFS2_LOCK_PENDING exist?  To close a race between setting
 * OCFS2_LOCK_BUSY and calling ocfs2_dlm_lock().  See ocfs2_unblock_lock()
 * for more details on the race.
 *
 * OCFS2_LOCK_PENDING closes the race quite nicely.  However, it introduces
 * a race on itself.  In o2dlm, we can get the ast before ocfs2_dlm_lock()
 * returns.  The ast clears OCFS2_LOCK_BUSY, and must therefore clear
 * OCFS2_LOCK_PENDING at the same time.  When ocfs2_dlm_lock() returns,
 * the caller is going to try to clear PENDING again.  If nothing else is
 * happening, __lockres_clear_pending() sees PENDING is unset and does
 * nothing.
 *
 * But what if another path (eg downconvert thread) has just started a
 * new locking action?  The other path has re-set PENDING.  Our path
 * cannot clear PENDING, because that will re-open the original race
 * window.
 *
 * [Example]
 *
 < ASCII >
 * ocfs2_meta_lock()
 *  ocfs2_cluster_lock()
 *   set BUSY
 *   set PENDING
 *   drop l_lock
 *   ocfs2_dlm_lock()
 *    ocfs2_locking_ast()		ocfs2_downconvert_thread()
 *     clear PENDING			 ocfs2_unblock_lock()
 *					  take_l_lock
 *					  !BUSY
 *					  ocfs2_prepare_downconvert()
 *					   set BUSY
 *					   set PENDING
 *					  drop l_lock
 *   take l_lock
 *   clear PENDING
 *   drop l_lock
 *			<window>
 *					  ocfs2_dlm_lock()
 < ASCII >
 *
 * So as you can see, we now have a window where l_lock is not held,
 * PENDING is not set, and ocfs2_dlm_lock() has not been called.
 *
 * The core problem is that ocfs2_cluster_lock() has cleared the PENDING
 * set by ocfs2_prepare_downconvert().  That wasn't nice.
 *
 * To solve this we introduce l_pending_gen.  A call to
 * lockres_clear_pending() will only do so when it is passed a generation
 * number that matches the lockres.  lockres_set_pending() will return the
 * current generation number.  When ocfs2_cluster_lock() goes to clear
 * PENDING, it passes the generation it got from set_pending().  In our
 * example above, the generation numbers will *not* match.  Thus,
 * ocfs2_cluster_lock() will not clear the PENDING set by
 * ocfs2_prepare_downconvert().
 */
```
## Visual type:
- #tree


== ./linux/linux_848.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/ocfs2/dlmglue.c#L2630-L2670

```c
/*
 * This _tracker variantes are introduced to deal with the recursive cluster
 * locking issue. The idea is to keep track of a lock holder on the stack of
 * the current process. If there's a lock holder on the stack, we know the
 * task context is already protected by cluster locking. Currently, they're
 * used in some VFS entry routines.
 *
 * return < 0 on error, return == 0 if there's no lock holder on the stack
 * before this call, return == 1 if this call would be a recursive locking.
 * return == -1 if this lock attempt will cause an upgrade which is forbidden.
 *
 * When taking lock levels into account,we face some different situations.
 *
 * 1. no lock is held
 *    In this case, just lock the inode as requested and return 0
 *
 * 2. We are holding a lock
 *    For this situation, things diverges into several cases
 *
 < ASCII >
 *    wanted     holding	     what to do
 *    ex		ex	    see 2.1 below
 *    ex		pr	    see 2.2 below
 *    pr		ex	    see 2.1 below
 *    pr		pr	    see 2.1 below
 < ASCII >
 *
 *    2.1 lock level that is been held is compatible
 *    with the wanted level, so no lock action will be tacken.
 *
 *    2.2 Otherwise, an upgrade is needed, but it is forbidden.
 *
 * Reason why upgrade within a process is forbidden is that
 * lock upgrade may cause dead lock. The following illustrates
 * how it happens.
 *
 < ASCII >
 *         thread on node1                             thread on node2
 * ocfs2_inode_lock_tracker(ex=0)
 *
 *                                <======   ocfs2_inode_lock_tracker(ex=1)
 *
 * ocfs2_inode_lock_tracker(ex=1)
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_849.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/orangefs/orangefs-debug.h#L52-L64

```c
/*
 * Map all kmod keywords to kmod debug masks here. Keep this
 * structure "packed":
 *
 *   "all" is always last...
 *
 < ASCII >
 *   keyword     mask_val     index
 *     foo          1           0
 *     bar          2           1
 *     baz          4           2
 *     qux          8           3
 *      .           .           .
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_85.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/kvm/hyp/nvhe/page_alloc.c#L12-L32

```c
/*
 * Index the hyp_vmemmap to find a potential buddy page, but make no assumption
 * about its current state.
 *
 * Example buddy-tree for a 4-pages physically contiguous pool:
 *
 < ASCII >
 *                 o : Page 3
 *                /
 *               o-o : Page 2
 *              /
 *             /   o : Page 1
 *            /   /
 *           o---o-o : Page 0
 *    Order  2   1 0
 < ASCII >
 *
 * Example of requests on this pool:
 *   __find_buddy_nocheck(pool, page 0, order 0) => page 1
 *   __find_buddy_nocheck(pool, page 0, order 1) => page 2
 *   __find_buddy_nocheck(pool, page 1, order 0) => page 0
 *   __find_buddy_nocheck(pool, page 2, order 0) => page 3
 */
```
## Visual type:
- #tree


== ./linux/linux_850.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/overlayfs/export.c#L155-L182

```c
/*
 * We only need to encode origin if there is a chance that the same object was
 * encoded pre copy up and then we need to stay consistent with the same
 * encoding also after copy up. If non-pure upper is not indexed, then it was
 * copied up before NFS export was enabled. In that case we don't need to worry
 * about staying consistent with pre copy up encoding and we encode an upper
 * file handle. Overlay root dentry is a private case of non-indexed upper.
 *
 * The following table summarizes the different file handle encodings used for
 * different overlay object types:
 *
 < ASCII >
 *  Object type		| Encoding
 * --------------------------------
 *  Pure upper		| U
 *  Non-indexed upper	| U
 *  Indexed upper	| L (*)
 *  Non-upper		| L (*)
 < ASCII >
 *
 * U = upper file handle
 * L = lower file handle
 *
 * (*) Connecting an overlay dir from real lower dentry is not always
 * possible when there are redirects in lower layers and non-indexed merge dirs.
 * To mitigate those case, we may copy up the lower dir ancestor before encode
 * a lower dir file handle.
 *
 * Return 0 for upper file handle, > 0 for lower file handle or < 0 on error.
 */
```
## Visual type:
- #table


== ./linux/linux_851.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/reiserfs/reiserfs.h#L1632-L1639

```c
/*
 * Picture represents a leaf of the S+tree
 < ASCII >
 *  ______________________________________________________
 * |      |  Array of     |                   |           |
 * |Block |  Object-Item  |      F r e e      |  Objects- |
 * | head |  Headers      |     S p a c e     |   Items   |
 * |______|_______________|___________________|___________|
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_852.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/reiserfs/reiserfs.h#L2606-L2624

```c
/*
 < ASCII >
 * there are 4 types of items: stat data, directory item, indirect, direct.
 * +-------------------+------------+--------------+------------+
 * |                   |  k_offset  | k_uniqueness | mergeable? |
 * +-------------------+------------+--------------+------------+
 * |     stat data     |     0      |      0       |   no       |
 * +-------------------+------------+--------------+------------+
 * | 1st directory item| DOT_OFFSET | DIRENTRY_ .. |   no       |
 * | non 1st directory | hash value | UNIQUENESS   |   yes      |
 * |     item          |            |              |            |
 * +-------------------+------------+--------------+------------+
 * | indirect item     | offset + 1 |TYPE_INDIRECT |    [1]	|
 * +-------------------+------------+--------------+------------+
 * | direct item       | offset + 1 |TYPE_DIRECT   |    [2]     |
 * +-------------------+------------+--------------+------------+
 < ASCII >
 *
 * [1] if this is not the first indirect item of the object
 * [2] if this is not the first direct item of the object
*/
```
## Visual type:
- #table


== ./linux/linux_853.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/unicode/mkutf8data.c#L202-L249

```c
/*
 * UTF8 valid ranges.
 *
 * The UTF-8 encoding spreads the bits of a 32bit word over several
 * bytes. This table gives the ranges that can be held and how they'd
 * be represented.
 *
 < ASCII >
 * 0x00000000 0x0000007F: 0xxxxxxx
 * 0x00000000 0x000007FF: 110xxxxx 10xxxxxx
 * 0x00000000 0x0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx
 * 0x00000000 0x001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
 * 0x00000000 0x03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
 * 0x00000000 0x7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
 < ASCII >
 *
 * There is an additional requirement on UTF-8, in that only the
 * shortest representation of a 32bit value is to be used.  A decoder
 * must not decode sequences that do not satisfy this requirement.
 * Thus the allowed ranges have a lower bound.
 *
 < ASCII >
 * 0x00000000 0x0000007F: 0xxxxxxx
 * 0x00000080 0x000007FF: 110xxxxx 10xxxxxx
 * 0x00000800 0x0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx
 * 0x00010000 0x001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
 * 0x00200000 0x03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
 * 0x04000000 0x7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
 < ASCII >
 *
 * Actual unicode characters are limited to the range 0x0 - 0x10FFFF,
 * 17 planes of 65536 values.  This limits the sequences actually seen
 * even more, to just the following.
 *
 < ASCII >
 *          0 -     0x7f: 0                     0x7f
 *       0x80 -    0x7ff: 0xc2 0x80             0xdf 0xbf
 *      0x800 -   0xffff: 0xe0 0xa0 0x80        0xef 0xbf 0xbf
 *    0x10000 - 0x10ffff: 0xf0 0x90 0x80 0x80   0xf4 0x8f 0xbf 0xbf
 < ASCII >
 *
 * Even within those ranges not all values are allowed: the surrogates
 * 0xd800 - 0xdfff should never be seen.
 *
 * Note that the longest sequence seen with valid usage is 4 bytes,
 * the same a single UTF-32 character.  This makes the UTF-8
 * representation of Unicode strictly smaller than UTF-32.
 *
 * The shortest sequence requirement was introduced by:
 *    Corrigendum #1: UTF-8 Shortest Form
 * It can be found here:
 *    http://www.unicode.org/versions/corrigendum1.html
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_854.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/unicode/utf8-norm.c#L21-L67

```c
/*
 * UTF-8 valid ranges.
 *
 * The UTF-8 encoding spreads the bits of a 32bit word over several
 * bytes. This table gives the ranges that can be held and how they'd
 * be represented.
 *
 < ASCII >
 * 0x00000000 0x0000007F: 0xxxxxxx
 * 0x00000000 0x000007FF: 110xxxxx 10xxxxxx
 * 0x00000000 0x0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx
 * 0x00000000 0x001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
 * 0x00000000 0x03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
 * 0x00000000 0x7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
 < ASCII >
 *
 * There is an additional requirement on UTF-8, in that only the
 * shortest representation of a 32bit value is to be used.  A decoder
 * must not decode sequences that do not satisfy this requirement.
 * Thus the allowed ranges have a lower bound.
 *
 < ASCII >
 * 0x00000000 0x0000007F: 0xxxxxxx
 * 0x00000080 0x000007FF: 110xxxxx 10xxxxxx
 * 0x00000800 0x0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx
 * 0x00010000 0x001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
 * 0x00200000 0x03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
 * 0x04000000 0x7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
 < ASCII >
 *
 * Actual unicode characters are limited to the range 0x0 - 0x10FFFF,
 * 17 planes of 65536 values.  This limits the sequences actually seen
 * even more, to just the following.
 *
 < ASCII >
 *          0 -     0x7F: 0                   - 0x7F
 *       0x80 -    0x7FF: 0xC2 0x80           - 0xDF 0xBF
 *      0x800 -   0xFFFF: 0xE0 0xA0 0x80      - 0xEF 0xBF 0xBF
 *    0x10000 - 0x10FFFF: 0xF0 0x90 0x80 0x80 - 0xF4 0x8F 0xBF 0xBF
 < ASCII >
 *
 * Within those ranges the surrogates 0xD800 - 0xDFFF are not allowed.
 *
 * Note that the longest sequence seen with valid usage is 4 bytes,
 * the same a single UTF-32 character.  This makes the UTF-8
 * representation of Unicode strictly smaller than UTF-32.
 *
 * The shortest sequence requirement was introduced by:
 *    Corrigendum #1: UTF-8 Shortest Form
 * It can be found here:
 *    http://www.unicode.org/versions/corrigendum1.html
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_855.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/xfs/xfs_reflink.c#L33-L119

```c
/*
 * Copy on Write of Shared Blocks
 *
 * XFS must preserve "the usual" file semantics even when two files share
 * the same physical blocks.  This means that a write to one file must not
 * alter the blocks in a different file; the way that we'll do that is
 * through the use of a copy-on-write mechanism.  At a high level, that
 * means that when we want to write to a shared block, we allocate a new
 * block, write the data to the new block, and if that succeeds we map the
 * new block into the file.
 *
 * XFS provides a "delayed allocation" mechanism that defers the allocation
 * of disk blocks to dirty-but-not-yet-mapped file blocks as long as
 * possible.  This reduces fragmentation by enabling the filesystem to ask
 * for bigger chunks less often, which is exactly what we want for CoW.
 *
 * The delalloc mechanism begins when the kernel wants to make a block
 * writable (write_begin or page_mkwrite).  If the offset is not mapped, we
 * create a delalloc mapping, which is a regular in-core extent, but without
 * a real startblock.  (For delalloc mappings, the startblock encodes both
 * a flag that this is a delalloc mapping, and a worst-case estimate of how
 * many blocks might be required to put the mapping into the BMBT.)  delalloc
 * mappings are a reservation against the free space in the filesystem;
 * adjacent mappings can also be combined into fewer larger mappings.
 *
 * As an optimization, the CoW extent size hint (cowextsz) creates
 * outsized aligned delalloc reservations in the hope of landing out of
 * order nearby CoW writes in a single extent on disk, thereby reducing
 * fragmentation and improving future performance.
 *
 < ASCII >
 * D: --RRRRRRSSSRRRRRRRR--- (data fork)
 * C: ------DDDDDDD--------- (CoW fork)
 < ASCII >
 *
 * When dirty pages are being written out (typically in writepage), the
 * delalloc reservations are converted into unwritten mappings by
 * allocating blocks and replacing the delalloc mapping with real ones.
 * A delalloc mapping can be replaced by several unwritten ones if the
 * free space is fragmented.
 *
 < ASCII >
 * D: --RRRRRRSSSRRRRRRRR---
 * C: ------UUUUUUU---------
 < ASCII >
 *
 * We want to adapt the delalloc mechanism for copy-on-write, since the
 * write paths are similar.  The first two steps (creating the reservation
 * and allocating the blocks) are exactly the same as delalloc except that
 * the mappings must be stored in a separate CoW fork because we do not want
 * to disturb the mapping in the data fork until we're sure that the write
 * succeeded.  IO completion in this case is the process of removing the old
 * mapping from the data fork and moving the new mapping from the CoW fork to
 * the data fork.  This will be discussed shortly.
 *
 * For now, unaligned directio writes will be bounced back to the page cache.
 * Block-aligned directio writes will use the same mechanism as buffered
 * writes.
 *
 * Just prior to submitting the actual disk write requests, we convert
 * the extents representing the range of the file actually being written
 * (as opposed to extra pieces created for the cowextsize hint) to real
 * extents.  This will become important in the next step:
 *
 < ASCII >
 * D: --RRRRRRSSSRRRRRRRR---
 * C: ------UUrrUUU---------
 < ASCII >
 *
 * CoW remapping must be done after the data block write completes,
 * because we don't want to destroy the old data fork map until we're sure
 * the new block has been written.  Since the new mappings are kept in a
 * separate fork, we can simply iterate these mappings to find the ones
 * that cover the file blocks that we just CoW'd.  For each extent, simply
 * unmap the corresponding range in the data fork, map the new range into
 * the data fork, and remove the extent from the CoW fork.  Because of
 * the presence of the cowextsize hint, however, we must be careful
 * only to remap the blocks that we've actually written out --  we must
 * never remap delalloc reservations nor CoW staging blocks that have
 * yet to be written.  This corresponds exactly to the real extents in
 * the CoW fork:
 *
 < ASCII >
 * D: --RRRRRRrrSRRRRRRRR---
 * C: ------UU--UUU---------
 < ASCII >
 *
 * Since the remapping operation can be applied to an arbitrary file
 * range, we record the need for the remap step as a flag in the ioend
 * instead of declaring a new IO type.  This is required for direct io
 * because we only have ioend for the whole dio, and we have to be able to
 * remember the presence of unwritten blocks and CoW blocks with a single
 * ioend structure.  Better yet, the more ground we can cover with one
 * ioend, the better.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_856.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/xfs/xfs_reflink.c#L938-L1012

```c
/*
 * Reflinking (Block) Ranges of Two Files Together
 *
 * First, ensure that the reflink flag is set on both inodes.  The flag is an
 * optimization to avoid unnecessary refcount btree lookups in the write path.
 *
 * Now we can iteratively remap the range of extents (and holes) in src to the
 * corresponding ranges in dest.  Let drange and srange denote the ranges of
 * logical blocks in dest and src touched by the reflink operation.
 *
 * While the length of drange is greater than zero,
 *    - Read src's bmbt at the start of srange ("imap")
 *    - If imap doesn't exist, make imap appear to start at the end of srange
 *      with zero length.
 *    - If imap starts before srange, advance imap to start at srange.
 *    - If imap goes beyond srange, truncate imap to end at the end of srange.
 *    - Punch (imap start - srange start + imap len) blocks from dest at
 *      offset (drange start).
 *    - If imap points to a real range of pblks,
 *         > Increase the refcount of the imap's pblks
 *         > Map imap's pblks into dest at the offset
 *           (drange start + imap start - srange start)
 *    - Advance drange and srange by (imap start - srange start + imap len)
 *
 * Finally, if the reflink made dest longer, update both the in-core and
 * on-disk file sizes.
 *
 * ASCII Art Demonstration:
 *
 < ASCII >
 * Let's say we want to reflink this source file:
 *
 * ----SSSSSSS-SSSSS----SSSSSS (src file)
 *   <-------------------->
 *
 * into this destination file:
 *
 * --DDDDDDDDDDDDDDDDDDD--DDD (dest file)
 *        <-------------------->
 < ASCII >
 * '-' means a hole, and 'S' and 'D' are written blocks in the src and dest.
 * Observe that the range has different logical offsets in either file.
 *
 * Consider that the first extent in the source file doesn't line up with our
 * reflink range.  Unmapping  and remapping are separate operations, so we can
 * unmap more blocks from the destination file than we remap.
 *
 < ASCII >
 * ----SSSSSSS-SSSSS----SSSSSS
 *   <------->
 * --DDDDD---------DDDDD--DDD
 *        <------->
 *
 * Now remap the source extent into the destination file:
 *
 * ----SSSSSSS-SSSSS----SSSSSS
 *   <------->
 * --DDDDD--SSSSSSSDDDDD--DDD
 *        <------->
 *
 * Do likewise with the second hole and extent in our range.  Holes in the
 * unmap range don't affect our operation.
 *
 * ----SSSSSSS-SSSSS----SSSSSS
 *            <---->
 * --DDDDD--SSSSSSS-SSSSS-DDD
 *                 <---->
 *
 * Finally, unmap and remap part of the third extent.  This will increase the
 * size of the destination file.
 *
 * ----SSSSSSS-SSSSS----SSSSSS
 *                  <----->
 * --DDDDD--SSSSSSS-SSSSS----SSS
 *                       <----->
 < ASCII >
 *
 * Once we update the destination file's i_size, we're done.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_857.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/xfs/libxfs/xfs_attr.h#L83-L425

```c
/*
 * Below is a state machine diagram for attr remove operations. The  XFS_DAS_*
 * states indicate places where the function would return -EAGAIN, and then
 * immediately resume from after being called by the calling function. States
 * marked as a "subroutine state" indicate that they belong to a subroutine, and
 * so the calling function needs to pass them back to that subroutine to allow
 * it to finish where it left off. But they otherwise do not have a role in the
 * calling function other than just passing through.
 *
 < ASCII >
 * xfs_attr_remove_iter()
 *              │
 *              v
 *        have attr to remove? ──n──> done
 *              │
 *              y
 *              │
 *              v
 *        are we short form? ──y──> xfs_attr_shortform_remove ──> done
 *              │
 *              n
 *              │
 *              V
 *        are we leaf form? ──y──> xfs_attr_leaf_removename ──> done
 *              │
 *              n
 *              │
 *              V
 *   ┌── need to setup state?
 *   │          │
 *   n          y
 *   │          │
 *   │          v
 *   │ find attr and get state
 *   │ attr has remote blks? ──n─┐
 *   │          │                v
 *   │          │         find and invalidate
 *   │          y         the remote blocks.
 *   │          │         mark attr incomplete
 *   │          ├────────────────┘
 *   └──────────┤
 *              │
 *              v
 *   Have remote blks to remove? ───y─────┐
 *              │        ^          remove the blks
 *              │        │                │
 *              │        │                v
 *              │  XFS_DAS_RMTBLK <─n── done?
 *              │  re-enter with          │
 *              │  one less blk to        y
 *              │      remove             │
 *              │                         V
 *              │                  refill the state
 *              n                         │
 *              │                         v
 *              │                   XFS_DAS_RM_NAME
 *              │                         │
 *              ├─────────────────────────┘
 *              │
 *              v
 *       remove leaf and
 *       update hash with
 *   xfs_attr_node_remove_cleanup
 *              │
 *              v
 *           need to
 *        shrink tree? ─n─┐
 *              │         │
 *              y         │
 *              │         │
 *              v         │
 *          join leaf     │
 *              │         │
 *              v         │
 *      XFS_DAS_RM_SHRINK │
 *              │         │
 *              v         │
 *       do the shrink    │
 *              │         │
 *              v         │
 *          free state <──┘
 *              │
 *              v
 *            done
 < ASCII >
 *
 *
 * Below is a state machine diagram for attr set operations.
 *
 * It seems the challenge with understanding this system comes from trying to
 * absorb the state machine all at once, when really one should only be looking
 * at it with in the context of a single function. Once a state sensitive
 * function is called, the idea is that it "takes ownership" of the
 * state machine. It isn't concerned with the states that may have belonged to
 * it's calling parent. Only the states relevant to itself or any other
 * subroutines there in. Once a calling function hands off the state machine to
 * a subroutine, it needs to respect the simple rule that it doesn't "own" the
 * state machine anymore, and it's the responsibility of that calling function
 * to propagate the -EAGAIN back up the call stack. Upon reentry, it is
 * committed to re-calling that subroutine until it returns something other than
 * -EAGAIN. Once that subroutine signals completion (by returning anything other
 * than -EAGAIN), the calling function can resume using the state machine.
 *
 < ASCII >
 *  xfs_attr_set_iter()
 *              │
 *              v
 *   ┌─y─ has an attr fork?
 *   │          |
 *   │          n
 *   │          |
 *   │          V
 *   │       add a fork
 *   │          │
 *   └──────────┤
 *              │
 *              V
 *   ┌─── is shortform?
 *   │          │
 *   │          y
 *   │          │
 *   │          V
 *   │   xfs_attr_set_fmt
 *   │          |
 *   │          V
 *   │ xfs_attr_try_sf_addname
 *   │          │
 *   │          V
 *   │      had enough ──y──> done
 *   │        space?
 *   n          │
 *   │          n
 *   │          │
 *   │          V
 *   │   transform to leaf
 *   │          │
 *   │          V
 *   │   hold the leaf buffer
 *   │          │
 *   │          V
 *   │     return -EAGAIN
 *   │      Re-enter in
 *   │       leaf form
 *   │
 *   └─> release leaf buffer
 *          if needed
 *              │
 *              V
 *   ┌───n── fork has
 *   │      only 1 blk?
 *   │          │
 *   │          y
 *   │          │
 *   │          v
 *   │ xfs_attr_leaf_try_add()
 *   │          │
 *   │          v
 *   │      had enough ──────────────y─────────────┐
 *   │        space?                               │
 *   │          │                                  │
 *   │          n                                  │
 *   │          │                                  │
 *   │          v                                  │
 *   │    return -EAGAIN                           │
 *   │      re-enter in                            │
 *   │        node form                            │
 *   │          │                                  │
 *   └──────────┤                                  │
 *              │                                  │
 *              V                                  │
 * xfs_attr_node_addname_find_attr                 │
 *        determines if this                       │
 *       is create or rename                       │
 *     find space to store attr                    │
 *              │                                  │
 *              v                                  │
 *     xfs_attr_node_addname                       │
 *              │                                  │
 *              v                                  │
 *   fits in a node leaf? ────n─────┐              │
 *              │     ^             v              │
 *              │     │       single leaf node?    │
 *              │     │         │            │     │
 *              y     │         y            n     │
 *              │     │         │            │     │
 *              v     │         v            v     │
 *            update  │    grow the leaf  split if │
 *           hashvals └── return -EAGAIN   needed  │
 *              │         retry leaf add     │     │
 *              │           on reentry       │     │
 *              ├────────────────────────────┘     │
 *              │                                  │
 *              v                                  │
 *         need to alloc                           │
 *   ┌─y── or flip flag?                           │
 *   │          │                                  │
 *   │          n                                  │
 *   │          │                                  │
 *   │          v                                  │
 *   │         done                                │
 *   │                                             │
 *   │                                             │
 *   │         XFS_DAS_FOUND_LBLK <────────────────┘
 *   │                  │
 *   │                  V
 *   │        xfs_attr_leaf_addname()
 *   │                  │
 *   │                  v
 *   │      ┌──first time through?
 *   │      │          │
 *   │      │          y
 *   │      │          │
 *   │      n          v
 *   │      │    if we have rmt blks
 *   │      │    find space for them
 *   │      │          │
 *   │      └──────────┤
 *   │                 │
 *   │                 v
 *   │            still have
 *   │      ┌─n─ blks to alloc? <──┐
 *   │      │          │           │
 *   │      │          y           │
 *   │      │          │           │
 *   │      │          v           │
 *   │      │     alloc one blk    │
 *   │      │     return -EAGAIN ──┘
 *   │      │    re-enter with one
 *   │      │    less blk to alloc
 *   │      │
 *   │      │
 *   │      └───> set the rmt
 *   │               value
 *   │                 │
 *   │                 v
 *   │               was this
 *   │              a rename? ──n─┐
 *   │                 │          │
 *   │                 y          │
 *   │                 │          │
 *   │                 v          │
 *   │           flip incomplete  │
 *   │               flag         │
 *   │                 │          │
 *   │                 v          │
 *   │         XFS_DAS_FLIP_LFLAG │
 *   │                 │          │
 *   │                 v          │
 *   │          need to remove    │
 *   │              old bks? ──n──┤
 *   │                 │          │
 *   │                 y          │
 *   │                 │          │
 *   │                 V          │
 *   │               remove       │
 *   │        ┌───> old blks      │
 *   │        │        │          │
 *   │ XFS_DAS_RM_LBLK │          │
 *   │        ^        │          │
 *   │        │        v          │
 *   │        └──y── more to      │
 *   │              remove?       │
 *   │                 │          │
 *   │                 n          │
 *   │                 │          │
 *   │                 v          │
 *   │          XFS_DAS_RD_LEAF   │
 *   │                 │          │
 *   │                 v          │
 *   │            remove leaf     │
 *   │                 │          │
 *   │                 v          │
 *   │            shrink to sf    │
 *   │             if needed      │
 *   │                 │          │
 *   │                 v          │
 *   │                done <──────┘
 *   │
 *   └──────> XFS_DAS_FOUND_NBLK
 *                     │
 *                     v
 *       ┌─────n──  need to
 *       │        alloc blks?
 *       │             │
 *       │             y
 *       │             │
 *       │             v
 *       │        find space
 *       │             │
 *       │             v
 *       │  ┌─>XFS_DAS_ALLOC_NODE
 *       │  │          │
 *       │  │          v
 *       │  │      alloc blk
 *       │  │          │
 *       │  │          v
 *       │  └──y── need to alloc
 *       │         more blocks?
 *       │             │
 *       │             n
 *       │             │
 *       │             v
 *       │      set the rmt value
 *       │             │
 *       │             v
 *       │          was this
 *       └────────> a rename? ──n─┐
 *                     │          │
 *                     y          │
 *                     │          │
 *                     v          │
 *               flip incomplete  │
 *                   flag         │
 *                     │          │
 *                     v          │
 *             XFS_DAS_FLIP_NFLAG │
 *                     │          │
 *                     v          │
 *                 need to        │
 *               remove blks? ─n──┤
 *                     │          │
 *                     y          │
 *                     │          │
 *                     v          │
 *                   remove       │
 *        ┌────────> old blks     │
 *        │            │          │
 *  XFS_DAS_RM_NBLK    │          │
 *        ^            │          │
 *        │            v          │
 *        └──────y── more to      │
 *                   remove       │
 *                     │          │
 *                     n          │
 *                     │          │
 *                     v          │
 *              XFS_DAS_CLR_FLAG  │
 *                     │          │
 *                     v          │
 *                clear flags     │
 *                     │          │
 *                     ├──────────┘
 *                     │
 *                     v
 *                   done
 < ASCII >
 */
```
## Visual type:
- #state-machine


== ./linux/linux_858.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/xfs/libxfs/xfs_btree.c#L513-L585

```c
/*
 * XFS btree block layout and addressing:
 *
 * There are two types of blocks in the btree: leaf and non-leaf blocks.
 *
 * The leaf record start with a header then followed by records containing
 * the values.  A non-leaf block also starts with the same header, and
 * then first contains lookup keys followed by an equal number of pointers
 * to the btree blocks at the previous level.
 *
 < ASCII >
 *		+--------+-------+-------+-------+-------+-------+-------+
 * Leaf:	| header | rec 1 | rec 2 | rec 3 | rec 4 | rec 5 | rec N |
 *		+--------+-------+-------+-------+-------+-------+-------+
 *
 *		+--------+-------+-------+-------+-------+-------+-------+
 * Non-Leaf:	| header | key 1 | key 2 | key N | ptr 1 | ptr 2 | ptr N |
 *		+--------+-------+-------+-------+-------+-------+-------+
 < ASCII >
 *
 * The header is called struct xfs_btree_block for reasons better left unknown
 * and comes in different versions for short (32bit) and long (64bit) block
 * pointers.  The record and key structures are defined by the btree instances
 * and opaque to the btree core.  The block pointers are simple disk endian
 * integers, available in a short (32bit) and long (64bit) variant.
 *
 * The helpers below calculate the offset of a given record, key or pointer
 * into a btree block (xfs_btree_*_offset) or return a pointer to the given
 * record, key or pointer (xfs_btree_*_addr).  Note that all addressing
 * inside the btree block is done using indices starting at one, not zero!
 *
 * If XFS_BTREE_OVERLAPPING is set, then this btree supports keys containing
 * overlapping intervals.  In such a tree, records are still sorted lowest to
 * highest and indexed by the smallest key value that refers to the record.
 * However, nodes are different: each pointer has two associated keys -- one
 * indexing the lowest key available in the block(s) below (the same behavior
 * as the key in a regular btree) and another indexing the highest key
 * available in the block(s) below.  Because records are /not/ sorted by the
 * highest key, all leaf block updates require us to compute the highest key
 * that matches any record in the leaf and to recursively update the high keys
 * in the nodes going further up in the tree, if necessary.  Nodes look like
 * this:
 *
 < ASCII >
 *		+--------+-----+-----+-----+-----+-----+-------+-------+-----+
 * Non-Leaf:	| header | lo1 | hi1 | lo2 | hi2 | ... | ptr 1 | ptr 2 | ... |
 *		+--------+-----+-----+-----+-----+-----+-------+-------+-----+
 < ASCII >
 *
 * To perform an interval query on an overlapped tree, perform the usual
 * depth-first search and use the low and high keys to decide if we can skip
 * that particular node.  If a leaf node is reached, return the records that
 * intersect the interval.  Note that an interval query may return numerous
 * entries.  For a non-overlapped tree, simply search for the record associated
 * with the lowest key and iterate forward until a non-matching record is
 * found.  Section 14.3 ("Interval Trees") of _Introduction to Algorithms_ by
 * Cormen, Leiserson, Rivest, and Stein (2nd or 3rd ed. only) discuss this in
 * more detail.
 *
 * Why do we care about overlapping intervals?  Let's say you have a bunch of
 * reverse mapping records on a reflink filesystem:
 *
 < ASCII >
 * 1: +- file A startblock B offset C length D -----------+
 * 2:      +- file E startblock F offset G length H --------------+
 * 3:      +- file I startblock F offset J length K --+
 * 4:                                                        +- file L... --+
 < ASCII >
 *
 * Now say we want to map block (B+D) into file A at offset (C+D).  Ideally,
 * we'd simply increment the length of record 1.  But how do we find the record
 * that ends at (B+D-1) (i.e. record 1)?  A LE lookup of (B+D-1) would return
 * record 3 because the keys are ordered first by startblock.  An interval
 * query would return records 1 and 2 because they both overlap (B+D-1), and
 * from that we can pick out record 1 as the appropriate left neighbor.
 *
 * In the non-overlapped case you can do a LE lookup and decrement the cursor
 * because a record's interval must end before the next record.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_859.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/xfs/libxfs/xfs_da_format.h#L247-L269

```c
/*
 * Data block structures.
 *
 * A pure data block looks like the following drawing on disk:
 *
 < ASCII >
 *    +-------------------------------------------------+
 *    | xfs_dir2_data_hdr_t                             |
 *    +-------------------------------------------------+
 *    | xfs_dir2_data_entry_t OR xfs_dir2_data_unused_t |
 *    | xfs_dir2_data_entry_t OR xfs_dir2_data_unused_t |
 *    | xfs_dir2_data_entry_t OR xfs_dir2_data_unused_t |
 *    | ...                                             |
 *    +-------------------------------------------------+
 *    | unused space                                    |
 *    +-------------------------------------------------+
 < ASCII >
 *
 * As all the entries are variable size structures the accessors below should
 * be used to iterate over them.
 *
 * In addition to the pure data blocks for the data and node formats,
 * most structures are also used for the combined data/freespace "block"
 * format below.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_86.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/mm/hugetlbpage.c#L21-L31

```c
/*
 * HugeTLB Support Matrix
 *
 < ASCII >
 * ---------------------------------------------------
 * | Page Size | CONT PTE |  PMD  | CONT PMD |  PUD  |
 * ---------------------------------------------------
 * |     4K    |   64K    |   2M  |    32M   |   1G  |
 * |    16K    |    2M    |  32M  |     1G   |       |
 * |    64K    |    2M    | 512M  |    16G   |       |
 * ---------------------------------------------------
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_860.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/xfs/libxfs/xfs_da_format.h#L371-L400

```c
/*
 * Leaf block structures.
 *
 * A pure leaf block looks like the following drawing on disk:
 *
 < ASCII >
 *    +---------------------------+
 *    | xfs_dir2_leaf_hdr_t       |
 *    +---------------------------+
 *    | xfs_dir2_leaf_entry_t     |
 *    | xfs_dir2_leaf_entry_t     |
 *    | xfs_dir2_leaf_entry_t     |
 *    | xfs_dir2_leaf_entry_t     |
 *    | ...                       |
 *    +---------------------------+
 *    | xfs_dir2_data_off_t       |
 *    | xfs_dir2_data_off_t       |
 *    | xfs_dir2_data_off_t       |
 *    | ...                       |
 *    +---------------------------+
 *    | xfs_dir2_leaf_tail_t      |
 *    +---------------------------+
 < ASCII >
 *
 * The xfs_dir2_data_off_t members (bests) and tail are at the end of the block
 * for single-leaf (magic = XFS_DIR2_LEAF1_MAGIC) blocks only, but not present
 * for directories with separate leaf nodes and free space blocks
 * (magic = XFS_DIR2_LEAFN_MAGIC).
 *
 * As all the entries are variable size structures the accessors below should
 * be used to iterate over them.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_861.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/xfs/libxfs/xfs_da_format.h#L503-L527

```c
/*
 * Single block format.
 *
 * The single block format looks like the following drawing on disk:
 *
 < ASCII >
 *    +-------------------------------------------------+
 *    | xfs_dir2_data_hdr_t                             |
 *    +-------------------------------------------------+
 *    | xfs_dir2_data_entry_t OR xfs_dir2_data_unused_t |
 *    | xfs_dir2_data_entry_t OR xfs_dir2_data_unused_t |
 *    | xfs_dir2_data_entry_t OR xfs_dir2_data_unused_t :
 *    | ...                                             |
 *    +-------------------------------------------------+
 *    | unused space                                    |
 *    +-------------------------------------------------+
 *    | ...                                             |
 *    | xfs_dir2_leaf_entry_t                           |
 *    | xfs_dir2_leaf_entry_t                           |
 *    +-------------------------------------------------+
 *    | xfs_dir2_block_tail_t                           |
 *    +-------------------------------------------------+
 < ASCII >
 *
 * As all the entries are variable size structures the accessors below should
 * be used to iterate over them.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_862.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/xfs/libxfs/xfs_defer.c#L32-L183

```c
/*
 * Deferred Operations in XFS
 *
 * Due to the way locking rules work in XFS, certain transactions (block
 * mapping and unmapping, typically) have permanent reservations so that
 * we can roll the transaction to adhere to AG locking order rules and
 * to unlock buffers between metadata updates.  Prior to rmap/reflink,
 * the mapping code had a mechanism to perform these deferrals for
 * extents that were going to be freed; this code makes that facility
 * more generic.
 *
 * When adding the reverse mapping and reflink features, it became
 * necessary to perform complex remapping multi-transactions to comply
 * with AG locking order rules, and to be able to spread a single
 * refcount update operation (an operation on an n-block extent can
 * update as many as n records!) among multiple transactions.  XFS can
 * roll a transaction to facilitate this, but using this facility
 * requires us to log "intent" items in case log recovery needs to
 * redo the operation, and to log "done" items to indicate that redo
 * is not necessary.
 *
 * Deferred work is tracked in xfs_defer_pending items.  Each pending
 * item tracks one type of deferred work.  Incoming work items (which
 * have not yet had an intent logged) are attached to a pending item
 * on the dop_intake list, where they wait for the caller to finish
 * the deferred operations.
 *
 * Finishing a set of deferred operations is an involved process.  To
 * start, we define "rolling a deferred-op transaction" as follows:
 *
 * > For each xfs_defer_pending item on the dop_intake list,
 *   - Sort the work items in AG order.  XFS locking
 *     order rules require us to lock buffers in AG order.
 *   - Create a log intent item for that type.
 *   - Attach it to the pending item.
 *   - Move the pending item from the dop_intake list to the
 *     dop_pending list.
 * > Roll the transaction.
 *
 * NOTE: To avoid exceeding the transaction reservation, we limit the
 * number of items that we attach to a given xfs_defer_pending.
 *
 * The actual finishing process looks like this:
 *
 * > For each xfs_defer_pending in the dop_pending list,
 *   - Roll the deferred-op transaction as above.
 *   - Create a log done item for that type, and attach it to the
 *     log intent item.
 *   - For each work item attached to the log intent item,
 *     * Perform the described action.
 *     * Attach the work item to the log done item.
 *     * If the result of doing the work was -EAGAIN, ->finish work
 *       wants a new transaction.  See the "Requesting a Fresh
 *       Transaction while Finishing Deferred Work" section below for
 *       details.
 *
 * The key here is that we must log an intent item for all pending
 * work items every time we roll the transaction, and that we must log
 * a done item as soon as the work is completed.  With this mechanism
 * we can perform complex remapping operations, chaining intent items
 * as needed.
 *
 * Requesting a Fresh Transaction while Finishing Deferred Work
 *
 * If ->finish_item decides that it needs a fresh transaction to
 * finish the work, it must ask its caller (xfs_defer_finish) for a
 * continuation.  The most likely cause of this circumstance are the
 * refcount adjust functions deciding that they've logged enough items
 * to be at risk of exceeding the transaction reservation.
 *
 * To get a fresh transaction, we want to log the existing log done
 * item to prevent the log intent item from replaying, immediately log
 * a new log intent item with the unfinished work items, roll the
 * transaction, and re-call ->finish_item wherever it left off.  The
 * log done item and the new log intent item must be in the same
 * transaction or atomicity cannot be guaranteed; defer_finish ensures
 * that this happens.
 *
 * This requires some coordination between ->finish_item and
 * defer_finish.  Upon deciding to request a new transaction,
 * ->finish_item should update the current work item to reflect the
 * unfinished work.  Next, it should reset the log done item's list
 * count to the number of items finished, and return -EAGAIN.
 * defer_finish sees the -EAGAIN, logs the new log intent item
 * with the remaining work items, and leaves the xfs_defer_pending
 * item at the head of the dop_work queue.  Then it rolls the
 * transaction and picks up processing where it left off.  It is
 * required that ->finish_item must be careful to leave enough
 * transaction reservation to fit the new log intent item.
 *
 * This is an example of remapping the extent (E, E+B) into file X at
 * offset A and dealing with the extent (C, C+B) already being mapped
 * there:
 < ASCII >
 * +-------------------------------------------------+
 * | Unmap file X startblock C offset A length B     | t0
 * | Intent to reduce refcount for extent (C, B)     |
 * | Intent to remove rmap (X, C, A, B)              |
 * | Intent to free extent (D, 1) (bmbt block)       |
 * | Intent to map (X, A, B) at startblock E         |
 * +-------------------------------------------------+
 * | Map file X startblock E offset A length B       | t1
 * | Done mapping (X, E, A, B)                       |
 * | Intent to increase refcount for extent (E, B)   |
 * | Intent to add rmap (X, E, A, B)                 |
 * +-------------------------------------------------+
 * | Reduce refcount for extent (C, B)               | t2
 * | Done reducing refcount for extent (C, 9)        |
 * | Intent to reduce refcount for extent (C+9, B-9) |
 * | (ran out of space after 9 refcount updates)     |
 * +-------------------------------------------------+
 * | Reduce refcount for extent (C+9, B+9)           | t3
 * | Done reducing refcount for extent (C+9, B-9)    |
 * | Increase refcount for extent (E, B)             |
 * | Done increasing refcount for extent (E, B)      |
 * | Intent to free extent (C, B)                    |
 * | Intent to free extent (F, 1) (refcountbt block) |
 * | Intent to remove rmap (F, 1, REFC)              |
 * +-------------------------------------------------+
 * | Remove rmap (X, C, A, B)                        | t4
 * | Done removing rmap (X, C, A, B)                 |
 * | Add rmap (X, E, A, B)                           |
 * | Done adding rmap (X, E, A, B)                   |
 * | Remove rmap (F, 1, REFC)                        |
 * | Done removing rmap (F, 1, REFC)                 |
 * +-------------------------------------------------+
 * | Free extent (C, B)                              | t5
 * | Done freeing extent (C, B)                      |
 * | Free extent (D, 1)                              |
 * | Done freeing extent (D, 1)                      |
 * | Free extent (F, 1)                              |
 * | Done freeing extent (F, 1)                      |
 * +-------------------------------------------------+
 < ASCII >
 *
 * If we should crash before t2 commits, log recovery replays
 * the following intent items:
 *
 * - Intent to reduce refcount for extent (C, B)
 * - Intent to remove rmap (X, C, A, B)
 * - Intent to free extent (D, 1) (bmbt block)
 * - Intent to increase refcount for extent (E, B)
 * - Intent to add rmap (X, E, A, B)
 *
 * In the process of recovering, it should also generate and take care
 * of these intent items:
 *
 * - Intent to free extent (C, B)
 * - Intent to free extent (F, 1) (refcountbt block)
 * - Intent to remove rmap (F, 1, REFC)
 *
 * Note that the continuation requested between t2 and t3 is likely to
 * reoccur.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_863.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/xfs/libxfs/xfs_iext_tree.c#L16-L27

```c
/*
 * In-core extent record layout:
 *
 < ASCII >
 * +-------+----------------------------+
 * | 00:53 | all 54 bits of startoff    |
 * | 54:63 | low 10 bits of startblock  |
 * +-------+----------------------------+
 * | 00:20 | all 21 bits of length      |
 * |    21 | unwritten extent bit       |
 * | 22:63 | high 42 bits of startblock |
 * +-------+----------------------------+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_864.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/xfs/libxfs/xfs_iext_tree.c#L95-L115

```c
/*
 * In-core extent btree block layout:
 *
 * There are two types of blocks in the btree: leaf and inner (non-leaf) blocks.
 *
 * The leaf blocks are made up by %KEYS_PER_NODE extent records, which each
 * contain the startoffset, blockcount, startblock and unwritten extent flag.
 * See above for the exact format, followed by pointers to the previous and next
 * leaf blocks (if there are any).
 *
 * The inner (non-leaf) blocks first contain KEYS_PER_NODE lookup keys, followed
 * by an equal number of pointers to the btree blocks at the next lower level.
 *
 < ASCII >
 *		+-------+-------+-------+-------+-------+----------+----------+
 * Leaf:	| rec 1 | rec 2 | rec 3 | rec 4 | rec N | prev-ptr | next-ptr |
 *		+-------+-------+-------+-------+-------+----------+----------+
 *
 *		+-------+-------+-------+-------+-------+-------+------+-------+
 * Inner:	| key 1 | key 2 | key 3 | key N | ptr 1 | ptr 2 | ptr3 | ptr N |
 *		+-------+-------+-------+-------+-------+-------+------+-------+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_865.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/xfs/libxfs/xfs_inode_fork.h#L35-L39

```c
/*
 * Punching out an extent from the middle of an existing extent can cause the
 * extent count to increase by 1.
 < ASCII >
 * i.e. | Old extent | Hole | Old extent |
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_866.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/fs/xfs/libxfs/xfs_refcount.c#L271-L346

```c
/*
 * Adjusting the Reference Count
 *
 * As stated elsewhere, the reference count btree (refcbt) stores
 * >1 reference counts for extents of physical blocks.  In this
 * operation, we're either raising or lowering the reference count of
 * some subrange stored in the tree:
 *
 < ASCII >
 *      <------ adjustment range ------>
 * ----+   +---+-----+ +--+--------+---------
 *  2  |   | 3 |  4  | |17|   55   |   10
 * ----+   +---+-----+ +--+--------+---------
 < ASCII >
 * X axis is physical blocks number;
 * reference counts are the numbers inside the rectangles
 *
 * The first thing we need to do is to ensure that there are no
 * refcount extents crossing either boundary of the range to be
 * adjusted.  For any extent that does cross a boundary, split it into
 * two extents so that we can increment the refcount of one of the
 * pieces later:
 *
 < ASCII >
 *      <------ adjustment range ------>
 * ----+   +---+-----+ +--+--------+----+----
 *  2  |   | 3 |  2  | |17|   55   | 10 | 10
 * ----+   +---+-----+ +--+--------+----+----
 < ASCII >
 *
 * For this next step, let's assume that all the physical blocks in
 * the adjustment range are mapped to a file and are therefore in use
 * at least once.  Therefore, we can infer that any gap in the
 * refcount tree within the adjustment range represents a physical
 * extent with refcount == 1:
 *
 < ASCII >
 *      <------ adjustment range ------>
 * ----+---+---+-----+-+--+--------+----+----
 *  2  |"1"| 3 |  2  |1|17|   55   | 10 | 10
 * ----+---+---+-----+-+--+--------+----+----
 *      ^
 < ASCII >
 *
 * For each extent that falls within the interval range, figure out
 * which extent is to the left or the right of that extent.  Now we
 * have a left, current, and right extent.  If the new reference count
 * of the center extent enables us to merge left, center, and right
 * into one record covering all three, do so.  If the center extent is
 * at the left end of the range, abuts the left extent, and its new
 * reference count matches the left extent's record, then merge them.
 * If the center extent is at the right end of the range, abuts the
 * right extent, and the reference counts match, merge those.  In the
 * example, we can left merge (assuming an increment operation):
 *
 < ASCII >
 *      <------ adjustment range ------>
 * --------+---+-----+-+--+--------+----+----
 *    2    | 3 |  2  |1|17|   55   | 10 | 10
 * --------+---+-----+-+--+--------+----+----
 *          ^
 < ASCII >
 *
 * For all other extents within the range, adjust the reference count
 * or delete it if the refcount falls below 2.  If we were
 * incrementing, the end result looks like this:
 *
 < ASCII >
 *      <------ adjustment range ------>
 * --------+---+-----+-+--+--------+----+----
 *    2    | 4 |  3  |2|18|   56   | 11 | 10
 * --------+---+-----+-+--+--------+----+----
 *
 * The result of a decrement operation looks as such:
 *
 *      <------ adjustment range ------>
 * ----+   +---+       +--+--------+----+----
 *  2  |   | 2 |       |16|   54   |  9 | 10
 * ----+   +---+       +--+--------+----+----
 *      DDDD    111111DD
 < ASCII >
 *
 * The blocks marked "D" are freed; the blocks marked "1" are only
 * referenced once and therefore the record is removed from the
 * refcount btree.
 */
```
## Visual type:
- #sequence


== ./linux/linux_867.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/acpi/actypes.h#L36-L82

```c
/*
 * Architecture-specific ACPICA Subsystem Data Types
 *
 * The goal of these types is to provide source code portability across
 * 16-bit, 32-bit, and 64-bit targets.
 *
 * 1) The following types are of fixed size for all targets (16/32/64):
 *
 < ASCII >
 * u8           Logical boolean
 *
 * u8           8-bit  (1 byte) unsigned value
 * u16          16-bit (2 byte) unsigned value
 * u32          32-bit (4 byte) unsigned value
 * u64          64-bit (8 byte) unsigned value
 *
 * s16          16-bit (2 byte) signed value
 * s32          32-bit (4 byte) signed value
 * s64          64-bit (8 byte) signed value
 < ASCII >
 *
 * COMPILER_DEPENDENT_UINT64/s64 - These types are defined in the
 * compiler-dependent header(s) and were introduced because there is no
 * common 64-bit integer type across the various compilation models, as
 * shown in the table below.
 *
 < ASCII >
 * Datatype  LP64 ILP64 LLP64 ILP32 LP32 16bit
 * char      8    8     8     8     8    8
 * short     16   16    16    16    16   16
 * _int32         32
 * int       32   64    32    32    16   16
 * long      64   64    32    32    32   32
 * long long            64    64
 * pointer   64   64    64    32    32   32
 < ASCII >
 *
 * Note: ILP64 and LP32 are currently not supported.
 *
 *
 * 2) These types represent the native word size of the target mode of the
 * processor, and may be 16-bit, 32-bit, or 64-bit as required. They are
 * usually used for memory allocation, efficient loop counters, and array
 * indexes. The types are similar to the size_t type in the C library and
 * are required because there is no C type that consistently represents the
 * native data width. acpi_size is needed because there is no guarantee
 * that a kernel-level C library is present.
 *
 < ASCII >
 * acpi_size        16/32/64-bit unsigned value
 * acpi_native_int  16/32/64-bit signed value
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_868.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/acpi/actypes.h#L730-L747

```c
/*
 * Event status - Per event
 * -------------
 * The encoding of acpi_event_status is illustrated below.
 * Note that a set bit (1) indicates the property is TRUE
 * (e.g. if bit 0 is set then the event is enabled).
 < ASCII >
 * +-------------+-+-+-+-+-+-+
 * |   Bits 31:6 |5|4|3|2|1|0|
 * +-------------+-+-+-+-+-+-+
 *          |     | | | | | |
 *          |     | | | | | +- Enabled?
 *          |     | | | | +--- Enabled for wake?
 *          |     | | | +----- Status bit set?
 *          |     | | +------- Enable bit set?
 *          |     | +--------- Has a handler?
 *          |     +----------- Masked?
 *          +----------------- <Reserved>
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_869.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/acpi/actypes.h#L765-L776

```c
/*
 * GPE info flags - Per GPE
 < ASCII >
 * +---+-+-+-+---+
 * |7:6|5|4|3|2:0|
 * +---+-+-+-+---+
 *   |  | | |  |
 *   |  | | |  +-- Type of dispatch:to method, handler, notify, or none
 *   |  | | +----- Interrupt type: edge or level triggered
 *   |  | +------- Is a Wake GPE
 *   |  +--------- Has been enabled automatically at init time
 *   +------------ <Reserved>
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_87.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/arm64/net/bpf_jit_comp.c#L222-L248

```c
/*
 * There are 3 types of AArch64 LDR/STR (immediate) instruction:
 * Post-index, Pre-index, Unsigned offset.
 *
 * For BPF ldr/str, the "unsigned offset" type is sufficient.
 *
 * "Unsigned offset" type LDR(immediate) format:
 *
 < ASCII >
 *    3                   2                   1                   0
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |x x|1 1 1 0 0 1 0 1|         imm12         |    Rn   |    Rt   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * scale
 < ASCII >
 *
 < ASCII >
 * "Unsigned offset" type STR(immediate) format:
 *    3                   2                   1                   0
 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |x x|1 1 1 0 0 1 0 0|         imm12         |    Rn   |    Rt   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * scale
 < ASCII >
 *
 * The offset is calculated from imm12 and scale in the following way:
 *
 * offset = (u64)imm12 << scale
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_870.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/crypto/gf128mul.h#L56-L132

```c
/* Comment by Rik:
 *
 * For some background on GF(2^128) see for example: 
 * http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/gcm/gcm-revised-spec.pdf 
 *
 * The elements of GF(2^128) := GF(2)[X]/(X^128-X^7-X^2-X^1-1) can
 * be mapped to computer memory in a variety of ways. Let's examine
 * three common cases.
 *
 * Take a look at the 16 binary octets below in memory order. The msb's
 * are left and the lsb's are right. char b[16] is an array and b[0] is
 * the first octet.
 *
 < ASCII >
 * 10000000 00000000 00000000 00000000 .... 00000000 00000000 00000000
 *   b[0]     b[1]     b[2]     b[3]          b[13]    b[14]    b[15]
 < ASCII >
 *
 * Every bit is a coefficient of some power of X. We can store the bits
 * in every byte in little-endian order and the bytes themselves also in
 * little endian order. I will call this lle (little-little-endian).
 * The above buffer represents the polynomial 1, and X^7+X^2+X^1+1 looks
 * like 11100001 00000000 .... 00000000 = { 0xE1, 0x00, }.
 * This format was originally implemented in gf128mul and is used
 * in GCM (Galois/Counter mode) and in ABL (Arbitrary Block Length).
 *
 * Another convention says: store the bits in bigendian order and the
 * bytes also. This is bbe (big-big-endian). Now the buffer above
 * represents X^127. X^7+X^2+X^1+1 looks like 00000000 .... 10000111,
 * b[15] = 0x87 and the rest is 0. LRW uses this convention and bbe
 * is partly implemented.
 *
 * Both of the above formats are easy to implement on big-endian
 * machines.
 *
 * XTS and EME (the latter of which is patent encumbered) use the ble
 * format (bits are stored in big endian order and the bytes in little
 * endian). The above buffer represents X^7 in this case and the
 * primitive polynomial is b[0] = 0x87.
 *
 * The common machine word-size is smaller than 128 bits, so to make
 * an efficient implementation we must split into machine word sizes.
 * This implementation uses 64-bit words for the moment. Machine
 * endianness comes into play. The lle format in relation to machine
 * endianness is discussed below by the original author of gf128mul Dr
 * Brian Gladman.
 *
 * Let's look at the bbe and ble format on a little endian machine.
 *
 < ASCII >
 * bbe on a little endian machine u32 x[4]:
 *
 *  MS            x[0]           LS  MS            x[1]		  LS
 *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
 *  103..96 111.104 119.112 127.120  71...64 79...72 87...80 95...88
 *
 *  MS            x[2]           LS  MS            x[3]		  LS
 *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
 *  39...32 47...40 55...48 63...56  07...00 15...08 23...16 31...24
 *
 * ble on a little endian machine
 *
 *  MS            x[0]           LS  MS            x[1]		  LS
 *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
 *  31...24 23...16 15...08 07...00  63...56 55...48 47...40 39...32
 *
 *  MS            x[2]           LS  MS            x[3]		  LS
 *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
 *  95...88 87...80 79...72 71...64  127.120 199.112 111.104 103..96
 < ASCII >
 *
 * Multiplications in GF(2^128) are mostly bit-shifts, so you see why
 * ble (and lbe also) are easier to implement on a little-endian
 * machine than on a big-endian machine. The converse holds for bbe
 * and lle.
 *
 * Note: to have good alignment, it seems to me that it is sufficient
 * to keep elements of GF(2^128) in type u64[2]. On 32-bit wordsize
 * machines this will automatically aligned to wordsize and on a 64-bit
 * machine also.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_871.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/drm/drm_atomic.h#L34-L71

```c
/**
 * struct drm_crtc_commit - track modeset commits on a CRTC
 *
 * This structure is used to track pending modeset changes and atomic commit on
 * a per-CRTC basis. Since updating the list should never block, this structure
 * is reference counted to allow waiters to safely wait on an event to complete,
 * without holding any locks.
 *
 * It has 3 different events in total to allow a fine-grained synchronization
 * between outstanding updates::
 < ASCII >
 *
 *	atomic commit thread			hardware
 *
 * 	write new state into hardware	---->	...
 * 	signal hw_done
 * 						switch to new state on next
 * 	...					v/hblank
 *
 *	wait for buffers to show up		...
 *
 *	...					send completion irq
 *						irq handler signals flip_done
 *	cleanup old buffers
 *
 * 	signal cleanup_done
 *
 * 	wait for flip_done		<----
 * 	clean up atomic state
 *
 < ASCII >
 * The important bit to know is that &cleanup_done is the terminal event, but the
 * ordering between &flip_done and &hw_done is entirely up to the specific driver
 * and modeset state change.
 *
 * For an implementation of how to use this look at
 * drm_atomic_helper_setup_commit() from the atomic helper library.
 *
 * See also drm_crtc_commit_wait().
 */
```
## Visual type:
- #sequence-diagram


== ./linux/linux_872.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/drm/drm_modes.h#L197-L251

```c
/**
 * struct drm_display_mode - DRM kernel-internal display mode structure
 * @hdisplay: horizontal display size
 * @hsync_start: horizontal sync start
 * @hsync_end: horizontal sync end
 * @htotal: horizontal total size
 * @hskew: horizontal skew?!
 * @vdisplay: vertical display size
 * @vsync_start: vertical sync start
 * @vsync_end: vertical sync end
 * @vtotal: vertical total size
 * @vscan: vertical scan?!
 * @crtc_hdisplay: hardware mode horizontal display size
 * @crtc_hblank_start: hardware mode horizontal blank start
 * @crtc_hblank_end: hardware mode horizontal blank end
 * @crtc_hsync_start: hardware mode horizontal sync start
 * @crtc_hsync_end: hardware mode horizontal sync end
 * @crtc_htotal: hardware mode horizontal total size
 * @crtc_hskew: hardware mode horizontal skew?!
 * @crtc_vdisplay: hardware mode vertical display size
 * @crtc_vblank_start: hardware mode vertical blank start
 * @crtc_vblank_end: hardware mode vertical blank end
 * @crtc_vsync_start: hardware mode vertical sync start
 * @crtc_vsync_end: hardware mode vertical sync end
 * @crtc_vtotal: hardware mode vertical total size
 *
 * This is the kernel API display mode information structure. For the
 * user-space version see struct drm_mode_modeinfo.
 *
 * The horizontal and vertical timings are defined per the following diagram.
 *
 < ASCII >
 * ::
 *
 *
 *               Active                 Front           Sync           Back
 *              Region                 Porch                          Porch
 *     <-----------------------><----------------><-------------><-------------->
 *       //////////////////////|
 *      ////////////////////// |
 *     //////////////////////  |..................               ................
 *                                                _______________
 *     <----- [hv]display ----->
 *     <------------- [hv]sync_start ------------>
 *     <--------------------- [hv]sync_end --------------------->
 *     <-------------------------------- [hv]total ----------------------------->*
 < ASCII >
 *
 * This structure contains two copies of timings. First are the plain timings,
 * which specify the logical mode, as it would be for a progressive 1:1 scanout
 * at the refresh rate userspace can observe through vblank timestamps. Then
 * there's the hardware timings, which are corrected for interlacing,
 * double-clocking and similar things. They are provided as a convenience, and
 * can be appropriately computed using drm_mode_set_crtcinfo().
 *
 * For printing you can use %DRM_MODE_FMT and DRM_MODE_ARG().
 */
```
## Visual type:
- #interval


== ./linux/linux_873.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/drm/bridge/dw_hdmi.h#L17-L76

```c
/**
 * DOC: Supported input formats and encodings
 *
 * Depending on the Hardware configuration of the Controller IP, it supports
 * a subset of the following input formats and encodings on its internal
 * 48bit bus.
 *
 < ASCII >
 * +----------------------+----------------------------------+------------------------------+
 * | Format Name          | Format Code                      | Encodings                    |
 * +----------------------+----------------------------------+------------------------------+
 * | RGB 4:4:4 8bit       | ``MEDIA_BUS_FMT_RGB888_1X24``    | ``V4L2_YCBCR_ENC_DEFAULT``   |
 * +----------------------+----------------------------------+------------------------------+
 * | RGB 4:4:4 10bits     | ``MEDIA_BUS_FMT_RGB101010_1X30`` | ``V4L2_YCBCR_ENC_DEFAULT``   |
 * +----------------------+----------------------------------+------------------------------+
 * | RGB 4:4:4 12bits     | ``MEDIA_BUS_FMT_RGB121212_1X36`` | ``V4L2_YCBCR_ENC_DEFAULT``   |
 * +----------------------+----------------------------------+------------------------------+
 * | RGB 4:4:4 16bits     | ``MEDIA_BUS_FMT_RGB161616_1X48`` | ``V4L2_YCBCR_ENC_DEFAULT``   |
 * +----------------------+----------------------------------+------------------------------+
 * | YCbCr 4:4:4 8bit     | ``MEDIA_BUS_FMT_YUV8_1X24``      | ``V4L2_YCBCR_ENC_601``       |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_XV601``  |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_XV709``  |
 * +----------------------+----------------------------------+------------------------------+
 * | YCbCr 4:4:4 10bits   | ``MEDIA_BUS_FMT_YUV10_1X30``     | ``V4L2_YCBCR_ENC_601``       |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_XV601``  |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_XV709``  |
 * +----------------------+----------------------------------+------------------------------+
 * | YCbCr 4:4:4 12bits   | ``MEDIA_BUS_FMT_YUV12_1X36``     | ``V4L2_YCBCR_ENC_601``       |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_XV601``  |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_XV709``  |
 * +----------------------+----------------------------------+------------------------------+
 * | YCbCr 4:4:4 16bits   | ``MEDIA_BUS_FMT_YUV16_1X48``     | ``V4L2_YCBCR_ENC_601``       |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_XV601``  |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_XV709``  |
 * +----------------------+----------------------------------+------------------------------+
 * | YCbCr 4:2:2 8bit     | ``MEDIA_BUS_FMT_UYVY8_1X16``     | ``V4L2_YCBCR_ENC_601``       |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
 * +----------------------+----------------------------------+------------------------------+
 * | YCbCr 4:2:2 10bits   | ``MEDIA_BUS_FMT_UYVY10_1X20``    | ``V4L2_YCBCR_ENC_601``       |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
 * +----------------------+----------------------------------+------------------------------+
 * | YCbCr 4:2:2 12bits   | ``MEDIA_BUS_FMT_UYVY12_1X24``    | ``V4L2_YCBCR_ENC_601``       |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
 * +----------------------+----------------------------------+------------------------------+
 * | YCbCr 4:2:0 8bit     | ``MEDIA_BUS_FMT_UYYVYY8_0_5X24`` | ``V4L2_YCBCR_ENC_601``       |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
 * +----------------------+----------------------------------+------------------------------+
 * | YCbCr 4:2:0 10bits   | ``MEDIA_BUS_FMT_UYYVYY10_0_5X30``| ``V4L2_YCBCR_ENC_601``       |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
 * +----------------------+----------------------------------+------------------------------+
 * | YCbCr 4:2:0 12bits   | ``MEDIA_BUS_FMT_UYYVYY12_0_5X36``| ``V4L2_YCBCR_ENC_601``       |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
 * +----------------------+----------------------------------+------------------------------+
 * | YCbCr 4:2:0 16bits   | ``MEDIA_BUS_FMT_UYYVYY16_0_5X48``| ``V4L2_YCBCR_ENC_601``       |
 * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
 * +----------------------+----------------------------------+------------------------------+
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_874.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/dt-bindings/pinctrl/pinctrl-starfive-jh7100.h#L14-L25

```c
/*
 < ASCII >
 * GPIOMUX bits:
 *  | 31 - 24 | 23 - 16 | 15 - 8 |     7    |     6    |  5 - 0  |
 *  |  dout   |  doen   |  din   | dout rev | doen rev | gpio nr |
 < ASCII >
 *
 * dout:     output signal
 * doen:     output enable signal
 * din:      optional input signal, 0xff = none
 * dout rev: output signal reverse bit
 * doen rev: output enable signal reverse bit
 * gpio nr:  gpio number, 0 - 63
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_875.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/console_struct.h#L62-L93

```c
/*
 * Example: vc_data of a console that was scrolled 3 lines down.
 *
 < ASCII >
 *                              Console buffer
 * vc_screenbuf ---------> +----------------------+-.
 *                         | initializing W       |  \
 *                         | initializing X       |   |
 *                         | initializing Y       |    > scroll-back area
 *                         | initializing Z       |   |
 *                         |                      |  /
 * vc_visible_origin ---> ^+----------------------+-:
 * (changes by scroll)    || Welcome to linux     |  \
 *                        ||                      |   |
 *           vc_rows --->< | login: root          |   |  visible on console
 *                        || password:            |    > (vc_screenbuf_size is
 * vc_origin -----------> ||                      |   |   vc_size_row * vc_rows)
 * (start when no scroll) || Last login: 12:28    |  /
 *                        v+----------------------+-:
 *                         | Have a lot of fun... |  \
 * vc_pos -----------------|--------v             |   > scroll-front area
 *                         | ~ # cat_             |  /
 * vc_scr_end -----------> +----------------------+-:
 * (vc_origin +            |                      |  \ EMPTY, to be filled by
 *  vc_screenbuf_size)     |                      |  / vc_video_erase_char
 *                         +----------------------+-'
 *                         <---- 2 * vc_cols ----->
 *                         <---- vc_size_row ----->
 < ASCII >
 *
 * Note that every character in the console buffer is accompanied with an
 * attribute in the buffer right after the character. This is not depicted
 * in the figure.
 */
```
## Visual type:
- #gui


== ./linux/linux_876.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/dmaengine.h#L87-L108

```c
/**
 * Interleaved Transfer Request
 * ----------------------------
 * A chunk is collection of contiguous bytes to be transferred.
 * The gap(in bytes) between two chunks is called inter-chunk-gap(ICG).
 * ICGs may or may not change between chunks.
 * A FRAME is the smallest series of contiguous {chunk,icg} pairs,
 *  that when repeated an integral number of times, specifies the transfer.
 * A transfer template is specification of a Frame, the number of times
 *  it is to be repeated and other per-transfer attributes.
 *
 * Practically, a client driver would have ready a template for each
 *  type of transfer it is going to need during its lifetime and
 *  set only 'src_start' and 'dst_start' before submitting the requests.
 *
 *
 < ASCII >
 *  |      Frame-1        |       Frame-2       | ~ |       Frame-'numf'  |
 *  |====....==.===...=...|====....==.===...=...| ~ |====....==.===...=...|
 < ASCII >
 *
 *    ==  Chunk size
 *    ... ICG
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_877.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/f2fs_fs.h#L550-L561

```c
/*
 < ASCII >
 * space utilization of regular dentry and inline dentry (w/o extra reservation)
 *		regular dentry		inline dentry (def)	inline dentry (min)
 * bitmap	1 * 27 = 27		1 * 23 = 23		1 * 1 = 1
 * reserved	1 * 3 = 3		1 * 7 = 7		1 * 1 = 1
 * dentry	11 * 214 = 2354		11 * 182 = 2002		11 * 2 = 22
 * filename	8 * 214 = 1712		8 * 182 = 1456		8 * 2 = 16
 * total	4096			3488			40
 < ASCII >
 *
 * Note: there are more reserved space in inline dentry than in regular
 * dentry, when converting inline dentry we should handle this carefully.
 */
```
## Visual type:
- #table


== ./linux/linux_878.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/fortify-string.h#L103-L134

```c
/**
 * strncpy - Copy a string to memory with non-guaranteed NUL padding
 *
 * @p: pointer to destination of copy
 * @q: pointer to NUL-terminated source string to copy
 * @size: bytes to write at @p
 *
 * If strlen(@q) >= @size, the copy of @q will stop after @size bytes,
 * and @p will NOT be NUL-terminated
 *
 * If strlen(@q) < @size, following the copy of @q, trailing NUL bytes
 * will be written to @p until @size total bytes have been written.
 *
 * Do not use this function. While FORTIFY_SOURCE tries to avoid
 * over-reads of @q, it cannot defend against writing unterminated
 * results to @p. Using strncpy() remains ambiguous and fragile.
 * Instead, please choose an alternative, so that the expectation
 * of @p's contents is unambiguous:
 *
 < ASCII >
 * +--------------------+--------------------+------------+
 * | **p** needs to be: | padded to **size** | not padded |
 * +====================+====================+============+
 * |     NUL-terminated | strscpy_pad()      | strscpy()  |
 * +--------------------+--------------------+------------+
 * | not NUL-terminated | strtomem_pad()     | strtomem() |
 * +--------------------+--------------------+------------+
 < ASCII >
 *
 * Note strscpy*()'s differing return values for detecting truncation,
 * and strtomem*()'s expectation that the destination is marked with
 * __nonstring when it is a character array.
 *
 */
```
## Visual type:
- #table


== ./linux/linux_879.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/fortify-string.h#L458-L488

```c
/*
 * To make sure the compiler can enforce protection against buffer overflows,
 * memcpy(), memmove(), and memset() must not be used beyond individual
 * struct members. If you need to copy across multiple members, please use
 * struct_group() to create a named mirror of an anonymous struct union.
 * (e.g. see struct sk_buff.) Read overflow checking is currently only
 * done when a write overflow is also present, or when building with W=1.
 *
 < ASCII >
 * Mitigation coverage matrix
 *					Bounds checking at:
 *					+-------+-------+-------+-------+
 *					| Compile time  |   Run time    |
 * memcpy() argument sizes:		| write | read  | write | read  |
 *        dest     source   length      +-------+-------+-------+-------+
 * memcpy(known,   known,   constant)	|   y   |   y   |  n/a  |  n/a  |
 * memcpy(known,   unknown, constant)	|   y   |   n   |  n/a  |   V   |
 * memcpy(known,   known,   dynamic)	|   n   |   n   |   B   |   B   |
 * memcpy(known,   unknown, dynamic)	|   n   |   n   |   B   |   V   |
 * memcpy(unknown, known,   constant)	|   n   |   y   |   V   |  n/a  |
 * memcpy(unknown, unknown, constant)	|   n   |   n   |   V   |   V   |
 * memcpy(unknown, known,   dynamic)	|   n   |   n   |   V   |   B   |
 * memcpy(unknown, unknown, dynamic)	|   n   |   n   |   V   |   V   |
 *					+-------+-------+-------+-------+
 < ASCII >
 *
 * y = perform deterministic compile-time bounds checking
 * n = cannot perform deterministic compile-time bounds checking
 * n/a = no run-time bounds checking needed since compile-time deterministic
 * B = can perform run-time bounds checking (currently unimplemented)
 * V = vulnerable to run-time overflow (will need refactoring to solve)
 *
 */
```
## Visual type:
- #table


== ./linux/linux_88.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/csky/abiv2/mcount.S#L9-L25

```c
/*
 * csky-gcc with -pg will put the following asm after prologue:
 *      push	r15
 *      jsri	_mcount
 *
 * stack layout after mcount_enter in _mcount():
 *
 < ASCII >
 * current sp => 0:+-------+
 *                 | a0-a3 | -> must save all argument regs
 *             +16:+-------+
 *                 | lr    | -> _mcount lr (instrumente function's pc)
 *             +20:+-------+
 *                 | fp=r8 | -> instrumented function fp
 *             +24:+-------+
 *                 | plr   | -> instrumented function lr (parent's pc)
 *                 +-------+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_880.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/hyperv.h#L34-L70

```c
/*
 * Types for GPADL, decides is how GPADL header is created.
 *
 * It doesn't make much difference between BUFFER and RING if PAGE_SIZE is the
 * same as HV_HYP_PAGE_SIZE.
 *
 * If PAGE_SIZE is bigger than HV_HYP_PAGE_SIZE, the headers of ring buffers
 * will be of PAGE_SIZE, however, only the first HV_HYP_PAGE will be put
 * into gpadl, therefore the number for HV_HYP_PAGE and the indexes of each
 * HV_HYP_PAGE will be different between different types of GPADL, for example
 * if PAGE_SIZE is 64K:
 *
 < ASCII >
 * BUFFER:
 *
 * gva:    |--       64k      --|--       64k      --| ... |
 * gpa:    | 4k | 4k | ... | 4k | 4k | 4k | ... | 4k |
 * index:  0    1    2     15   16   17   18 .. 31   32 ...
 *         |    |    ...   |    |    |   ...    |   ...
 *         v    V          V    V    V          V
 * gpadl:  | 4k | 4k | ... | 4k | 4k | 4k | ... | 4k | ... |
 * index:  0    1    2 ... 15   16   17   18 .. 31   32 ...
 *
 * RING:
 *
 *         | header  |           data           | header  |     data      |
 * gva:    |-- 64k --|--       64k      --| ... |-- 64k --|-- 64k --| ... |
 * gpa:    | 4k | .. | 4k | 4k | ... | 4k | ... | 4k | .. | 4k | .. | ... |
 * index:  0    1    16   17   18    31   ...   n   n+1  n+16 ...         2n
 *         |         /    /          /          |         /               /
 *         |        /    /          /           |        /               /
 *         |       /    /   ...    /    ...     |       /      ...      /
 *         |      /    /          /             |      /               /
 *         |     /    /          /              |     /               /
 *         V    V    V          V               V    V               v
 * gpadl:  | 4k | 4k |   ...    |    ...        | 4k | 4k |  ...     |
 * index:  0    1    2   ...    16   ...       n-15 n-14 n-13  ...  2n-30
 < ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_881.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/ieee80211.h#L25-L39

```c
/*
 * DS bit usage
 *
 * TA = transmitter address
 * RA = receiver address
 * DA = destination address
 * SA = source address
 *
 < ASCII >
 * ToDS    FromDS  A1(RA)  A2(TA)  A3      A4      Use
 * -----------------------------------------------------------------
 *  0       0       DA      SA      BSSID   -       IBSS/DLS
 *  0       1       DA      BSSID   SA      -       AP -> STA
 *  1       0       BSSID   SA      DA      -       AP <- STA
 *  1       1       RA      TA      DA      SA      unspecified (WDS)
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_882.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/iosys-map.h#L425-L486

```c
/**
 * iosys_map_rd_field - Read a member from a struct in the iosys_map
 *
 * @map__:		The iosys_map structure
 * @struct_offset__:	Offset from the beggining of the map, where the struct
 *			is located
 * @struct_type__:	The struct describing the layout of the mapping
 * @field__:		Member of the struct to read
 *
 * Read a value from iosys_map considering its layout is described by a C struct
 * starting at @struct_offset__. The field offset and size is calculated and its
 * value read. If the field access would incur in un-aligned access, then either
 * iosys_map_memcpy_from() needs to be used or the architecture must support it.
 * For example: suppose there is a @struct foo defined as below and the value
 * ``foo.field2.inner2`` needs to be read from the iosys_map:
 *
 * .. code-block:: c
 *
 *	struct foo {
 *		int field1;
 *		struct {
 *			int inner1;
 *			int inner2;
 *		} field2;
 *		int field3;
 *	} __packed;
 *
 * This is the expected memory layout of a buffer using iosys_map_rd_field():
 *
 < ASCII >
 * +------------------------------+--------------------------+
 * | Address                      | Content                  |
 * +==============================+==========================+
 * | buffer + 0000                | start of mmapped buffer  |
 * |                              | pointed by iosys_map     |
 * +------------------------------+--------------------------+
 * | ...                          | ...                      |
 * +------------------------------+--------------------------+
 * | buffer + ``struct_offset__`` | start of ``struct foo``  |
 * +------------------------------+--------------------------+
 * | ...                          | ...                      |
 * +------------------------------+--------------------------+
 * | buffer + wwww                | ``foo.field2.inner2``    |
 * +------------------------------+--------------------------+
 * | ...                          | ...                      |
 * +------------------------------+--------------------------+
 * | buffer + yyyy                | end of ``struct foo``    |
 * +------------------------------+--------------------------+
 * | ...                          | ...                      |
 * +------------------------------+--------------------------+
 * | buffer + zzzz                | end of mmaped buffer     |
 * +------------------------------+--------------------------+
 < ASCII >
 *
 * Values automatically calculated by this macro or not needed are denoted by
 * wwww, yyyy and zzzz. This is the code to read that value:
 *
 * .. code-block:: c
 *
 *	x = iosys_map_rd_field(&map, offset, struct foo, field2.inner2);
 *
 * Returns:
 * The value read from the mapping.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_883.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/ipmi_smi.h#L41-L87

```c
/*
 * SMI messages
 *
 * When communicating with an SMI, messages come in two formats:
 *
 * * Normal (to a BMC over a BMC interface)
 *
 * * IPMB (over a IPMB to another MC)
 *
 * When normal, commands are sent using the format defined by a
 * standard message over KCS (NetFn must be even):
 *
 < ASCII >
 *   +-----------+-----+------+
 *   | NetFn/LUN | Cmd | Data |
 *   +-----------+-----+------+
 < ASCII >
 *
 * And responses, similarly, with an completion code added (NetFn must
 * be odd):
 *
 < ASCII >
 *   +-----------+-----+------+------+
 *   | NetFn/LUN | Cmd | CC   | Data |
 *   +-----------+-----+------+------+
 < ASCII >
 *
 * With normal messages, only commands are sent and only responses are
 * received.
 *
 * In IPMB mode, we are acting as an IPMB device. Commands will be in
 * the following format (NetFn must be even):
 *
 < ASCII >
 *   +-------------+------+-------------+-----+------+
 *   | NetFn/rsLUN | Addr | rqSeq/rqLUN | Cmd | Data |
 *   +-------------+------+-------------+-----+------+
 < ASCII >
 *
 * Responses will using the following format:
 *
 < ASCII >
 *   +-------------+------+-------------+-----+------+------+
 *   | NetFn/rqLUN | Addr | rqSeq/rsLUN | Cmd | CC   | Data |
 *   +-------------+------+-------------+-----+------+------+
 < ASCII >
 *
 * This is similar to the format defined in the IPMB manual section
 * 2.11.1 with the checksums and the first address removed.  Also, the
 * address is always the remote address.
 *
 * IPMB messages can be commands and responses in both directions.
 * Received commands are handled as received commands from the message
 * queue.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_884.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/jump_label.h#L426-L480

```c
/*
 * Combine the right initial value (type) with the right branch order
 * to generate the desired result.
 *
 *
 < ASCII >
 * type\branch|	likely (1)	      |	unlikely (0)
 * -----------+-----------------------+------------------
 *            |                       |
 *  true (1)  |	   ...		      |	   ...
 *            |    NOP		      |	   JMP L
 *            |    <br-stmts>	      |	1: ...
 *            |	L: ...		      |
 *            |			      |
 *            |			      |	L: <br-stmts>
 *            |			      |	   jmp 1b
 *            |                       |
 * -----------+-----------------------+------------------
 *            |                       |
 *  false (0) |	   ...		      |	   ...
 *            |    JMP L	      |	   NOP
 *            |    <br-stmts>	      |	1: ...
 *            |	L: ...		      |
 *            |			      |
 *            |			      |	L: <br-stmts>
 *            |			      |	   jmp 1b
 *            |                       |
 * -----------+-----------------------+------------------
 < ASCII >
 *
 * The initial value is encoded in the LSB of static_key::entries,
 * type: 0 = false, 1 = true.
 *
 * The branch type is encoded in the LSB of jump_entry::key,
 * branch: 0 = unlikely, 1 = likely.
 *
 * This gives the following logic table:
 *
 < ASCII >
 *	enabled	type	branch	  instuction
 * -----------------------------+-----------
 *	0	0	0	| NOP
 *	0	0	1	| JMP
 *	0	1	0	| NOP
 *	0	1	1	| JMP
 *
 *	1	0	0	| JMP
 *	1	0	1	| NOP
 *	1	1	0	| JMP
 *	1	1	1	| NOP
 < ASCII >
 *
 * Which gives the following functions:
 *
 *   dynamic: instruction = enabled ^ branch
 *   static:  instruction = type ^ branch
 *
 * See jump_label_type() / jump_label_init_type().
 */
```
## Visual type:
- #table


== ./linux/linux_885.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/kernfs.h#L38-L61

```c
/*
 * NR_KERNFS_LOCK_BITS determines size (NR_KERNFS_LOCKS) of hash
 * table of locks.
 * Having a small hash table would impact scalability, since
 * more and more kernfs_node objects will end up using same lock
 * and having a very large hash table would waste memory.
 *
 * At the moment size of hash table of locks is being set based on
 * the number of CPUs as follows:
 *
 < ASCII >
 * NR_CPU      NR_KERNFS_LOCK_BITS      NR_KERNFS_LOCKS
 *   1                  1                       2
 *  2-3                 2                       4
 *  4-7                 4                       16
 *  8-15                6                       64
 *  16-31               8                       256
 *  32 and more         10                      1024
 < ASCII >
 *
 * The above relation between NR_CPU and number of locks is based
 * on some internal experimentation which involved booting qemu
 * with different values of smp, performing some sysfs operations
 * on all CPUs and observing how increase in number of locks impacts
 * completion time of these sysfs operations on each CPU.
 */
```
## Visual type:
- #table


== ./linux/linux_886.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/llist.h#L4-L49

```c
/*
 * Lock-less NULL terminated single linked list
 *
 * Cases where locking is not needed:
 * If there are multiple producers and multiple consumers, llist_add can be
 * used in producers and llist_del_all can be used in consumers simultaneously
 * without locking. Also a single consumer can use llist_del_first while
 * multiple producers simultaneously use llist_add, without any locking.
 *
 * Cases where locking is needed:
 * If we have multiple consumers with llist_del_first used in one consumer, and
 * llist_del_first or llist_del_all used in other consumers, then a lock is
 * needed.  This is because llist_del_first depends on list->first->next not
 * changing, but without lock protection, there's no way to be sure about that
 * if a preemption happens in the middle of the delete operation and on being
 * preempted back, the list->first is the same as before causing the cmpxchg in
 * llist_del_first to succeed. For example, while a llist_del_first operation
 * is in progress in one consumer, then a llist_del_first, llist_add,
 * llist_add (or llist_del_all, llist_add, llist_add) sequence in another
 * consumer may cause violations.
 *
 * This can be summarized as follows:
 *
 < ASCII >
 *           |   add    | del_first |  del_all
 * add       |    -     |     -     |     -
 * del_first |          |     L     |     L
 * del_all   |          |           |     -
 < ASCII >
 *
 * Where, a particular row's operation can happen concurrently with a column's
 * operation, with "-" being no lock needed, while "L" being lock is needed.
 *
 * The list entries deleted via llist_del_all can be traversed with
 * traversing function such as llist_for_each etc.  But the list
 * entries can not be traversed safely before deleted from the list.
 * The order of deleted entries is from the newest to the oldest added
 * one.  If you want to traverse from the oldest to the newest, you
 * must reverse the order by yourself before traversing.
 *
 * The basic atomic operation of this list is cmpxchg on long.  On
 * architectures that don't have NMI-safe cmpxchg implementation, the
 * list can NOT be used in NMI handlers.  So code that uses the list in
 * an NMI handler should depend on CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG.
 *
 * Copyright 2010,2011 Intel Corp.
 *   Author: Huang Ying <ying.huang@intel.com>
 */
```
## Visual type:
- #table


== ./linux/linux_887.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/ntb.h#L1566-L1596

```c
/**
 * ntb_peer_resource_idx() - get a resource index for a given peer idx
 * @ntb:	NTB device context.
 * @pidx:	Peer port index.
 *
 * When constructing a graph of peers, each remote peer must use a different
 * resource index (mw, doorbell, etc) to communicate with each other
 * peer.
 *
 * In a two peer system, this function should always return 0 such that
 * resource 0 points to the remote peer on both ports.
 *
 * In a 5 peer system, this function will return the following matrix
 *
 < ASCII >
 * pidx \ port    0    1    2    3    4
 * 0              0    0    1    2    3
 * 1              0    1    1    2    3
 * 2              0    1    2    2    3
 * 3              0    1    2    3    3
 < ASCII >
 *
 * For example, if this function is used to program peer's memory
 * windows, port 0 will program MW 0 on all it's peers to point to itself.
 * port 1 will program MW 0 in port 0 to point to itself and MW 1 on all
 * other ports. etc.
 *
 * For the legacy two host case, ntb_port_number() and ntb_peer_port_number()
 * both return zero and therefore this function will always return zero.
 * So MW 0 on each host would be programmed to point to the other host.
 *
 * Return: the resource index to use for that peer.
 */
```
## Visual type:
- #matrix


== ./linux/linux_888.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/page-flags-layout.h#L37-L51

```c
/*
 * page->flags layout:
 *
 * There are five possibilities for how page->flags get laid out.  The first
 * pair is for the normal case without sparsemem. The second pair is for
 * sparsemem when there is plenty of space for node and section information.
 * The last is when there is insufficient space in page->flags and a separate
 * lookup is necessary.
 *
 < ASCII >
 * No sparsemem or sparsemem vmemmap: |       NODE     | ZONE |             ... | FLAGS |
 *      " plus space for last_cpupid: |       NODE     | ZONE | LAST_CPUPID ... | FLAGS |
 * classic sparse with space for node:| SECTION | NODE | ZONE |             ... | FLAGS |
 *      " plus space for last_cpupid: | SECTION | NODE | ZONE | LAST_CPUPID ... | FLAGS |
 * classic sparse no space for node:  | SECTION |     ZONE    | ... | FLAGS |
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_889.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/page-flags.h#L85-L99

```c
/*
 * Don't use the pageflags directly.  Use the PageFoo macros.
 *
 * The page flags field is split into two parts, the main flags area
 * which extends from the low bits upwards, and the fields area which
 * extends from the high bits downwards.
 *
 < ASCII >
 *  | FIELD | ... | FLAGS |
 *  N-1           ^       0
 *               (NR_PAGEFLAGS)
 < ASCII >
 *
 * The fields area is reserved for fields mapping zone, node (for NUMA) and
 * SPARSEMEM section (for variants of SPARSEMEM that require section ids like
 * SPARSEMEM_EXTREME with !SPARSEMEM_VMEMMAP).
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_89.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/csky/include/asm/barrier.h#L12-L39

```c
/*
 * bar.brwarws: ordering barrier for all load/store instructions
 *              before/after
 *
 < ASCII >
 * |31|30 26|25 21|20 16|15  10|9   5|4           0|
 *  1  10000 00000 00000 100001	00001 0 bw br aw ar
 < ASCII >
 *
 * b: before
 * a: after
 * r: read
 * w: write
 *
 * Here are all combinations:
 *
 * bar.brw
 * bar.br
 * bar.bw
 * bar.arw
 * bar.ar
 * bar.aw
 * bar.brwarw
 * bar.brarw
 * bar.bwarw
 * bar.brwar
 * bar.brwaw
 * bar.brar
 * bar.bwaw
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_890.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/pim.h#L15-L32

```c
/* RFC7761, sec 4.9:
 *  Type
 *        Types for specific PIM messages.  PIM Types are:
 *
 < ASCII >
 *  Message Type                          Destination
 *  ---------------------------------------------------------------------
 *  0 = Hello                             Multicast to ALL-PIM-ROUTERS
 *  1 = Register                          Unicast to RP
 *  2 = Register-Stop                     Unicast to source of Register
 *                                        packet
 *  3 = Join/Prune                        Multicast to ALL-PIM-ROUTERS
 *  4 = Bootstrap                         Multicast to ALL-PIM-ROUTERS
 *  5 = Assert                            Multicast to ALL-PIM-ROUTERS
 *  6 = Graft (used in PIM-DM only)       Unicast to RPF'(S)
 *  7 = Graft-Ack (used in PIM-DM only)   Unicast to source of Graft
 *                                        packet
 *  8 = Candidate-RP-Advertisement        Unicast to Domain's BSR
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_891.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/pim.h#L47-L54

```c
/* RFC7761, sec 4.9:
 * The PIM header common to all PIM messages is:
 < ASCII >
 *   0                   1                   2                   3
 *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |PIM Ver| Type  |   Reserved    |           Checksum            |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_892.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/plist.h#L2-L72

```c
/*
 * Descending-priority-sorted double-linked list
 *
 * (C) 2002-2003 Intel Corp
 * Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>.
 *
 * 2001-2005 (c) MontaVista Software, Inc.
 * Daniel Walker <dwalker@mvista.com>
 *
 * (C) 2005 Thomas Gleixner <tglx@linutronix.de>
 *
 * Simplifications of the original code by
 * Oleg Nesterov <oleg@tv-sign.ru>
 *
 * Based on simple lists (include/linux/list.h).
 *
 * This is a priority-sorted list of nodes; each node has a
 * priority from INT_MIN (highest) to INT_MAX (lowest).
 *
 * Addition is O(K), removal is O(1), change of priority of a node is
 * O(K) and K is the number of RT priority levels used in the system.
 * (1 <= K <= 99)
 *
 * This list is really a list of lists:
 *
 *  - The tier 1 list is the prio_list, different priority nodes.
 *
 *  - The tier 2 list is the node_list, serialized nodes.
 *
 * Simple ASCII art explanation:
 *
 * pl:prio_list (only for plist_node)
 * nl:node_list
 < ASCII >
 *   HEAD|             NODE(S)
 *       |
 *       ||------------------------------------|
 *       ||->|pl|<->|pl|<--------------->|pl|<-|
 *       |   |10|   |21|   |21|   |21|   |40|   (prio)
 *       |   |  |   |  |   |  |   |  |   |  |
 *       |   |  |   |  |   |  |   |  |   |  |
 * |->|nl|<->|nl|<->|nl|<->|nl|<->|nl|<->|nl|<-|
 * |-------------------------------------------|
 < ASCII >
 *
 * The nodes on the prio_list list are sorted by priority to simplify
 * the insertion of new nodes. There are no nodes with duplicate
 * priorites on the list.
 *
 * The nodes on the node_list are ordered by priority and can contain
 * entries which have the same priority. Those entries are ordered
 * FIFO
 *
 * Addition means: look for the prio_list node in the prio_list
 * for the priority of the node and insert it before the node_list
 * entry of the next prio_list node. If it is the first node of
 * that priority, add it to the prio_list in the right position and
 * insert it into the serialized node_list list
 *
 * Removal means remove it from the node_list and remove it from
 * the prio_list if the node_list list_head is non empty. In case
 * of removal from the prio_list it must be checked whether other
 * entries of the same priority are on the list or not. If there
 * is another entry of the same priority then this entry has to
 * replace the removed entry on the prio_list. If the entry which
 * is removed is the only entry of this priority then a simple
 * remove from both list is sufficient.
 *
 * INT_MIN is the highest priority, 0 is the medium highest, INT_MAX
 * is lowest priority.
 *
 * No locking is done, up to the caller.
 */
```
## Visual type:
- #custom


== ./linux/linux_893.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/power_supply.h#L357-L432

```c
/**
 * struct power_supply_maintenance_charge_table - setting for maintenace charging
 * @charge_current_max_ua: maintenance charging current that is used to keep
 *   the charge of the battery full as current is consumed after full charging.
 *   The corresponding charge_voltage_max_uv is used as a safeguard: when we
 *   reach this voltage the maintenance charging current is turned off. It is
 *   turned back on if we fall below this voltage.
 * @charge_voltage_max_uv: maintenance charging voltage that is usually a bit
 *   lower than the constant_charge_voltage_max_uv. We can apply this settings
 *   charge_current_max_ua until we get back up to this voltage.
 * @safety_timer_minutes: maintenance charging safety timer, with an expiry
 *   time in minutes. We will only use maintenance charging in this setting
 *   for a certain amount of time, then we will first move to the next
 *   maintenance charge current and voltage pair in respective array and wait
 *   for the next safety timer timeout, or, if we reached the last maintencance
 *   charging setting, disable charging until we reach
 *   charge_restart_voltage_uv and restart ordinary CC/CV charging from there.
 *   These timers should be chosen to align with the typical discharge curve
 *   for the battery.
 *
 * Ordinary CC/CV charging will stop charging when the charge current goes
 * below charge_term_current_ua, and then restart it (if the device is still
 * plugged into the charger) at charge_restart_voltage_uv. This happens in most
 * consumer products because the power usage while connected to a charger is
 * not zero, and devices are not manufactured to draw power directly from the
 * charger: instead they will at all times dissipate the battery a little, like
 * the power used in standby mode. This will over time give a charge graph
 * such as this:
 *
 < ASCII >
 * Energy
 *  ^      ...        ...      ...      ...      ...      ...      ...
 *  |    .   .       .  .     .  .     .  .     .  .     .  .     .
 *  |  ..     .   ..     .  ..    .  ..    .  ..    .  ..    .  ..
 *  |.          ..        ..       ..       ..       ..       ..
 *  +-------------------------------------------------------------------> t
 < ASCII >
 *
 * Practically this means that the Li-ions are wandering back and forth in the
 * battery and this causes degeneration of the battery anode and cathode.
 * To prolong the life of the battery, maintenance charging is applied after
 * reaching charge_term_current_ua to hold up the charge in the battery while
 * consuming power, thus lowering the wear on the battery:
 *
 < ASCII >
 * Energy
 *  ^      .......................................
 *  |    .                                        ......................
 *  |  ..
 *  |.
 *  +-------------------------------------------------------------------> t
 < ASCII >
 *
 * Maintenance charging uses the voltages from this table: a table of settings
 * is traversed using a slightly lower current and voltage than what is used for
 * CC/CV charging. The maintenance charging will for safety reasons not go on
 * indefinately: we lower the current and voltage with successive maintenance
 * settings, then disable charging completely after we reach the last one,
 * and after that we do not restart charging until we reach
 * charge_restart_voltage_uv (see struct power_supply_battery_info) and restart
 * ordinary CC/CV charging from there.
 *
 * As an example, a Samsung EB425161LA Lithium-Ion battery is CC/CV charged
 * at 900mA to 4340mV, then maintenance charged at 600mA and 4150mV for up to
 * 60 hours, then maintenance charged at 600mA and 4100mV for up to 200 hours.
 * After this the charge cycle is restarted waiting for
 * charge_restart_voltage_uv.
 *
 * For most mobile electronics this type of maintenance charging is enough for
 * the user to disconnect the device and make use of it before both maintenance
 * charging cycles are complete, if the current and voltage has been chosen
 * appropriately. These need to be determined from battery discharge curves
 * and expected standby current.
 *
 * If the voltage anyway drops to charge_restart_voltage_uv during maintenance
 * charging, ordinary CC/CV charging is restarted. This can happen if the
 * device is e.g. actively used during charging, so more current is drawn than
 * the expected stand-by current. Also overvoltage protection will be applied
 * as usual.
 */
```
## Visual type:
- #plot


== ./linux/linux_894.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/power_supply.h#L441-L726

```c
/**
 * struct power_supply_battery_info - information about batteries
 * @technology: from the POWER_SUPPLY_TECHNOLOGY_* enum
 * @energy_full_design_uwh: energy content when fully charged in microwatt
 *   hours
 * @charge_full_design_uah: charge content when fully charged in microampere
 *   hours
 * @voltage_min_design_uv: minimum voltage across the poles when the battery
 *   is at minimum voltage level in microvolts. If the voltage drops below this
 *   level the battery will need precharging when using CC/CV charging.
 * @voltage_max_design_uv: voltage across the poles when the battery is fully
 *   charged in microvolts. This is the "nominal voltage" i.e. the voltage
 *   printed on the label of the battery.
 * @tricklecharge_current_ua: the tricklecharge current used when trickle
 *   charging the battery in microamperes. This is the charging phase when the
 *   battery is completely empty and we need to carefully trickle in some
 *   charge until we reach the precharging voltage.
 * @precharge_current_ua: current to use in the precharge phase in microamperes,
 *   the precharge rate is limited by limiting the current to this value.
 * @precharge_voltage_max_uv: the maximum voltage allowed when precharging in
 *   microvolts. When we pass this voltage we will nominally switch over to the
 *   CC (constant current) charging phase defined by constant_charge_current_ua
 *   and constant_charge_voltage_max_uv.
 * @charge_term_current_ua: when the current in the CV (constant voltage)
 *   charging phase drops below this value in microamperes the charging will
 *   terminate completely and not restart until the voltage over the battery
 *   poles reach charge_restart_voltage_uv unless we use maintenance charging.
 * @charge_restart_voltage_uv: when the battery has been fully charged by
 *   CC/CV charging and charging has been disabled, and the voltage subsequently
 *   drops below this value in microvolts, the charging will be restarted
 *   (typically using CV charging).
 * @overvoltage_limit_uv: If the voltage exceeds the nominal voltage
 *   voltage_max_design_uv and we reach this voltage level, all charging must
 *   stop and emergency procedures take place, such as shutting down the system
 *   in some cases.
 * @constant_charge_current_max_ua: current in microamperes to use in the CC
 *   (constant current) charging phase. The charging rate is limited
 *   by this current. This is the main charging phase and as the current is
 *   constant into the battery the voltage slowly ascends to
 *   constant_charge_voltage_max_uv.
 * @constant_charge_voltage_max_uv: voltage in microvolts signifying the end of
 *   the CC (constant current) charging phase and the beginning of the CV
 *   (constant voltage) charging phase.
 * @maintenance_charge: an array of maintenance charging settings to be used
 *   after the main CC/CV charging phase is complete.
 * @maintenance_charge_size: the number of maintenance charging settings in
 *   maintenance_charge.
 * @alert_low_temp_charge_current_ua: The charging current to use if the battery
 *   enters low alert temperature, i.e. if the internal temperature is between
 *   temp_alert_min and temp_min. No matter the charging phase, this
 *   and alert_high_temp_charge_voltage_uv will be applied.
 * @alert_low_temp_charge_voltage_uv: Same as alert_low_temp_charge_current_ua,
 *   but for the charging voltage.
 * @alert_high_temp_charge_current_ua: The charging current to use if the
 *   battery enters high alert temperature, i.e. if the internal temperature is
 *   between temp_alert_max and temp_max. No matter the charging phase, this
 *   and alert_high_temp_charge_voltage_uv will be applied, usually lowering
 *   the charging current as an evasive manouver.
 * @alert_high_temp_charge_voltage_uv: Same as
 *   alert_high_temp_charge_current_ua, but for the charging voltage.
 * @factory_internal_resistance_uohm: the internal resistance of the battery
 *   at fabrication time, expressed in microohms. This resistance will vary
 *   depending on the lifetime and charge of the battery, so this is just a
 *   nominal ballpark figure. This internal resistance is given for the state
 *   when the battery is discharging.
 * @factory_internal_resistance_charging_uohm: the internal resistance of the
 *   battery at fabrication time while charging, expressed in microohms.
 *   The charging process will affect the internal resistance of the battery
 *   so this value provides a better resistance under these circumstances.
 *   This resistance will vary depending on the lifetime and charge of the
 *   battery, so this is just a nominal ballpark figure.
 * @ocv_temp: array indicating the open circuit voltage (OCV) capacity
 *   temperature indices. This is an array of temperatures in degrees Celsius
 *   indicating which capacity table to use for a certain temperature, since
 *   the capacity for reasons of chemistry will be different at different
 *   temperatures. Determining capacity is a multivariate problem and the
 *   temperature is the first variable we determine.
 * @temp_ambient_alert_min: the battery will go outside of operating conditions
 *   when the ambient temperature goes below this temperature in degrees
 *   Celsius.
 * @temp_ambient_alert_max: the battery will go outside of operating conditions
 *   when the ambient temperature goes above this temperature in degrees
 *   Celsius.
 * @temp_alert_min: the battery should issue an alert if the internal
 *   temperature goes below this temperature in degrees Celsius.
 * @temp_alert_max: the battery should issue an alert if the internal
 *   temperature goes above this temperature in degrees Celsius.
 * @temp_min: the battery will go outside of operating conditions when
 *   the internal temperature goes below this temperature in degrees Celsius.
 *   Normally this means the system should shut down.
 * @temp_max: the battery will go outside of operating conditions when
 *   the internal temperature goes above this temperature in degrees Celsius.
 *   Normally this means the system should shut down.
 * @ocv_table: for each entry in ocv_temp there is a corresponding entry in
 *   ocv_table and a size for each entry in ocv_table_size. These arrays
 *   determine the capacity in percent in relation to the voltage in microvolts
 *   at the indexed temperature.
 * @ocv_table_size: for each entry in ocv_temp this array is giving the size of
 *   each entry in the array of capacity arrays in ocv_table.
 * @resist_table: this is a table that correlates a battery temperature to the
 *   expected internal resistance at this temperature. The resistance is given
 *   as a percentage of factory_internal_resistance_uohm. Knowing the
 *   resistance of the battery is usually necessary for calculating the open
 *   circuit voltage (OCV) that is then used with the ocv_table to calculate
 *   the capacity of the battery. The resist_table must be ordered descending
 *   by temperature: highest temperature with lowest resistance first, lowest
 *   temperature with highest resistance last.
 * @resist_table_size: the number of items in the resist_table.
 * @vbat2ri_discharging: this is a table that correlates Battery voltage (VBAT)
 *   to internal resistance (Ri). The resistance is given in microohm for the
 *   corresponding voltage in microvolts. The internal resistance is used to
 *   determine the open circuit voltage so that we can determine the capacity
 *   of the battery. These voltages to resistance tables apply when the battery
 *   is discharging. The table must be ordered descending by voltage: highest
 *   voltage first.
 * @vbat2ri_discharging_size: the number of items in the vbat2ri_discharging
 *   table.
 * @vbat2ri_charging: same function as vbat2ri_discharging but for the state
 *   when the battery is charging. Being under charge changes the battery's
 *   internal resistance characteristics so a separate table is needed.*
 *   The table must be ordered descending by voltage: highest voltage first.
 * @vbat2ri_charging_size: the number of items in the vbat2ri_charging
 *   table.
 * @bti_resistance_ohm: The Battery Type Indicator (BIT) nominal resistance
 *   in ohms for this battery, if an identification resistor is mounted
 *   between a third battery terminal and ground. This scheme is used by a lot
 *   of mobile device batteries.
 * @bti_resistance_tolerance: The tolerance in percent of the BTI resistance,
 *   for example 10 for +/- 10%, if the bti_resistance is set to 7000 and the
 *   tolerance is 10% we will detect a proper battery if the BTI resistance
 *   is between 6300 and 7700 Ohm.
 *
 * This is the recommended struct to manage static battery parameters,
 * populated by power_supply_get_battery_info(). Most platform drivers should
 * use these for consistency.
 *
 * Its field names must correspond to elements in enum power_supply_property.
 * The default field value is -EINVAL or NULL for pointers.
 *
 * CC/CV CHARGING:
 *
 * The charging parameters here assume a CC/CV charging scheme. This method
 * is most common with Lithium Ion batteries (other methods are possible) and
 * looks as follows:
 *
 < ASCII >
 * ^ Battery voltage
 * |                                               --- overvoltage_limit_uv
 * |
 * |                    ...................................................
 * |                 .. constant_charge_voltage_max_uv
 * |              ..
 * |             .
 * |            .
 * |           .
 * |          .
 * |         .
 * |     .. precharge_voltage_max_uv
 * |  ..
 * |. (trickle charging)
 * +------------------------------------------------------------------> time
 *
 * ^ Current into the battery
 * |
 * |      ............. constant_charge_current_max_ua
 * |      .            .
 * |      .             .
 * |      .              .
 * |      .               .
 * |      .                ..
 * |      .                  ....
 * |      .                       .....
 * |    ... precharge_current_ua       .......  charge_term_current_ua
 * |    .                                    .
 * |    .                                    .
 * |.... tricklecharge_current_ua            .
 * |                                         .
 * +-----------------------------------------------------------------> time
 < ASCII >
 *
 * These diagrams are synchronized on time and the voltage and current
 * follow each other.
 *
 * With CC/CV charging commence over time like this for an empty battery:
 *
 * 1. When the battery is completely empty it may need to be charged with
 *    an especially small current so that electrons just "trickle in",
 *    this is the tricklecharge_current_ua.
 *
 * 2. Next a small initial pre-charge current (precharge_current_ua)
 *    is applied if the voltage is below precharge_voltage_max_uv until we
 *    reach precharge_voltage_max_uv. CAUTION: in some texts this is referred
 *    to as "trickle charging" but the use in the Linux kernel is different
 *    see below!
 *
 * 3. Then the main charging current is applied, which is called the constant
 *    current (CC) phase. A current regulator is set up to allow
 *    constant_charge_current_max_ua of current to flow into the battery.
 *    The chemical reaction in the battery will make the voltage go up as
 *    charge goes into the battery. This current is applied until we reach
 *    the constant_charge_voltage_max_uv voltage.
 *
 * 4. At this voltage we switch over to the constant voltage (CV) phase. This
 *    means we allow current to go into the battery, but we keep the voltage
 *    fixed. This current will continue to charge the battery while keeping
 *    the voltage the same. A chemical reaction in the battery goes on
 *    storing energy without affecting the voltage. Over time the current
 *    will slowly drop and when we reach charge_term_current_ua we will
 *    end the constant voltage phase.
 *
 * After this the battery is fully charged, and if we do not support maintenance
 * charging, the charging will not restart until power dissipation makes the
 * voltage fall so that we reach charge_restart_voltage_uv and at this point
 * we restart charging at the appropriate phase, usually this will be inside
 * the CV phase.
 *
 * If we support maintenance charging the voltage is however kept high after
 * the CV phase with a very low current. This is meant to let the same charge
 * go in for usage while the charger is still connected, mainly for
 * dissipation for the power consuming entity while connected to the
 * charger.
 *
 * All charging MUST terminate if the overvoltage_limit_uv is ever reached.
 * Overcharging Lithium Ion cells can be DANGEROUS and lead to fire or
 * explosions.
 *
 * DETERMINING BATTERY CAPACITY:
 *
 * Several members of the struct deal with trying to determine the remaining
 * capacity in the battery, usually as a percentage of charge. In practice
 * many chargers uses a so-called fuel gauge or coloumb counter that measure
 * how much charge goes into the battery and how much goes out (+/- leak
 * consumption). This does not help if we do not know how much capacity the
 * battery has to begin with, such as when it is first used or was taken out
 * and charged in a separate charger. Therefore many capacity algorithms use
 * the open circuit voltage with a look-up table to determine the rough
 * capacity of the battery. The open circuit voltage can be conceptualized
 * with an ideal voltage source (V) in series with an internal resistance (Ri)
 * like this:
 *
 < ASCII >
 *      +-------> IBAT >----------------+
 *      |                    ^          |
 *     [ ] Ri                |          |
 *      |                    | VBAT     |
 *      o <----------        |          |
 *     +|           ^        |         [ ] Rload
 *    .---.         |        |          |
 *    | V |         | OCV    |          |
 *    '---'         |        |          |
 *      |           |        |          |
 *  GND +-------------------------------+
 < ASCII >
 *
 * If we disconnect the load (here simplified as a fixed resistance Rload)
 * and measure VBAT with a infinite impedance voltage meter we will get
 * VBAT = OCV and this assumption is sometimes made even under load, assuming
 * Rload is insignificant. However this will be of dubious quality because the
 * load is rarely that small and Ri is strongly nonlinear depending on
 * temperature and how much capacity is left in the battery due to the
 * chemistry involved.
 *
 * In many practical applications we cannot just disconnect the battery from
 * the load, so instead we often try to measure the instantaneous IBAT (the
 * current out from the battery), estimate the Ri and thus calculate the
 * voltage drop over Ri and compensate like this:
 *
 *   OCV = VBAT - (IBAT * Ri)
 *
 * The tables vbat2ri_discharging and vbat2ri_charging are used to determine
 * (by interpolation) the Ri from the VBAT under load. These curves are highly
 * nonlinear and may need many datapoints but can be found in datasheets for
 * some batteries. This gives the compensated open circuit voltage (OCV) for
 * the battery even under load. Using this method will also compensate for
 * temperature changes in the environment: this will also make the internal
 * resistance change, and it will affect the VBAT under load, so correlating
 * VBAT to Ri takes both remaining capacity and temperature into consideration.
 *
 * Alternatively a manufacturer can specify how the capacity of the battery
 * is dependent on the battery temperature which is the main factor affecting
 * Ri. As we know all checmical reactions are faster when it is warm and slower
 * when it is cold. You can put in 1500mAh and only get 800mAh out before the
 * voltage drops too low for example. This effect is also highly nonlinear and
 * the purpose of the table resist_table: this will take a temperature and
 * tell us how big percentage of Ri the specified temperature correlates to.
 * Usually we have 100% of the factory_internal_resistance_uohm at 25 degrees
 * Celsius.
 *
 * The power supply class itself doesn't use this struct as of now.
 */
```
## Visual type:
- #plot


== ./linux/linux_895.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/rculist.h#L537-L546

```c
/**
 * hlists_swap_heads_rcu - swap the lists the hlist heads point to
 * @left:  The hlist head on the left
 * @right: The hlist head on the right
 *
 < ASCII >
 * The lists start out as [@left  ][node1 ... ] and
 *                        [@right ][node2 ... ]
 * The lists end up as    [@left  ][node2 ... ]
 *                        [@right ][node1 ... ]
 < ASCII >
 */
```
## Visual type:
- #sequence


== ./linux/linux_896.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/rcu_segcblist.h#L67-L117

```c
/*
 *                     ==NOCB Offloading state machine==
 *
 *
 < ASCII >
 *  ----------------------------------------------------------------------------
 *  |                              SEGCBLIST_RCU_CORE                          |
 *  |                                                                          |
 *  |  Callbacks processed by rcu_core() from softirqs or local                |
 *  |  rcuc kthread, without holding nocb_lock.                                |
 *  ----------------------------------------------------------------------------
 *                                         |
 *                                         v
 *  ----------------------------------------------------------------------------
 *  |       SEGCBLIST_RCU_CORE | SEGCBLIST_LOCKING | SEGCBLIST_OFFLOADED       |
 *  |                                                                          |
 *  | Callbacks processed by rcu_core() from softirqs or local                 |
 *  | rcuc kthread, while holding nocb_lock. Waking up CB and GP kthreads,     |
 *  | allowing nocb_timer to be armed.                                         |
 *  ----------------------------------------------------------------------------
 *                                         |
 *                                         v
 *                        -----------------------------------
 *                        |                                 |
 *                        v                                 v
 *  ---------------------------------------  ----------------------------------|
 *  |        SEGCBLIST_RCU_CORE   |       |  |     SEGCBLIST_RCU_CORE   |      |
 *  |        SEGCBLIST_LOCKING    |       |  |     SEGCBLIST_LOCKING    |      |
 *  |        SEGCBLIST_OFFLOADED  |       |  |     SEGCBLIST_OFFLOADED  |      |
 *  |        SEGCBLIST_KTHREAD_CB         |  |     SEGCBLIST_KTHREAD_GP        |
 *  |                                     |  |                                 |
 *  |                                     |  |                                 |
 *  | CB kthread woke up and              |  | GP kthread woke up and          |
 *  | acknowledged SEGCBLIST_OFFLOADED.   |  | acknowledged SEGCBLIST_OFFLOADED|
 *  | Processes callbacks concurrently    |  |                                 |
 *  | with rcu_core(), holding            |  |                                 |
 *  | nocb_lock.                          |  |                                 |
 *  ---------------------------------------  -----------------------------------
 *                        |                                 |
 *                        -----------------------------------
 *                                         |
 *                                         v
 *  |--------------------------------------------------------------------------|
 *  |                           SEGCBLIST_LOCKING    |                         |
 *  |                           SEGCBLIST_OFFLOADED  |                         |
 *  |                           SEGCBLIST_KTHREAD_GP |                         |
 *  |                           SEGCBLIST_KTHREAD_CB                           |
 *  |                                                                          |
 *  |   Kthreads handle callbacks holding nocb_lock, local rcu_core() stops    |
 *  |   handling callbacks. Enable bypass queueing.                            |
 *  ----------------------------------------------------------------------------
 < ASCII >
 */
```
## Visual type:
- #state-machine


== ./linux/linux_897.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/sched.h#L1883-L1888

```c
/**
 * task_nice - return the nice value of a given task.
 * @p: the task in question.
 *
 * Return: The nice value [ -20 ... 0 ... 19 ].
 */
```
## Visual type:



== ./linux/linux_898.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/sctp.h#L127-L147

```c
/*
 *  Set the T bit
 *
 < ASCII >
 *      0                   1                   2                   3
 *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |   Type = 14   |Reserved     |T|      Length = 4               |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 *
 * Chunk Flags: 8 bits
 *
 *   Reserved:  7 bits
 *     Set to 0 on transmit and ignored on receipt.
 *
 *   T bit:  1 bit
 *     The T bit is set to 0 if the sender had a TCB that it destroyed. If
 *     the sender did NOT have a TCB it should set this bit to 1.
 *
 * Note: Special rules apply to this chunk for verification, please
 * see Section 8.5.1 for details.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_899.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/sctp.h#L454-L472

```c
/* RFC 2960 3.3.10 - Operation Error
 *
 * Cause Code: 16 bits (unsigned integer)
 *
 < ASCII >
 *     Defines the type of error conditions being reported.
 *    Cause Code
 *     Value           Cause Code
 *     ---------      ----------------
 *      1              Invalid Stream Identifier
 *      2              Missing Mandatory Parameter
 *      3              Stale Cookie Error
 *      4              Out of Resource
 *      5              Unresolvable Address
 *      6              Unrecognized Chunk Type
 *      7              Invalid Mandatory Parameter
 *      8              Unrecognized Parameters
 *      9              No User Data
 *     10              Cookie Received While Shutting Down
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_9.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/alpha/kernel/core_apecs.c#L50-L90

```c
/*
 * Given a bus, device, and function number, compute resulting
 * configuration space address and setup the APECS_HAXR2 register
 * accordingly.  It is therefore not safe to have concurrent
 * invocations to configuration space access routines, but there
 * really shouldn't be any need for this.
 *
 < ASCII >
 * Type 0:
 *
 *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 
 *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | | | | | | | | | | | | | | | | | | | | | | | |F|F|F|R|R|R|R|R|R|0|0|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *	31:11	Device select bit.
 * 	10:8	Function number
 * 	 7:2	Register number
 *
 * Type 1:
 *
 *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 
 *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | | | | | | | | | | |B|B|B|B|B|B|B|B|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|1|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *	31:24	reserved
 *	23:16	bus number (8 bits = 128 possible buses)
 *	15:11	Device number (5 bits)
 *	10:8	function number
 *	 7:2	register number
 < ASCII >
 *  
 * Notes:
 *	The function number selects which function of a multi-function device 
 *	(e.g., SCSI and Ethernet).
 * 
 *	The register selects a DWORD (32 bit) register offset.  Hence it
 *	doesn't get shifted by 2 bits as we want to "drop" the bottom two
 *	bits.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_90.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/ia64/include/asm/mca_asm.h#L215-L237

```c
/*
 * The MCA and INIT stacks in struct ia64_mca_cpu look like normal kernel
 * stacks, except that the SAL/OS state and a switch_stack are stored near the
 * top of the MCA/INIT stack.  To support concurrent entry to MCA or INIT, as
 * well as MCA over INIT, each event needs its own SAL/OS state.  All entries
 * are 16 byte aligned.
 *
 < ASCII >
 *      +---------------------------+
 *      |          pt_regs          |
 *      +---------------------------+
 *      |        switch_stack       |
 *      +---------------------------+
 *      |        SAL/OS state       |
 *      +---------------------------+
 *      |    16 byte scratch area   |
 *      +---------------------------+ <-------- SP at start of C MCA handler
 *      |           .....           |
 *      +---------------------------+
 *      | RBS for MCA/INIT handler  |
 *      +---------------------------+
 *      | struct task for MCA/INIT  |
 *      +---------------------------+ <-------- Bottom of MCA/INIT stack
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_900.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/sctp.h#L553-L598

```c
/* PR-SCTP
 * 3.2 Forward Cumulative TSN Chunk Definition (FORWARD TSN)
 *
 < ASCII >
 * Forward Cumulative TSN chunk has the following format:
 *
 *        0                   1                   2                   3
 *        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      |   Type = 192  |  Flags = 0x00 |        Length = Variable      |
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      |                      New Cumulative TSN                       |
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      |         Stream-1              |       Stream Sequence-1       |
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      \                                                               /
 *      /                                                               \
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      |         Stream-N              |       Stream Sequence-N       |
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 *
 *      Chunk Flags:
 *
 *        Set to all zeros on transmit and ignored on receipt.
 *
 *      New Cumulative TSN: 32 bit u_int
 *
 *       This indicates the new cumulative TSN to the data receiver. Upon
 *       the reception of this value, the data receiver MUST consider
 *       any missing TSNs earlier than or equal to this value as received
 *       and stop reporting them as gaps in any subsequent SACKs.
 *
 *      Stream-N: 16 bit u_int
 *
 *       This field holds a stream number that was skipped by this
 *       FWD-TSN.
 *
 *      Stream Sequence-N: 16 bit u_int
 *       This field holds the sequence number associated with the stream
 *       that was skipped. The stream sequence field holds the largest stream
 *       sequence number in this stream being skipped.  The receiver of
 *       the FWD-TSN's can use the Stream-N and Stream Sequence-N fields
 *       to enable delivery of any stranded TSN's that remain on the stream
 *       re-ordering queues. This field MUST NOT report TSN's corresponding
 *       to DATA chunk that are marked as unordered. For ordered DATA
 *       chunks this field MUST be filled in.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_901.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/sctp.h#L678-L726

```c
/* AUTH
 * Section 4.1  Authentication Chunk (AUTH)
 *
 *   This chunk is used to hold the result of the HMAC calculation.
 *
 < ASCII >
 *    0                   1                   2                   3
 *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *   | Type = 0x0F   |   Flags=0     |             Length            |
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *   |     Shared Key Identifier     |   HMAC Identifier             |
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *   |                                                               |
 *   \                             HMAC                              /
 *   /                                                               \
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 *
 *   Type: 1 byte (unsigned integer)
 *   	This value MUST be set to 0x0F for  all AUTH-chunks.
 *
 *   Flags: 1 byte (unsigned integer)
 *	Set to zero on transmit and ignored on receipt.
 *
 *   Length: 2 bytes (unsigned integer)
 *   	This value holds the length of the HMAC in bytes plus 8.
 *
 *  Shared Key Identifier: 2 bytes (unsigned integer)
 *	This value describes which endpoint pair shared key is used.
 *
 *   HMAC Identifier: 2 bytes (unsigned integer)
 *   	This value describes which message digest is being used.  Table 2
 *	shows the currently defined values.
 *
 *    The following Table 2 shows the currently defined values for HMAC
 *       identifiers.
 *
 < ASCII >
 *	 +-----------------+--------------------------+
 *	 | HMAC Identifier | Message Digest Algorithm |
 *	 +-----------------+--------------------------+
 *	 | 0               | Reserved                 |
 *	 | 1               | SHA-1 defined in [8]     |
 *	 | 2               | Reserved                 |
 *	 | 3               | SHA-256 defined in [8]   |
 *	 +-----------------+--------------------------+
 < ASCII >
 *
 *
 *   HMAC: n bytes (unsigned integer) This hold the result of the HMAC
 *      calculation.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_902.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/sctp.h#L805-L817

```c
/* UDP Encapsulation
 * draft-tuexen-tsvwg-sctp-udp-encaps-cons-03.html#section-4-4
 *
 *   The error cause indicating an "Restart of an Association with
 *   New Encapsulation Port"
 *
 < ASCII >
 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |        Cause Code = 14        |       Cause Length = 8        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |   Current Encapsulation Port  |     New Encapsulation Port    |
 * +-------------------------------+-------------------------------+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_903.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/serial_core.h#L34-L372

```c
/**
 * struct uart_ops -- interface between serial_core and the driver
 *
 * This structure describes all the operations that can be done on the
 * physical hardware.
 *
 * @tx_empty: ``unsigned int ()(struct uart_port *port)``
 *
 *	This function tests whether the transmitter fifo and shifter for the
 *	@port is empty. If it is empty, this function should return
 *	%TIOCSER_TEMT, otherwise return 0. If the port does not support this
 *	operation, then it should return %TIOCSER_TEMT.
 *
 *	Locking: none.
 *	Interrupts: caller dependent.
 *	This call must not sleep
 *
 * @set_mctrl: ``void ()(struct uart_port *port, unsigned int mctrl)``
 *
 *	This function sets the modem control lines for @port to the state
 *	described by @mctrl. The relevant bits of @mctrl are:
 *
 *		- %TIOCM_RTS	RTS signal.
 *		- %TIOCM_DTR	DTR signal.
 *		- %TIOCM_OUT1	OUT1 signal.
 *		- %TIOCM_OUT2	OUT2 signal.
 *		- %TIOCM_LOOP	Set the port into loopback mode.
 *
 *	If the appropriate bit is set, the signal should be driven
 *	active.  If the bit is clear, the signal should be driven
 *	inactive.
 *
 *	Locking: @port->lock taken.
 *	Interrupts: locally disabled.
 *	This call must not sleep
 *
 * @get_mctrl: ``unsigned int ()(struct uart_port *port)``
 *
 *	Returns the current state of modem control inputs of @port. The state
 *	of the outputs should not be returned, since the core keeps track of
 *	their state. The state information should include:
 *
 *		- %TIOCM_CAR	state of DCD signal
 *		- %TIOCM_CTS	state of CTS signal
 *		- %TIOCM_DSR	state of DSR signal
 *		- %TIOCM_RI	state of RI signal
 *
 *	The bit is set if the signal is currently driven active.  If
 *	the port does not support CTS, DCD or DSR, the driver should
 *	indicate that the signal is permanently active. If RI is
 *	not available, the signal should not be indicated as active.
 *
 *	Locking: @port->lock taken.
 *	Interrupts: locally disabled.
 *	This call must not sleep
 *
 * @stop_tx: ``void ()(struct uart_port *port)``
 *
 *	Stop transmitting characters. This might be due to the CTS line
 *	becoming inactive or the tty layer indicating we want to stop
 *	transmission due to an %XOFF character.
 *
 *	The driver should stop transmitting characters as soon as possible.
 *
 *	Locking: @port->lock taken.
 *	Interrupts: locally disabled.
 *	This call must not sleep
 *
 * @start_tx: ``void ()(struct uart_port *port)``
 *
 *	Start transmitting characters.
 *
 *	Locking: @port->lock taken.
 *	Interrupts: locally disabled.
 *	This call must not sleep
 *
 * @throttle: ``void ()(struct uart_port *port)``
 *
 *	Notify the serial driver that input buffers for the line discipline are
 *	close to full, and it should somehow signal that no more characters
 *	should be sent to the serial port.
 *	This will be called only if hardware assisted flow control is enabled.
 *
 *	Locking: serialized with @unthrottle() and termios modification by the
 *	tty layer.
 *
 * @unthrottle: ``void ()(struct uart_port *port)``
 *
 *	Notify the serial driver that characters can now be sent to the serial
 *	port without fear of overrunning the input buffers of the line
 *	disciplines.
 *
 *	This will be called only if hardware assisted flow control is enabled.
 *
 *	Locking: serialized with @throttle() and termios modification by the
 *	tty layer.
 *
 * @send_xchar: ``void ()(struct uart_port *port, char ch)``
 *
 *	Transmit a high priority character, even if the port is stopped. This
 *	is used to implement XON/XOFF flow control and tcflow(). If the serial
 *	driver does not implement this function, the tty core will append the
 *	character to the circular buffer and then call start_tx() / stop_tx()
 *	to flush the data out.
 *
 *	Do not transmit if @ch == '\0' (%__DISABLED_CHAR).
 *
 *	Locking: none.
 *	Interrupts: caller dependent.
 *
 * @start_rx: ``void ()(struct uart_port *port)``
 *
 *	Start receiving characters.
 *
 *	Locking: @port->lock taken.
 *	Interrupts: locally disabled.
 *	This call must not sleep
 *
 * @stop_rx: ``void ()(struct uart_port *port)``
 *
 *	Stop receiving characters; the @port is in the process of being closed.
 *
 *	Locking: @port->lock taken.
 *	Interrupts: locally disabled.
 *	This call must not sleep
 *
 * @enable_ms: ``void ()(struct uart_port *port)``
 *
 *	Enable the modem status interrupts.
 *
 *	This method may be called multiple times. Modem status interrupts
 *	should be disabled when the @shutdown() method is called.
 *
 *	Locking: @port->lock taken.
 *	Interrupts: locally disabled.
 *	This call must not sleep
 *
 * @break_ctl: ``void ()(struct uart_port *port, int ctl)``
 *
 *	Control the transmission of a break signal. If @ctl is nonzero, the
 *	break signal should be transmitted. The signal should be terminated
 *	when another call is made with a zero @ctl.
 *
 *	Locking: caller holds tty_port->mutex
 *
 * @startup: ``int ()(struct uart_port *port)``
 *
 *	Grab any interrupt resources and initialise any low level driver state.
 *	Enable the port for reception. It should not activate RTS nor DTR;
 *	this will be done via a separate call to @set_mctrl().
 *
 *	This method will only be called when the port is initially opened.
 *
 *	Locking: port_sem taken.
 *	Interrupts: globally disabled.
 *
 * @shutdown: ``void ()(struct uart_port *port)``
 *
 *	Disable the @port, disable any break condition that may be in effect,
 *	and free any interrupt resources. It should not disable RTS nor DTR;
 *	this will have already been done via a separate call to @set_mctrl().
 *
 *	Drivers must not access @port->state once this call has completed.
 *
 *	This method will only be called when there are no more users of this
 *	@port.
 *
 *	Locking: port_sem taken.
 *	Interrupts: caller dependent.
 *
 * @flush_buffer: ``void ()(struct uart_port *port)``
 *
 *	Flush any write buffers, reset any DMA state and stop any ongoing DMA
 *	transfers.
 *
 *	This will be called whenever the @port->state->xmit circular buffer is
 *	cleared.
 *
 *	Locking: @port->lock taken.
 *	Interrupts: locally disabled.
 *	This call must not sleep
 *
 * @set_termios: ``void ()(struct uart_port *port, struct ktermios *new,
 *			struct ktermios *old)``
 *
 *	Change the @port parameters, including word length, parity, stop bits.
 *	Update @port->read_status_mask and @port->ignore_status_mask to
 *	indicate the types of events we are interested in receiving. Relevant
 *	ktermios::c_cflag bits are:
 *
 *	- %CSIZE - word size
 *	- %CSTOPB - 2 stop bits
 *	- %PARENB - parity enable
 *	- %PARODD - odd parity (when %PARENB is in force)
 *	- %ADDRB - address bit (changed through uart_port::rs485_config()).
 *	- %CREAD - enable reception of characters (if not set, still receive
 *	  characters from the port, but throw them away).
 *	- %CRTSCTS - if set, enable CTS status change reporting.
 *	- %CLOCAL - if not set, enable modem status change reporting.
 *
 *	Relevant ktermios::c_iflag bits are:
 *
 *	- %INPCK - enable frame and parity error events to be passed to the TTY
 *	  layer.
 *	- %BRKINT / %PARMRK - both of these enable break events to be passed to
 *	  the TTY layer.
 *	- %IGNPAR - ignore parity and framing errors.
 *	- %IGNBRK - ignore break errors. If %IGNPAR is also set, ignore overrun
 *	  errors as well.
 *
 *	The interaction of the ktermios::c_iflag bits is as follows (parity
 *	error given as an example):
 < ASCII >
 *
 *	============ ======= ======= =========================================
 *	Parity error INPCK   IGNPAR
 *	============ ======= ======= =========================================
 *	n/a	     0	     n/a     character received, marked as %TTY_NORMAL
 *	None	     1	     n/a     character received, marked as %TTY_NORMAL
 *	Yes	     1	     0	     character received, marked as %TTY_PARITY
 *	Yes	     1	     1	     character discarded
 *	============ ======= ======= =========================================
 < ASCII >
 *
 *	Other flags may be used (eg, xon/xoff characters) if your hardware
 *	supports hardware "soft" flow control.
 *
 *	Locking: caller holds tty_port->mutex
 *	Interrupts: caller dependent.
 *	This call must not sleep
 *
 * @set_ldisc: ``void ()(struct uart_port *port, struct ktermios *termios)``
 *
 *	Notifier for discipline change. See
 *	Documentation/driver-api/tty/tty_ldisc.rst.
 *
 *	Locking: caller holds tty_port->mutex
 *
 * @pm: ``void ()(struct uart_port *port, unsigned int state,
 *		 unsigned int oldstate)``
 *
 *	Perform any power management related activities on the specified @port.
 *	@state indicates the new state (defined by enum uart_pm_state),
 *	@oldstate indicates the previous state.
 *
 *	This function should not be used to grab any resources.
 *
 *	This will be called when the @port is initially opened and finally
 *	closed, except when the @port is also the system console. This will
 *	occur even if %CONFIG_PM is not set.
 *
 *	Locking: none.
 *	Interrupts: caller dependent.
 *
 * @type: ``const char *()(struct uart_port *port)``
 *
 *	Return a pointer to a string constant describing the specified @port,
 *	or return %NULL, in which case the string 'unknown' is substituted.
 *
 *	Locking: none.
 *	Interrupts: caller dependent.
 *
 * @release_port: ``void ()(struct uart_port *port)``
 *
 *	Release any memory and IO region resources currently in use by the
 *	@port.
 *
 *	Locking: none.
 *	Interrupts: caller dependent.
 *
 * @request_port: ``int ()(struct uart_port *port)``
 *
 *	Request any memory and IO region resources required by the port. If any
 *	fail, no resources should be registered when this function returns, and
 *	it should return -%EBUSY on failure.
 *
 *	Locking: none.
 *	Interrupts: caller dependent.
 *
 * @config_port: ``void ()(struct uart_port *port, int type)``
 *
 *	Perform any autoconfiguration steps required for the @port. @type
 *	contains a bit mask of the required configuration. %UART_CONFIG_TYPE
 *	indicates that the port requires detection and identification.
 *	@port->type should be set to the type found, or %PORT_UNKNOWN if no
 *	port was detected.
 *
 *	%UART_CONFIG_IRQ indicates autoconfiguration of the interrupt signal,
 *	which should be probed using standard kernel autoprobing techniques.
 *	This is not necessary on platforms where ports have interrupts
 *	internally hard wired (eg, system on a chip implementations).
 *
 *	Locking: none.
 *	Interrupts: caller dependent.
 *
 * @verify_port: ``int ()(struct uart_port *port,
 *			struct serial_struct *serinfo)``
 *
 *	Verify the new serial port information contained within @serinfo is
 *	suitable for this port type.
 *
 *	Locking: none.
 *	Interrupts: caller dependent.
 *
 * @ioctl: ``int ()(struct uart_port *port, unsigned int cmd,
 *		unsigned long arg)``
 *
 *	Perform any port specific IOCTLs. IOCTL commands must be defined using
 *	the standard numbering system found in <asm/ioctl.h>.
 *
 *	Locking: none.
 *	Interrupts: caller dependent.
 *
 * @poll_init: ``int ()(struct uart_port *port)``
 *
 *	Called by kgdb to perform the minimal hardware initialization needed to
 *	support @poll_put_char() and @poll_get_char(). Unlike @startup(), this
 *	should not request interrupts.
 *
 *	Locking: %tty_mutex and tty_port->mutex taken.
 *	Interrupts: n/a.
 *
 * @poll_put_char: ``void ()(struct uart_port *port, unsigned char ch)``
 *
 *	Called by kgdb to write a single character @ch directly to the serial
 *	@port. It can and should block until there is space in the TX FIFO.
 *
 *	Locking: none.
 *	Interrupts: caller dependent.
 *	This call must not sleep
 *
 * @poll_get_char: ``int ()(struct uart_port *port)``
 *
 *	Called by kgdb to read a single character directly from the serial
 *	port. If data is available, it should be returned; otherwise the
 *	function should return %NO_POLL_CHAR immediately.
 *
 *	Locking: none.
 *	Interrupts: caller dependent.
 *	This call must not sleep
 */
```
## Visual type:
- #table


== ./linux/linux_904.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/signal.h#L329-L401

```c
/*
 * In POSIX a signal is sent either to a specific thread (Linux task)
 * or to the process as a whole (Linux thread group).  How the signal
 * is sent determines whether it's to one thread or the whole group,
 * which determines which signal mask(s) are involved in blocking it
 * from being delivered until later.  When the signal is delivered,
 * either it's caught or ignored by a user handler or it has a default
 * effect that applies to the whole thread group (POSIX process).
 *
 * The possible effects an unblocked signal set to SIG_DFL can have are:
 *   ignore	- Nothing Happens
 *   terminate	- kill the process, i.e. all threads in the group,
 * 		  similar to exit_group.  The group leader (only) reports
 *		  WIFSIGNALED status to its parent.
 *   coredump	- write a core dump file describing all threads using
 *		  the same mm and then kill all those threads
 *   stop 	- stop all the threads in the group, i.e. TASK_STOPPED state
 *
 * SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.
 * Other signals when not blocked and set to SIG_DFL behaves as follows.
 * The job control signals also have other special effects.
 *
 < ASCII >
 *	+--------------------+------------------+
 *	|  POSIX signal      |  default action  |
 *	+--------------------+------------------+
 *	|  SIGHUP            |  terminate	|
 *	|  SIGINT            |	terminate	|
 *	|  SIGQUIT           |	coredump 	|
 *	|  SIGILL            |	coredump 	|
 *	|  SIGTRAP           |	coredump 	|
 *	|  SIGABRT/SIGIOT    |	coredump 	|
 *	|  SIGBUS            |	coredump 	|
 *	|  SIGFPE            |	coredump 	|
 *	|  SIGKILL           |	terminate(+)	|
 *	|  SIGUSR1           |	terminate	|
 *	|  SIGSEGV           |	coredump 	|
 *	|  SIGUSR2           |	terminate	|
 *	|  SIGPIPE           |	terminate	|
 *	|  SIGALRM           |	terminate	|
 *	|  SIGTERM           |	terminate	|
 *	|  SIGCHLD           |	ignore   	|
 *	|  SIGCONT           |	ignore(*)	|
 *	|  SIGSTOP           |	stop(*)(+)  	|
 *	|  SIGTSTP           |	stop(*)  	|
 *	|  SIGTTIN           |	stop(*)  	|
 *	|  SIGTTOU           |	stop(*)  	|
 *	|  SIGURG            |	ignore   	|
 *	|  SIGXCPU           |	coredump 	|
 *	|  SIGXFSZ           |	coredump 	|
 *	|  SIGVTALRM         |	terminate	|
 *	|  SIGPROF           |	terminate	|
 *	|  SIGPOLL/SIGIO     |	terminate	|
 *	|  SIGSYS/SIGUNUSED  |	coredump 	|
 *	|  SIGSTKFLT         |	terminate	|
 *	|  SIGWINCH          |	ignore   	|
 *	|  SIGPWR            |	terminate	|
 *	|  SIGRTMIN-SIGRTMAX |	terminate       |
 *	+--------------------+------------------+
 *	|  non-POSIX signal  |  default action  |
 *	+--------------------+------------------+
 *	|  SIGEMT            |  coredump	|
 *	+--------------------+------------------+
 < ASCII >
 *
 * (+) For SIGKILL and SIGSTOP the action is "always", not just "default".
 * (*) Special job control effects:
 * When SIGCONT is sent, it resumes the process (all threads in the group)
 * from TASK_STOPPED state and also clears any pending/queued stop signals
 * (any of those marked with "stop(*)").  This happens regardless of blocking,
 * catching, or ignoring SIGCONT.  When any stop signal is sent, it clears
 * any pending/queued SIGCONT signals; this happens regardless of blocking,
 * catching, or ignored the stop signal, though (except for SIGSTOP) the
 * default action of stopping the process may happen later or never.
 */
```
## Visual type:
- #table


== ./linux/linux_905.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/skbuff.h#L688-L726

```c
/**
 * DOC: Basic sk_buff geometry
 *
 * struct sk_buff itself is a metadata structure and does not hold any packet
 * data. All the data is held in associated buffers.
 *
 * &sk_buff.head points to the main "head" buffer. The head buffer is divided
 * into two parts:
 *
 *  - data buffer, containing headers and sometimes payload;
 *    this is the part of the skb operated on by the common helpers
 *    such as skb_put() or skb_pull();
 *  - shared info (struct skb_shared_info) which holds an array of pointers
 *    to read-only data in the (page, offset, length) format.
 *
 * Optionally &skb_shared_info.frag_list may point to another skb.
 *
 < ASCII >
 * Basic diagram may look like this::
 *
 *                                  ---------------
 *                                 | sk_buff       |
 *                                  ---------------
 *     ,---------------------------  + head
 *    /          ,-----------------  + data
 *   /          /      ,-----------  + tail
 *  |          |      |            , + end
 *  |          |      |           |
 *  v          v      v           v
 *   -----------------------------------------------
 *  | headroom | data |  tailroom | skb_shared_info |
 *   -----------------------------------------------
 *                                 + [page frag]
 *                                 + [page frag]
 *                                 + [page frag]
 *                                 + [page frag]       ---------
 *                                 + frag_list    --> | sk_buff |
 *                                                     ---------
 < ASCII >
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_906.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/swapops.h#L44-L61

```c
/**
 * Migration swap entry specific bitfield definitions.  Layout:
 *
 < ASCII >
 *   |----------+--------------------|
 *   | swp_type | swp_offset         |
 *   |----------+--------+-+-+-------|
 *   |          | resv   |D|A|  PFN  |
 *   |----------+--------+-+-+-------|
 < ASCII >
 *
 * @SWP_MIG_YOUNG_BIT: Whether the page used to have young bit set (bit A)
 * @SWP_MIG_DIRTY_BIT: Whether the page used to have dirty bit set (bit D)
 *
 * Note: A/D bits will be stored in migration entries iff there're enough
 * free bits in arch specific swp offset.  By default we'll ignore A/D bits
 * when migrating a page.  Please refer to migration_entry_supports_ad()
 * for more information.  If there're more bits besides PFN and A/D bits,
 * they should be reserved and always be zeros.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_907.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/can/bittiming.h#L20-L77

```c
/*
 * struct can_tdc - CAN FD Transmission Delay Compensation parameters
 *
 * At high bit rates, the propagation delay from the TX pin to the RX
 * pin of the transceiver causes measurement errors: the sample point
 * on the RX pin might occur on the previous bit.
 *
 * To solve this issue, ISO 11898-1 introduces in section 11.3.3
 * "Transmitter delay compensation" a SSP (Secondary Sample Point)
 * equal to the distance from the start of the bit time on the TX pin
 * to the actual measurement on the RX pin.
 *
 * This structure contains the parameters to calculate that SSP.
 *
 < ASCII >
 * -+----------- one bit ----------+-- TX pin
 *  |<--- Sample Point --->|
 *
 *                         --+----------- one bit ----------+-- RX pin
 *  |<-------- TDCV -------->|
 *                           |<------- TDCO ------->|
 *  |<----------- Secondary Sample Point ---------->|
 < ASCII >
 *
 * To increase precision, contrary to the other bittiming parameters
 * which are measured in time quanta, the TDC parameters are measured
 * in clock periods (also referred as "minimum time quantum" in ISO
 * 11898-1).
 *
 * @tdcv: Transmitter Delay Compensation Value. The time needed for
 *	the signal to propagate, i.e. the distance, in clock periods,
 *	from the start of the bit on the TX pin to when it is received
 *	on the RX pin. @tdcv depends on the controller modes:
 *
 *	  CAN_CTRLMODE_TDC_AUTO is set: The transceiver dynamically
 *	  measures @tdcv for each transmitted CAN FD frame and the
 *	  value provided here should be ignored.
 *
 *	  CAN_CTRLMODE_TDC_MANUAL is set: use the fixed provided @tdcv
 *	  value.
 *
 *	N.B. CAN_CTRLMODE_TDC_AUTO and CAN_CTRLMODE_TDC_MANUAL are
 *	mutually exclusive. Only one can be set at a time. If both
 *	CAN_TDC_CTRLMODE_AUTO and CAN_TDC_CTRLMODE_MANUAL are unset,
 *	TDC is disabled and all the values of this structure should be
 *	ignored.
 *
 * @tdco: Transmitter Delay Compensation Offset. Offset value, in
 *	clock periods, defining the distance between the start of the
 *	bit reception on the RX pin of the transceiver and the SSP
 *	position such that SSP = @tdcv + @tdco.
 *
 * @tdcf: Transmitter Delay Compensation Filter window. Defines the
 *	minimum value for the SSP position in clock periods. If the
 *	SSP position is less than @tdcf, then no delay compensations
 *	occur and the normal sampling point is used instead. The
 *	feature is enabled if and only if @tdcv is set to zero
 *	(automatic mode) and @tdcf is configured to a value greater
 *	than @tdco.
 */
```
## Visual type:
- #interval


== ./linux/linux_908.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/can/dev.h#L95-L114

```c
/*
 * can_get_relative_tdco() - TDCO relative to the sample point
 *
 * struct can_tdc::tdco represents the absolute offset from TDCV. Some
 * controllers use instead an offset relative to the Sample Point (SP)
 * such that:
 *
 * SSP = TDCV + absolute TDCO
 *     = TDCV + SP + relative TDCO
 *
 < ASCII >
 * -+----------- one bit ----------+-- TX pin
 *  |<--- Sample Point --->|
 *
 *                         --+----------- one bit ----------+-- RX pin
 *  |<-------- TDCV -------->|
 *                           |<------------------------>| absolute TDCO
 *                           |<--- Sample Point --->|
 *                           |                      |<->| relative TDCO
 *  |<------------- Secondary Sample Point ------------>|
 < ASCII >
 */
```
## Visual type:
- #interval


== ./linux/linux_909.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/ceph/ceph_fs.h#L241-L245

```c
/*
 < ASCII >
 * mds states
 *   > 0 -> in
 *  <= 0 -> out
 < ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_91.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/ia64/include/asm/uv/uv_hub.h#L20-L65

```c
/*
 * Addressing Terminology
 *
 *	M       - The low M bits of a physical address represent the offset
 *		  into the blade local memory. RAM memory on a blade is physically
 *		  contiguous (although various IO spaces may punch holes in
 *		  it)..
 *
 * 	N	- Number of bits in the node portion of a socket physical
 * 		  address.
 *
 * 	NASID   - network ID of a router, Mbrick or Cbrick. Nasid values of
 * 	 	  routers always have low bit of 1, C/MBricks have low bit
 * 		  equal to 0. Most addressing macros that target UV hub chips
 * 		  right shift the NASID by 1 to exclude the always-zero bit.
 * 		  NASIDs contain up to 15 bits.
 *
 *	GNODE   - NASID right shifted by 1 bit. Most mmrs contain gnodes instead
 *		  of nasids.
 *
 * 	PNODE   - the low N bits of the GNODE. The PNODE is the most useful variant
 * 		  of the nasid for socket usage.
 *
 *
 < ASCII >
 *  NumaLink Global Physical Address Format:
 *  +--------------------------------+---------------------+
 *  |00..000|      GNODE             |      NodeOffset     |
 *  +--------------------------------+---------------------+
 *          |<-------53 - M bits --->|<--------M bits ----->
 *
 *	M - number of node offset bits (35 .. 40)
 *
 *
 *  Memory/UV-HUB Processor Socket Address Format:
 *  +----------------+---------------+---------------------+
 *  |00..000000000000|   PNODE       |      NodeOffset     |
 *  +----------------+---------------+---------------------+
 *                   <--- N bits --->|<--------M bits ----->
 < ASCII >
 *
 *	M - number of node offset bits (35 .. 40)
 *	N - number of PNODE bits (0 .. 10)
 *
 *		Note: M + N cannot currently exceed 44 (x86_64) or 46 (IA64).
 *		The actual values are configuration dependent and are set at
 *		boot time. M & N values are set by the hardware/BIOS at boot.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_910.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/crush/crush.h#L98-L112

```c
/*
 * A bucket is a named container of other items (either devices or
 * other buckets).  Items within a bucket are chosen using one of a
 * few different algorithms.  The table summarizes how the speed of
 * each option measures up against mapping stability when items are
 * added or removed.
 *
 < ASCII >
 *  Bucket Alg     Speed       Additions    Removals
 *  ------------------------------------------------
 *  uniform         O(1)       poor         poor
 *  list            O(n)       optimal      poor
 *  tree            O(log n)   good         good
 *  straw           O(n)       better       better
 *  straw2          O(n)       optimal      optimal
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_911.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/dma/sprd-dma.h#L117-L183

```c
/*
 * struct sprd_dma_linklist - DMA link-list address structure
 * @virt_addr: link-list virtual address to configure link-list node
 * @phy_addr: link-list physical address to link DMA transfer
 * @wrap_addr: the wrap address for link-list mode, which means once the
 * transfer address reaches the wrap address, the next transfer address
 * will jump to the address specified by wrap_to register.
 *
 * The Spreadtrum DMA controller supports the link-list mode, that means slaves
 * can supply several groups configurations (each configuration represents one
 * DMA transfer) saved in memory, and DMA controller will link these groups
 * configurations by writing the physical address of each configuration into the
 * link-list register.
 *
 * Just as shown below, the link-list pointer register will be pointed to the
 * physical address of 'configuration 1', and the 'configuration 1' link-list
 * pointer will be pointed to 'configuration 2', and so on.
 * Once trigger the DMA transfer, the DMA controller will load 'configuration
 * 1' to its registers automatically, after 'configuration 1' transaction is
 * done, DMA controller will load 'configuration 2' automatically, until all
 * DMA transactions are done.
 *
 * Note: The last link-list pointer should point to the physical address
 * of 'configuration 1', which can avoid DMA controller loads incorrect
 * configuration when the last configuration transaction is done.
 *
 < ASCII >
 *     DMA controller                    linklist memory
 * ======================             -----------------------
 *|                      |           |    configuration 1    |<---
 *|   DMA controller     |   ------->|                       |   |
 *|                      |   |       |                       |   |
 *|                      |   |       |                       |   |
 *|                      |   |       |                       |   |
 *| linklist pointer reg |----   ----|    linklist pointer   |   |
 * ======================        |    -----------------------    |
 *                               |                               |
 *                               |    -----------------------    |
 *                               |   |    configuration 2    |   |
 *                               --->|                       |   |
 *                                   |                       |   |
 *                                   |                       |   |
 *                                   |                       |   |
 *                               ----|    linklist pointer   |   |
 *                               |    -----------------------    |
 *                               |                               |
 *                               |    -----------------------    |
 *                               |   |    configuration 3    |   |
 *                               --->|                       |   |
 *                                   |                       |   |
 *                                   |           .           |   |
 *                                               .               |
 *                                               .               |
 *                                               .               |
 *                               |               .               |
 *                               |    -----------------------    |
 *                               |   |    configuration n    |   |
 *                               --->|                       |   |
 *                                   |                       |   |
 *                                   |                       |   |
 *                                   |                       |   |
 *                                   |    linklist pointer   |----
 *                                    -----------------------
 < ASCII >
 *
 * To support the link-list mode, DMA slaves should allocate one segment memory
 * from always-on IRAM or dma coherent memory to store these groups of DMA
 * configuration, and pass the virtual and physical address to DMA controller.
 */
```
## Visual type:
- #custom


== ./linux/linux_912.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/dsa/ocelot.h#L38-L164

```c
/* The CPU injection header and the CPU extraction header can have 3 types of
 * prefixes: long, short and no prefix. The format of the header itself is the
 * same in all 3 cases.
 *
 < ASCII >
 * Extraction with long prefix:
 *
 * +-------------------+-------------------+------+------+------------+-------+
 * | ff:ff:ff:ff:ff:ff | fe:ff:ff:ff:ff:ff | 8880 | 000a | extraction | frame |
 * |                   |                   |      |      |   header   |       |
 * +-------------------+-------------------+------+------+------------+-------+
 *        48 bits             48 bits      16 bits 16 bits  128 bits
 *
 * Extraction with short prefix:
 *
 *                                         +------+------+------------+-------+
 *                                         | 8880 | 000a | extraction | frame |
 *                                         |      |      |   header   |       |
 *                                         +------+------+------------+-------+
 *                                         16 bits 16 bits  128 bits
 *
 * Extraction with no prefix:
 *
 *                                                       +------------+-------+
 *                                                       | extraction | frame |
 *                                                       |   header   |       |
 *                                                       +------------+-------+
 *                                                          128 bits
 *
 *
 * Injection with long prefix:
 *
 * +-------------------+-------------------+------+------+------------+-------+
 * |      any dmac     |      any smac     | 8880 | 000a | injection  | frame |
 * |                   |                   |      |      |   header   |       |
 * +-------------------+-------------------+------+------+------------+-------+
 *        48 bits             48 bits      16 bits 16 bits  128 bits
 *
 * Injection with short prefix:
 *
 *                                         +------+------+------------+-------+
 *                                         | 8880 | 000a | injection  | frame |
 *                                         |      |      |   header   |       |
 *                                         +------+------+------------+-------+
 *                                         16 bits 16 bits  128 bits
 *
 * Injection with no prefix:
 *
 *                                                       +------------+-------+
 *                                                       | injection  | frame |
 *                                                       |   header   |       |
 *                                                       +------------+-------+
 *                                                          128 bits
 < ASCII >
 *
 * The injection header looks like this (network byte order, bit 127
 * is part of lowest address byte in memory, bit 0 is part of highest
 * address byte):
 < ASCII >
 *
 *         +------+------+------+------+------+------+------+------+
 * 127:120 |BYPASS| MASQ |          MASQ_PORT        |REW_OP|REW_OP|
 *         +------+------+------+------+------+------+------+------+
 * 119:112 |                         REW_OP                        |
 *         +------+------+------+------+------+------+------+------+
 * 111:104 |                         REW_VAL                       |
 *         +------+------+------+------+------+------+------+------+
 * 103: 96 |                         REW_VAL                       |
 *         +------+------+------+------+------+------+------+------+
 *  95: 88 |                         REW_VAL                       |
 *         +------+------+------+------+------+------+------+------+
 *  87: 80 |                         REW_VAL                       |
 *         +------+------+------+------+------+------+------+------+
 *  79: 72 |                          RSV                          |
 *         +------+------+------+------+------+------+------+------+
 *  71: 64 |            RSV            |           DEST            |
 *         +------+------+------+------+------+------+------+------+
 *  63: 56 |                         DEST                          |
 *         +------+------+------+------+------+------+------+------+
 *  55: 48 |                          RSV                          |
 *         +------+------+------+------+------+------+------+------+
 *  47: 40 |  RSV |         SRC_PORT          |     RSV     |TFRM_TIMER|
 *         +------+------+------+------+------+------+------+------+
 *  39: 32 |     TFRM_TIMER     |               RSV                |
 *         +------+------+------+------+------+------+------+------+
 *  31: 24 |  RSV |  DP  |   POP_CNT   |           CPUQ            |
 *         +------+------+------+------+------+------+------+------+
 *  23: 16 |           CPUQ            |      QOS_CLASS     |TAG_TYPE|
 *         +------+------+------+------+------+------+------+------+
 *  15:  8 |         PCP        |  DEI |            VID            |
 *         +------+------+------+------+------+------+------+------+
 *   7:  0 |                          VID                          |
 *         +------+------+------+------+------+------+------+------+
 *
 * And the extraction header looks like this:
 *
 *         +------+------+------+------+------+------+------+------+
 * 127:120 |  RSV |                  REW_OP                        |
 *         +------+------+------+------+------+------+------+------+
 * 119:112 |       REW_OP       |              REW_VAL             |
 *         +------+------+------+------+------+------+------+------+
 * 111:104 |                         REW_VAL                       |
 *         +------+------+------+------+------+------+------+------+
 * 103: 96 |                         REW_VAL                       |
 *         +------+------+------+------+------+------+------+------+
 *  95: 88 |                         REW_VAL                       |
 *         +------+------+------+------+------+------+------+------+
 *  87: 80 |       REW_VAL      |               LLEN               |
 *         +------+------+------+------+------+------+------+------+
 *  79: 72 | LLEN |                      WLEN                      |
 *         +------+------+------+------+------+------+------+------+
 *  71: 64 | WLEN |                      RSV                       |
 *         +------+------+------+------+------+------+------+------+
 *  63: 56 |                          RSV                          |
 *         +------+------+------+------+------+------+------+------+
 *  55: 48 |                          RSV                          |
 *         +------+------+------+------+------+------+------+------+
 *  47: 40 | RSV  |          SRC_PORT         |       ACL_ID       |
 *         +------+------+------+------+------+------+------+------+
 *  39: 32 |       ACL_ID       |  RSV |         SFLOW_ID          |
 *         +------+------+------+------+------+------+------+------+
 *  31: 24 |ACL_HIT| DP  |  LRN_FLAGS  |           CPUQ            |
 *         +------+------+------+------+------+------+------+------+
 *  23: 16 |           CPUQ            |      QOS_CLASS     |TAG_TYPE|
 *         +------+------+------+------+------+------+------+------+
 *  15:  8 |         PCP        |  DEI |            VID            |
 *         +------+------+------+------+------+------+------+------+
 *   7:  0 |                          VID                          |
 *         +------+------+------+------+------+------+------+------+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_913.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/input/adp5589.h#L110-L117

```c
/* ADP5589 Mask Bits:
 < ASCII >
 * C C C C C C C C C C C | R R R R R R R R
 * 1 9 8 7 6 5 4 3 2 1 0 | 7 6 5 4 3 2 1 0
 * 0
 * ---------------- BIT ------------------
 * 1 1 1 1 1 1 1 1 1 0 0 | 0 0 0 0 0 0 0 0
 * 8 7 6 5 4 3 2 1 0 9 8 | 7 6 5 4 3 2 1 0
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_914.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/input/adp5589.h#L127-L134

```c
/* ADP5585 Mask Bits:
 < ASCII >
 * C C C C C | R R R R R R
 * 4 3 2 1 0 | 5 4 3 2 1 0
 *
 * ---- BIT -- -----------
 * 1 0 0 0 0 | 0 0 0 0 0 0
 * 0 9 8 7 6 | 5 4 3 2 1 0
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_915.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/regulator/fan53555.h#L18-L38

```c
/* Transition slew rate limiting from a low to high voltage.
 < ASCII >
 * -----------------------
 *   Bin |Slew Rate(mV/uS)
 * ------|----------------
 *   000 |    64.00
 * ------|----------------
 *   001 |    32.00
 * ------|----------------
 *   010 |    16.00
 * ------|----------------
 *   011 |     8.00
 * ------|----------------
 *   100 |     4.00
 * ------|----------------
 *   101 |     2.00
 * ------|----------------
 *   110 |     1.00
 * ------|----------------
 *   111 |     0.50
 * -----------------------
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_916.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/linux/sched/topology.h#L246-L255

```c
/**
 * arch_scale_cpu_capacity - get the capacity scale factor of a given CPU.
 * @cpu: the CPU in question.
 *
 * Return: the CPU scale factor normalized against SCHED_CAPACITY_SCALE, i.e.
 *
 < ASCII >
 *             max_perf(cpu)
 *      ----------------------------- * SCHED_CAPACITY_SCALE
 *      max(max_perf(c) : c \in CPUs)
 < ASCII >
 */
```
## Visual type:
- #formula


== ./linux/linux_917.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/media/drv-intf/msp3400.h#L146-L160

```c
 < ASCII >
/* Chip      TUNER_1   TUNER_2
   -------------------------
   msp34x0b  y         y
   msp34x0c  y         y
   msp34x0d  y         y
   msp34x5d  y         n
   msp34x7d  y         n
   msp34x0g  y         y
   msp34x1g  y         y
   msp34x2g  y         y
   msp34x5g  y         n
   msp34x7g  y         n
   msp44x0g  y         y
   msp44x8g  y         y
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_918.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/media/drv-intf/msp3400.h#L163-L177

```c
 < ASCII >
/* Chip      SC1 SC2 SC3 SC4
   -------------------------
   msp34x0b  y   y   y   n
   msp34x0c  y   y   y   n
   msp34x0d  y   y   y   y
   msp34x5d  y   y   n   n
   msp34x7d  y   n   n   n
   msp34x0g  y   y   y   y
   msp34x1g  y   y   y   y
   msp34x2g  y   y   y   y
   msp34x5g  y   y   n   n
   msp34x7g  y   n   n   n
   msp44x0g  y   y   y   y
   msp44x8g  y   y   y   y
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_919.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/media/drv-intf/msp3400.h#L180-L194

```c
 < ASCII >
/* Chip      I2S1 I2S2 I2S3 MAIN_AVC MAIN AUX
   ------------------------------------------
   msp34x0b  y    n    n    n        n    n
   msp34x0c  y    y    n    n        n    n
   msp34x0d  y    y    n    n        n    n
   msp34x5d  y    y    n    n        n    n
   msp34x7d  n    n    n    n        n    n
   msp34x0g  y    y    n    n        n    n
   msp34x1g  y    y    n    n        n    n
   msp34x2g  y    y    n    y        y    y
   msp34x5g  y    y    n    n        n    n
   msp34x7g  n    n    n    n        n    n
   msp44x0g  y    y    y    y        y    y
   msp44x8g  y    y    y    n        n    n
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_92.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/ia64/include/uapi/asm/ptrace.h#L19-L56

```c
/*
 * When a user process is blocked, its state looks as follows:
 *
 < ASCII >
 *            +----------------------+	-------	IA64_STK_OFFSET
 *     	      |			     |	 ^
 *            | struct pt_regs       |	 |
 *	      |			     |	 |
 *            +----------------------+	 |
 *	      |			     |	 |
 *     	      |	   memory stack	     |	 |
 *	      |	(growing downwards)  |	 |
 *	      //.....................//	 |
 *					 |
 *	      //.....................//	 |
 *	      |			     |	 |
 *            +----------------------+	 |
 *            | struct switch_stack  |	 |      
 *	      |			     |	 |
 *	      +----------------------+	 |
 *	      |			     |	 |
 *	      //.....................//	 |
 *					 |
 *	      //.....................//	 |
 *	      |			     |	 |
 *	      |	 register stack	     |	 |
 *	      |	(growing upwards)    |	 |
 *            |			     |	 |
 *	      +----------------------+	 |  ---	IA64_RBS_OFFSET
 *            |  struct thread_info  |	 |  ^
 *	      +----------------------+	 |  |
 *	      |			     |	 |  |
 *            |  struct task_struct  |	 |  |
 * current -> |			     |   |  |
 *	      +----------------------+ -------
 < ASCII >
 *
 * Note that ar.ec is not saved explicitly in pt_reg or switch_stack.
 * This is because ar.ec is saved as part of ar.pfs.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_920.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/media/drv-intf/msp3400.h#L197-L211

```c
 < ASCII >
/* Chip      MAIN AUX SCART1 SCART2 I2S
   ------------------------------------
   msp34x0b  y    y   y      n      y
   msp34x0c  y    y   y      n      y
   msp34x0d  y    y   y      y      y
   msp34x5d  y    n   y      n      y
   msp34x7d  y    n   y      n      n
   msp34x0g  y    y   y      y      y
   msp34x1g  y    y   y      y      y
   msp34x2g  y    y   y      y      y
   msp34x5g  y    n   y      n      y
   msp34x7g  y    n   y      n      n
   msp44x0g  y    y   y      y      y
   msp44x8g  y    y   y      y      y
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_921.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/erspan.h#L4-L59

```c
/*
 < ASCII >
 * GRE header for ERSPAN type I encapsulation (4 octets [34:37])
 *      0                   1                   2                   3
 *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |0|0|0|0|0|00000|000000000|00000|    Protocol Type for ERSPAN   |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 *
 *  The Type I ERSPAN frame format is based on the barebones IP + GRE
 *  encapsulation (as described above) on top of the raw mirrored frame.
 *  There is no extra ERSPAN header.
 *
 *
 < ASCII >
 * GRE header for ERSPAN type II and II encapsulation (8 octets [34:41])
 *       0                   1                   2                   3
 *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |0|0|0|1|0|00000|000000000|00000|    Protocol Type for ERSPAN   |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |      Sequence Number (increments per packet per session)      |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 *
 *  Note that in the above GRE header [RFC1701] out of the C, R, K, S,
 *  s, Recur, Flags, Version fields only S (bit 03) is set to 1. The
 *  other fields are set to zero, so only a sequence number follows.
 *
 < ASCII >
 *  ERSPAN Version 1 (Type II) header (8 octets [42:49])
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |  Ver  |          VLAN         | COS | En|T|    Session ID     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |      Reserved         |                  Index                |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *
 *  ERSPAN Version 2 (Type III) header (12 octets [42:49])
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |  Ver  |          VLAN         | COS |BSO|T|     Session ID    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                          Timestamp                            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |             SGT               |P|    FT   |   Hw ID   |D|Gra|O|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *      Platform Specific SubHeader (8 octets, optional)
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |  Platf ID |               Platform Specific Info              |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  Platform Specific Info                       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 * GRE proto ERSPAN type I/II = 0x88BE, type III = 0x22EB
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_922.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/geneve.h#L9-L24

```c
 < ASCII >
/* Geneve Header:
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |Ver|  Opt Len  |O|C|    Rsvd.  |          Protocol Type        |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |        Virtual Network Identifier (VNI)       |    Reserved   |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                    Variable Length Options                    |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 * Option Header:
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |          Option Class         |      Type     |R|R|R| Length  |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                      Variable Option Data                     |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_923.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/gue.h#L5-L31

```c
/* Definitions for the GUE header, standard and private flags, lengths
 * of optional fields are below.
 *
 < ASCII >
 * Diagram of GUE header:
 *
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |Ver|C|  Hlen   | Proto/ctype   |        Standard flags       |P|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * ~                      Fields (optional)                        ~
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |            Private flags (optional, P bit is set)             |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * ~                   Private fields (optional)                   ~
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 *
 * C bit indicates control message when set, data message when unset.
 * For a control message, proto/ctype is interpreted as a type of
 * control message. For data messages, proto/ctype is the IP protocol
 * of the next header.
 *
 * P bit indicates private flags field is present. The private flags
 * may refer to options placed after this field.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_924.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/inet_dscp.h#L2-L20

```c
/*
 * inet_dscp.h: helpers for handling differentiated services codepoints (DSCP)
 *
 < ASCII >
 * DSCP is defined in RFC 2474:
 *
 *        0   1   2   3   4   5   6   7
 *      +---+---+---+---+---+---+---+---+
 *      |         DSCP          |  CU   |
 *      +---+---+---+---+---+---+---+---+
 < ASCII >
 *
 *        DSCP: differentiated services codepoint
 *        CU:   currently unused
 *
 * The whole DSCP + CU bits form the DS field.
 * The DS field is also commonly called TOS or Traffic Class (for IPv6).
 *
 * Note: the CU bits are now used for Explicit Congestion Notification
 *       (RFC 3168).
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_925.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/inet_ecn.h#L227-L250

```c
/*
 * RFC 6040 4.2
 *  To decapsulate the inner header at the tunnel egress, a compliant
 *  tunnel egress MUST set the outgoing ECN field to the codepoint at the
 *  intersection of the appropriate arriving inner header (row) and outer
 *  header (column) in Figure 4
 *
 < ASCII >
 *      +---------+------------------------------------------------+
 *      |Arriving |            Arriving Outer Header               |
 *      |   Inner +---------+------------+------------+------------+
 *      |  Header | Not-ECT | ECT(0)     | ECT(1)     |     CE     |
 *      +---------+---------+------------+------------+------------+
 *      | Not-ECT | Not-ECT |Not-ECT(!!!)|Not-ECT(!!!)| <drop>(!!!)|
 *      |  ECT(0) |  ECT(0) | ECT(0)     | ECT(1)     |     CE     |
 *      |  ECT(1) |  ECT(1) | ECT(1) (!) | ECT(1)     |     CE     |
 *      |    CE   |      CE |     CE     |     CE(!!!)|     CE     |
 *      +---------+---------+------------+------------+------------+
 *
 < ASCII >
 *             Figure 4: New IP in IP Decapsulation Behaviour
 *
 *  returns 0 on success
 *          1 if something is broken and should be logged (!!! above)
 *          2 if packet should be dropped
 */
```
## Visual type:
- #table


== ./linux/linux_926.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/mld.h#L67-L76

```c
/* RFC3810, 5.1.3. Maximum Response Code:
 *
 * If Maximum Response Code >= 32768, Maximum Response Code represents a
 * floating-point value as follows:
 *
 < ASCII >
 *  0 1 2 3 4 5 6 7 8 9 A B C D E F
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |1| exp |          mant         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_927.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/mld.h#L80-L88

```c
/* RFC3810, 5.1.9. QQIC (Querier's Query Interval Code):
 *
 * If QQIC >= 128, QQIC represents a floating-point value as follows:
 *
 < ASCII >
 *  0 1 2 3 4 5 6 7
 * +-+-+-+-+-+-+-+-+
 * |1| exp | mant  |
 * +-+-+-+-+-+-+-+-+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_928.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/netlabel.h#L31-L56

```c
/*
 * NetLabel - A management interface for maintaining network packet label
 *            mapping tables for explicit packet labling protocols.
 *
 * Network protocols such as CIPSO and RIPSO require a label translation layer
 * to convert the label on the packet into something meaningful on the host
 * machine.  In the current Linux implementation these mapping tables live
 * inside the kernel; NetLabel provides a mechanism for user space applications
 * to manage these mapping tables.
 *
 * NetLabel makes use of the Generic NETLINK mechanism as a transport layer to
 * send messages between kernel and user space.  The general format of a
 * NetLabel message is shown below:
 *
 < ASCII >
 *  +-----------------+-------------------+--------- --- -- -
 *  | struct nlmsghdr | struct genlmsghdr | payload
 *  +-----------------+-------------------+--------- --- -- -
 < ASCII >
 *
 * The 'nlmsghdr' and 'genlmsghdr' structs should be dealt with like normal.
 * The payload is dependent on the subsystem specified in the
 * 'nlmsghdr->nlmsg_type' and should be defined below, supporting functions
 * should be defined in the corresponding net/netlabel/netlabel_<subsys>.h|c
 * file.  All of the fields in the NetLabel payload are NETLINK attributes, see
 * the include/net/netlink.h file for more information on NETLINK attributes.
 *
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_929.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/netlink.h#L10-L160

```c
/* ========================================================================
 *         Netlink Messages and Attributes Interface (As Seen On TV)
 * ------------------------------------------------------------------------
 *                          Messages Interface
 * ------------------------------------------------------------------------
 *
 < ASCII >
 * Message Format:
 *    <--- nlmsg_total_size(payload)  --->
 *    <-- nlmsg_msg_size(payload) ->
 *   +----------+- - -+-------------+- - -+-------- - -
 *   | nlmsghdr | Pad |   Payload   | Pad | nlmsghdr
 *   +----------+- - -+-------------+- - -+-------- - -
 *   nlmsg_data(nlh)---^                   ^
 *   nlmsg_next(nlh)-----------------------+
 *
 * Payload Format:
 *    <---------------------- nlmsg_len(nlh) --------------------->
 *    <------ hdrlen ------>       <- nlmsg_attrlen(nlh, hdrlen) ->
 *   +----------------------+- - -+--------------------------------+
 *   |     Family Header    | Pad |           Attributes           |
 *   +----------------------+- - -+--------------------------------+
 *   nlmsg_attrdata(nlh, hdrlen)---^
 < ASCII >
 *
 * Data Structures:
 *   struct nlmsghdr			netlink message header
 *
 * Message Construction:
 *   nlmsg_new()			create a new netlink message
 *   nlmsg_put()			add a netlink message to an skb
 *   nlmsg_put_answer()			callback based nlmsg_put()
 *   nlmsg_end()			finalize netlink message
 *   nlmsg_get_pos()			return current position in message
 *   nlmsg_trim()			trim part of message
 *   nlmsg_cancel()			cancel message construction
 *   nlmsg_free()			free a netlink message
 *
 * Message Sending:
 *   nlmsg_multicast()			multicast message to several groups
 *   nlmsg_unicast()			unicast a message to a single socket
 *   nlmsg_notify()			send notification message
 *
 * Message Length Calculations:
 *   nlmsg_msg_size(payload)		length of message w/o padding
 *   nlmsg_total_size(payload)		length of message w/ padding
 *   nlmsg_padlen(payload)		length of padding at tail
 *
 * Message Payload Access:
 *   nlmsg_data(nlh)			head of message payload
 *   nlmsg_len(nlh)			length of message payload
 *   nlmsg_attrdata(nlh, hdrlen)	head of attributes data
 *   nlmsg_attrlen(nlh, hdrlen)		length of attributes data
 *
 * Message Parsing:
 *   nlmsg_ok(nlh, remaining)		does nlh fit into remaining bytes?
 *   nlmsg_next(nlh, remaining)		get next netlink message
 *   nlmsg_parse()			parse attributes of a message
 *   nlmsg_find_attr()			find an attribute in a message
 *   nlmsg_for_each_msg()		loop over all messages
 *   nlmsg_validate()			validate netlink message incl. attrs
 *   nlmsg_for_each_attr()		loop over all attributes
 *
 * Misc:
 *   nlmsg_report()			report back to application?
 *
 * ------------------------------------------------------------------------
 *                          Attributes Interface
 * ------------------------------------------------------------------------
 *
 < ASCII >
 * Attribute Format:
 *    <------- nla_total_size(payload) ------->
 *    <---- nla_attr_size(payload) ----->
 *   +----------+- - -+- - - - - - - - - +- - -+-------- - -
 *   |  Header  | Pad |     Payload      | Pad |  Header
 *   +----------+- - -+- - - - - - - - - +- - -+-------- - -
 *                     <- nla_len(nla) ->      ^
 *   nla_data(nla)----^                        |
 *   nla_next(nla)-----------------------------'
 < ASCII >
 *
 * Data Structures:
 *   struct nlattr			netlink attribute header
 *
 * Attribute Construction:
 *   nla_reserve(skb, type, len)	reserve room for an attribute
 *   nla_reserve_nohdr(skb, len)	reserve room for an attribute w/o hdr
 *   nla_put(skb, type, len, data)	add attribute to skb
 *   nla_put_nohdr(skb, len, data)	add attribute w/o hdr
 *   nla_append(skb, len, data)		append data to skb
 *
 * Attribute Construction for Basic Types:
 *   nla_put_u8(skb, type, value)	add u8 attribute to skb
 *   nla_put_u16(skb, type, value)	add u16 attribute to skb
 *   nla_put_u32(skb, type, value)	add u32 attribute to skb
 *   nla_put_u64_64bit(skb, type,
 *                     value, padattr)	add u64 attribute to skb
 *   nla_put_s8(skb, type, value)	add s8 attribute to skb
 *   nla_put_s16(skb, type, value)	add s16 attribute to skb
 *   nla_put_s32(skb, type, value)	add s32 attribute to skb
 *   nla_put_s64(skb, type, value,
 *               padattr)		add s64 attribute to skb
 *   nla_put_string(skb, type, str)	add string attribute to skb
 *   nla_put_flag(skb, type)		add flag attribute to skb
 *   nla_put_msecs(skb, type, jiffies,
 *                 padattr)		add msecs attribute to skb
 *   nla_put_in_addr(skb, type, addr)	add IPv4 address attribute to skb
 *   nla_put_in6_addr(skb, type, addr)	add IPv6 address attribute to skb
 *
 * Nested Attributes Construction:
 *   nla_nest_start(skb, type)		start a nested attribute
 *   nla_nest_end(skb, nla)		finalize a nested attribute
 *   nla_nest_cancel(skb, nla)		cancel nested attribute construction
 *
 * Attribute Length Calculations:
 *   nla_attr_size(payload)		length of attribute w/o padding
 *   nla_total_size(payload)		length of attribute w/ padding
 *   nla_padlen(payload)		length of padding
 *
 * Attribute Payload Access:
 *   nla_data(nla)			head of attribute payload
 *   nla_len(nla)			length of attribute payload
 *
 * Attribute Payload Access for Basic Types:
 *   nla_get_u8(nla)			get payload for a u8 attribute
 *   nla_get_u16(nla)			get payload for a u16 attribute
 *   nla_get_u32(nla)			get payload for a u32 attribute
 *   nla_get_u64(nla)			get payload for a u64 attribute
 *   nla_get_s8(nla)			get payload for a s8 attribute
 *   nla_get_s16(nla)			get payload for a s16 attribute
 *   nla_get_s32(nla)			get payload for a s32 attribute
 *   nla_get_s64(nla)			get payload for a s64 attribute
 *   nla_get_flag(nla)			return 1 if flag is true
 *   nla_get_msecs(nla)			get payload for a msecs attribute
 *
 * Attribute Misc:
 *   nla_memcpy(dest, nla, count)	copy attribute into memory
 *   nla_memcmp(nla, data, size)	compare attribute with memory area
 *   nla_strscpy(dst, nla, size)	copy attribute to a sized string
 *   nla_strcmp(nla, str)		compare attribute with string
 *
 * Attribute Parsing:
 *   nla_ok(nla, remaining)		does nla fit into remaining bytes?
 *   nla_next(nla, remaining)		get next netlink attribute
 *   nla_validate()			validate a stream of attributes
 *   nla_validate_nested()		validate a stream of nested attributes
 *   nla_find()				find attribute in stream of attributes
 *   nla_find_nested()			find attribute in nested attributes
 *   nla_parse()			parse and validate stream of attrs
 *   nla_parse_nested()			parse nested attributes
 *   nla_for_each_attr()		loop over all attributes
 *   nla_for_each_nested()		loop over the nested attributes
 *=========================================================================
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_93.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/ia64/kernel/ivt.S#L25-L48

```c
/*
 * This file defines the interruption vector table used by the CPU.
 * It does not include one entry per possible cause of interruption.
 *
 * The first 20 entries of the table contain 64 bundles each while the
 * remaining 48 entries contain only 16 bundles each.
 *
 * The 64 bundles are used to allow inlining the whole handler for critical
 * interruptions like TLB misses.
 *
 *  For each entry, the comment is as follows:
 *
 < ASCII >
 *		// 0x1c00 Entry 7 (size 64 bundles) Data Key Miss (12,51)
 *  entry offset ----/     /         /                  /          /
 *  entry number ---------/         /                  /          /
 *  size of the entry -------------/                  /          /
 *  vector name -------------------------------------/          /
 *  interruptions triggering this vector ----------------------/
 < ASCII >
 *
 * The table is 32KB in size and must be aligned on 32KB boundary.
 * (The CPU ignores the 15 lower bits of the address)
 *
 * Table is based upon EAS2.6 (Oct 1999)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_930.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/nsh.h#L6-L191

```c
/*
 < ASCII >
 * Network Service Header:
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |          Service Path Identifier (SPI)        | Service Index |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * ~               Mandatory/Optional Context Headers              ~
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 *
 * Version: The version field is used to ensure backward compatibility
 * going forward with future NSH specification updates.  It MUST be set
 * to 0x0 by the sender, in this first revision of NSH.  Given the
 * widespread implementation of existing hardware that uses the first
 * nibble after an MPLS label stack for ECMP decision processing, this
 * document reserves version 01b and this value MUST NOT be used in
 * future versions of the protocol.  Please see [RFC7325] for further
 * discussion of MPLS-related forwarding requirements.
 *
 * O bit: Setting this bit indicates an Operations, Administration, and
 * Maintenance (OAM) packet.  The actual format and processing of SFC
 * OAM packets is outside the scope of this specification (see for
 * example [I-D.ietf-sfc-oam-framework] for one approach).
 *
 * The O bit MUST be set for OAM packets and MUST NOT be set for non-OAM
 * packets.  The O bit MUST NOT be modified along the SFP.
 *
 * SF/SFF/SFC Proxy/Classifier implementations that do not support SFC
 * OAM procedures SHOULD discard packets with O bit set, but MAY support
 * a configurable parameter to enable forwarding received SFC OAM
 * packets unmodified to the next element in the chain.  Forwarding OAM
 * packets unmodified by SFC elements that do not support SFC OAM
 * procedures may be acceptable for a subset of OAM functions, but can
 * result in unexpected outcomes for others, thus it is recommended to
 * analyze the impact of forwarding an OAM packet for all OAM functions
 * prior to enabling this behavior.  The configurable parameter MUST be
 * disabled by default.
 *
 * TTL: Indicates the maximum SFF hops for an SFP.  This field is used
 * for service plane loop detection.  The initial TTL value SHOULD be
 * configurable via the control plane; the configured initial value can
 * be specific to one or more SFPs.  If no initial value is explicitly
 * provided, the default initial TTL value of 63 MUST be used.  Each SFF
 * involved in forwarding an NSH packet MUST decrement the TTL value by
 * 1 prior to NSH forwarding lookup.  Decrementing by 1 from an incoming
 * value of 0 shall result in a TTL value of 63.  The packet MUST NOT be
 * forwarded if TTL is, after decrement, 0.
 *
 * All other flag fields, marked U, are unassigned and available for
 * future use, see Section 11.2.1.  Unassigned bits MUST be set to zero
 * upon origination, and MUST be ignored and preserved unmodified by
 * other NSH supporting elements.  Elements which do not understand the
 * meaning of any of these bits MUST NOT modify their actions based on
 * those unknown bits.
 *
 * Length: The total length, in 4-byte words, of NSH including the Base
 * Header, the Service Path Header, the Fixed Length Context Header or
 * Variable Length Context Header(s).  The length MUST be 0x6 for MD
 * Type equal to 0x1, and MUST be 0x2 or greater for MD Type equal to
 * 0x2.  The length of the NSH header MUST be an integer multiple of 4
 * bytes, thus variable length metadata is always padded out to a
 * multiple of 4 bytes.
 *
 * MD Type: Indicates the format of NSH beyond the mandatory Base Header
 * and the Service Path Header.  MD Type defines the format of the
 * metadata being carried.
 *
 * 0x0 - This is a reserved value.  Implementations SHOULD silently
 * discard packets with MD Type 0x0.
 *
 * 0x1 - This indicates that the format of the header includes a fixed
 * length Context Header (see Figure 4 below).
 *
 * 0x2 - This does not mandate any headers beyond the Base Header and
 * Service Path Header, but may contain optional variable length Context
 * Header(s).  The semantics of the variable length Context Header(s)
 * are not defined in this document.  The format of the optional
 * variable length Context Headers is provided in Section 2.5.1.
 *
 * 0xF - This value is reserved for experimentation and testing, as per
 * [RFC3692].  Implementations not explicitly configured to be part of
 * an experiment SHOULD silently discard packets with MD Type 0xF.
 *
 * Next Protocol: indicates the protocol type of the encapsulated data.
 * NSH does not alter the inner payload, and the semantics on the inner
 * protocol remain unchanged due to NSH service function chaining.
 * Please see the IANA Considerations section below, Section 11.2.5.
 *
 * This document defines the following Next Protocol values:
 *
 * 0x1: IPv4
 * 0x2: IPv6
 * 0x3: Ethernet
 * 0x4: NSH
 * 0x5: MPLS
 * 0xFE: Experiment 1
 * 0xFF: Experiment 2
 *
 * Packets with Next Protocol values not supported SHOULD be silently
 * dropped by default, although an implementation MAY provide a
 * configuration parameter to forward them.  Additionally, an
 * implementation not explicitly configured for a specific experiment
 * [RFC3692] SHOULD silently drop packets with Next Protocol values 0xFE
 * and 0xFF.
 *
 * Service Path Identifier (SPI): Identifies a service path.
 * Participating nodes MUST use this identifier for Service Function
 * Path selection.  The initial classifier MUST set the appropriate SPI
 * for a given classification result.
 *
 * Service Index (SI): Provides location within the SFP.  The initial
 * classifier for a given SFP SHOULD set the SI to 255, however the
 * control plane MAY configure the initial value of SI as appropriate
 * (i.e., taking into account the length of the service function path).
 * The Service Index MUST be decremented by a value of 1 by Service
 * Functions or by SFC Proxy nodes after performing required services
 * and the new decremented SI value MUST be used in the egress packet's
 * NSH.  The initial Classifier MUST send the packet to the first SFF in
 * the identified SFP for forwarding along an SFP.  If re-classification
 * occurs, and that re-classification results in a new SPI, the
 * (re)classifier is, in effect, the initial classifier for the
 * resultant SPI.
 *
 * The SI is used in conjunction the with Service Path Identifier for
 * Service Function Path Selection and for determining the next SFF/SF
 * in the path.  The SI is also valuable when troubleshooting or
 * reporting service paths.  Additionally, while the TTL field is the
 * main mechanism for service plane loop detection, the SI can also be
 * used for detecting service plane loops.
 *
 * When the Base Header specifies MD Type = 0x1, a Fixed Length Context
 * Header (16-bytes) MUST be present immediately following the Service
 * Path Header. The value of a Fixed Length Context
 * Header that carries no metadata MUST be set to zero.
 *
 * When the base header specifies MD Type = 0x2, zero or more Variable
 * Length Context Headers MAY be added, immediately following the
 * Service Path Header (see Figure 5).  Therefore, Length = 0x2,
 * indicates that only the Base Header followed by the Service Path
 * Header are present.  The optional Variable Length Context Headers
 * MUST be of an integer number of 4-bytes.  The base header Length
 * field MUST be used to determine the offset to locate the original
 * packet or frame for SFC nodes that require access to that
 * information.
 *
 < ASCII >
 * The format of the optional variable length Context Headers
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |          Metadata Class       |      Type     |U|    Length   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Variable Metadata                        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 *
 * Metadata Class (MD Class): Defines the scope of the 'Type' field to
 * provide a hierarchical namespace.  The IANA Considerations
 * Section 11.2.4 defines how the MD Class values can be allocated to
 * standards bodies, vendors, and others.
 *
 * Type: Indicates the explicit type of metadata being carried.  The
 * definition of the Type is the responsibility of the MD Class owner.
 *
 * Unassigned bit: One unassigned bit is available for future use. This
 * bit MUST NOT be set, and MUST be ignored on receipt.
 *
 * Length: Indicates the length of the variable metadata, in bytes.  In
 * case the metadata length is not an integer number of 4-byte words,
 * the sender MUST add pad bytes immediately following the last metadata
 * byte to extend the metadata to an integer number of 4-byte words.
 * The receiver MUST round up the length field to the nearest 4-byte
 * word boundary, to locate and process the next field in the packet.
 * The receiver MUST access only those bytes in the metadata indicated
 * by the length field (i.e., actual number of bytes) and MUST ignore
 * the remaining bytes up to the nearest 4-byte word boundary.  The
 * Length may be 0 or greater.
 *
 * A value of 0 denotes a Context Header without a Variable Metadata
 * field.
 *
 * [0] https://datatracker.ietf.org/doc/draft-ietf-sfc-nsh/
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_931.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/vxlan.h#L15-L23

```c
/* VXLAN protocol (RFC 7348) header:
 < ASCII >
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |R|R|R|R|I|R|R|R|               Reserved                        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                VXLAN Network Identifier (VNI) |   Reserved    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 *
 * I = VXLAN Network Identifier (VNI) present.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_932.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/vxlan.h#L42-L58

```c
/* Remote checksum offload for VXLAN (VXLAN_F_REMCSUM_[RT]X):
 < ASCII >
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |R|R|R|R|I|R|R|R|R|R|C|              Reserved                   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |           VXLAN Network Identifier (VNI)      |O| Csum start  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 *
 * C = Remote checksum offload bit. When set indicates that the
 *     remote checksum offload data is present.
 *
 * O = Offset bit. Indicates the checksum offset relative to
 *     checksum start.
 *
 * Csum start = Checksum start divided by two.
 *
 * http://tools.ietf.org/html/draft-herbert-vxlan-rco
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_933.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/vxlan.h#L70-L88

```c
/*
 * VXLAN Group Based Policy Extension (VXLAN_F_GBP):
 < ASCII >
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |G|R|R|R|I|R|R|R|R|D|R|R|A|R|R|R|        Group Policy ID        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                VXLAN Network Identifier (VNI) |   Reserved    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 *
 * G = Group Policy ID present.
 *
 * D = Don't Learn bit. When set, this bit indicates that the egress
 *     VTEP MUST NOT learn the source address of the encapsulated frame.
 *
 * A = Indicates that the group policy has already been applied to
 *     this packet. Policies MUST NOT be applied by devices when the
 *     A bit is set.
 *
 * https://tools.ietf.org/html/draft-smith-vxlan-group-policy
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_934.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/vxlan.h#L115-L120

```c
/* skb->mark mapping
 *
 < ASCII >
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |R|R|R|R|R|R|R|R|R|D|R|R|A|R|R|R|        Group Policy ID        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_935.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/vxlan.h#L128-L148

```c
/*
 * VXLAN Generic Protocol Extension (VXLAN_F_GPE):
 < ASCII >
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |R|R|Ver|I|P|R|O|       Reserved                |Next Protocol  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                VXLAN Network Identifier (VNI) |   Reserved    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 *
 * Ver = Version. Indicates VXLAN GPE protocol version.
 *
 * P = Next Protocol Bit. The P bit is set to indicate that the
 *     Next Protocol field is present.
 *
 * O = OAM Flag Bit. The O bit is set to indicate that the packet
 *     is an OAM packet.
 *
 * Next Protocol = This 8 bit field indicates the protocol header
 * immediately following the VXLAN GPE header.
 *
 * https://tools.ietf.org/html/draft-ietf-nvo3-vxlan-gpe-01
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_936.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/net/sctp/constants.h#L402-L415

```c
/* SCTP-AUTH, Section 3.3
 *
 *  The following Table 2 shows the currently defined values for HMAC
 *  identifiers.
 *
 < ASCII >
 *  +-----------------+--------------------------+
 *  | HMAC Identifier | Message Digest Algorithm |
 *  +-----------------+--------------------------+
 *  | 0               | Reserved                 |
 *  | 1               | SHA-1 defined in [8]     |
 *  | 2               | Reserved                 |
 *  | 3               | SHA-256 defined in [8]   |
 *  +-----------------+--------------------------+
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_937.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/scsi/libsas.h#L459-L470

```c
/*
 < ASCII >
      service_response |  SAS_TASK_COMPLETE  |  SAS_TASK_UNDELIVERED |
  exec_status          |                     |                       |
  ---------------------+---------------------+-----------------------+
       SAM_...         |         X           |                       |
       DEV_NO_RESPONSE |         X           |           X           |
       INTERRUPTED     |         X           |                       |
       QUEUE_FULL      |                     |           X           |
       DEVICE_UNKNOWN  |                     |           X           |
       SG_ERR          |                     |           X           |
  ---------------------+---------------------+-----------------------+
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_938.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L627-L641

```c
/**
 * @ingroup Debugfs
 * @brief Request with #MRQ_DEBUGFS.
 *
 * The sender of an MRQ_DEBUGFS message uses #cmd to specify a debugfs
 * command to execute. Legal commands are the values of @ref
 * mrq_debugfs_commands. Each command requires a specific additional
 * payload of data.
 *
 < ASCII >
 * |command            |payload|
 * |-------------------|-------|
 * |CMD_DEBUGFS_READ   |fop    |
 * |CMD_DEBUGFS_WRITE  |fop    |
 * |CMD_DEBUGFS_DUMPDIR|dumpdir|
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_939.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L816-L832

```c
/**
 * @ingroup Debugfs
 * @brief Request with #MRQ_DEBUG.
 *
 * The sender of an MRQ_DEBUG message uses #cmd to specify a debugfs
 * command to execute. Legal commands are the values of @ref
 * mrq_debug_commands. Each command requires a specific additional
 * payload of data.
 *
 < ASCII >
 * |command            |payload|
 * |-------------------|-------|
 * |CMD_DEBUG_OPEN_RO  |fop    |
 * |CMD_DEBUG_OPEN_WO  |fop    |
 * |CMD_DEBUG_READ     |frd    |
 * |CMD_DEBUG_WRITE    |fwr    |
 * |CMD_DEBUG_CLOSE    |fcl    |
 < ASCII > 
 */
```
## Visual type:
- #table


== ./linux/linux_94.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/ia64/kernel/mca_drv.h#L9-L34

```c
/*
 * Processor error section:
 *
 < ASCII >
 *  +-sal_log_processor_info_t *info-------------+
 *  | sal_log_section_hdr_t header;              |
 *  | ...                                        |
 *  | sal_log_mod_error_info_t info[0];          |
 *  +-+----------------+-------------------------+
 *    | CACHE_CHECK    |  ^ num_cache_check v
 *    +----------------+
 *    | TLB_CHECK      |  ^ num_tlb_check v
 *    +----------------+
 *    | BUS_CHECK      |  ^ num_bus_check v
 *    +----------------+
 *    | REG_FILE_CHECK |  ^ num_reg_file_check v
 *    +----------------+
 *    | MS_CHECK       |  ^ num_ms_check v
 *  +-struct cpuid_info *id----------------------+
 *  | regs[5];                                   |
 *  | reserved;                                  |
 *  +-sal_processor_static_info_t *regs----------+
 *  | valid;                                     |
 *  | ...                                        |
 *  | fr[128];                                   |
 *  +--------------------------------------------+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_940.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L938-L951

```c
/**
 * @brief Response with MRQ_RESET
 *
 * Each sub-command supported by @ref mrq_reset_request may return
 * sub-command-specific data. Some do and some do not as indicated
 * in the following table
 *
 < ASCII >
 * | sub-command          | payload          |
 * |----------------------|------------------|
 * | CMD_RESET_ASSERT     | -                |
 * | CMD_RESET_DEASSERT   | -                |
 * | CMD_RESET_MODULE     | -                |
 * | CMD_RESET_GET_MAX_ID | reset_get_max_id |
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_941.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L1302-L1326

```c
/**
 * @ingroup Clocks
 * @brief Request with #MRQ_CLK
 *
 * Used by the sender of an #MRQ_CLK message to control clocks. The
 * clk_request is split into several sub-commands. Some sub-commands
 * require no additional data. Others have a sub-command specific
 * payload
 *
 < ASCII >
 * |sub-command                 |payload                |
 * |----------------------------|-----------------------|
 * |CMD_CLK_GET_RATE            |-                      |
 * |CMD_CLK_SET_RATE            |clk_set_rate           |
 * |CMD_CLK_ROUND_RATE          |clk_round_rate         |
 * |CMD_CLK_GET_PARENT          |-                      |
 * |CMD_CLK_SET_PARENT          |clk_set_parent         |
 * |CMD_CLK_IS_ENABLED          |-                      |
 * |CMD_CLK_ENABLE              |-                      |
 * |CMD_CLK_DISABLE             |-                      |
 * |CMD_CLK_GET_ALL_INFO        |-                      |
 * |CMD_CLK_GET_MAX_CLK_ID      |-                      |
 * |CMD_CLK_GET_FMAX_AT_VMIN    |-
 * |
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_942.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L1328-L1337

```c
/** @cond DEPRECATED
 *
 < ASCII >
 * Older versions of firmware also supported following sub-commands:
 * |CMD_CLK_PROPERTIES          |-                      |
 * |CMD_CLK_POSSIBLE_PARENTS    |-                      |
 * |CMD_CLK_NUM_POSSIBLE_PARENTS|-                      |
 * |CMD_CLK_GET_POSSIBLE_PARENT |clk_get_possible_parent|
 * |CMD_CLK_RESET_REFCOUNTS     |-                      |
 < ASCII >
 *
 * @endcond DEPRECATED */
```
## Visual type:
- #table


== ./linux/linux_943.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L1378-L1400

```c
/**
 * @ingroup Clocks
 * @brief Response to MRQ_CLK
 *
 * Each sub-command supported by @ref mrq_clk_request may return
 * sub-command-specific data. Some do and some do not as indicated in
 * the following table
 *
 < ASCII >
 * |sub-command                 |payload                 |
 * |----------------------------|------------------------|
 * |CMD_CLK_GET_RATE            |clk_get_rate            |
 * |CMD_CLK_SET_RATE            |clk_set_rate            |
 * |CMD_CLK_ROUND_RATE          |clk_round_rate          |
 * |CMD_CLK_GET_PARENT          |clk_get_parent          |
 * |CMD_CLK_SET_PARENT          |clk_set_parent          |
 * |CMD_CLK_IS_ENABLED          |clk_is_enabled          |
 * |CMD_CLK_ENABLE              |-                       |
 * |CMD_CLK_DISABLE             |-                       |
 * |CMD_CLK_GET_ALL_INFO        |clk_get_all_info        |
 * |CMD_CLK_GET_MAX_CLK_ID      |clk_get_max_id          |
 * |CMD_CLK_GET_FMAX_AT_VMIN    |clk_get_fmax_at_vmin    |
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_944.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L1402-L1411

```c
/** @cond DEPRECATED
 *
 < ASCII >
 * Older versions of firmware also supported following sub-commands:
 * |CMD_CLK_PROPERTIES          |clk_properties          |
 * |CMD_CLK_POSSIBLE_PARENTS    |clk_possible_parents    |
 * |CMD_CLK_NUM_POSSIBLE_PARENTS|clk_num_possible_parents|
 * |CMD_CLK_GET_POSSIBLE_PARENT |clk_get_possible_parents|
 * |CMD_CLK_RESET_REFCOUNTS     |-                       |
 < ASCII >
 *
 * @endcond DEPRECATED */
```
## Visual type:
- #table


== ./linux/linux_945.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L1605-L1621

```c
/**
 * @brief Request with #MRQ_PG
 *
 * Used by the sender of an #MRQ_PG message to control power
 * partitions. The pg_request is split into several sub-commands. Some
 * sub-commands require no additional data. Others have a sub-command
 * specific payload
 *
 < ASCII >
 * |sub-command                 |payload                |
 * |----------------------------|-----------------------|
 * |CMD_PG_QUERY_ABI            | query_abi             |
 * |CMD_PG_SET_STATE            | set_state             |
 * |CMD_PG_GET_STATE            | -                     |
 * |CMD_PG_GET_NAME             | -                     |
 * |CMD_PG_GET_MAX_ID           | -                     |
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_946.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L1631-L1645

```c
/**
 * @brief Response to MRQ_PG
 *
 * Each sub-command supported by @ref mrq_pg_request may return
 * sub-command-specific data. Some do and some do not as indicated in
 * the following table
 *
 < ASCII >
 * |sub-command                 |payload                |
 * |----------------------------|-----------------------|
 * |CMD_PG_QUERY_ABI            | -                     |
 * |CMD_PG_SET_STATE            | -                     |
 * |CMD_PG_GET_STATE            | get_state             |
 * |CMD_PG_GET_NAME             | get_name              |
 * |CMD_PG_GET_MAX_ID           | get_max_id            |
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_947.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L2270-L2279

```c
/*
 * @brief Request with #MRQ_BWMGR
 *
 *
 < ASCII >
 * |sub-command                 |payload                       |
 * |----------------------------|------------------------------|
 * |CMD_BWMGR_QUERY_ABI         | cmd_bwmgr_query_abi_request  |
 * |CMD_BWMGR_CALC_RATE         | cmd_bwmgr_calc_rate_request  |
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_948.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L2288-L2294

```c
/*
 * @brief Response to MRQ_BWMGR
 *
 < ASCII >
 * |sub-command                 |payload                       |
 * |----------------------------|------------------------------|
 * |CMD_BWMGR_CALC_RATE         | cmd_bwmgr_calc_rate_response |
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_949.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L2414-L2424

```c
/*
 * @brief Request with #MRQ_BWMGR_INT
 *
 *
 < ASCII >
 * |sub-command                 |payload                            |
 * |----------------------------|-----------------------------------|
 * |CMD_BWMGR_INT_QUERY_ABI     | cmd_bwmgr_int_query_abi_request   |
 * |CMD_BWMGR_INT_CALC_AND_SET  | cmd_bwmgr_int_calc_and_set_request|
 * |CMD_BWMGR_INT_CAP_SET       | cmd_bwmgr_int_cap_set_request     |
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_95.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/ia64/kernel/patch.c#L16-L28

```c
/*
 * This was adapted from code written by Tony Luck:
 *
 * The 64-bit value in a "movl reg=value" is scattered between the two words of the bundle
 * like this:
 *
 < ASCII >
 * 6  6         5         4         3         2         1
 * 3210987654321098765432109876543210987654321098765432109876543210
 * ABBBBBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCDEEEEEFFFFFFFFFGGGGGGG
 *
 * CCCCCCCCCCCCCCCCCCxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 * xxxxAFFFFFFFFFEEEEEDxGGGGGGGxxxxxxxxxxxxxBBBBBBBBBBBBBBBBBBBBBBB
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_950.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L2434-L2440

```c
/*
 * @brief Response to MRQ_BWMGR_INT
 *
 < ASCII >
 * |sub-command                 |payload                                |
 * |----------------------------|---------------------------------------|
 * |CMD_BWMGR_INT_CALC_AND_SET  | cmd_bwmgr_int_calc_and_set_response   |
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_951.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L2591-L2603

```c
/**
 * @brief Request with #MRQ_ISO_CLIENT
 *
 * Used by the sender of an #MRQ_ISO_CLIENT message.
 *
 < ASCII >
 * |sub-command                          |payload                                 |
 * |------------------------------------ |----------------------------------------|
 * |CMD_ISO_CLIENT_QUERY_ABI		 |cmd_iso_client_query_abi_request        |
 * |CMD_ISO_CLIENT_CALCULATE_LA		 |cmd_iso_client_calculate_la_request     |
 * |CMD_ISO_CLIENT_SET_LA		 |cmd_iso_client_set_la_request           |
 * |CMD_ISO_CLIENT_GET_MAX_BW		 |cmd_iso_client_get_max_bw_request       |
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_952.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L2616-L2629

```c
/**
 * @brief Response to MRQ_ISO_CLIENT
 *
 * Each sub-command supported by @ref mrq_iso_client_request may return
 * sub-command-specific data. Some do and some do not as indicated in
 * the following table
 *
 < ASCII >
 * |sub-command                  |payload                             |
 * |---------------------------- |------------------------------------|
 * |CMD_ISO_CLIENT_CALCULATE_LA  |cmd_iso_client_calculate_la_response|
 * |CMD_ISO_CLIENT_SET_LA        |N/A                                 |
 * |CMD_ISO_CLIENT_GET_MAX_BW    |cmd_iso_client_get_max_bw_response  |
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_953.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L3027-L3047

```c
/**
 * @ingroup UPHY
 * @brief Request with #MRQ_UPHY
 *
 * Used by the sender of an #MRQ_UPHY message to control UPHY.
 * The uphy_request is split into several sub-commands. CMD_UPHY_PCIE_LANE_MARGIN_STATUS
 * requires no additional data. Others have a sub-command specific payload. Below table
 * shows sub-commands with their corresponding payload data.
 *
 < ASCII >
 * |sub-command                          |payload                                 |
 * |------------------------------------ |----------------------------------------|
 * |CMD_UPHY_PCIE_LANE_MARGIN_CONTROL    |uphy_set_margin_control                 |
 * |CMD_UPHY_PCIE_LANE_MARGIN_STATUS     |                                        |
 * |CMD_UPHY_PCIE_EP_CONTROLLER_PLL_INIT |cmd_uphy_ep_controller_pll_init_request |
 * |CMD_UPHY_PCIE_CONTROLLER_STATE       |cmd_uphy_pcie_controller_state_request  |
 * |CMD_UPHY_PCIE_EP_CONTROLLER_PLL_OFF  |cmd_uphy_ep_controller_pll_off_request  |
 * |CMD_UPHY_PCIE_DISPLAY_PORT_INIT      |cmd_uphy_display_port_init_request      |
 * |CMD_UPHY_PCIE_DISPLAY_PORT_OFF       |                                        |
 * |CMD_UPHY_XUSB_DYN_LANES_RESTORE      |cmd_uphy_xusb_dyn_lanes_restore_request |
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_954.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L3065-L3078

```c
/**
 * @ingroup UPHY
 * @brief Response to MRQ_UPHY
 *
 * Each sub-command supported by @ref mrq_uphy_request may return
 * sub-command-specific data. Some do and some do not as indicated in
 * the following table
 *
 < ASCII >
 * |sub-command                       |payload                 |
 * |----------------------------      |------------------------|
 * |CMD_UPHY_PCIE_LANE_MARGIN_CONTROL |                        |
 * |CMD_UPHY_PCIE_LANE_MARGIN_STATUS  |uphy_get_margin_status  |
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_955.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L3234-L3250

```c
/**
 * @ingroup FMON
 * @brief Request with #MRQ_FMON
 *
 * Used by the sender of an #MRQ_FMON message to configure clock
 * frequency monitors. The FMON request is split into several
 * sub-commands. Some sub-commands require no additional data.
 * Others have a sub-command specific payload
 *
 < ASCII >
 * |sub-command                 |payload                |
 * |----------------------------|-----------------------|
 * |CMD_FMON_GEAR_CLAMP         |fmon_gear_clamp        |
 * |CMD_FMON_GEAR_FREE          |-                      |
 * |CMD_FMON_GEAR_GET           |-                      |
 * |CMD_FMON_FAULT_STS_GET      |fmon_fault_sts_get     |
 *
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_956.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L3269-L3283

```c
/**
 * @ingroup FMON
 * @brief Response to MRQ_FMON
 *
 * Each sub-command supported by @ref mrq_fmon_request may
 * return sub-command-specific data as indicated below.
 *
 < ASCII >
 * |sub-command                 |payload                 |
 * |----------------------------|------------------------|
 * |CMD_FMON_GEAR_CLAMP         |-                       |
 * |CMD_FMON_GEAR_FREE          |-                       |
 * |CMD_FMON_GEAR_GET           |fmon_gear_get           |
 * |CMD_FMON_FAULT_STS_GET      |fmon_fault_sts_get      |
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_957.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L3454-L3458

```c
/**
 < ASCII >
 * |error type                       | fmon_clk_id values        |
 * |---------------------------------|---------------------------|
 * |@ref EC_ERR_TYPE_CLOCK_MONITOR   |@ref bpmp_clock_ids        |
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_958.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L3474-L3478

```c
/**
 < ASCII >
 * | error type                      | vmon_adc_id values        |
 * |---------------------------------|---------------------------|
 * |@ref EC_ERR_TYPE_VOLTAGE_MONITOR |@ref bpmp_adc_ids          |
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_959.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L3490-L3494

```c
/**
 < ASCII >
 * |error type                       | reg_id values         |
 * |---------------------------------|-----------------------|
 * |@ref EC_ERR_TYPE_REGISTER_PARITY | bpmp_ec_registers_ids |
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_96.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/ia64/kernel/process.c#L267-L297

```c
/*
 * Copy the state of an ia-64 thread.
 *
 * We get here through the following  call chain:
 *
 *	from user-level:	from kernel:
 *
 *	<clone syscall>	        <some kernel call frames>
 *	sys_clone		   :
 *	kernel_clone		kernel_clone
 *	copy_thread		copy_thread
 *
 * This means that the stack layout is as follows:
 *
 < ASCII >
 *	+---------------------+ (highest addr)
 *	|   struct pt_regs    |
 *	+---------------------+
 *	| struct switch_stack |
 *	+---------------------+
 *	|                     |
 *	|    memory stack     |
 *	|                     | <-- sp (lowest addr)
 *	+---------------------+
 < ASCII >
 *
 * Observe that we copy the unat values that are in pt_regs and switch_stack.  Spilling an
 * integer to address X causes bit N in ar.unat to be set to the NaT bit of the register,
 * with N=(X & 0x1ff)/8.  Thus, copying the unat value preserves the NaT bits ONLY if the
 * pt_regs structure in the parent is congruent to that of the child, modulo 512.  Since
 * the stack is page aligned and the page size is at least 4KB, this is always the case,
 * so there is nothing to worry about.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_960.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L3519-L3529

```c
/**
 < ASCII >
 * |error type                              | err_source_id values   |
 * |----------------------------------------|------------------------|
 * |@ref EC_ERR_TYPE_PARITY_INTERNAL        |  bpmp_ec_ipath_ids     |
 * |@ref EC_ERR_TYPE_ECC_SEC_INTERNAL       |  bpmp_ec_ipath_ids     |
 * |@ref EC_ERR_TYPE_ECC_DED_INTERNAL       |  bpmp_ec_ipath_ids     |
 * |@ref EC_ERR_TYPE_COMPARATOR             |  bpmp_ec_comparator_ids|
 * |@ref EC_ERR_TYPE_OTHER_HW_CORRECTABLE   |  bpmp_ec_misc_hwd_ids  |
 * |@ref EC_ERR_TYPE_OTHER_HW_UNCORRECTABLE |  bpmp_ec_misc_hwd_ids  |
 * |@ref EC_ERR_TYPE_PARITY_SRAM            |  bpmp_clock_ids        |
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_961.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L3602-L3619

```c
/**
 * @ingroup EC
 * @brief Request with #MRQ_EC
 *
 * Used by the sender of an #MRQ_EC message to access ECs owned
 * by BPMP.
 *
 < ASCII >
 * @cond DEPRECATED
 * |sub-command                 |payload                |
 * |----------------------------|-----------------------|
 * |@ref CMD_EC_STATUS_GET      |ec_status_get          |
 * @endcond DEPRECATED
 *
 * |sub-command                 |payload                |
 * |----------------------------|-----------------------|
 * |@ref CMD_EC_STATUS_EX_GET   |ec_status_get          |
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_962.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L3630-L3647

```c
/**
 * @ingroup EC
 * @brief Response to MRQ_EC
 *
 * Each sub-command supported by @ref mrq_ec_request may return
 * sub-command-specific data as indicated below.
 *
 < ASCII >
 * @cond DEPRECATED
 * |sub-command                 |payload                 |
 * |----------------------------|------------------------|
 * |@ref CMD_EC_STATUS_GET      |ec_status_get           |
 * @endcond DEPRECATED
 *
 * |sub-command                 |payload                 |
 * |----------------------------|------------------------|
 * |@ref CMD_EC_STATUS_EX_GET   |ec_status_ex_get        |
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_963.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L3826-L3835

```c
/**
 * @brief Request with #MRQ_PWR_LIMIT
 *
 < ASCII >
 * |sub-command                 |payload                          |
 * |----------------------------|---------------------------------|
 * |CMD_PWR_LIMIT_QUERY_ABI     | cmd_pwr_limit_query_abi_request |
 * |CMD_PWR_LIMIT_SET           | cmd_pwr_limit_set_request       |
 * |CMD_PWR_LIMIT_GET           | cmd_pwr_limit_get_request       |
 * |CMD_PWR_LIMIT_CURR_CAP      | cmd_pwr_limit_curr_cap_request  |
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_964.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/soc/tegra/bpmp-abi.h#L3846-L3855

```c
/**
 * @brief Response to MRQ_PWR_LIMIT
 *
 < ASCII >
 * |sub-command                 |payload                          |
 * |----------------------------|---------------------------------|
 * |CMD_PWR_LIMIT_QUERY_ABI     | -                               |
 * |CMD_PWR_LIMIT_SET           | -                               |
 * |CMD_PWR_LIMIT_GET           | cmd_pwr_limit_get_response      |
 * |CMD_PWR_LIMIT_CURR_CAP      | cmd_pwr_limit_curr_cap_response |
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_965.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/sound/opl3.h#L160-L193

```c
/*
 *    In the 4 OP mode there is four possible configurations how the
 *      operators can be connected together (in 2 OP modes there is just
 *      AM or FM). The 4 OP connection mode is defined by the rightmost
 *      bit of the FEEDBACK_CONNECTION (0xC0-0xC8) on the both halves.
 *
 < ASCII >
 *      First half      Second half     Mode
 *
 *                                       +---+
 *                                       v   |
 *      0               0               >+-1-+--2--3--4-->
 *
 *
 *                                      
 *                                       +---+
 *                                       |   |
 *      0               1               >+-1-+--2-+
 *                                                |->
 *                                      >--3----4-+
 *                                      
 *                                       +---+
 *                                       |   |
 *      1               0               >+-1-+-----+
 *                                                 |->
 *                                      >--2--3--4-+
 *
 *                                       +---+
 *                                       |   |
 *      1               1               >+-1-+--+
 *                                              |
 *                                      >--2--3-+->
 *                                              |
 *                                      >--4----+
 < ASCII >
 */
```
## Visual type:
- #custom


== ./linux/linux_966.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/drm/drm_fourcc.h#L1167-L1225

```c
/*
 * Arm Fixed-Rate Compression (AFRC) modifiers
 *
 * AFRC is a proprietary fixed rate image compression protocol and format,
 * designed to provide guaranteed bandwidth and memory footprint
 * reductions in graphics and media use-cases.
 *
 * AFRC buffers consist of one or more planes, with the same components
 * and meaning as an uncompressed buffer using the same pixel format.
 *
 * Within each plane, the pixel/luma/chroma values are grouped into
 * "coding unit" blocks which are individually compressed to a
 * fixed size (in bytes). All coding units within a given plane of a buffer
 * store the same number of values, and have the same compressed size.
 *
 * The coding unit size is configurable, allowing different rates of compression.
 *
 * The start of each AFRC buffer plane must be aligned to an alignment granule which
 * depends on the coding unit size.
 *
 < ASCII >
 * Coding Unit Size   Plane Alignment
 * ----------------   ---------------
 * 16 bytes           1024 bytes
 * 24 bytes           512  bytes
 * 32 bytes           2048 bytes
 < ASCII >
 *
 * Coding units are grouped into paging tiles. AFRC buffer dimensions must be aligned
 * to a multiple of the paging tile dimensions.
 * The dimensions of each paging tile depend on whether the buffer is optimised for
 * scanline (SCAN layout) or rotated (ROT layout) access.
 *
 < ASCII >
 * Layout   Paging Tile Width   Paging Tile Height
 * ------   -----------------   ------------------
 * SCAN     16 coding units     4 coding units
 * ROT      8  coding units     8 coding units
 < ASCII >
 *
 * The dimensions of each coding unit depend on the number of components
 * in the compressed plane and whether the buffer is optimised for
 * scanline (SCAN layout) or rotated (ROT layout) access.
 *
 < ASCII >
 * Number of Components in Plane   Layout      Coding Unit Width   Coding Unit Height
 * -----------------------------   ---------   -----------------   ------------------
 * 1                               SCAN        16 samples          4 samples
 * Example: 16x4 luma samples in a 'Y' plane
 *          16x4 chroma 'V' values, in the 'V' plane of a fully-planar YUV buffer
 * -----------------------------   ---------   -----------------   ------------------
 * 1                               ROT         8 samples           8 samples
 * Example: 8x8 luma samples in a 'Y' plane
 *          8x8 chroma 'V' values, in the 'V' plane of a fully-planar YUV buffer
 * -----------------------------   ---------   -----------------   ------------------
 * 2                               DONT CARE   8 samples           4 samples
 * Example: 8x4 chroma pairs in the 'UV' plane of a semi-planar YUV buffer
 * -----------------------------   ---------   -----------------   ------------------
 * 3                               DONT CARE   4 samples           4 samples
 * Example: 4x4 pixels in an RGB buffer without alpha
 * -----------------------------   ---------   -----------------   ------------------
 * 4                               DONT CARE   4 samples           4 samples
 < ASCII >
 * Example: 4x4 pixels in an RGB buffer with alpha
 */
```
## Visual type:
- #table


== ./linux/linux_967.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/acrn.h#L86-L147

```c
/**
 * struct acrn_io_request - 256-byte ACRN I/O request
 * @type:		Type of this request (ACRN_IOREQ_TYPE_*).
 * @completion_polling:	Polling flag. Hypervisor will poll completion of the
 *			I/O request if this flag set.
 * @reserved0:		Reserved fields.
 * @reqs:		Union of different types of request. Byte offset: 64.
 * @reqs.pio_request:	PIO request data of the I/O request.
 * @reqs.pci_request:	PCI configuration space request data of the I/O request.
 * @reqs.mmio_request:	MMIO request data of the I/O request.
 * @reqs.data:		Raw data of the I/O request.
 * @reserved1:		Reserved fields.
 * @kernel_handled:	Flag indicates this request need be handled in kernel.
 * @processed:		The status of this request (ACRN_IOREQ_STATE_*).
 *
 < ASCII >
 * The state transitions of ACRN I/O request:
 *
 *    FREE -> PENDING -> PROCESSING -> COMPLETE -> FREE -> ...
 < ASCII >
 *
 * An I/O request in COMPLETE or FREE state is owned by the hypervisor. HSM and
 * ACRN userspace are in charge of processing the others.
 *
 * On basis of the states illustrated above, a typical lifecycle of ACRN IO
 * request would look like:
 *
 < ASCII >
 * Flow                 (assume the initial state is FREE)
 * |
 * |   Service VM vCPU 0     Service VM vCPU x      User vCPU y
 * |
 * |                                             hypervisor:
 * |                                               fills in type, addr, etc.
 * |                                               pauses the User VM vCPU y
 * |                                               sets the state to PENDING (a)
 * |                                               fires an upcall to Service VM
 * |
 * | HSM:
 * |  scans for PENDING requests
 * |  sets the states to PROCESSING (b)
 * |  assigns the requests to clients (c)
 * V
 * |                     client:
 * |                       scans for the assigned requests
 * |                       handles the requests (d)
 * |                     HSM:
 * |                       sets states to COMPLETE
 * |                       notifies the hypervisor
 * |
 * |                     hypervisor:
 * |                       resumes User VM vCPU y (e)
 * |
 * |                                             hypervisor:
 * |                                               post handling (f)
 * V                                               sets states to FREE
 < ASCII >
 *
 * Note that the procedures (a) to (f) in the illustration above require to be
 * strictly processed in the order.  One vCPU cannot trigger another request of
 * I/O emulation before completing the previous one.
 *
 * Atomic and barriers are required when HSM and hypervisor accessing the state
 * of &struct acrn_io_request.
 *
 */
```
## Visual type:
- #custom


== ./linux/linux_968.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/audit.h#L303-L317

```c
/* These are the supported operators.
 < ASCII >
 *	4  2  1  8
 *	=  >  <  ?
 *	----------
 *	0  0  0	 0	00	nonsense
 *	0  0  0	 1	08	&  bit mask
 *	0  0  1	 0	10	<
 *	0  1  0	 0	20	>
 *	0  1  1	 0	30	!=
 *	1  0  0	 0	40	=
 *	1  0  0	 1	48	&=  bit test
 *	1  0  1	 0	50	<=
 *	1  1  0	 0	60	>=
 *	1  1  1	 1	78	all operators
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_969.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/cdrom.h#L317-L349

```c
/*
 * A CD-ROM physical sector size is 2048, 2052, 2056, 2324, 2332, 2336, 
 * 2340, or 2352 bytes long.  

 < ASCII >
*         Sector types of the standard CD-ROM data formats:
 *
 * format   sector type               user data size (bytes)
 * -----------------------------------------------------------------------------
 *   1     (Red Book)    CD-DA          2352    (CD_FRAMESIZE_RAW)
 *   2     (Yellow Book) Mode1 Form1    2048    (CD_FRAMESIZE)
 *   3     (Yellow Book) Mode1 Form2    2336    (CD_FRAMESIZE_RAW0)
 *   4     (Green Book)  Mode2 Form1    2048    (CD_FRAMESIZE)
 *   5     (Green Book)  Mode2 Form2    2328    (2324+4 spare bytes)
 *
 *
 *       The layout of the standard CD-ROM data formats:
 * -----------------------------------------------------------------------------
 * - audio (red):                  | audio_sample_bytes |
 *                                 |        2352        |
 *
 * - data (yellow, mode1):         | sync - head - data - EDC - zero - ECC |
 *                                 |  12  -   4  - 2048 -  4  -   8  - 276 |
 *
 * - data (yellow, mode2):         | sync - head - data |
 *                                 |  12  -   4  - 2336 |
 *
 * - XA data (green, mode2 form1): | sync - head - sub - data - EDC - ECC |
 *                                 |  12  -   4  -  8  - 2048 -  4  - 276 |
 *
 * - XA data (green, mode2 form2): | sync - head - sub - data - Spare |
 *                                 |  12  -   4  -  8  - 2324 -  4    |
 < ASCII >
 *
 */
```
## Visual type:
- #table


== ./linux/linux_97.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/ia64/kernel/ptrace.c#L193-L246

```c
/*
 * This routine is used to read an rnat bits that are stored on the
 * kernel backing store.  Since, in general, the alignment of the user
 * and kernel are different, this is not completely trivial.  In
 * essence, we need to construct the user RNAT based on up to two
 * kernel RNAT values and/or the RNAT value saved in the child's
 * pt_regs.
 *
 < ASCII >
 * user rbs
 *
 * +--------+ <-- lowest address
 * | slot62 |
 * +--------+
 * |  rnat  | 0x....1f8
 * +--------+
 * | slot00 | \
 * +--------+ |
 * | slot01 | > child_regs->ar_rnat
 * +--------+ |
 * | slot02 | /				kernel rbs
 * +--------+				+--------+
 *	    <- child_regs->ar_bspstore	| slot61 | <-- krbs
 * +- - - - +				+--------+
 *					| slot62 |
 * +- - - - +				+--------+
 *					|  rnat	 |
 * +- - - - +				+--------+
 *   vrnat				| slot00 |
 * +- - - - +				+--------+
 *					=	 =
 *					+--------+
 *					| slot00 | \
 *					+--------+ |
 *					| slot01 | > child_stack->ar_rnat
 *					+--------+ |
 *					| slot02 | /
 *					+--------+
 *						  <--- child_stack->ar_bspstore
 < ASCII >
 *
 * The way to think of this code is as follows: bit 0 in the user rnat
 * corresponds to some bit N (0 <= N <= 62) in one of the kernel rnat
 * value.  The kernel rnat value holding this bit is stored in
 * variable rnat0.  rnat1 is loaded with the kernel rnat value that
 * form the upper bits of the user rnat value.
 *
 * Boundary cases:
 *
 * o when reading the rnat "below" the first rnat slot on the kernel
 *   backing store, rnat0/rnat1 are set to 0 and the low order bits are
 *   merged in from pt->ar_rnat.
 *
 * o when reading the rnat "above" the last rnat slot on the kernel
 *   backing store, rnat0/rnat1 gets its value from sw->ar_rnat.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_970.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/kvm.h#L2071-L2093

```c
/*
 < ASCII >
 * KVM dirty GFN flags, defined as:
 *
 * |---------------+---------------+--------------|
 * | bit 1 (reset) | bit 0 (dirty) | Status       |
 * |---------------+---------------+--------------|
 * |             0 |             0 | Invalid GFN  |
 * |             0 |             1 | Dirty GFN    |
 * |             1 |             X | GFN to reset |
 * |---------------+---------------+--------------|
 *
 * Lifecycle of a dirty GFN goes like:
 *
 *      dirtied         harvested        reset
 * 00 -----------> 01 -------------> 1X -------+
 *  ^                                          |
 *  |                                          |
 *  +------------------------------------------+
 < ASCII >
 *
 * The userspace program is only responsible for the 01->1X state
 * conversion after harvesting an entry.  Also, it must not skip any
 * dirty bits, so that dirty bits are always harvested in sequence.
 */
```
## Visual type:
- #custom


== ./linux/linux_971.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/map_to_14segment.h#L13-L58

```c
/* This file provides translation primitives and tables for the conversion
 * of (ASCII) characters to a 14-segments notation.
 *
 * The 14 segment's wikipedia notation below is used as standard.
 * See: https://en.wikipedia.org/wiki/Fourteen-segment_display
 *
 < ASCII >
 * Notation:	+---a---+
 *		|\  |  /|
 *		f h i j b
 *		|  \|/  |
 *		+-g1+-g2+
 *		|  /|\  |
 *		e k l m c
 *		|/  |  \|
 *		+---d---+
 < ASCII >
 *
 * Usage:
 *
 *   Register a map variable, and fill it with a character set:
 *	static SEG14_DEFAULT_MAP(map_seg14);
 *
 *
 *   Then use for conversion:
 *	seg14 = map_to_seg14(&map_seg14, some_char);
 *	...
 *
 * In device drivers it is recommended, if required, to make the char map
 * accessible via the sysfs interface using the following scheme:
 *
 * static ssize_t map_seg14_show(struct device *dev,
 *				 struct device_attribute *attr, char *buf)
 * {
 *	memcpy(buf, &map_seg14, sizeof(map_seg14));
 *	return sizeof(map_seg14);
 * }
 * static ssize_t map_seg14_store(struct device *dev,
 *				  struct device_attribute *attr,
 *				  const char *buf, size_t cnt)
 * {
 *	if (cnt != sizeof(map_seg14))
 *		return -EINVAL;
 *	memcpy(&map_seg14, buf, cnt);
 *	return cnt;
 * }
 * static DEVICE_ATTR_RW(map_seg14);
 */
```
## Visual type:
- #custom


== ./linux/linux_972.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/mpls.h#L8-L20

```c
/* Reference: RFC 5462, RFC 3032
 *
 < ASCII >
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                Label                  | TC  |S|       TTL     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 < ASCII >
 *
 *	Label:  Label Value, 20 bits
 *	TC:     Traffic Class field, 3 bits
 *	S:      Bottom of Stack, 1 bit
 *	TTL:    Time to Live, 8 bits
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_973.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/netlink.h#L220-L227

```c
/*
 < ASCII >
 *  <------- NLA_HDRLEN ------> <-- NLA_ALIGN(payload)-->
 * +---------------------+- - -+- - - - - - - - - -+- - -+
 * |        Header       | Pad |     Payload       | Pad |
 * |   (struct nlattr)   | ing |                   | ing |
 * +---------------------+- - -+- - - - - - - - - -+- - -+
 *  <-------------- nlattr->nla_len -------------->
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_974.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/netlink.h#L234-L243

```c
/*
 < ASCII >
 * nla_type (16 bits)
 * +---+---+-------------------------------+
 * | N | O | Attribute Type                |
 * +---+---+-------------------------------+
 < ASCII >
 * N := Carries nested attributes
 * O := Payload stored in network byte order
 *
 * Note: The N and O flag are mutually exclusive.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_975.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/omap3isp.h#L556-L563

```c
/**
 * struct omap3isp_prev_rgbtorgb - RGB to RGB Blending
 < ASCII >
 * @matrix: Blending values(S12Q8 format)
 *              [RR] [GR] [BR]
 *              [RG] [GG] [BG]
 *              [RB] [GB] [BB]
 < ASCII >
 * @offset: Blending offset value for R,G,B in 2's complement integer format.
 */
```
## Visual type:
- #matrix


== ./linux/linux_976.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/perf_event.h#L739-L753

```c
/*
 * The current state of perf_event_header::misc bits usage:
 * ('|' used bit, '-' unused bit)
 *
 < ASCII >
 *  012         CDEF
 *  |||---------||||
 < ASCII >
 *
 *  Where:
 *    0-2     CPUMODE_MASK
 *
 *    C       PROC_MAP_PARSE_TIMEOUT
 *    D       MMAP_DATA / COMM_EXEC / FORK_EXEC / SWITCH_OUT
 *    E       MMAP_BUILD_ID / EXACT_IP / SCHED_OUT_PREEMPT
 *    F       (reserved)
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_977.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/pkt_cls.h#L747-L760

```c
 < ASCII >
/*  0                   1
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 
 * +-----------------------+-+-+---+
 * |         Unused        |S|I| R |
 * +-----------------------+-+-+---+
 < ASCII >
 *
 * R(2) ::= relation to next ematch
 *          where: 0 0 END (last ematch)
 *                 0 1 AND
 *                 1 0 OR
 *                 1 1 Unused (invalid)
 * I(1) ::= invert result
 * S(1) ::= simple payload
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_978.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/serial_reg.h#L53-L67

```c
/*
 * Note: The FIFO trigger levels are chip specific:
 < ASCII >
 *	RX:76 = 00  01  10  11	TX:54 = 00  01  10  11
 * PC16550D:	 1   4   8  14		xx  xx  xx  xx
 * TI16C550A:	 1   4   8  14          xx  xx  xx  xx
 * TI16C550C:	 1   4   8  14          xx  xx  xx  xx
 * ST16C550:	 1   4   8  14		xx  xx  xx  xx
 * ST16C650:	 8  16  24  28		16   8  24  30	PORT_16650V2
 * NS16C552:	 1   4   8  14		xx  xx  xx  xx
 * ST16C654:	 8  16  56  60		 8  16  32  56	PORT_16654
 * TI16C750:	 1  16  32  56		xx  xx  xx  xx	PORT_16750
 * TI16C752:	 8  16  56  60		 8  16  32  56
 * OX16C950:	16  32 112 120		16  32  64 112	PORT_16C950
 * Tegra:	 1   4   8  14		16   8   4   1	PORT_TEGRA
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_979.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/vsockmon.h#L7-L32

```c
/*
 * vsockmon is the AF_VSOCK packet capture device.  Packets captured have the
 * following layout:
 *
 < ASCII >
 *   +-----------------------------------+
 *   |           vsockmon header         |
 *   |      (struct af_vsockmon_hdr)     |
 *   +-----------------------------------+
 *   |          transport header         |
 *   | (af_vsockmon_hdr->len bytes long) |
 *   +-----------------------------------+
 *   |              payload              |
 *   |       (until end of packet)       |
 *   +-----------------------------------+
 < ASCII >
 *
 * The vsockmon header is a transport-independent description of the packet.
 * It duplicates some of the information from the transport header so that
 * no transport-specific knowledge is necessary to process packets.
 *
 * The transport header is useful for low-level transport-specific packet
 * analysis.  Transport type is given in af_vsockmon_hdr->transport and
 * transport header length is given in af_vsockmon_hdr->len.
 *
 * If af_vsockmon_hdr->op is AF_VSOCK_OP_PAYLOAD then the payload follows the
 * transport header.  Other ops do not have a payload.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_98.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/ia64/kernel/smpboot.c#L242-L273

```c
/*
 * Synchronize ar.itc of the current (slave) CPU with the ar.itc of the MASTER CPU
 * (normally the time-keeper CPU).  We use a closed loop to eliminate the possibility of
 * unaccounted-for errors (such as getting a machine check in the middle of a calibration
 * step).  The basic idea is for the slave to ask the master what itc value it has and to
 * read its own itc before and after the master responds.  Each iteration gives us three
 * timestamps:
 *
 < ASCII >
 *	slave		master
 *
 *	t0 ---\
 *             ---\
 *		   --->
 *			tm
 *		   /---
 *	       /---
 *	t1 <---
 < ASCII >
 *
 *
 * The goal is to adjust the slave's ar.itc such that tm falls exactly half-way between t0
 * and t1.  If we achieve this, the clocks are synchronized provided the interconnect
 * between the slave and the master is symmetric.  Even if the interconnect were
 * asymmetric, we would still know that the synchronization error is smaller than the
 * roundtrip latency (t0 - t1).
 *
 * When the interconnect is quiet and symmetric, this lets us synchronize the itc to
 * within one or two cycles.  However, we can only *guarantee* that the synchronization is
 * accurate to within a round-trip time, which is typically in the range of several
 * hundred cycles (e.g., ~500 cycles).  In practice, this means that the itc's are usually
 * almost perfectly synchronized, but we shouldn't assume that the accuracy is much better
 * than half a micro second or so.
 */
```
## Visual type:
- #sequence-diagram


== ./linux/linux_980.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/usb/functionfs.h#L89-L178

```c
/*
 < ASCII >
 * Descriptors format:
 *
 * | off | name      | type         | description                          |
 * |-----+-----------+--------------+--------------------------------------|
 * |   0 | magic     | LE32         | FUNCTIONFS_DESCRIPTORS_MAGIC_V2      |
 * |   4 | length    | LE32         | length of the whole data chunk       |
 * |   8 | flags     | LE32         | combination of functionfs_flags      |
 * |     | eventfd   | LE32         | eventfd file descriptor              |
 * |     | fs_count  | LE32         | number of full-speed descriptors     |
 * |     | hs_count  | LE32         | number of high-speed descriptors     |
 * |     | ss_count  | LE32         | number of super-speed descriptors    |
 * |     | os_count  | LE32         | number of MS OS descriptors          |
 * |     | fs_descrs | Descriptor[] | list of full-speed descriptors       |
 * |     | hs_descrs | Descriptor[] | list of high-speed descriptors       |
 * |     | ss_descrs | Descriptor[] | list of super-speed descriptors      |
 * |     | os_descrs | OSDesc[]     | list of MS OS descriptors            |
 < ASCII >
 *
 * Depending on which flags are set, various fields may be missing in the
 * structure.  Any flags that are not recognised cause the whole block to be
 * rejected with -ENOSYS.
 *
 < ASCII >
 * Legacy descriptors format (deprecated as of 3.14):
 *
 * | off | name      | type         | description                          |
 * |-----+-----------+--------------+--------------------------------------|
 * |   0 | magic     | LE32         | FUNCTIONFS_DESCRIPTORS_MAGIC         |
 * |   4 | length    | LE32         | length of the whole data chunk       |
 * |   8 | fs_count  | LE32         | number of full-speed descriptors     |
 * |  12 | hs_count  | LE32         | number of high-speed descriptors     |
 * |  16 | fs_descrs | Descriptor[] | list of full-speed descriptors       |
 * |     | hs_descrs | Descriptor[] | list of high-speed descriptors       |
 < ASCII >
 *
 * All numbers must be in little endian order.
 *
 < ASCII >
 * Descriptor[] is an array of valid USB descriptors which have the following
 * format:
 *
 * | off | name            | type | description              |
 * |-----+-----------------+------+--------------------------|
 * |   0 | bLength         | U8   | length of the descriptor |
 * |   1 | bDescriptorType | U8   | descriptor type          |
 * |   2 | payload         |      | descriptor's payload     |
 *
 * OSDesc[] is an array of valid MS OS Feature Descriptors which have one of
 * the following formats:
 *
 * | off | name            | type | description              |
 * |-----+-----------------+------+--------------------------|
 * |   0 | inteface        | U8   | related interface number |
 * |   1 | dwLength        | U32  | length of the descriptor |
 * |   5 | bcdVersion      | U16  | currently supported: 1   |
 * |   7 | wIndex          | U16  | currently supported: 4   |
 * |   9 | bCount          | U8   | number of ext. compat.   |
 * |  10 | Reserved        | U8   | 0                        |
 * |  11 | ExtCompat[]     |      | list of ext. compat. d.  |
 *
 * | off | name            | type | description              |
 * |-----+-----------------+------+--------------------------|
 * |   0 | inteface        | U8   | related interface number |
 * |   1 | dwLength        | U32  | length of the descriptor |
 * |   5 | bcdVersion      | U16  | currently supported: 1   |
 * |   7 | wIndex          | U16  | currently supported: 5   |
 * |   9 | wCount          | U16  | number of ext. compat.   |
 * |  11 | ExtProp[]       |      | list of ext. prop. d.    |
 *
 * ExtCompat[] is an array of valid Extended Compatiblity descriptors
 * which have the following format:
 *
 * | off | name                  | type | description                         |
 * |-----+-----------------------+------+-------------------------------------|
 * |   0 | bFirstInterfaceNumber | U8   | index of the interface or of the 1st|
 * |     |                       |      | interface in an IAD group           |
 * |   1 | Reserved              | U8   | 1                                   |
 * |   2 | CompatibleID          | U8[8]| compatible ID string                |
 * |  10 | SubCompatibleID       | U8[8]| subcompatible ID string             |
 * |  18 | Reserved              | U8[6]| 0                                   |
 *
 * ExtProp[] is an array of valid Extended Properties descriptors
 * which have the following format:
 *
 * | off | name                  | type | description                         |
 * |-----+-----------------------+------+-------------------------------------|
 * |   0 | dwSize                | U32  | length of the descriptor            |
 * |   4 | dwPropertyDataType    | U32  | 1..7                                |
 * |   8 | wPropertyNameLength   | U16  | bPropertyName length (NL)           |
 * |  10 | bPropertyName         |U8[NL]| name of this property               |
 * |10+NL| dwPropertyDataLength  | U32  | bPropertyData length (DL)           |
 * |14+NL| bProperty             |U8[DL]| payload of this property            |
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_981.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/linux/usb/functionfs.h#L187-L209

```c
/*
 < ASCII >
 * Strings format:
 *
 * | off | name       | type                  | description                |
 * |-----+------------+-----------------------+----------------------------|
 * |   0 | magic      | LE32                  | FUNCTIONFS_STRINGS_MAGIC   |
 * |   4 | length     | LE32                  | length of the data chunk   |
 * |   8 | str_count  | LE32                  | number of strings          |
 * |  12 | lang_count | LE32                  | number of languages        |
 * |  16 | stringtab  | StringTab[lang_count] | table of strings per lang  |
 *
 * For each language there is one stringtab entry (ie. there are lang_count
 * stringtab entires).  Each StringTab has following format:
 *
 * | off | name    | type              | description                        |
 * |-----+---------+-------------------+------------------------------------|
 * |   0 | lang    | LE16              | language code                      |
 * |   2 | strings | String[str_count] | array of strings in given language |
 < ASCII >
 *
 * For each string there is one strings entry (ie. there are str_count
 * string entries).  Each String is a NUL terminated string encoded in
 * UTF-8.
 */
```
## Visual type:
- #table


== ./linux/linux_982.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/rdma/rdma_netlink.h#L218-L232

```c
/*
 < ASCII >
 * Local service attributes:
 *   Attr Name       Size                       Byte order
 *   -----------------------------------------------------
 *   PATH_RECORD     struct ib_path_rec_data
 *   TIMEOUT         u32                        cpu
 *   SERVICE_ID      u64                        cpu
 *   DGID            u8[16]                     BE
 *   SGID            u8[16]                     BE
 *   TCLASS          u8
 *   PKEY            u16                        cpu
 *   QOS_CLASS       u16                        cpu
 *   IPV4            u32                        BE
 *   IPV6            u8[16]                     BE
 < ASCII >
 */
```
## Visual type:
- #table


== ./linux/linux_983.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/sound/asoc.h#L464-L479

```c
/*
 * DAPM Widget.
 *
 < ASCII >
 * File block representation for DAPM widget :-
 * +-------------------------------------+-----+
 * | struct snd_soc_tplg_hdr             |  1  |
 * +-------------------------------------+-----+
 * | struct snd_soc_tplg_dapm_widget     |  N  |
 * +-------------------------------------+-----+
 * |   struct snd_soc_tplg_enum_control  | 0|1 |
 * |   struct snd_soc_tplg_mixer_control | 0|N |
 * +-------------------------------------+-----+
 < ASCII >
 *
 * Optional enum or mixer control can be appended to the end of each widget
 * in the block.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_984.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/sound/asoc.h#L503-L512

```c
/*
 * Describes SW/FW specific features of PCM (FE DAI & DAI link).
 *
 < ASCII >
 * File block representation for PCM :-
 * +-----------------------------------+-----+
 * | struct snd_soc_tplg_hdr           |  1  |
 * +-----------------------------------+-----+
 * | struct snd_soc_tplg_pcm           |  N  |
 * +-----------------------------------+-----+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_985.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/uapi/sound/asoc.h#L556-L566

```c
/*
 * Describes SW/FW specific features of physical DAI.
 * It can be used to configure backend DAIs for DPCM.
 *
 < ASCII >
 * File block representation for physical DAI :-
 * +-----------------------------------+-----+
 * | struct snd_soc_tplg_hdr           |  1  |
 * +-----------------------------------+-----+
 * | struct snd_soc_tplg_dai           |  N  |
 * +-----------------------------------+-----+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_986.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/video/display_timing.h#L46-L62

```c
/*
 * Single "mode" entry. This describes one set of signal timings a display can
 * have in one setting. This struct can later be converted to struct videomode
 * (see include/video/videomode.h). As each timing_entry can be defined as a
 * range, one struct display_timing may become multiple struct videomodes.
 *
 * Example: hsync active high, vsync active low
 *
 < ASCII >
 *				    Active Video
 * Video  ______________________XXXXXXXXXXXXXXXXXXXXXX_____________________
 *	  |<- sync ->|<- back ->|<----- active ----->|<- front ->|<- sync..
 *	  |	     |	 porch  |		     |	 porch	 |
 *
 * HSync _|¯¯¯¯¯¯¯¯¯¯|___________________________________________|¯¯¯¯¯¯¯¯¯
 *
 * VSync ¯|__________|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|_________
 < ASCII >
 */
```
## Visual type:
- #plot


== ./linux/linux_987.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/video/samsung_fimd.h#L458-L477

```c
/* Notes on per-window bpp settings
 *
 < ASCII >
 * Value	Win0	 Win1	  Win2	   Win3	    Win 4
 * 0000		1(P)	 1(P)	  1(P)	   1(P)	    1(P)
 * 0001		2(P)	 2(P)     2(P)	   2(P)	    2(P)
 * 0010		4(P)	 4(P)     4(P)	   4(P)     -none-
 * 0011		8(P)	 8(P)     -none-   -none-   -none-
 * 0100		-none-	 8(A232)  8(A232)  -none-   -none-
 * 0101		16(565)	 16(565)  16(565)  16(565)   16(565)
 * 0110		-none-	 16(A555) 16(A555) 16(A555)  16(A555)
 * 0111		16(I555) 16(I565) 16(I555) 16(I555)  16(I555)
 * 1000		18(666)	 18(666)  18(666)  18(666)   18(666)
 * 1001		-none-	 18(A665) 18(A665) 18(A665)  16(A665)
 * 1010		-none-	 19(A666) 19(A666) 19(A666)  19(A666)
 * 1011		24(888)	 24(888)  24(888)  24(888)   24(888)
 * 1100		-none-	 24(A887) 24(A887) 24(A887)  24(A887)
 * 1101		-none-	 25(A888) 25(A888) 25(A888)  25(A888)
 * 1110		-none-	 -none-	  -none-   -none-    -none-
 * 1111		-none-	 -none-   -none-   -none-    -none-
 < ASCII >
*/
```
## Visual type:
- #table


== ./linux/linux_988.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/xen.h#L114-L250

```c
/*
 * enum neg_errnoval HYPERVISOR_mmu_update(const struct mmu_update reqs[],
 *                                         unsigned count, unsigned *done_out,
 *                                         unsigned foreigndom)
 * @reqs is an array of mmu_update_t structures ((ptr, val) pairs).
 * @count is the length of the above array.
 * @pdone is an output parameter indicating number of completed operations
 * @foreigndom[15:0]: FD, the expected owner of data pages referenced in this
 *                    hypercall invocation. Can be DOMID_SELF.
 * @foreigndom[31:16]: PFD, the expected owner of pagetable pages referenced
 *                     in this hypercall invocation. The value of this field
 *                     (x) encodes the PFD as follows:
 *                     x == 0 => PFD == DOMID_SELF
 *                     x != 0 => PFD == x - 1
 *
 * Sub-commands: ptr[1:0] specifies the appropriate MMU_* command.
 * -------------
 * ptr[1:0] == MMU_NORMAL_PT_UPDATE:
 * Updates an entry in a page table belonging to PFD. If updating an L1 table,
 * and the new table entry is valid/present, the mapped frame must belong to
 * FD. If attempting to map an I/O page then the caller assumes the privilege
 * of the FD.
 * FD == DOMID_IO: Permit /only/ I/O mappings, at the priv level of the caller.
 * FD == DOMID_XEN: Map restricted areas of Xen's heap space.
 * ptr[:2]  -- Machine address of the page-table entry to modify.
 * val      -- Value to write.
 *
 * There also certain implicit requirements when using this hypercall. The
 * pages that make up a pagetable must be mapped read-only in the guest.
 * This prevents uncontrolled guest updates to the pagetable. Xen strictly
 * enforces this, and will disallow any pagetable update which will end up
 * mapping pagetable page RW, and will disallow using any writable page as a
 * pagetable. In practice it means that when constructing a page table for a
 * process, thread, etc, we MUST be very dilligient in following these rules:
 *  1). Start with top-level page (PGD or in Xen language: L4). Fill out
 *      the entries.
 *  2). Keep on going, filling out the upper (PUD or L3), and middle (PMD
 *      or L2).
 *  3). Start filling out the PTE table (L1) with the PTE entries. Once
 *      done, make sure to set each of those entries to RO (so writeable bit
 *      is unset). Once that has been completed, set the PMD (L2) for this
 *      PTE table as RO.
 *  4). When completed with all of the PMD (L2) entries, and all of them have
 *      been set to RO, make sure to set RO the PUD (L3). Do the same
 *      operation on PGD (L4) pagetable entries that have a PUD (L3) entry.
 *  5). Now before you can use those pages (so setting the cr3), you MUST also
 *      pin them so that the hypervisor can verify the entries. This is done
 *      via the HYPERVISOR_mmuext_op(MMUEXT_PIN_L4_TABLE, guest physical frame
 *      number of the PGD (L4)). And this point the HYPERVISOR_mmuext_op(
 *      MMUEXT_NEW_BASEPTR, guest physical frame number of the PGD (L4)) can be
 *      issued.
 * For 32-bit guests, the L4 is not used (as there is less pagetables), so
 * instead use L3.
 * At this point the pagetables can be modified using the MMU_NORMAL_PT_UPDATE
 * hypercall. Also if so desired the OS can also try to write to the PTE
 * and be trapped by the hypervisor (as the PTE entry is RO).
 *
 * To deallocate the pages, the operations are the reverse of the steps
 * mentioned above. The argument is MMUEXT_UNPIN_TABLE for all levels and the
 * pagetable MUST not be in use (meaning that the cr3 is not set to it).
 *
 * ptr[1:0] == MMU_MACHPHYS_UPDATE:
 * Updates an entry in the machine->pseudo-physical mapping table.
 * ptr[:2]  -- Machine address within the frame whose mapping to modify.
 *             The frame must belong to the FD, if one is specified.
 * val      -- Value to write into the mapping entry.
 *
 * ptr[1:0] == MMU_PT_UPDATE_PRESERVE_AD:
 * As MMU_NORMAL_PT_UPDATE above, but A/D bits currently in the PTE are ORed
 * with those in @val.
 *
 * @val is usually the machine frame number along with some attributes.
 * The attributes by default follow the architecture defined bits. Meaning that
 * if this is a X86_64 machine and four page table layout is used, the layout
 * of val is:
 *  - 63 if set means No execute (NX)
 *  - 46-13 the machine frame number
 *  - 12 available for guest
 *  - 11 available for guest
 *  - 10 available for guest
 *  - 9 available for guest
 *  - 8 global
 *  - 7 PAT (PSE is disabled, must use hypercall to make 4MB or 2MB pages)
 *  - 6 dirty
 *  - 5 accessed
 *  - 4 page cached disabled
 *  - 3 page write through
 *  - 2 userspace accessible
 *  - 1 writeable
 *  - 0 present
 *
 *  The one bits that does not fit with the default layout is the PAGE_PSE
 *  also called PAGE_PAT). The MMUEXT_[UN]MARK_SUPER arguments to the
 *  HYPERVISOR_mmuext_op serve as mechanism to set a pagetable to be 4MB
 *  (or 2MB) instead of using the PAGE_PSE bit.
 *
 *  The reason that the PAGE_PSE (bit 7) is not being utilized is due to Xen
 *  using it as the Page Attribute Table (PAT) bit - for details on it please
 *  refer to Intel SDM 10.12. The PAT allows to set the caching attributes of
 *  pages instead of using MTRRs.
 *
 < ASCII >
 *  The PAT MSR is as follows (it is a 64-bit value, each entry is 8 bits):
 *                    PAT4                 PAT0
 *  +-----+-----+----+----+----+-----+----+----+
 *  | UC  | UC- | WC | WB | UC | UC- | WC | WB |  <= Linux
 *  +-----+-----+----+----+----+-----+----+----+
 *  | UC  | UC- | WT | WB | UC | UC- | WT | WB |  <= BIOS (default when machine boots)
 *  +-----+-----+----+----+----+-----+----+----+
 *  | rsv | rsv | WP | WC | UC | UC- | WT | WB |  <= Xen
 *  +-----+-----+----+----+----+-----+----+----+
 < ASCII >
 *
 *  The lookup of this index table translates to looking up
 *  Bit 7, Bit 4, and Bit 3 of val entry:
 *
 *  PAT/PSE (bit 7) ... PCD (bit 4) .. PWT (bit 3).
 *
 *  If all bits are off, then we are using PAT0. If bit 3 turned on,
 *  then we are using PAT1, if bit 3 and bit 4, then PAT2..
 *
 *  As you can see, the Linux PAT1 translates to PAT4 under Xen. Which means
 *  that if a guest that follows Linux's PAT setup and would like to set Write
 *  Combined on pages it MUST use PAT4 entry. Meaning that Bit 7 (PAGE_PAT) is
 *  set. For example, under Linux it only uses PAT0, PAT1, and PAT2 for the
 *  caching as:
 *
 *   WB = none (so PAT0)
 *   WC = PWT (bit 3 on)
 *   UC = PWT | PCD (bit 3 and 4 are on).
 *
 * To make it work with Xen, it needs to translate the WC bit as so:
 *
 *  PWT (so bit 3 on) --> PAT (so bit 7 is on) and clear bit 3
 *
 * And to translate back it would:
 *
 * PAT (bit 7 on) --> PWT (bit 3 on) and clear bit 7.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_989.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/hvm/start_info.h#L9-L85

```c
/*
 * Start of day structure passed to PVH guests and to HVM guests in %ebx.
 *
 * NOTE: nothing will be loaded at physical address 0, so a 0 value in any
 * of the address fields should be treated as not present.
 *
 < ASCII >
 *  0 +----------------+
 *    | magic          | Contains the magic value XEN_HVM_START_MAGIC_VALUE
 *    |                | ("xEn3" with the 0x80 bit of the "E" set).
 *  4 +----------------+
 *    | version        | Version of this structure. Current version is 1. New
 *    |                | versions are guaranteed to be backwards-compatible.
 *  8 +----------------+
 *    | flags          | SIF_xxx flags.
 * 12 +----------------+
 *    | nr_modules     | Number of modules passed to the kernel.
 * 16 +----------------+
 *    | modlist_paddr  | Physical address of an array of modules
 *    |                | (layout of the structure below).
 * 24 +----------------+
 *    | cmdline_paddr  | Physical address of the command line,
 *    |                | a zero-terminated ASCII string.
 * 32 +----------------+
 *    | rsdp_paddr     | Physical address of the RSDP ACPI data structure.
 * 40 +----------------+
 *    | memmap_paddr   | Physical address of the (optional) memory map. Only
 *    |                | present in version 1 and newer of the structure.
 * 48 +----------------+
 *    | memmap_entries | Number of entries in the memory map table. Zero
 *    |                | if there is no memory map being provided. Only
 *    |                | present in version 1 and newer of the structure.
 * 52 +----------------+
 *    | reserved       | Version 1 and newer only.
 * 56 +----------------+
 *
 * The layout of each entry in the module structure is the following:
 *
 *  0 +----------------+
 *    | paddr          | Physical address of the module.
 *  8 +----------------+
 *    | size           | Size of the module in bytes.
 * 16 +----------------+
 *    | cmdline_paddr  | Physical address of the command line,
 *    |                | a zero-terminated ASCII string.
 * 24 +----------------+
 *    | reserved       |
 * 32 +----------------+
 *
 * The layout of each entry in the memory map table is as follows:
 *
 *  0 +----------------+
 *    | addr           | Base address
 *  8 +----------------+
 *    | size           | Size of mapping in bytes
 * 16 +----------------+
 *    | type           | Type of mapping as defined between the hypervisor
 *    |                | and guest. See XEN_HVM_MEMMAP_TYPE_* values below.
 * 20 +----------------|
 *    | reserved       |
 * 24 +----------------+
 < ASCII >
 *
 * The address and sizes are always a 64bit little endian unsigned integer.
 *
 * NB: Xen on x86 will always try to place all the data below the 4GiB
 * boundary.
 *
 * Version numbers of the hvm_start_info structure have evolved like this:
 *
 * Version 0:  Initial implementation.
 *
 * Version 1:  Added the memmap_paddr/memmap_entries fields (plus 4 bytes of
 *             padding) to the end of the hvm_start_info struct. These new
 *             fields can be used to pass a memory map to the guest. The
 *             memory map is optional and so guests that understand version 1
 *             of the structure must check that memmap_entries is non-zero
 *             before trying to read the memory map.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_99.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/arch/ia64/lib/memcpy_mck.S#L377-L394

```c
/* we have up to 15 byte to copy in the tail.
 * part of work is already done in the jump table code
 * we are at the following state.
 < ASCII >
 * src side:
 * 
 *   xxxxxx xx                   <----- r21 has xxxxxxxx already
 * -------- -------- --------
 * 0        8        16
 *          ^
 *          |
 *          src1
 * 
 * dst
 * -------- -------- --------
 * ^
 * |
 * dst1
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_990.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/displif.h#L229-L331

```c
/*
 ******************************************************************************
 *                               STATE DIAGRAMS
 ******************************************************************************
 *
 * Tool stack creates front and back state nodes with initial state
 * XenbusStateInitialising.
 * Tool stack creates and sets up frontend display configuration
 * nodes per domain.
 *
 < ASCII >
 *-------------------------------- Normal flow --------------------------------
 *
 * Front                                Back
 * =================================    =====================================
 * XenbusStateInitialising              XenbusStateInitialising
 *                                       o Query backend device identification
 *                                         data.
 *                                       o Open and validate backend device.
 *                                                |
 *                                                |
 *                                                V
 *                                      XenbusStateInitWait
 *
 * o Query frontend configuration
 * o Allocate and initialize
 *   event channels per configured
 *   connector.
 * o Publish transport parameters
 *   that will be in effect during
 *   this connection.
 *              |
 *              |
 *              V
 * XenbusStateInitialised
 *
 *                                       o Query frontend transport parameters.
 *                                       o Connect to the event channels.
 *                                                |
 *                                                |
 *                                                V
 *                                      XenbusStateConnected
 *
 *  o Create and initialize OS
 *    virtual display connectors
 *    as per configuration.
 *              |
 *              |
 *              V
 * XenbusStateConnected
 *
 *                                      XenbusStateUnknown
 *                                      XenbusStateClosed
 *                                      XenbusStateClosing
 * o Remove virtual display device
 * o Remove event channels
 *              |
 *              |
 *              V
 * XenbusStateClosed
 *
 < ASCII >
 *------------------------------- Recovery flow -------------------------------
 *
 * In case of frontend unrecoverable errors backend handles that as
 * if frontend goes into the XenbusStateClosed state.
 *
 * In case of backend unrecoverable errors frontend tries removing
 * the virtualized device. If this is possible at the moment of error,
 * then frontend goes into the XenbusStateInitialising state and is ready for
 * new connection with backend. If the virtualized device is still in use and
 * cannot be removed, then frontend goes into the XenbusStateReconfiguring state
 * until either the virtualized device is removed or backend initiates a new
 * connection. On the virtualized device removal frontend goes into the
 * XenbusStateInitialising state.
 *
 * Note on XenbusStateReconfiguring state of the frontend: if backend has
 * unrecoverable errors then frontend cannot send requests to the backend
 * and thus cannot provide functionality of the virtualized device anymore.
 * After backend is back to normal the virtualized device may still hold some
 * state: configuration in use, allocated buffers, client application state etc.
 * In most cases, this will require frontend to implement complex recovery
 * reconnect logic. Instead, by going into XenbusStateReconfiguring state,
 * frontend will make sure no new clients of the virtualized device are
 * accepted, allow existing client(s) to exit gracefully by signaling error
 * state etc.
 * Once all the clients are gone frontend can reinitialize the virtualized
 * device and get into XenbusStateInitialising state again signaling the
 * backend that a new connection can be made.
 *
 * There are multiple conditions possible under which frontend will go from
 * XenbusStateReconfiguring into XenbusStateInitialising, some of them are OS
 * specific. For example:
 * 1. The underlying OS framework may provide callbacks to signal that the last
 *    client of the virtualized device has gone and the device can be removed
 * 2. Frontend can schedule a deferred work (timer/tasklet/workqueue)
 *    to periodically check if this is the right time to re-try removal of
 *    the virtualized device.
 * 3. By any other means.
 *
 ******************************************************************************
 *                             REQUEST CODES
 ******************************************************************************
 * Request codes [0; 15] are reserved and must not be used
 */
```
## Visual type:
- #state-machine


== ./linux/linux_991.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/displif.h#L373-L493

```c
/*
 ******************************************************************************
 *                          STATUS RETURN CODES
 ******************************************************************************
 *
 * Status return code is zero on success and -XEN_EXX on failure.
 *
 ******************************************************************************
 *                              Assumptions
 ******************************************************************************
 * o usage of grant reference 0 as invalid grant reference:
 *   grant reference 0 is valid, but never exposed to a PV driver,
 *   because of the fact it is already in use/reserved by the PV console.
 * o all references in this document to page sizes must be treated
 *   as pages of size XEN_PAGE_SIZE unless otherwise noted.
 *
 ******************************************************************************
 *       Description of the protocol between frontend and backend driver
 ******************************************************************************
 *
 * The two halves of a Para-virtual display driver communicate with
 * each other using shared pages and event channels.
 * Shared page contains a ring with request/response packets.
 *
 * All reserved fields in the structures below must be 0.
 * Display buffers's cookie of value 0 is treated as invalid.
 * Framebuffer's cookie of value 0 is treated as invalid.
 *
 * For all request/response/event packets that use cookies:
 *   dbuf_cookie - uint64_t, unique to guest domain value used by the backend
 *     to map remote display buffer to its local one
 *   fb_cookie - uint64_t, unique to guest domain value used by the backend
 *     to map remote framebuffer to its local one
 *
 *---------------------------------- Requests ---------------------------------
 *
 * All requests/responses, which are not connector specific, must be sent over
 * control ring of the connector which has the index value of 0:
 *   /local/domain/<dom-id>/device/vdispl/<dev-id>/0/req-ring-ref
 *
 * All request packets have the same length (64 octets)
 < ASCII >
 * All request packets have common header:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |    operation   |   reserved     | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 < ASCII >
 *   id - uint16_t, private guest value, echoed in response
 *   operation - uint8_t, operation code, XENDISPL_OP_???
 *
 < ASCII >
 * Request dbuf creation - request creation of a display buffer.
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |_OP_DBUF_CREATE |   reserved     | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                       dbuf_cookie low 32-bit                      | 12
 * +----------------+----------------+----------------+----------------+
 * |                       dbuf_cookie high 32-bit                     | 16
 * +----------------+----------------+----------------+----------------+
 * |                               width                               | 20
 * +----------------+----------------+----------------+----------------+
 * |                               height                              | 24
 * +----------------+----------------+----------------+----------------+
 * |                                bpp                                | 28
 * +----------------+----------------+----------------+----------------+
 * |                             buffer_sz                             | 32
 * +----------------+----------------+----------------+----------------+
 * |                               flags                               | 36
 * +----------------+----------------+----------------+----------------+
 * |                           gref_directory                          | 40
 * +----------------+----------------+----------------+----------------+
 * |                             data_ofs                              | 44
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 48
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
 < ASCII >
 *
 * Must be sent over control ring of the connector which has the index
 * value of 0:
 *   /local/domain/<dom-id>/device/vdispl/<dev-id>/0/req-ring-ref
 * All unused bits in flags field must be set to 0.
 *
 * An attempt to create multiple display buffers with the same dbuf_cookie is
 * an error. dbuf_cookie can be re-used after destroying the corresponding
 * display buffer.
 *
 * Width and height of the display buffers can be smaller, equal or bigger
 * than the connector's resolution. Depth/pixel format of the individual
 * buffers can differ as well.
 *
 * width - uint32_t, width in pixels
 * height - uint32_t, height in pixels
 * bpp - uint32_t, bits per pixel
 * buffer_sz - uint32_t, buffer size to be allocated, octets
 * flags - uint32_t, flags of the operation
 *   o XENDISPL_DBUF_FLG_REQ_ALLOC - if set, then backend is requested
 *     to allocate the buffer with the parameters provided in this request.
 *     Page directory is handled as follows:
 *       Frontend on request:
 *         o allocates pages for the directory (gref_directory,
 *           gref_dir_next_page(s)
 *         o grants permissions for the pages of the directory to the backend
 *         o sets gref_dir_next_page fields
 *       Backend on response:
 *         o grants permissions for the pages of the buffer allocated to
 *           the frontend
 *         o fills in page directory with grant references
 *           (gref[] in struct xendispl_page_directory)
 * gref_directory - grant_ref_t, a reference to the first shared page
 *   describing shared buffer references. At least one page exists. If shared
 *   buffer size (buffer_sz) exceeds what can be addressed by this single page,
 *   then reference to the next page must be supplied (see gref_dir_next_page
 *   below)
 * data_ofs - uint32_t, offset of the data in the buffer, octets
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_992.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/displif.h#L508-L536

```c
/*
 * Shared page for XENDISPL_OP_DBUF_CREATE buffer descriptor (gref_directory in
 * the request) employs a list of pages, describing all pages of the shared
 < ASCII >
 * data buffer:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |                        gref_dir_next_page                         | 4
 * +----------------+----------------+----------------+----------------+
 * |                              gref[0]                              | 8
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                              gref[i]                              | i*4+8
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             gref[N - 1]                           | N*4+8
 * +----------------+----------------+----------------+----------------+
 < ASCII >
 *
 * gref_dir_next_page - grant_ref_t, reference to the next page describing
 *   page directory. Must be 0 if there are no more pages in the list.
 * gref[i] - grant_ref_t, reference to a shared page of the buffer
 *   allocated at XENDISPL_OP_DBUF_CREATE
 *
 * Number of grant_ref_t entries in the whole page directory is not
 * passed, but instead can be calculated as:
 *   num_grefs_total = (XENDISPL_OP_DBUF_CREATE.buffer_sz + XEN_PAGE_SIZE - 1) /
 *       XEN_PAGE_SIZE
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_993.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/displif.h#L543-L565

```c
/*
 < ASCII >
 * Request dbuf destruction - destroy a previously allocated display buffer:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |_OP_DBUF_DESTROY|   reserved     | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                       dbuf_cookie low 32-bit                      | 12
 * +----------------+----------------+----------------+----------------+
 * |                       dbuf_cookie high 32-bit                     | 16
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 20
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
 < ASCII >
 *
 * Must be sent over control ring of the connector which has the index
 * value of 0:
 *   /local/domain/<dom-id>/device/vdispl/<dev-id>/0/req-ring-ref
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_994.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/displif.h#L571-L614

```c
/*
 < ASCII >
 * Request framebuffer attachment - request attachment of a framebuffer to
 * previously created display buffer.
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                | _OP_FB_ATTACH  |   reserved     | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                       dbuf_cookie low 32-bit                      | 12
 * +----------------+----------------+----------------+----------------+
 * |                       dbuf_cookie high 32-bit                     | 16
 * +----------------+----------------+----------------+----------------+
 * |                        fb_cookie low 32-bit                       | 20
 * +----------------+----------------+----------------+----------------+
 * |                        fb_cookie high 32-bit                      | 24
 * +----------------+----------------+----------------+----------------+
 * |                               width                               | 28
 * +----------------+----------------+----------------+----------------+
 * |                               height                              | 32
 * +----------------+----------------+----------------+----------------+
 * |                            pixel_format                           | 36
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 40
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
 < ASCII >
 *
 * Must be sent over control ring of the connector which has the index
 * value of 0:
 *   /local/domain/<dom-id>/device/vdispl/<dev-id>/0/req-ring-ref
 * Width and height can be smaller, equal or bigger than the connector's
 * resolution.
 *
 * An attempt to create multiple frame buffers with the same fb_cookie is
 * an error. fb_cookie can be re-used after destroying the corresponding
 * frame buffer.
 *
 * width - uint32_t, width in pixels
 * height - uint32_t, height in pixels
 * pixel_format - uint32_t, pixel format of the framebuffer, FOURCC code
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_995.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/displif.h#L624-L647

```c
/*
 < ASCII >
 * Request framebuffer detach - detach a previously
 * attached framebuffer from the display buffer in request:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |  _OP_FB_DETACH |   reserved     | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                        fb_cookie low 32-bit                       | 12
 * +----------------+----------------+----------------+----------------+
 * |                        fb_cookie high 32-bit                      | 16
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 20
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
 < ASCII >
 *
 * Must be sent over control ring of the connector which has the index
 * value of 0:
 *   /local/domain/<dom-id>/device/vdispl/<dev-id>/0/req-ring-ref
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_996.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/displif.h#L653-L695

```c
/*
 * Request configuration set/reset - request to set or reset
 < ASCII >
 * the configuration/mode of the display:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                | _OP_SET_CONFIG |   reserved     | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                        fb_cookie low 32-bit                       | 12
 * +----------------+----------------+----------------+----------------+
 * |                        fb_cookie high 32-bit                      | 16
 * +----------------+----------------+----------------+----------------+
 * |                                 x                                 | 20
 * +----------------+----------------+----------------+----------------+
 * |                                 y                                 | 24
 * +----------------+----------------+----------------+----------------+
 * |                               width                               | 28
 * +----------------+----------------+----------------+----------------+
 * |                               height                              | 32
 * +----------------+----------------+----------------+----------------+
 * |                                bpp                                | 40
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 44
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
 < ASCII >
 *
 * Pass all zeros to reset, otherwise command is treated as
 * configuration set.
 * Framebuffer's cookie defines which framebuffer/dbuf must be
 * displayed while enabling display (applying configuration).
 * x, y, width and height are bound by the connector's resolution and must not
 * exceed it.
 *
 * x - uint32_t, starting position in pixels by X axis
 * y - uint32_t, starting position in pixels by Y axis
 * width - uint32_t, width in pixels
 * height - uint32_t, height in pixels
 * bpp - uint32_t, bits per pixel
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_997.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/displif.h#L706-L725

```c
/*
 * Request page flip - request to flip a page identified by the framebuffer
 * cookie:
 < ASCII >
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                | _OP_PG_FLIP    |   reserved     | 4
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 8
 * +----------------+----------------+----------------+----------------+
 * |                        fb_cookie low 32-bit                       | 12
 * +----------------+----------------+----------------+----------------+
 * |                        fb_cookie high 32-bit                      | 16
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 20
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
 < ASCII >
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_998.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/displif.h#L731-L762

```c
/*
 < ASCII >
 * Request EDID - request EDID describing current connector:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                | _OP_GET_EDID   |   reserved     | 4
 * +----------------+----------------+----------------+----------------+
 * |                             buffer_sz                             | 8
 * +----------------+----------------+----------------+----------------+
 * |                          gref_directory                           | 12
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 16
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
 < ASCII >
 *
 * Notes:
 *   - This command is not available in protocol version 1 and should be
 *     ignored.
 *   - This request is optional and if not supported then visible area
 *     is defined by the relevant XenStore's "resolution" property.
 *   - Shared buffer, allocated for EDID storage, must not be less then
 *     XENDISPL_EDID_MAX_SIZE octets.
 *
 * buffer_sz - uint32_t, buffer size to be allocated, octets
 * gref_directory - grant_ref_t, a reference to the first shared page
 *   describing EDID buffer references. See XENDISPL_OP_DBUF_CREATE for
 *   grant page directory structure (struct xendispl_page_directory).
 *
 * See response format for this request.
 */
```
## Visual type:
- #memory-layout


== ./linux/linux_999.md
# https://github.com/torvalds/linux/blob/67d7c3023a672c2b73d19d6d23684df670fce648/include/xen/interface/io/displif.h#L769-L813

```c
/*
 *---------------------------------- Responses --------------------------------
 *
 * All response packets have the same length (64 octets)
 *
 < ASCII >
 * All response packets have common header:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |            reserved             | 4
 * +----------------+----------------+----------------+----------------+
 * |                              status                               | 8
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 12
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
 < ASCII >
 *
 * id - uint16_t, private guest value, echoed from request
 * status - int32_t, response status, zero on success and -XEN_EXX on failure
 *
 *
 < ASCII >
 * Get EDID response - response for XENDISPL_OP_GET_EDID:
 *         0                1                 2               3        octet
 * +----------------+----------------+----------------+----------------+
 * |               id                |    operation   |    reserved    | 4
 * +----------------+----------------+----------------+----------------+
 * |                              status                               | 8
 * +----------------+----------------+----------------+----------------+
 * |                             edid_sz                               | 12
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 16
 * +----------------+----------------+----------------+----------------+
 * |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
 * +----------------+----------------+----------------+----------------+
 * |                             reserved                              | 64
 * +----------------+----------------+----------------+----------------+
 < ASCII >
 *
 * Notes:
 *   - This response is not available in protocol version 1 and should be
 *     ignored.
 *
 * edid_sz - uint32_t, size of the EDID, octets
 */
```
## Visual type:
- #memory-layout
